<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在浏览器和 Node Server 之间加密敏感信息]]></title>
    <url>%2F2019%2F06%2F18%2Fcrypto-password-between-browser-and-node-server%2F</url>
    <content type="text"><![CDATA[我们的官网项目有个简单的后台管理系统，不开放注册，目前只有一个管理在用，功能比较少，也比较简单，主要就是发布文章，维护一些配置项等。所以在技术选型上我们选择对前端友好的Node，这样只要一个前端同事开发维护即可。后来在安全测试时，收到了一个Issue，说是在登录时没有将密码字段加密。关于这个问题，我认为通过HTTPS协议来发送请求已经足够安全了，但是我还是听从了安全测试同事的建议，对敏感信息做了加密处理。 对于加密分类想必大家都听说过，分为对称加密和非对称加密，对称加密有计算量小，加密速度快等特点，但是由于加密和解密双方使用同样的秘钥，安全性得不到保证。非对称加密有一对秘钥，公钥和私钥，用公钥加密后，只能用对应的私钥才能解密。非对称加密加解密速度比对称加密要慢很多，它不需要公开解密秘钥，即私钥，安全性很高。我们的项目是访问量很小的后台管理类应用，对性能要求也不高，所以我决定使用非对称加密。 Node语言自带加密模块crypto，在很早的版本中就提供了解密的API crypto.privateDecrypt，而在10.12版本中还添加了crypto.generateKeyPair新接口用来生成非对称加密的秘钥对。因此我打算在通过npm scripts生成秘钥对，前端在需要加密之前通过AJAX请求获取公钥，将敏感字段加密以后发给服务器。 关于如何生成秘钥对，我们可以参考Node官方文档中的示例代码并稍作修改，代码如下：1234567891011121314const options = &#123; modulusLength: 1024, publicKeyEncoding: &#123; type: 'spki', format: 'pem', &#125;, privateKeyEncoding: &#123; type: 'pkcs1', format: 'pem', &#125;,&#125;;crypto.generateKeyPair('rsa', options, (error, publicKey, privateKey) =&gt; &#123; console.log(publicKey, privateKey);&#125;); 这样我们就获得了一对公钥秘钥，我们可以把它们保存一个本地文件或数据库中。 在页面中需要引入jsencrypt，在需要发送敏感信息之前先发请求活动公钥，得到公钥以后进行加密，比如：1234const crypt = new window.JSEncrypt();crypt.setKey(publicKey);// 对密码字段进行加密password = crypt.encrypt(password); 在服务器端得到加密后的密码字段以后，调用以下我封装好的方法即可获得原始密码字段。请注意padding字段的设置，否则可能会报错哦。12345678910function decrypt(encrypted, privateKey) =&gt; &#123; const buffer = crypto.privateDecrypt( &#123; key: privateKey, padding: crypto.constants.RSA_PKCS1_PADDING, &#125;, Buffer.from(encrypted, 'base64'), ); return buffer.toString('utf8');&#125; 到此我们就介绍完了如何在浏览器和Node Server之间传递敏感信息，是不是很简单呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[集中地声明 TypeScript 类型]]></title>
    <url>%2F2019%2F06%2F13%2Fdeclare-file-in-typescript%2F</url>
    <content type="text"><![CDATA[最近我将一个老项目改造成 TypeScript 项目，项目中有一些模型类型，这写类型在多个文件中都会使用，比如对用户的增删改查逻辑会分散在多个文件中，他们都会使用 User 这个类型，如果我把对 User 类型的生命放在任何一个文件中都会导致文件之间的互相引用，如果创建一个文件专门用来保存这个类型，又会导致文件更多并且这个文件内容略显单薄。后来就想到将所有的模型类型存放到一个单独的文件中，可以命名为types.ts，并确保该文件在tsconfig.json中的includes或files中，这样就可以文件中直接使用了。比如以下就是我的types.ts。1234567891011121314151617declare namespace GW &#123; export type Image = &#123; id: string; url: string; alt: string; description: string; &#125;; export type User = &#123; id?: string; name: string; phone: string; email: string; username: string; password: string; &#125;;&#125; 在其他文件中直接使用，代码如下：12345class PostAddStore&#123; show = (post: GW.Post) =&gt; &#123; // do something &#125;&#125; 为了让敏感信息在传输中更加安全，在我的项目还用到jsencrypt对密码字段进行加密，而jsencrypt是没有类型声明的。jsencrypt给我们提供一个全局构造函数JSEncrypt，通过它创建的对象包含2个函数属性，分别是setKey和encrypt，以及这两个函数的类型声明。根据这些信息我在types.ts文件中对它进行了声明，代码如下：123456interface Window &#123; JSEncrypt: new () =&gt; &#123; setKey: (publicKey: string) =&gt; void; encrypt: (content: string) =&gt; string; &#125;;&#125; 看起来以上代码非常简单，也非常直观，由于这中做法并不多件，所以我在网上找了很就才找到这种方法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何编写模拟数据]]></title>
    <url>%2F2019%2F05%2F12%2Fmock-server%2F</url>
    <content type="text"><![CDATA[1. 为什么要编写模拟数据？肯定会有不少同事疑惑，为什么要编写模拟数据？编写和维护模拟数据都会增加工作量。但是请想想你有没有遇到过以下情形： 任务工期太短，立马去做，再加加班，应该还能完成。但是后端还在设计数据库表结构，接口还没有动工呢，怎么办？ 时间紧，不能等，这个就不要多说了吧，相信大家不止一次遇到这种情况。即便时间比较宽裕，也不能等后端开发完成才开始，还要考虑后端延期的风险。否则到了上线前天晚上，后端跑来告诉你说他接口开发好了，你就懵逼了。 后端接口终于好了，我可以安心些 Bug 了。。。503。。。哎哎哎，XXX，怎么503了？。。。哎呦卧槽，你这服务太不稳定了，能不能上线啊？。。。 后端服务不稳定，恭喜你成为后端接口的第一个用户，实际上就是个小白鼠。在掘金上有人开玩笑说“不要叫我前端了，叫我后端API测试工程师算了”，以此来吐槽后端接口的不稳定。 测试今天给我报了一个 Bug，说是用户名大于20个字符时截断了，但是没有显示点点点。老子不服，还不是因为联调时后端给我的用户名都很短，本来我也想到了，但是用户名来自单点登录系统，改起来很麻烦，后来一忙就忘了。 边界条件覆盖少，导致很多问题要到测试环境甚至生产环境才被发现。庆幸测试发现了，不然被用户发现那就是线上故障了。 2. 编写模拟数据的最佳实践相信你看完以上几个案例之后，也会认为模拟数据很有必要。那好，我们来看看应该怎样编写模拟数据。 2.1 模拟后端接口确认需求之后，首先和后端定义接口，然后两边同事开工。我们创建一个 mock server，其规格和前后端接口完全一致，只是它的逻辑是简化后的，甚至是写死的。 2.2 手动编写数据网上有不少生成模拟数据的第三方库，为什么还要手动编写呢？原因如下： 学习成本低 你不需要学习和使用第三方库的 DSL ，也不受限第三方库的 DSL 的表达能力。你编写的就是普通代码。 数据有意义 试想在页面中看到 bW9kdWxlPXNoYXJl 你能知道他代表什么吗？如果看到 Steve Jobs 呢？ 边界覆盖高 假设用户名长度在1-6之间，那么我们在编写用户列表数据时，就可以写三条数据，用户名分别是A，Abel，Albert，我们刻意有针对性编写的模拟数据在很大程度上起到单元测试的功能。 流程更完整 必要时我们可以实现一些简单的逻辑，让操作流程更加流畅。比如在用户新增了一个用户之后，用户列表中就真的多了这个用户。 2.3 代码版本管理模拟数据本质上就是代码，也需要你不断维护，也就产生了不同版本，加入代码版本管理以后，你就不用担心数据丢失，无法恢复的问题了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何正确地使用电子邮件]]></title>
    <url>%2F2019%2F04%2F28%2Fhow-to-write-a-good-email%2F</url>
    <content type="text"><![CDATA[上周我收到一封电子邮件，邮件能够表达清楚来意，但是邮件的格式让我触目惊心，促使我下定决心写这篇文章简单地说明一下如何正确地使用电子邮件。 以Gmail为例，点击左侧“写邮件”按钮，页面右下角会弹出新邮件窗口，里面有收件人，抄送人，密送人，主题和内容几个部分，很多时候我们还会使用附件发送一些文档。下面我们来看看它们的含义。收件人：这封邮件是讲给谁听的。抄送人：这封邮件需要被谁知悉，抄送人只需要知悉，无须做出任何动作。一般还包括对方的老板和自己的老板，目的是让领导知道大家在做什么，让领导了解项目进展，还能留下沟通记录，明确责任，避免甩锅。密送人：秘密地将邮件发给某人，收件人不会知道这个邮件同时发给了其他人。这种做法在职场中很少使用，并且被认为是不道德的。主题：对邮件内容的简单概括。内容：不必多说，邮件的详细内容。附件：给收件人发送一些word, excel和pdf等文档。 网上也有一些不太严谨的表达，但是非常有意思。比如：1. 收件人是跑腿儿办事的，抄送人是领导监工的。2. 收件人：接下来该怎样你自己看着办噢；抄送人：球踢出去了出什么事情都不关我事了哈。 介绍完了邮件的组成部分，下面我看看职场中书写电子邮件的注意事项： 标题一定要写，并且言简意赅写邮件不写标题是非常不礼貌的，邮件标题应该能够表达邮件的主要内容，并且不宜过长。比如小明发邮件给领导请假，标题可以这么写“小明5月5日请假”，对方通过邮件标题已经能够清楚地了解邮件内容。 一封邮件只能有一个主题Linux设计理念中很重要的一条就是“一个程序只能实现一个功能”，同样地一封邮件也只能描述一件事情，即使两件事情拥有相同的收件人和抄送人也不要写在一起，否则标题要么很长，要么不能表达所有内容，还会让收件人抓不住重点内容，造成困扰。 合理地选择收件人和抄送人邮件只应该发送给相关的人，否则可能造成信息泄露，也会给不明真相的收件人造成困扰。 如何称呼对方？一般我们写Hi Xxx，Dear Xxx等。如果你想对大家宣布一件事情，可以说Hi All或Dear All。如果你需要某人比如Bob做出某个行动或回复邮件，则需要另起一个段落Hi Bob或Dear Bob写上相对Bob说的话，并确保Bob出现在收件人列表中。 给陌生人发邮件时先自我介绍如果对方不认识你，第一件事应该是表明自己的身份和来意，以示对对方的尊重。 邮件正文要把事情说清楚应该把事情一次性说清楚，说正确。否则过个两分钟再来一封邮件来”补充”或“更正”某些信息，这种行为不够专业，也会让人反感。让收件人看完邮件就能明白你在说什么，他要怎么做，是最重要的原则。必要时我们可以通过1，2，3，4等分段落说明一个复杂的问题，还可以使用大写字母，加粗，加大字号，修改文字颜色等手段让收件人快速抓住重点，但也不宜过多。 邮件末尾的祝福语在邮件的末尾另起一行顶格可以写句祝福语，比如“Best Regards”，还可以表达感谢并祝福，比如“Thanks &amp; Best Regards”。 不要忘记附件发送邮件时最容易忘记的就是附件，时不时就会看到某个邮件中明明提到了“见附件”等字样，但是没有任何附件的情况。推荐在写邮件时先添加附件。 附件不宜过大首先邮箱存储空间是有限的，存放大量附件很容易爆掉。每个人都下载一份拷贝，也不利于修改和协作。另外如果对方在旅行出差中，使用移动网络或者很慢的WiFi，下载一个大文件是很耗时间和金钱的。推荐的方法是发送链接，如果不行应该尽量压缩附件。 回复邮件时也有一些原则，如下： 收到邮件后，24小时内必须回复，这是对发件人的一种尊重，如果无法立即准确的答复别人，回复“我将在X天内回复你”也是可以的。 回复之前要想想是“回复全部”还是“回复”。有些行政通知类的邮件是发给公司全员的，一定不要“回复全部”。 回复邮件时，你发现另外一个人也需要参与进来，你可以把他添加到收件人或抄送人中，并在邮件中说明“把 XXX，XXX 添加到收件人列表中”，让别人知道有新人加进来。 回复邮件时，可以根据邮件内容适当修改邮件标题，不要出现一串“RE: RE: RE:”或“回复：回复：回复：”，现在很多邮件客户端就能自动识别，如果已经有了“RE: ”或“回复：”就不再添加了。 最后再说一个非常非常重要的规则，多检查几遍，不要出现错别字；中文要使用全角标点符号，英文使用半角标点符号，英文的标点符号之后要有一个空格；英文名字首字母要大写等。我注意到很多同事都会犯这类错误。 OK，以上就是写电子邮件时要注意的一些事项。希望各位写的每封邮件都能规范整洁。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用 Shell 实现服务的监控和重启]]></title>
    <url>%2F2019%2F04%2F18%2Fmonitor-shell%2F</url>
    <content type="text"><![CDATA[我们在公司内部通过verdaccio创建了私有npm仓库，但是verdaccio不太稳定，每周都可能会挂掉一次两次的，在网上也没有找到好的解决方法。随着挂掉次数越来越多，痛定思痛，决定写个脚本主动监控verdaccio并在其挂掉以后自动重启。 判断服务是否正常运行怎么判断verdaccio是否正常正常呢？如果是我肉眼判断的话，我直接打开verdaccio的主页，比如http://example:4873，如果能看到页面内容则说明服务正常，如果看到”无法访问次网站“等字样则说明服务挂掉了。为了实现自动化的监控和重启，我们必须通过脚本程序来做，在此我们可以通过curl命令来获取http://example:4873页面的响应码，如果返回200则说明服务正常，否则服务挂掉了。我们使用curl命令的参数-I只显示响应头。然后通过判断响应头中是否包含HTTP/1.1 200 OK字样来检查服务是否正常。因此就有了以下程序： 123456header=`curl -I http://example:4873`if [[ $header =~ 'HTTP/1.1 200 OK' ]]; then echo 'ok'else echo 'not ok'fi 通过以上代码我们就可以监控服务是否正常了，我们再来拓展一下思路，其实我们还可以通过检查verdaccio服务进程是否存在来判断verdaccio服务正常与否。怎么判断进程是否存在呢？这里不再详细介绍，请参考一下代码： 1234567# 查询有几个进程占用了`4873`端口count=`lsof -ti :4873 | wc -l`if [[ $count -ne 0 ]]; then echo 'ok'else echo 'not ok'fi 第二种方案不如第一种直观，我仍然把它写出来主要是提醒各位多多思考，不要拘泥于某一种方案。接下来我们仍然采用第一种更加直观的方案继续进行。 服务挂了以后自动重启在上一节中我们已经能够检查服务是否正常了，在这一节中我们要实现的是自动重启服务，这个就非常简单了，想想我们是怎么启动verdaccio的，嗯，我们是在控制台中输入一下命令，nohup verdaccio &amp;，其中nohup让命令永远执行下去，即使用户退出也没有关系，&amp;让程序在后台运行。两者结合起来就可以程序永久地在后台运行。 1234567header=`curl -I http://example:4873`if [[ $header =~ 'HTTP/1.1 200 OK' ]]; then echo 'ok';else # 重启服务 nohup verdaccio &amp;fi 定期监控服务运行状况通过前面两个步骤我们已经写出一个脚本，它会检查服务是否正常运行，如果服务挂掉了就会重启。这还是这个检查工作是一次性的，需要我们不停地执行脚本。当然可以通过crontab命令（以后再介绍）实现，不过在这里我们将通过写一个死循环逻辑来实现每隔一段时间来检查服务是否正常运行。 123456789101112while truedo header=`curl -I http://example:4873` if [[ $header =~ 'HTTP/1.1 200 OK' ]]; then echo 'ok'; else # 重启服务 nohup verdaccio &amp; fi # 每个10秒检查一次 sleep 10sdone sleep命令会让程序暂停一段时间，很适合用在循环方式运行的监控脚本中，它有一个参数表示要暂停的时间，时间单位可以是s秒，m分钟，h小时和d天。默认为秒。我们也可以传入小数0.1s来实现毫秒级的睡眠，但是sleep命令只能保证10ms的睡眠，如果你对时间精度要求特别高的话，sleep命令就无能为力了。 重启服务以后记录日志当服务挂了以后除了重启以外，还需要将重启行为记入到日志文件中，方便以后我们查看什么时候服务被重启了，最终代码如下： 123456789101112131415161718#!/bin/sh# 获取脚本目录shell_folder=$(cd `dirname $0`; pwd)while truedo header=`curl -I http://example:4873` if [[ $header =~ 'HTTP/1.1 200 OK' ]]; then echo 'ok'; else # 重启服务并记录日志 nohup verdaccio &amp; echo `date +%Y-%m-%d\ %H:%M:%S` "restart" &gt;&gt; $shell_folder/verdaccio.restart.log fi # 每个10秒检查一次 sleep 10sdone 执行命令nohup sh verdaccio.sh &amp;就启动了一个守护进程，实现了每隔10秒检查一次服务是否运行正常，如果挂掉就会重启的功能，并且还会记录到日志中。 如果你是在Ubuntu服务器上运行该命令，可能会遇到这个错误[[: not found，这是因为sh只是一个符号链接，最终指向是一个叫做dash的程序，自Ubuntu 6.10以后，系统的默认shell /bin/sh被改成了dash。dash(the Debian Almquist shell) 是一个比bash小很多但仍兼容POSIX标准的shell，它占用的磁盘空间更少，执行shell脚本比bash更快，依赖的库文件更少，当然，在功能上无法与bash相比。所以在Ubuntu上我们需要指定使用bash，即nohup bash verdaccio.sh &amp;。 如何取消服务自动重启如果有一天，你想关闭verdaccio服务，守护进程就会检测到该服务挂掉，并自动重启该服务。导致你想关闭该服务也不行了。所以我们首先要先关闭守护进程，如何关闭呢？我们可以使用jobs命令查看守护进程ID，然后杀掉该进程。12jobs -lkill -9 &lt;id&gt; 针对verdaccio的特殊方案其实verdaccio是用Node写的，因此可以通过pm2让其达到自动重启的功能，命令如下：123456# 启动pm2 start which verdaccio # 停止pm2 stop which verdaccio # 查看日志pm2 show verdaccio]]></content>
  </entry>
  <entry>
    <title><![CDATA[想提高决策的效率？试试 DACI 框架]]></title>
    <url>%2F2019%2F04%2F10%2Fdaci-desicion-framework%2F</url>
    <content type="text"><![CDATA[相信大家都遇到这样的情况，拉了一堆人开会讨论一个问题，整个过程热火朝天，会议也一再拖延，但是最后还是没有结论。有没有什么方法能够改善这个状态呢？我今天就给大家介绍一个Atlassian提出的一种方案：DACI框架。 什么是DACI?DACI是一个框架，通过定义角色促进我们做出重大决定。这个框架非常简单，DACI分别代码四个角色，如下： 简写 描述 职责 D Driver，即会议的驱动人 他负责召集参会人，分享会议信息，安排会议时间地点等工作 A Approver，即会议的审批人 他将作出最终的决定 C Contributors，即贡献者 他们可以对议题给出自己的看法和专业见解，但不能做决定 I Informed，即会议最终的决定会通知给这些人 要确保每个团队成员都能拥护团队做出的最终决定DACI才能起作用。如果不能说出自己的顾虑并且相信它们会被充分考虑，团队将会将会陷入无尽的争吵，并且什么决定也做不了。个别成员可能为了追求他支持的方案，而希望官方决定最终失败。 实施步骤第一步 创建跟踪页面（5 分钟）将正在考虑的内容以及相关的研究，利弊，建议等记录在案，有利于核心成员提供建议，有利于决策者做出最终决定。可以通过Team Playbook – DACI插件在Confluence上创建一个页面。如果你并不使用Confluence可以下载模板打印出来再填写表单。 第二步 定义各种角色（10 分钟） 谁是驱动人？一个决策有一个驱动人，他不需要推动整个项目，只需要推动这个决策。 谁是审批人？一个决策有一个审批人。 谁是贡献者？一个决策可能有多个贡献者，贡献者可能来自核心团队之外，任何具有相关知识或经验的人都可以作为贡献者。 谁应该被告知？任何直接受该决定影响的人都需要被告知，很可能来自核心团队之外。 第三步 制定进击计划（15 分钟）现在就要思考需要收集哪些信息才能做出决定，让我们来看看Team Playbook – DACI中包含哪些信息： 截止日期 Due date - 作出决定的截止日期。背景 Background - 为什么需要做此决策？现状 Current state - 你现在在哪里。支持数据 Supporting data - 您为完成决策所做的研究。可选项 Options considered - 每个选项都有一列的表格，您可以在其中总结利弊，风险，权衡，估计成本或工作量等。建议 Recommendations - 贡献者的意见。常见问题解答 FAQs - 回答常见问题或预期问题。参考文献 References - 参考资料的链接列表，以及相关原因的简要说明。行动项目 Action items - 与决定相关的任务或后续行动清单。结果 Outcome - 最终决策 第四步 让您的团队参与进来将跟踪页面发给你的团队成员，请求他们的意见。如果需要某人来填写页面的某些部分，现在就去找他们。如果你觉得事情已经停滞不前，就把驱动人和贡献者拉到一个会议室里，如果能带上审批人，也是个好主意。让他们充分表达他们的关注点，建议，其他选项等等。面对面沟通非常有效，可以快速回到正轨。 以上内容主要来自Atlassian官网，下面是他们公司某团队使用DACI框架决定要不要支持更多语言的例子，给你做个参考。]]></content>
  </entry>
  <entry>
    <title><![CDATA[koa-router-decors@4.0.0 功能介绍]]></title>
    <url>%2F2019%2F04%2F07%2Fkoa-router-decors%404.0.0%2F</url>
    <content type="text"><![CDATA[上周koa-router-decors发布了它的第 4 个大版本 V4.0.0，这次更新带来了很多新的功能。从名字可以看出通过它可以使用装饰器编写 Koa 路由。确实如此，通过它，你不仅可以充分利用koa-router强大的功能，还可以忘记 koa-router 的存在，更加关注在核心业务逻辑。 下面我从两个方面介绍一下koa-router-decors，首先是基本用法，其次是高阶用法。 基本用法koa-router-decors最基本的功能就是简化编写路由和加载路由的方法。下面我们来看一下它是如何简化的。 编写路由koa-router-decors提供了 5 种名为get, put, post, del 和 patch的装饰器，表示该路由对应的 HTTP 方法，他们还接受一个字符串参数，表示该路由对应的 URL 地址。它从 koa-router 继承了一种能力，你可以编写类似/user/:id这种带有占位符的 URL，它通过path-to-regexp生成正则表达式来匹配某一类请求。 12345678910111213import &#123; get, put, post, del, patch &#125; from 'koa-router-decors';class User &#123; @get('/user/:id') async getUserById(ctx) &#123; ctx.body = &#123;&#125;; &#125; @post('/user') async createUser(ctx) &#123; ctx.body = &#123;&#125;; &#125;&#125; 通过以上步骤我们编写了路由文件，但是只有在启动应用时加载它们才能生效。比如使用了koa-router-decors的一个典型的应用入口文件index.ts是这样的： 123456import * as Koa from 'koa';import &#123; load &#125; from 'koa-router-decors';const app = new Koa();app.use(load('/api', `$&#123;__dirname&#125;/router`).routes());app.listen(9100); koa-router-decors还提供了一个load方法，我们通过它加载上面我们编写好的路由文件。它接受两个参数，第一个参数是prefix，表示所有 URL 的统一前缀，比如我们想让所有的 URL 以api打头，如果在每个路由文件中都写上api会很冗繁，并且想修改时要同时修改很多路由文件的很多处。第二个参数是路由文件所在文件夹地址，比如`${__dirname}/router`。它会同步加载该文件夹下所有路由文件中的所有路由，并返回一个 koa-router 实例。然后你就可以像使用 koa-router 一样使用它了。 这是koa-router-decors提供的最基本的功能，我们下面将介绍它的一些高阶功能。 高阶用法1. 一个函数对应两个路由比如在我们的官网项目中，通过标签查询文章的页面地址是&#39;/tag/:name/page/:page&#39;的，但是首页的页面地址是可以简化成&#39;/tag/:name/&#39;的，也就是说没有说第几页时就是第一页。这时候我们只需要将两个装饰器同时作用在一个路由上即可，是不是非常简单呢？ 1234567export default class Page &#123; @get('/tag/:name/') @get('/tag/:name/page/:page') public async renderTagPage(ctx: Koa.Context) &#123; await Page.getPost('tag', ctx); &#125;&#125; 2. 处理 URL 前缀的特例为了便于区分动态请求和和静态资源，我们一般给所有的动态请求都加上/api前缀，但是存在特例情况，个别请求地址因为第三方系统的限制，它并不是以/api打头的。怎么办呢？我们可以通过get等装饰器函数的第二个参数来指定，如下： 123456class User &#123; @get('/method', &#123; prefix: '' &#125;) async get(ctx: Koa.Context) &#123; ctx.body = &#123;&#125;; &#125;&#125; 这样，上述文件所有生成的路由地址是/method，因为它指定了自己特殊的前缀，而不再使用load函数中指定的前缀。你可能会想到，如果特例情况较多呢，每次手动指定也很烦，没有关系，你可以将路由文件放置在两个文件夹中，两次调用load函数即可。 12345const app = new Koa();// 可以多次调用`load`分别加载不同的目录app.use(load('/api', `$&#123;__dirname&#125;/router/api`).routes());app.use(load('/web', `$&#123;__dirname&#125;/router/web`).routes());export default app.listen(9100); 3. 添加多个面向切面的中间件在 Koa 中，想给所有路由添加一段面向切面的通用逻辑，比如添加日志，比如计算响应时间等，非常简单，通过app.use即可。但是如果只想给部分路由添加这种逻辑呢？如果还用app.use就根据 URL 等进行判断了，可能会用到正则表达式，可能会用到很多判断条件等，有没有简单一点方法呢？如果你使用koa-router-decors就非常简单了。代码如下： 1234567891011121314151617// 给该类中定义的所有路由添加 setResponseTime 中间件@middlewares([setResponseTime])class User &#123; @get('/method') async get(ctx: Koa.Context) &#123; ctx.body = &#123; method: ctx.method, &#125;; &#125;&#125;// 以下就是一个给路由添加响应时间响应头的中间件async function setResponseTime(ctx, next) &#123; let date = new Date(); await next(); ctx.set('X-Response-Time', String(new Date().getTime() - date.getTime()));&#125; 如果只想给路由文件中某一个路由添加中间件可以这么做： 123456789class User &#123; // 给特定路由添加 setResponseTime 中间件 @get('/method', &#123; middlewares: [setResponseTime] &#125;) async get(ctx: Koa.Context) &#123; ctx.body = &#123; method: ctx.method, &#125;; &#125;&#125; 以上就是koa-router-decors@4.0.0所提供的功能了，欢迎使用，有问题请反馈给我，有建议也请联系我。]]></content>
  </entry>
  <entry>
    <title><![CDATA[为什么要引入 BFF]]></title>
    <url>%2F2019%2F03%2F25%2Fwhy-bff%2F</url>
    <content type="text"><![CDATA[上周六，也就是 2019 年 3 月 23 日，我们组织了一次主题为《重新定义前端——基于 Node 的 BFF》前端技术沙龙，我给大家分享了《为什么要引入 BFF》。以下就是这次分享的主要内容。 BS 架构发展的历史在 BS 架构发展之处，典型的技术包括 PHP，JSP 等，那时候最常见的就是：一个人负责一个网站，一个页面一个文件。一个人承担了现在一个团队的角色，产品经理，开发，测试，运维统统一个人干，一个文件完成一个页面，包括处理请求参数，连接数据库，修改数据，查询数据，展示数据等等，可以说是一个蛮荒时代，这时候基本没有什么架构，代码质量基本全靠程序员自身素质。 很快地上述开发模式遭到普遍的摒弃，MVC 架构渐渐成为主流。值得注意的是 MVC 最早在 1978 年就被提出，那时候还都是 CS 架构的应用程序。在 MVC 架构里，Model(M)负责访问数据，View(V)负责显示数据，Control(C)负责处理消息，调用 Model(M)访问数据，并通过 View(V)显示数据。 到目前为止，BS 架构的应用体验还是非常差的，和服务器端交互也仅限于表单提交，并且会有较常时间的白屏。有了问题迟早就会有解决方案，后来出现了 AJAX 技术，我们可以通过 AJAX 技术做出非常酷的应用，当时最杰出的代表就是谷歌的 GMail 邮箱应用。以 AJAX 技术为代表的前端技术给用户体验带来了极大提升，使得前端技术在软件开发中逐步变得主流，前端技术和后端技术差别较大，抛开前端后端编程思想上的差异不谈，让一个写惯了 Java 代码的程序员去写简单的 JavaScript 还行，但是遇到富客户端应用场景就吃不消了。这就促使了一部分后端程序员去专职负责前端技术，就产生了专职前端程序员。我在 2007 年毕业后也做了 2 年多 J2EE 的，后来因为项目的机缘我才转做前端的。跟我类似，国内最初的前端基本都是从后端转来的。 那时候前端后端的协作方式有两种，第一种是前端写静态页面，后端将静态页面转成视图层模板，前端再复查后端转换的效果对不对。前端后端这么协作确实能够做出复杂的富客户端应用了，但是缺点也是相当地明显，后端必须要等前端完成以后才能开始视图层开发工作，如果前端能够一次性高质量完成工作还好，如果因为需求变动或代码质量能原因要返工，后端也要跟着一起来。第二种就是前端负责视图层，后端提供数据。这种方式解决了一部分问题，但是仍要前端后端密切配合，同事负责一块代码，要求前端熟悉后端语言，甚至了解后端架构。这两种模式都存在前端后端高度耦合的问题，沟通频繁，维护复杂，无法快速响应变化，代码的腐烂是迟早的事。 2009 年 Node 出现之初并没有引起什么轰动，但是它却带来了前端生态圈的空前繁荣。Node 让我们使用 JavaScript 的语法编写脚本和服务器端应用程序，让前端生态圈能够能够形成一个闭环。以前要做 JavaScript 的代码的合并压缩就要使用 Java 等语言编写的压缩的工具，因为编程思想和语法等因素导致前端很难了解和涉足后端的开发，有了 Node 这一切都有了可能。以 React, Angular, Vue 为代表的前端开发框架或工具给我们带来一种全新的开发模式：后端提供数据，前端渲染界面，前端后端通过 HTTP 请求传输数据。前端第一次这么独立，前端第一次这么拥有强大的能力，一切看起来那么完美，我们欢呼雀跃，前后端终于分离了。 从以上介绍来看，BS 架构的发展历史是关注点分离的演进过程。 美好外衣下的问题但是我们还是会遇到很多问题。 前几天我们 App 上突然遇到不能登录的问题，经过排查发展可能跟企业微信版的一个修改本有关，并且有一些还不能解释的问题。 一些批量操作非常耗时，用户傻傻等待会感到非常焦虑，还在想着系统在处理吗？还是挂掉了？在性能难以提升以后，我们想通过告诉用户我们系统的处理进度来减少用户焦虑。我们想到的技术是 BigPipe，但是我怎么跟后端解释他们似乎都不懂，如果我会写后端代码，我就直接帮他们修改了，就不用这么啰嗦了。 为什么前端没有 bug，也需要陪着后端一起加班？虽然前端后端的代码可以分别独立开发，运行环境也是独立，但是毕竟需要一起部署，一起上线。 在组织人事的页面，用户期望看到排班和考勤等信息，而排班和考勤分别属于其他产品线，这时候只能通过 iframe 来加载其他产品线的页面。 我们经常听到前端抱怨后端对需求响应的太慢了，前端完成了以后还要等后端。后端抱怨前端又修改接口了，又要加字段了。 那么，怎么解决呢？那就是引入 BFF。 重新定义前端，引入 BFF什么是 BFF? BFF 这个词是 2015 年 11 月 Sam Newman 在他的一篇博客中提出的。BFF 是 Backends for Frontends 的简写，为了前端的后端。Sam Newman 的博客还有一个副标题：Single-purpose Edge Services for UIs and external parties，为了用户界面或外部方的单一目的的边缘服务。用户界面比如我们常见的网页，或 App，外部方比如第三方 App，客户 App，企业微信，小程序等。其实这中模式更早一点就出现了，淘宝在更早一点的时候就设立中途岛项目，其主要内容就是 BFF。既然是为了前端的后端，所以跟前端更加密切，适合前端同事来负责；既然是后端，所以要部署在服务器。 BFF 负责哪些事情呢？BFF 主要负责以下几件事情： 聚合 将后端多个请求合并成一个请求，以减少网络传输时间。这些请求可能来自一个服务，也可能来自多个服务。 适配 因为遵守的接口规范不同，多个微服务和外部服务的接口可能有很多不同，在 BFF 层可以做一些适配，给前端代码提供同一个的数据格式和接口格式。 裁剪 同样的信息在不同的客户端有着不同的展现，比如手机屏幕尺寸较小，内存较小，CPU 性能较差，只能展示部分非常重要的信息，如果和电脑上使用同一个接口，势必导致手机上页面渲染变慢，还会浪费手机电量和网络流量。 哪些公司在使用 BFF我们最为熟知的，也是这个领域最早发力的当然是淘宝网了，同是阿里巴巴集团下的蚂蚁金服也在使用。有很多公司都在使用，只是相关信息披露的较少。 BFF 给我们带来什么解放后端 后端仅仅关注核心业务，不再关心用户界面。不管最终产品形式是 Web 网页，App，还是公众号，还是小程序，核心逻辑都不变，都一样，都不需要后端关心。 后端仅仅提供通用业务接口，不再关心数据怎么展示，比如不管是导出 PDF，导出 Excel，还是在表格里展示，都是数据的一种显示形式，和核心业务无关，因此交给前端更加合适。 赋能前端 前端开始独立负责一个网站，有能力和机会做各种优化，想通过 BigPipe 进行优化时，也不再需要后端参与，减少沟通成本，提高研发效率。 前端基于已有通用接口，可以快速开发新产品。天下武功，唯快不破；快速开发已经成为一个企业的核心竞争力。公众号，小程序，企业微信，钉钉，快应用等层出不穷，如果我们还像以前那样用一个庞大的团队负责一个端就太笨重了，成本很大，动作很慢。 前端基于已有通用接口，可以快速客制化。如果我们把客制化当成一个新的产品形式的话，那么这个论点实际上是上个论点的推论。 前端基于已有通用接口，产品可以行业化。我们的客户很群很杂，有制造业，有零售业等等，每个行业都有不同的特点，也因为此我们公司已经根据不同的行业对顾问团队进行了划分，分成不同的行业群。在行业群成立之初，很多顾问非常兴奋，就问到对于不同行业群的客户，会不会提供不同的产品？当然他们得到了一个让他们失望的答案。如果我们引入 BFF，后端将通用逻辑封装在接口中，前端基于不同的行业特征做出不同的产品出来更有可行性。 承担更多责任，获得更多发展机会。在职业发展中，后端因为接触了比较核心的业务逻辑，所以他们在晋升中更有优势。项目负责人或技术总监岗位一般也都是后端出身，如果有了 BFF 以后，前端又了更多发挥的空间，可以承担更多的责任，可以获得更多发展机会。 扩展业务开放通用接口给合作伙伴，多了一种合作的可能，以接口的形式提供服务，以接口的调用次数等收费。开放通用接口给客户：我们的很多客户都比较大，有开发团队的，对于一些用户特殊的需求，我们客制化的成本也很高，得不偿失，这时候可以让客户基于我们的通过接口来实现特殊的业务逻辑。 产品质量更加彻底的前后端分离模式，让前端后端架构更加清晰，让接口更加趋于稳定，促进自动化测试落地，从而提高产品质量 BFF 又有哪些问题 对前端开发的能力要求更高，比如至少要掌握 Node，以及后端开发思想。 对前端开发的人力需求更大，这个是很明显的，前端多了 BFF 层的开发工作。 对后端开发的能力要求更高。以前后端值对应一个前端，只需要提供前端需要的接口就行了，使用 BFF 以后，后端就显得更加抽象一些，后端开发的时候可能跟不知道产品形态，也只能通过单元测试或 PostMan 等工具来测试。如果一个接口设计的不好，或者产品需要发生变化，可能需要同时维护多个版本。 站点数量增加，部署更复杂。 多了一些内网请求，性能怎么破？一般情况下后端提供 HTTP 协议的接口，对于性能有瓶颈的，也可以采用 RPC 方式。相信通过合理拆分接口，合理使用缓存这个问题影响不大。 那么多或大或小的公司都在使用这中开发模式，相信这些问题都得到了解决，至少得到了控制。因此不需要有太多担心。网站架构是不断演化来的，不是凭空设计的。果断开始，逢山开路，雨水搭桥，相应我们会走出一条更有特色的道路来。 参考资料 Pattern: Backends For Frontends 微服务下使用 GraphQL 构建 BFF 干货 | 携程机票 Node.js 开发实践 架构的本质是管理复杂性，微服务本身也是架构演化的结果 微服务架构~BFF 和网关是如何演化出来的]]></content>
  </entry>
  <entry>
    <title><![CDATA[生命的密度]]></title>
    <url>%2F2019%2F03%2F15%2Fdensity-of-life%2F</url>
    <content type="text"><![CDATA[广州离我们（苏州）那么远，我从来没有想过花一个周末的时间去一趟，直到两周前仔细查询了 12306 应用，根据车次信息制定行程，周五晚上下班之后从苏州坐动车去广州，中间在上海虹桥换乘。周一晚上从广州坐动车回苏州，同样在上海虹桥换乘，周二早上正好直接来上班。具体车次信息如下： 从苏州去广州：① D2211 苏州（18:47）–&gt; 上海虹桥（19:20）② D931 上海虹桥 20：00 –&gt; 广州南（次日 07:12) 从广州回苏州：① D933 广州南（19:24）–&gt; 上海虹桥（次日 06:50)② D2212 上海虹桥（次日 07:37）–&gt; 苏州（次日 08:11） 就这样请了一天假从苏州去广州玩了三天两夜，前后在动车上睡了两晚。当然后来为了回家洗个澡再去上班，我周二早上额外请了一个小时的假。 通过这次旅行，我们可以看到，经过合理的安排我们很大程度上增加生命的密度，让生命更有意义。通常周末窝在家里，躺在床上赖一会，磨磨唧唧吃个早饭，做做家务，写写代码，两天也就过去了。而我这次用一个周末和一天假就在广州逛了三天两天，比起平时的生活，可谓非常的充实，非常的满足。因为有各种意外因素，生命的长度我们不能控制，但是我们可以锻炼身体，让生命更有质量，我们可以合理安排行程，让生命更有密度。 顺便说一点生活小技巧，是关于火车站内换乘通道的。从苏州去广州在上海虹桥换乘时，我还是习惯性地先出站再进站的方法完成换乘。这样非常麻烦，尤其是带着大包小包，带着老人孩子的乘客。从广州南站下车的时候，我打算乘坐一个直梯出站时被告知这是换乘通道，我应该去乘扶梯出站。我好像突然想起来了，隐隐约约觉得以前听过换乘通道这回事。以前做过那么多次火车，我不可能没有看到过“换乘通道”的字样，因为不需要换乘，换乘通道都被我熟视无睹了，以至于当我这次需要换乘时也想不到使用这个方法。想想我来广州时在上海虹桥换乘的那么紧张的麻烦的场景，我决定回去时一定要尝试一下换乘通道。当广州南的动车准点到达上海虹桥后，我迅速下车并找到换乘通道，直接进入二楼候车大厅，检票员在检查了我的换乘车票以后直接放行，免去了出站进站安检等繁琐步骤，从下车到候车室大概只花了 3 分钟的时间。考虑到高铁动车一般不会晚点，需要换乘时留个 10 分钟的时间还是有很大可能的，当然考虑到班车晚点或人流量大等意外因素，建议换乘时间预留适当多一点。另外为了更加顺利地换乘，建议出发前将两班火车的车票都取出来。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何从`WordPress`中导入文章到数据库中]]></title>
    <url>%2F2019%2F03%2F05%2Fimport-posts-from-wordpress%2F</url>
    <content type="text"><![CDATA[公司成立已经10年了，通过WordPress创建的官网也运行10年了。一直没有出现什么严重的问题，随着公司的成长，对官网的要求也在变高，后来有专业前端的加入实现页面效果，而WordPress对专业前端却没有那么友好了，后来我们决定抛弃WordPress对官网进行重构。考虑负责官网的人力少，项目比较简单，因此我们决定用Node(Koa)来实现一些动态请求，比如给用户发送手机验证码，收集用户表单数据等动态请求，以及后台管理系统；用Pug + Less + Webpack + Browserify编写静态页面等，通过阿里云OSS+CDN存储和分发图片等资源。这些都不是本文的重点，本文的重点是较少如何将现有官网中的文章迁移到新系统中。 下面我简单介绍一下WordPress，它是一个基于PHP和MySQL的开源内容管理系统，通常用于架设博客网站。通过插件和模板可以实现很多功能，是当今最流行的博客系统。 获取文章列表在开始迁移老系统的文章这个任务之后，我首先找到官网系统的数据库，登录了以后发现文章表，但是为了安全起见，这个用户只能在服务器本机登录，我也不想添加用户或增加外部访问权限，所以我想通过WordPress公开API来获取文章列表，很幸运我搜索到 公开 API：https://codex.wordpress.org/XML-RPC_WordPress_API以及对应的Node 软件包 wordpress，这样我就做了一下尝试： 12345678910var`WordPress`= require(&apos;wordpress&apos;);var client = wordpress.createClient(&#123; url: &apos;http://www.domain.cn&apos;, username: &apos;用户&apos;, password: &apos;密码&apos;,&#125;);client.getPosts(&#123; number: 10 &#125;, function(error, posts) &#123; console.log(posts);&#125;); 很好，通过这个软件包我们已经能够获取10篇文章了，我们官网的文章大概有几百篇文章，因此我把number修改成1000，这样我就获取到所有文章了。但是我还发现这个接口给出的文章内容（content字段）不是最终的HTML文本，而包含了一些WordPress特殊标记，比如 1[caption id=&quot;attachment_16488&quot; align=&quot;aligncenter&quot; width=&quot;721&quot;]&lt;img class=&quot;wp-image-16488 size-full&quot; src=&quot;http://www.&lt;domain&gt;.cn/wp-content/uploads/2019/02/5s.jpg&quot; alt=&quot;&quot; width=&quot;721&quot; height=&quot;3412&quot; /&gt; 5s[/caption] 所以我并没有能够获取文章的最终真实内容，我也搜索了这个问题，看了各种答案，最后还是需要通过网络爬虫的技术来获取文章内容。既然动用了网络爬虫了，我还需要上述的wordpress软件包吗？我们也可以通过sitemap.xml文件来获取文章列表，然后爬取每篇文章的链接，从页面中获取文章内容，作者，标签，创建时间等，但是还是有一些信息并没有出现在这个页面，影响较大的就是文章摘要，和缩略图等。因此我决定继续使用wordpress软件包获取所有文章信息，对于文章内容则通过网络爬虫技术来获取。 爬取文章内容怎么爬取文章内容呢？ 我首先想到的是以前用过谷歌出品的 HeadLess Chrome 浏览器puppeteer，但是考虑到安装比较复杂，并且有点杀鸡用牛刀的感觉，我就放弃了，通过在npm网站中搜索发现以前也了解过的jsdom，通过它提供的接口很容易就获取了文章内容，代码如下： 1234const dom = await JSDOM.fromURL(post.link);const document = dom.window.document;const $content = document.querySelector('.entry-content');const content = $content.innerHTML; 这样就把所有文章到导入到新的数据库中了。 生成文章摘要很快发现了一个问题，大部分文章都没有摘要，可以猜想到WordPress是在渲染到页面时才根据文章内容生成摘要的，根据WordPress官网可以看到生成摘要的算法比较简单，就是从文章内容中截取前90个字符做为摘要。我还是希望把生成摘要的工作放在创建文章和修改文章，毕竟管理每天一班创建一篇文章，慢一点没有问题，而我们每天有成千上万的用户来查看文章。所以我需要根据文章内容生成摘要。 1const excerpt = post.excerpt || $content.textContent.trim().substring(0, 90); 注意在jsdom中元素是没有innerText属性的，需要使用textContent代替。这样摘要也生成了。文章已经从老系统迁移到新系统了。 转存图片资源还有一点不要忘记，这些文章所引用的图片资源还存放在老系统上，我们需要将这些图片资源迁移到阿里云OSS上，并且修改文章中图片的地址。要操作阿里云OSS，当然首选阿里巴巴的一群小伙伴提供的Node软件包ali-oss，它提供了上传图片的接口：client.put(name, file)，name就是文件名，而file是文章数据，可以是String, Buffer, ReadStream, File（浏览器），Blob（浏览器），比较好用的是可读流。代码如下 12345678910http.get(url, async res =&gt; &#123; if (res.statusCode !== 200) return onError(); try &#123; let path = require('url').parse(url).pathname; if (rename) path = rename(path); await oss.put(path, res); &#125; catch (e) &#123; onError(); &#125;&#125;).on('error', onError); 通过Node原生API http.get获取图片的可读流，请注意该接口既不是基于Promise的，也不是错误优先的，所以对其错误处理一定要小心。通过上述代码我们就可以将文章缩略图和文章内容中的图片上传到阿里云OSS中，生成基于CDN的图片地址，然后替换文章中相应字段即可。 爬虫相关问题这样文章导入就没有业务上的问题了，但是还是出现一些错误，比如域名解析错误，可能是因为我们公司内部的域名服务器的问题，对于频繁的域名解析不能正确响应。我们没有详细了解，反正我频繁访问的域名只有一个，因此直接修改本机hosts文件。还有有些图片下载会失败，后来改为在每处理完一篇文章之后睡眠2秒之后再处理下一篇文章，避免服务器压力过大，或者触发反爬虫，反DOS攻击机制。代码也非常简单： 123456// utils.tsexport default &#123; sleep: ms =&gt; new Promise(r =&gt; setTimeout(r, ms)),&#125;;// import.tsawait utils.sleep(2000); 以上就是将基于WordPress的老官网中的文章迁移到新系统中遇到的问题，主要是通过WordPress的公开API获取文章列表，并通过爬虫相关技术获取文章内容。如果以上内容有误或你有任何建议，欢迎留言。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何快速找到 Nginx 配置文件？]]></title>
    <url>%2F2019%2F02%2F25%2Fwhere-is-my-nginx-config-file%2F</url>
    <content type="text"><![CDATA[我虽是前端工程师，也经常会去 Linux 服务器上修改 Nginx 配置文件并且重启，但是那么多的服务器，每个服务器上安装 Nginx 的版本和方法也不尽相同，导致 Nginx 配置文件的位置并不相同，那怎么才能快速地找到 Nginx 配置文件呢？这里介绍一个简单的方法。 如何快速找到 Nginx 配置文件不知道你是否还记得检查 Nginx 配置文件是否合法的那个命令吗？对的，就是nginx -t。如果通过检查，你会看到类似以下信息， 123nginx -tnginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is oknginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful 如果没有通过检查，就有各种可能错误，比如以下就是一种可能： 1234nginx -tnginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is oknginx: [emerg] open() "/aa/aa.log" failed (2: No such file or directory)nginx: configuration file /usr/local/etc/nginx/nginx.conf test failed 你可能已经注意到不管配置文件是否正确，nginx -t命令都会告诉你 Nginx 配置文件在哪里，所以通过执行nginx -t命令可以帮我们找到 Nginx 配置文件。 如何快速找到任何我想要的文件你可能会说，上面的方法不具有通用性，如果我想找到其他文件就没用了。的确是这样，不过我接下来介绍一个命令，它可以帮你快速找到任意一个文件。 我们要安装命令是locate命令，它和find -name作用类似，但是速度更快，因为不会检索文件目录，而是去事先建立好的数据库里查询。这个数据库每天更新一次，因次如果你的文件是刚刚创建的，是不能立即搜索到的，需要手动执行updatedb命令才行。 说了那么多，我们来看看怎么安装吧？ 1yum install mlocate 安装好了，就可以用起来了，该命令常见参数如下：-b：只匹配 Base Name，比如locate -b &#39;\passwd&#39;；-i：忽略大小写，比如locate -i PASSWD-r：正则表达式。 它也有配置文件，一般位于/etc/updatedb.conf，通过它可以配置，哪些后缀的文件会被忽略，哪些目录下的文件会被忽略等。必要时可以修改该配置文件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSH 免密登录远程主机]]></title>
    <url>%2F2019%2F02%2F11%2Fssh-wihtout-password%2F</url>
    <content type="text"><![CDATA[开发过程中经常需要通过SSH协议登录到服务器做一些部署测试环境、查看日志等操作，需要记住很多服务器的账号和密码。密码设置的太简单了，不安全；密码设置的太复杂了，记不住。我也曾经通过印象笔记等软件维护过服务器的账号和密码，查看密码还是很麻烦，有没有什么简单的方法呢？ 相信大家都使用过Git以及Github，不知道你是否还记得，你曾经在本地使用ssh-keygen生成一对秘钥，然后将公钥（~/.ssh/id_rsa.pub）添加到Github网站上，在这个操作之前，每次提交代码都需要输入密码，烦不胜烦。 看到这里，你是不是也在想，同样是SSH协议，登录服务器应该也可以做到免密。答案是肯定的。以下我将介绍如何实现通过SSH协议免密登录服务器。 检查秘钥是否存在，如果存在请直接进入第 3 步，如果不存在请进入第 2 步。如果你以前在当前电脑上开发过项目，提交过代码，一般都已经成了秘钥。你也可以通过ls ~/.ssh命令可以检查秘钥是否已经生成，比如在我的电脑上执行该命令打印出id_rsa id_rsa.pub known_hosts，而id_rsa和id_rsa.pub正是一对私钥公钥。 生成秘钥通过ssh-keygen可以生成一对秘钥。这是一个交互式命令，需要你回答几个问题，不过不要担心，一般你只需要一路回车即可。 将公钥添加到远程主机中ssh-copy-id命令可以把本地主机的公钥复制到远程主机的authorized_keys文件中，它还会给远程主机的用户主目录和~/.ssh, 和~/.ssh/authorized_keys设置合适的权限。 1ssh-copy-id -i ~/.ssh/id_rsa.pub user@server 大功告成，现在你再通过ssh user@server登录服务器时就不需要输入密码了，是不是很方便呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[如果你想走得快，一个人走；如果想走得远，选择一些人一起走]]></title>
    <url>%2F2019%2F01%2F12%2Fgo-together%2F</url>
    <content type="text"><![CDATA[最早看到这句话，是在我刚入职场不久，在我一位学长MSN签名上看到的。当时也是懵懵懂懂地理解它的意思，也很同意这种观点，但是真正有所感悟还是在最近几年。下面我来给大家分享我的两个经历。 青山计划我们公司有个传统，我们称之为“青山计划”：每年征服一座山。今年我选择了黄山，这也是我第一次爬黄山。在出发之前，老婆特别交代，孩子刚刚六个月，不要去有危险的地方，不能冒险。而我自身也不是爱冒险的人，也有一些恐高，并且我也有两年左右的时候没有怎么运动，也担心我的体能能不能爬上黄山天都峰。在山脚下，爱好爬山的老板号召大家爬天都峰，我心头一热就站到老板这个队伍来了，另外一边负责组织这次活动的 HR 同事就说天都峰最危险的地方是一块山脊，只能用两手抓着绳索才能通过，在经过一番思想斗争以后，我还是放弃爬天都峰了。 我和其他一些不爬天都峰的同事一起，一边爬山一边聊着，累了就休息一下。大概过了两个小时左右，就到了去天都峰的三叉路口了，往右走去天都峰，往左走就绕过了天都峰直奔迎客松去了。由老板带队的那波要爬天都峰的同事已经走远了，看不到了，只能抬头网上望，隐约看到一些人影。我又一次纠结了，天都峰今年马上就要封山了，要爬只能 5 年以后了。问了同行的几位同事，有没有想去天都峰的？如果这时候只要有一个人愿意去，我就会去。但是没有一个要去的。一个人去也确实有些风险，也就作罢了。 其实再想一下天都峰也不会太危险，毕竟是面向普通大众开放的一条爬山线路，景区应该有足够的信心才敢开放的，并且我们也没有听过说有人从这里摔下来了。何况我们在莲蕊峰处，遇到一对老人，在闲聊中得知他们就是从天都峰上下来的，他们已经退休，趁着身体尚好再来爬山。六旬老人都行，我们还有什么不可以的。我至今仍然后悔当初没有上天都峰。同事们正在穿越天都峰最险之处 小镇会议我们每个季度的小镇会议一般也会有爬山的活动，令我记忆最深的是 2018 年 7 月在江苏无锡滨城军嶂古道，在炎热的夏天，徒步 15 公里山路。从蠡湖国家湿地公园出发，开始还是比较欢乐的，地势平坦，环境优美。后来逐渐进入少有人至的山路，偶尔能够遇到几个骑行爱好者。反正是要走过同样的路程，我一般喜欢跟着向导走在队伍的前列，。爬过了一座山，前面还有一座，多少次希望之后又接着绝望，多少次想着放弃。当时只有一个信念，不能丢人，不能在别人在分享成功的喜悦时自己不好意思地躲到一边去。别人行我也一定行，用李云龙的话说就是大家都是两个肩膀扛一个脑袋，谁怕谁啊？也就是靠着这个信念，一路坚持下来。可以肯定的是，如果不是大家的一路坚持，互相鼓舞，我肯定早就放弃了。咕咚记下的军嶂古道徒步路线图 2017 年 7 月浙江临安樟村镇黄金山，和军嶂古道有着异曲同工之“妙” “如果你想走得快，一个人走；如果想走得远，选择一些人一起走。”送给各位。]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过一个案例了解 nginx 重载过程]]></title>
    <url>%2F2019%2F01%2F05%2Fnginx-reload-failed-without-error%2F</url>
    <content type="text"><![CDATA[这周四，同事Katrina告诉我一个奇怪的问题：在我们的一台服务器上原来已经有了一个网站，现在需要再部署另一个网站。分别通过两个不同的域名来访问，这很简单，使用基于域名的虚拟主机就可以做到。但是奇怪的是nginx -s reload重载之后，通过两个域名访问到的都是那个老的网站。 为了方便描述，我们假设老的网站叫做“网站 A”，对应域名是“a.com”，新部署的网站叫做“网站 B”，对应的域名是“b.com”。 在我接手这个问题以后，我首先看了网站 B 对应的配置文件 1234567891011server &#123; listen 80; server_name b.com; access_log /var/log/nginx/logs/access.log main; error_log /var/log/nginx/logs/error.log; location / &#123; root /var/www; index index.html; &#125;&#125; 看起来没有任何问题。我首先 ping 了一下域名ping b.com发现异常ping: cannot resolve b.com: Unknown host。因此我怀疑是不是域名配置有什么问题，我找了运维也没有发现配置有任何可疑之处，只好作罢。在这之前我还是比较怀疑的，毕竟我们是依靠域名做的虚拟主机。我也查了 nginx 的日志文件，看到了 b.com 域名的访问记录，也基本证明了域名配置正确。（事后回顾：我现在再ping b.com就正常了，当时可能是域名解析的缓存问题） 然后我想到我以前见到过的默认虚拟主机default_server配置，我大概了解这个特性，但是不了解具体用法。所以搜索了一番。了解到在匹配虚拟主机时，首先测试请求的 IP 地址和端口（通过 listen 指定配置）是否匹配，然后才测试 Host（通过 server_name 指令配置）是否匹配，如果没有匹配到，nginx 把这个请求交给默认虚拟主机处理。虚拟主机是配置在 listen 指令，也就是 IP 和端口上，所有不同的 IP+Port 组合可以设置不同的默认服务器。根据以上信息，我尝试设置默认虚拟主机，但是仍然没有任何改变。 这时候我开始怀疑人生了，我开始怀疑是不是这台服务器上有两个 nginx，是不是修改错了配置文件，我要测试一下。我通过sudo nginx -s stop停止 nginx 服务器，立马访问a.com发现不能访问了，也就是说确定是这个 nginx 服务器了，没有问题。我紧接着通过sudo nginx重启 nginx 服务，但是很不幸，报错了，居然报错了。 1nginx: [emerg] open() "/var/log/nginx/logs/error.log" failed (2: No such file or directory) 本来好好的，怎么突然找不到文件了呢，我一度怀疑是我启动姿势不对，还特地去问了同事，然后急忙注释掉”error_log /var/log/nginx/logs/error.log;”这句话才成功地启动了。 到这里可以看出，原来是错误日志文件找不到，所以重载失败，但是没有给出任何错误提示。为什么会这样呢？我明明记得有时候也会报错的？ 经过各种搜索才发现，原来重载时 master 进程首先检查配置的语法有效性，如果有语法错误会报错，比如你将第一行替换成server1 {试试。如果通过语法检测，就会尝试配置，打开日志文件，尝试分配新的监听端口等，这一步如果有错误，就回滚改变，继续使用原来的配置。如果尝试配置成功，就会使用新的配置创建新的 worker 进程，并给旧的 worker 进程发一个关闭的消息。旧的 worker 进程收到关闭消息后，继续处理当前正在处理的请求，等完成以后就会关闭。关于重载过程请参考官方文档。 通过上面对于重载过程的讲解不难看出，重载时如果打开日志文件出现错误就回滚了，并不会报错。会让你误以为成功了。其实还有另一个命令，它可以检查配置是否正确，不仅可以进行语法检查，还能检查到上述的错误日志文件不存在的问题。它就是： 1nginx -t]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过装饰器自动同步本地存储]]></title>
    <url>%2F2018%2F12%2F27%2Fstorage-decorator%2F</url>
    <content type="text"><![CDATA[为了让我们的产品更加人性化，很多时候我们需要记住用户的一些操作和设置。对于一些重要的设置，我们可以保存在服务器端，比如语言设置，优点是对于一个用户来说只需要设置一次，缺点是实现代价较大。还有大量不重要的设置，我们可以保存在浏览器端，通常通过localStorage本地存储来保存，优点是实现方便，缺点是对于一个用户来说，每次换浏览器都需要再设置一次。今天我们就来聊一聊怎么将用户操作和设置保存localStorage里。 假设我们有一个日历页面，该页面提供了几个视图：天视图，周视图，月视图和年视图，用户可以通过按钮组来切换。当用户切换到某个视图以后我们就保存在localStorage里，以便当用户再次打开该页面时，我们能够自动切换到上次使用的视图。代码如下： 123456789101112131415161718192021onViewChange(view)&#123; this.view = view; // 首先我们需要在用户切换视图时将当前视图保存在`localStorage`里 try&#123; localStorage.setItem('calendar-view', view); &#125;catch(e)&#123; // log error &#125;&#125;// 默认是周视图this.view = 'week';// 在用户再次进入该页面时切换到用户上次使用的视图try &#123; let view = localStorage.getItem('calendar-view'); if(view)&#123; this.view = view; &#125;&#125; catch (e) &#123; // log error&#125; 功能完成了，代码似乎也不多，但是关键信息密度特别低，我们列出关键信息如下：局部变量this.view，本地存储键值calendar-view，默认值week。如果这样的代码只写一次不要紧，但是类似的需求很多，就很糟糕了。通过分析代码，我们首先看到的就是localStorage的接口在某些极端情况下可能报错，比如超过限额等。我们可以先封装一下这个接口。 12345678910111213141516171819// storage.jsexport default &#123; setItem(key, value) &#123; try &#123; localStorage.setItem(key, value); &#125; catch (e) &#123; // log error &#125; &#125;, getItem(key) &#123; let value = null; try &#123; value = localStorage.getItem('calendar-view'); &#125; catch (e) &#123; // log error &#125; return value; &#125;,&#125;; 现在我们再来重构一下原来的文件 12345678910import storage from './storage.js';onViewChange(view)&#123; this.view = view; // 首先我们需要在用户切换视图时将当前视图保存在`localStorage`里 storage.setItem('calendar-view', view);&#125;// 在用户再次进入该页面时切换到用户上次使用的视图, 默认是周视图this.view = storage.getItem('calendar-view') || 'week'; 看起来已经很简单了，但是还是需要我们手动同步在localStorage里，有没有什么方法能让它自动同步到localStorage里？答案是肯定，接下里就是我们这篇文章的重点了。 装饰器（Decorator），可以作用在类，类的属性和方法上，来修改类的行为。一般用于记录日志，检查权限等通用的切面的逻辑，可以减少代码侵入性，让你更加关注于处理核心业务逻辑，可以大大减少代码量。比如我们常用的mobx，就是通过装饰器来工作的。 123456789101112131415// store.jsexport default class A &#123; @observable field = 5; @action changeFieldValue(field) &#123; this.field = field; &#125;&#125;// components.jsx@observerexport default class MyComp extends React.Component&#123; render()&#123;&#125;&#125; 作用在属性上的装饰器写法如下： 1234567/** * @param `target` 作用对象 * @param `name` 属性名 * @param `descriptor` 属性描述符 * @return 如果返回属性描述符，则会调用`Object.defineProperty()`修改原有属性。 */function decorator(target, name, descriptor) &#123;&#125; 下面我们就来看看我写的用来同步数据到localStorage里的装饰器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051storage.sync = function(key) &#123; return function(target, name, descriptor) &#123; // 如果是普通属性 if (descriptor.initializer) &#123; //首选尝试从`localStorage`取出上次存储的值，如果有的话 let value = storage.getItem(key); //如果没有`localStorage`保存该值，则使用该字段的默认值，比如`@observable field = 5`的默认值就是`5` if (_.isNil(value)) &#123; value = descriptor.initializer(); &#125; // 返回一个新的属性描述符，以修改该字段的取值赋值行为 return &#123; // 每当赋值时，修改内部变量值，并将新值保存到`localStorage`中 set: function(v) &#123; if (value === v) return; value = v; storage.setItem(key, v); &#125;, // 每当取值时，将内部变量返回出去，这里并不直接从`localStorage`取值是因为该操作性能较差 get: function() &#123; return value; &#125;, enumerable: true, configurable: true, &#125;; &#125; // 如果属性通过`get`和`set`定义，或者在使用当前装饰器之前还使用了其他装饰器 else &#123; // 首选尝试从`localStorage`取出上次存储的值，如果有的话 let value = storage.getItem(key); // 如果`localStorage`已经保存该值，则调用原有属性描述符的`set`方法赋值 if (!_.isNil(value)) &#123; descriptor.set(value); &#125; // 返回一个新的属性描述符，以修改该字段的取值赋值行为 return &#123; // 每当赋值时，将新值保存到`localStorage`中，并调用原有属性描述符的`set`方法赋值 set: function(v) &#123; storage.setItem(key, v); return descriptor.set(v); &#125;, // 每当取值时，调用原有属性描述符的`get`方法取值 get: function() &#123; return descriptor.get(); &#125;, enumerable: true, configurable: true, &#125;; &#125; &#125;;&#125;; 有了以上装饰器的实现以后，以后你再想同步某个变量到localStorage的时候，只需要这样写 1234class A &#123; @store.sync('local-storage-key') view = 'week';&#125; 是不是非常简单，没有任何冗余信息啊？你也快来试试吧。如果你有任何问题，欢迎联系我。]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过`Proxy`揭秘`JavaScript`的连续赋值]]></title>
    <url>%2F2018%2F12%2F12%2Fcontinuous-assignment%2F</url>
    <content type="text"><![CDATA[相信很多都看到过 JavaScript 连续赋值面试题的解读文章，在本文中我们不去猜测，而是通过 Proxy 来揭示这一过程，你将会得到一个意想不到的结论。 首先要申明的是，这种题目不应该作为普通前端岗位的面试题目存在，也更不应该编写这样的代码。网上有很多文章都在解析这到题目，题目基本一样，我在下面贴出了最常见的一个。 12345var a = &#123; n: 1 &#125;;var b = a;a.x = a = &#123; n: 2 &#125;;console.log(a.x);console.log(b.x); 答案可能很难回答，但是要想知道答案却很简单，只要在控制台执行一下即可：undefined, {n:2}. 对于这个答案网上有很多推测，但是好像统统错误。我也曾对这个答案做过各种推断，尝试解释这个答案，尝试自圆其说。但是很快我意识到这样做是错误的，我们应该阅读ECMAScript规范，应该阅读V8引擎的源码。规范难读，源码难看，还能怎么做呢？好了，下面我通过Proxy来揭露连续赋值的过程。首先我们改造一下代码，将a改成一个代理对象，这样对a的修改将一目了然。 123456789101112131415// 初始化代码var a = new Proxy( &#123; n: 1 &#125;, &#123; get: function(target, prop) &#123; console.log('get', prop, target[prop]); return target[prop]; &#125;, set: function(target, prop, value) &#123; console.log('set', prop, value); target[prop] = value; &#125;, &#125;);var b = a; 现在我们执行一下代码 1a.x = a.y = 1; 控制台打印如下： 12set y 1set x 1 由此可以验证，如我们以前所被告知的那样的，连续赋值操作是从右往左执行的。我们再来执行代码 12// 为了消除前一步代码执行的影响，请在这里添加上面的初始化代码a.x.y = a.y.x = 1; 控制台打印如下： 123get x undefinedget y undefinedUncaught TypeError: Cannot set property &apos;x&apos; of undefined 根据以上结果我们判断，V8引擎首先获取a.x的值，虽然是undefined也不直接报错，继续获取a.y的值，同样是undefined也不报错，然后执行赋值操作，给a.y即undefined添加x属性时报错，赋值操作中断。 现在再来看本文最初的题目，就很容易理解了吧。 首先是左侧，表达式a.x是对象赋值，获取a的值，为{ n: 1 }（也就是b），等待右侧表达式返回值进行赋值 然后是中间，表达式a不需要提前处理，等待右侧表达式的返回值 再然后是右侧新建对象{ n: 2 } 再然后回到第 2 步，将右侧返回值{ n: 2 }赋值为变量a 最后是将右侧是赋值表达式a = { n: 2 }的值{ n: 2 }赋值为对象{ n: 1 }（也就是b）的x属性 我的讲解到此结束。各位读者，你们有不同的看法吗？]]></content>
  </entry>
  <entry>
    <title><![CDATA[打造高效的macOS开发环境 - 添加打印机]]></title>
    <url>%2F2018%2F12%2F06%2Fmacos-printer%2F</url>
    <content type="text"><![CDATA[公司内使用苹果电脑的并不多，IT 部门给出的相关文档中也很少。怎样在苹果电脑上安装打印机就是这样，IT 部门给出的文章中仅仅说明了如何在 Windows 系统使用打印机，却没有说明在 macOS 系统中怎么做。很长一段时间以来，我都是将要打印的文件发给其他同事，让他们代为打印。 在前些天一次打印时，我就想了，每次都找人帮忙还是挺麻烦的，实在不够极客啊。很多高端用户都使用苹果电脑，打印机厂商没有理由不支持 macOS 系统。因此我决定在我的苹果电脑上安装打印机。 首先我查看了通过 IT 部门提供的文档得知，我们的打印机型号是FXDocuCentre-II C3000，IP是192.168.0.8。在网上进行一番搜索之后，总结了以下操作步骤，以飨读者。 注意，根据macOS官方文档显示，除了“AirPrint”协议之外，还支持“HP Jetdirect – Socket”，“行式打印机监控程序 - LPD”和“互联网打印协议 - IPP”协议等。 不需要额外安装驱动程序，是不是非常简单，非常优雅呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[运行时指定 Webpack 的 publicPath]]></title>
    <url>%2F2018%2F02%2F08%2Fwebpack-public-path%2F</url>
    <content type="text"><![CDATA[问题描述一般情况下，我们在使用Webpack时，都会通过以下方式指定publicPath，它表示静态资源的访问地址。 1234567&#123; output: &#123; path: `$&#123;__dirname&#125;/dest`, filename: 'app-[hash].js', publicPath: '', &#125;&#125; 如果你需要把静态资源放在 CDN 上，则同样可行。 1234567&#123; output: &#123; path: `$&#123;__dirname&#125;/dest`, filename: 'app-[hash].js', publicPath: 'https://cdn.example.com/', &#125;&#125; 但是这样就把静态资源的地址写死了，而测试环境和生产环境的静态资源往往存在在不同的地方。OK，下面我就通过__webpack_public_path__变量来实现。 解决方法 在webpack配置文件（比如webpack.config.babel.js）中删除publicPath的选项。 1234output: &#123; path: `$&#123;__dirname&#125;/dest`, filename: 'app-[hash].js',&#125; 在html模板文件中添加以下代码 1&lt;script&gt;window.webpackPublicPath = '&lt;域名，可以由后端运行时改写，或由前端发布资源时改写&gt;';&lt;/script&gt; 上个步骤中后端已经给我们提供了静态资源访问地址了，那么怎么应用到静态资源中呢？创建一个新文件，名字自己定，比如叫做webpack.js。 12/* eslint-disable */__webpack_public_path__ = window.webpackPublicPath; 在 App 的入口文件的首行添加以下代码，其中./webpack.js就代表第三步创建的文件。 12/* eslint-disable import/first */import &apos;./webpack.js&apos;; 通过以上 4 个步骤即可实现有后端在代码运行时期指定publicPath了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[IIS 的 URL 重写（反向代理）]]></title>
    <url>%2F2018%2F01%2F12%2Fiis-url-rewrite%2F</url>
    <content type="text"><![CDATA[以前我使用过Apache或Nginx实现反向代理，但是目前后端使用的是.Net语言，服务器操作系统是Windows Server，并且后端应用程序就部署在IIS上，因此不打算再安装Nginx，改为使用IIS。 在操作过程中，遇到各种问题也耽误了不少时间，现在将一些操作流程记录下来，以备再用。 项目简介项目采用前后端分离方式开发，两个代码仓库，并部署为两个应用。后端接口地址全部以/api打头，方便简化转发规则。现在就需要在前端应用中将/api打头的请求转至后端应用。 IIS 默认不支持反向代理，需要额外安装插件很难想象IIS(Internet Information Service)竟然不默认支持反向代理，需要安装官方提供的两个插件。安装插件： Application Request Routing URL Rewrite安装完成之后重新启动一下IIS. 启用反向代理功能 双击IIS根目录，双击Application Request Routing Cache，双击右侧的Server Proxy Settings。 勾选Enable proxy 添加入站规则 点击前端应用，双击URL Rewrite -&gt; Add Rules(新建规则) -&gt; Blank rule(空白规则) 填写入站规则信息 填写转发条件 填写操作部分 点击右侧应用 最后反向代理的配置相比Nginx等复杂太多了，还需要额外理解 IIS 自己定义的一些概念，比如入站规则等。相信大部分刚毕业的同学跟我一样，一度特别喜欢有操作界面的软件，随着对系统掌握程度的增加，这个想法会慢慢的逆转。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cookie 的共享规则]]></title>
    <url>%2F2017%2F10%2F24%2Fshared-cookie%2F</url>
    <content type="text"><![CDATA[今天是 1024 程序猿的节日，今天不加班，回家加俩菜。 问题昨天同事报出一个问题，给某家客户部署测试环境时遇到一个问题，他们访问该测试环境时完全正常，但是客户却不能访问。这是为什么呢？ 原来是这样的，测试环境部署在阿里云上，包括两个系统，称他们分别是系统 A 和系统 B 吧。系统 A 通过https://customer.exmaple.com 访问，系统 B 作为系统 A 的子系统以iframe方式嵌入到系统 A，并且通过https://customer.exmaple.com:8010访问。部署完成之后我们同事正常访问，但是客户能访问系统 A，但是不能访问被iframe嵌入系统 B。通过浏览器控制台可以看到报错. Failed to load resource: net::ERR_TUNNEL_CONNECTION_FAILED. 解决从报错的信息上看，隧道连接失败，隧道还不通，也就是请求就没有发送到服务器端去。我很快注意到系统 B 使用https协议和 8010 端口，并猜想会不会https协议必须使用 443 端口。我部署https系统较少，没有看到或留意非 443 端口的https应用。但是这个猜测很快被同事证明是错误的，因为我们的另外一个客户也是这样部署的，但是能够正常访问，突然感觉自己的网络方面的知识还是很欠缺的，其实这个也是很容易推断出来的，因为https协议就是在 http 协议的基础上加了 SSL。http 协议支持的端口https也应该支持。 请求根本就没有发送到服务器端去，不可能是服务器端的问题，这也被另一个现象佐证：我们同事可以正常访问。可以确定是客户网络问题，考虑到 8010 端口的https实在少见，猜测是客户网络设置中禁止了非 443 端口的https协议，那么怎么解决这个问题呢？让用户调整网络设置当然是最简单的，但是客户公司是整个集团统一设置的网络安全策略，想修改一定要有足够理由才行，在这之前还是想想有没有其他方案吧。 如果系统 A 和系统 B 使用相同的https协议，相同的 443 端口，但是不同的域名呢？很快就找到 CTO 申请了一个customer-s.example.com，部署之后发现上面的错误没有了，系统 B 的页面可以访问了，但是页面还是出不来，系统 B 的请求大多报错了。 Uncaught Type Error: Cannot read property ‘job’ of undefined 从浏览器端的错误信息可以看出该页面没有给出合适的初始化数据。经过后端同事诊断之后发现是系统 A 的Cookie没有带过去，所以请求出现错误。啊？这是什么道理？访问系统 B 为什么要让浏览器自动带上系统 A 设置的Cookie？ 原来系统 A 和系统 B 并没有实现单点登录，而是系统 A 在即将打开系统 B 的iframe时，首先调用系统 B 的登录接口换取登录URL和token，并在iframe中打开系统 B，系统 B 的后端没有完备的数据给客户端使用，还会通过http请求从系统 A 中获取数据，而系统 A 不知道系统 B 的服务器端程序要获取哪个用户的数据，怎么办呢？ 猜测故事是这样的，开发阶段两个系统使用相同的 localhost 域名使用不同的端口，同时部署在本地，调试系统 B 的服务器端代码时发现原来可以获得系统 A 设置的Cookie，那我把系统 A 的Cookie带上去访问系统 A 的接口，模拟了一个浏览器请求，不就可以系统 A 获取当前用户的数据了吗？这样也就不需要系统 A 单独为系统 B 开发接口了，就这么办了。这里不去评价糟糕的设计，乱七八糟的设计最终也算是跑通了。 终于说到了这篇文章的主题了，Cookie的作用域是整个域名，跨协议（HTTP或HTTPS，可以指定Cookie仅适用于HTTPS），跨端口共享。了解更详细内容请参考RFC6265。这是我以前没有注意到的，又长知识了。 由于解耦两个系统的工作量较大，目前还是采取跟客户沟通，对HTTPS协议开放某个非 433 的端口。 总结 在解决问题过程中暴露了我两个知识点上的欠缺。 HTTPS协议和HTTP协议一样，可以绑定在不同的端口上。 Cookie的作用域是整个域名，跨协议跨端口共享。 在遇到复杂系统通信时，需要做一些架构评审，防止出现上面提到的很不专业的处理方法。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【Node系列】回调地狱和异步编程]]></title>
    <url>%2F2017%2F06%2F30%2Fcallback-hell-and-async-program%2F</url>
    <content type="text"><![CDATA[回调地狱Node中有大量的异步 IO 操作，被封装成基于回调的函数，遇到复杂的业务逻辑很容易形成多级缩进的代码，在左侧形成一个由空格（或 Tab）组成的三角形，代码变得非常难读，被称为回调地狱。 12345678910111213141516171819202122232425const fs = require('fs');const _ = require('lodash');function compose() &#123; //读取页面模板 fs.readFile('sample.template.html', 'utf-8', function(error, template) &#123; if (error) throw error; //读取用户数据 fs.readFile('sample.data.user.js', 'utf-8', function(error, user) &#123; if (error) throw error; //读取公司数据 fs.readFile('sample.data.company.js', 'utf-8', function(error, company) &#123; if (error) throw error; user = JSON.parse(user); company = JSON.parse(company); //组装页面 let data = &#123; user, company &#125;; let html = _.template(template)(data); console.log(html); &#125;); &#125;); &#125;);&#125;compose(); 下面我们来看一下，怎么解决回调地狱问题。 解决方案 函数拆解并使用第三方异步库 Promise 生成器函数 终极大招：async/await 函数拆解并使用第三方异步库1234567891011121314151617181920212223242526272829303132333435const fs = require(&apos;fs&apos;);const _ = require(&apos;lodash&apos;);const async = require(&apos;async&apos;);function readTemplate(callback)&#123; //读取页面模板 fs.readFile(&apos;sample.template.html&apos;, &apos;utf-8&apos;, callback);&#125;function readUserData(callback)&#123; //读取用户数据 fs.readFile(&apos;sample.data.user.js&apos;, &apos;utf-8&apos;, callback);&#125;function readCompanyData(callback)&#123; //读取公司数据 fs.readFile(&apos;sample.data.company.js&apos;, &apos;utf-8&apos;, callback);&#125;function compose(template, user, company)&#123; user = JSON.parse(user); company = JSON.parse(company); //组装页面 let data = &#123;user, company&#125;; let html = _.template(template)(data); console.log(html);&#125;async.series([ readTemplate, readUserData, readCompanyData], function(error, results)&#123; compose(results[0], results[1], results[2]);&#125;); 使用第三方库 多个逻辑单元被分成独立的函数。 每个函数有了有意义的名称，更加易读。 依赖第三方异步类库解决回调地狱问题。 PromisePromise 简介 Promise 成为 JavaScript API 的基石从 Node 6.X 开始内置 Promise. JavaScript 相关生态中更多的 API 都开始基于 Promise 实现。比如下面的两段代码。 Battery API，提供了有关系统充电级别的信息并提供了通过电池等级或者充电状态的改变提醒用户的事件。 这个可以在设备电量低的时候调整应用的资源使用状态，或者在电池用尽前保存应用中的修改以防数据丢失。 1234567891011121314//获取设备电池相关数据navigator.getBattery().then(function(battery) &#123; console.log(battery); // &#123; // charging: true // chargingTime: 0 // dischargingTime: Infinity // level: 1 // onchargingchange: null // onchargingtimechange: null // ondischargingtimechange: null // onlevelchange: null // &#125;&#125;); Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合乎逻辑的方式来跨网络异步获取资源 12345678fetch('flowers.jpg') .then(function(response) &#123; return response.blob(); &#125;) .then(function(blob) &#123; let objectURL = URL.createObjectURL(blob); document.querySelector('img').src = objectURL; &#125;); Promise 类方法简介12345Promise.resolve(1);//等价于以下代码new Promise(function(resolve, reject) &#123; resolve(1);&#125;); 12345Promise.reject(1);//等价于以下代码new Promise(function(resolve, reject) &#123; reject(1);&#125;); Promise.all：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变成rejected，新的 Promise 实例的状态就改变成rejected，否则等所有状态改变成fulfilled，新的 Promise 实例的状态就改变成fulfilled。 Promise.race：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变，新的 Promise 实例的状态就改变，新的 Promise 实例的状态就是第一个改变状态的 Promise 实例的状态。 Promise 实例方法Promise.prototype.thenPromise.prototype.catch 使用 util.promisify 转成基于 Promise 的函数12345678910111213141516const &#123; promisify &#125; = require('util');const read = promisify(require('fs').readFile);read(path, 'utf-8').then( function(txt) &#123; console.log(txt); &#125;, function(err) &#123; console.error(err); &#125;);let date = new Date();promisify(setTimeout)(10000).then(function() &#123; console.log(new Date() - date);&#125;); 自定义基于 Promise 的函数使用fn[util.promisify.custom]来定义基于 Promise 的接口。 1234567891011const util = require(&apos;util&apos;);function foo() &#123; return &apos;abc&apos;;&#125;async function fooAsync() &#123; return &apos;abc&apos;;&#125;foo[util.promisify.custom] = fooAsync;console.log(util.promisify(foo) === fooAsync); // true 使用 Promise 解决回调问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//使用`util.promisify`转成基于Promise的接口const &#123; promisify &#125; = require('util');const read = promisify(require('fs').readFile);const _ = require('lodash');function usePromise() &#123; var template, user, company; //读取页面模板 read('sample.template.html', 'utf-8') .then(t =&gt; (template = t)) .then(function() &#123; //这里必须return，否则下面的一个 then 不等待 user 数据 //读取用户数据 return read('sample.data.user.js', 'utf-8').then(u =&gt; (user = u)); &#125;) .then(() =&gt; &#123; //读取公司数据 return read('sample.data.company.js', 'utf-8').then(c =&gt; (company = c)); &#125;) .then(() =&gt; &#123; console.log(template, user, company); &#125;);&#125;//使用Promise.allfunction usePromiseAll() &#123; Promise.all([ read('sample.template.html', 'utf-8'), read('sample.data.user.js', 'utf-8'), read('sample.data.company.js', 'utf-8'), ]).then(([template, user, company]) =&gt; &#123; compose( template, user, company ); &#125;);&#125;//组装页面function compose(template, user, company) &#123; let data = &#123; user: JSON.parse(user), company: JSON.parse(company), &#125;; let html = _.template(template)(data); console.log(html);&#125;usePromise();usePromiseAll(); 通过生成器函数生成器函数是一个状态机，封装了多个内部状态。还是一个遍历器生成函数，返回遍历器对象，可以依次遍历生成器函数内部的每一个状态。 生成器函数执行器co是一个基于生成器函数的流程控制工作，可用于 Node.js 和浏览器。它可以通过 Promise 让你的非阻塞代码以一种漂亮的方式呈现。 12345let print = val =&gt; console.log(val);co(function*() &#123; return yield Promise.resolve(true);&#125;).then(print); 12345var fn = co.wrap(function*(val) &#123; return yield Promise.resolve(val);&#125;);fn(true).then(print); 使用生成器函数解决回调地狱问题12345678910111213141516171819202122232425262728//使用`util.promisify`转成基于Promise的接口const &#123; promisify &#125; = require('util');const read = promisify(require('fs').readFile);const _ = require('lodash');const co = require('co');//组装页面function compose(template, user, company) &#123; let data = &#123; user: JSON.parse(user), company: JSON.parse(company), &#125;; let html = _.template(template)(data); console.log(html);&#125;let useGenerator = co.wrap(function*() &#123; let template = yield read('sample.template.html', 'utf-8'); let user = yield read('sample.data.user.js', 'utf-8'); let company = yield read('sample.data.company.js', 'utf-8'); compose( template, user, company );&#125;);useGenerator(); 终极大招：async/await生成器函数和 async 函数比较使用生成器函数 12345678910const &#123; promisify &#125; = require('util');let read = promisify(require('fs').readFile);var fn = function*() &#123; var f1 = yield read('/etc/fstab'); var f2 = yield read('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;;require('co')(fn); 使用async函数 123456var fn = async function() &#123; var f1 = await read('/etc/fstab'); var f2 = await read('/etc/shells'); console.log(f1.toString()); console.log(f2.toString());&#125;; async函数和生成器函数非常相似，基本上就是*换成async，yield换成了await。 async 函数的优点 内置了执行器生成器函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。 更好的语义async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。 更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 返回值是 Promise。async 函数的返回值是 Promise 对象，这比生成器函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。 进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。 使用 async 函数解决回调地狱问题1234567891011121314151617181920212223242526const &#123; promisify &#125; = require('util');const read = promisify(require('fs').readFile);const _ = require('lodash');//组装页面function compose(template, user, company) &#123; let data = &#123; user: JSON.parse(user), company: JSON.parse(company), &#125;; let html = _.template(template)(data); console.log(html);&#125;let useAsync = async function() &#123; let template = await read('sample.template.html', 'utf-8'); let user = await read('sample.data.user.js', 'utf-8'); let company = await read('sample.data.company.js', 'utf-8'); compose( template, user, company );&#125;;useAsync(); 总结 回调地狱问题可以通过第三方异步类库，Promise，生成器函数和 async 函数等方式解决。 Promise 是 ECMAScript 中异步 API 的基石，需要重点掌握。 async 函数解决异步问题更加优雅，推荐在 Node 中使用。 参考资料 Node.js 8: util.promisify() ECMAScript 6 入门 阮一峰 co 生成器函数执行器]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】React模式]]></title>
    <url>%2F2017%2F05%2F04%2Freact-patterns%2F</url>
    <content type="text"><![CDATA[原文链接 1. 无状态函数（Stateless function）无状态函数是一种创建高度可复用组件的牛逼闪闪的方法，它自己不管理状态，他只是函数。 1const Greeting = () =&gt; &lt;div&gt;Hi there!&lt;/div&gt;; 可以传递props和context。 1const Greeting = (props, context) =&gt; &lt;div style=&#123;&#123; color: context.color &#125;&#125;&gt;Hi &#123;props.name&#125;!&lt;/div&gt;; 也可以定义局部变量。 1234567const Greeting = (props, context) =&gt; &#123; const style = &#123; fontWeight: 'bold', color: context.color, &#125;; return &lt;div style=&#123;style&#125;&gt;&#123;props.name&#125;&lt;/div&gt;;&#125;; 当然也可以不定义局部变量，改为函数。 123456const getStyle = context =&gt; (&#123; fontWeight: 'bold', color: context.color,&#125;);const Greeting = (props, context) =&gt; &lt;div style=&#123;getStyle(context)&#125;&gt;&#123;props.name&#125;&lt;/div&gt;; 无状态函数也可以拥有defaultProps，propTypes和contextTypes。 123456789Greeting.propTypes = &#123; name: PropTypes.string.isRequired,&#125;;Greeting.defaultProps = &#123; name: 'Guest',&#125;;Greeting.contextTypes = &#123; color: PropTypes.string,&#125;; 2. JSX 展开属性（JSX Spread Attributes）展开属性是 JSX 的一个特性，一种语法糖，用来将一个对象的所有属性作为 JSX 的属性传递。以下两个例子是等价的 1234// props written as attributes&lt;main className="main" role="main"&gt; &#123;children&#125;&lt;/main&gt; 12// props "spread" from object&lt;main &#123;...&#123; className: 'main', role: 'main', children &#125;&#125; /&gt; 用它可以方便地将属性转发给底层组件。 1const FancyDiv = props =&gt; &lt;div className="fancy" &#123;...props&#125; /&gt;; 这时我给可以FancyDiv组件添加他关心和他不关心的属性。 123&lt;FancyDiv data-id="my-fancy-div"&gt;So Fancy&lt;/FancyDiv&gt;// output: &lt;div className="fancy" data-id="my-fancy-div"&gt;So Fancy&lt;/div&gt; 注意属性顺序很重要，如果外部传入className属性，那么FancyDiv定义的className将会被覆盖。 123&lt;FancyDiv className="my-fancy-div" /&gt;// output: &lt;div className="my-fancy-div"&gt;&lt;/div&gt; 也可以让FancyDiv定义的className永远生效，只需要将它放在展开属性（{…props}）后面。 12// my `className` clobbers your `className`const FancyDiv = props =&gt; &lt;div &#123;...props&#125; className="fancy" /&gt;; 你应该优雅地处理这类情形，这种情况下我会合并使用者定义的className和组件自身的className。 1const FancyDiv = (&#123; className, ...props &#125;) =&gt; &lt;div className=&#123;['fancy', className].join(' ')&#125; &#123;...props&#125; /&gt;; 3. 参数解构（Destructuring Arguments）参数解构是 ES2015 的特性，它能够很好的配合无状态函数的参数。以下两个例子是等价的。 123const Greeting = props =&gt; &lt;div&gt;Hi &#123;props.name&#125;!&lt;/div&gt;;const Greeting = (&#123; name &#125;) =&gt; &lt;div&gt;Hi &#123;name&#125;!&lt;/div&gt;; 剩余参数（中文链接）语法可以将剩余的参数手机到一个新对象中。 1const Greeting = (&#123; name, ...props &#125;) =&gt; &lt;div&gt;Hi &#123;name&#125;!&lt;/div&gt;; 反过来，这个新对象可以通过展开属性将属性转发给底层组件。 1const Greeting = (&#123; name, ...props &#125;) =&gt; &lt;div &#123;...props&#125;&gt;Hi &#123;name&#125;!&lt;/div&gt;; 应该避免将非 DOM 属性转发给原生组件，通过解构可以创建一个不包含高阶组件特有属性的新对象，因此解构可以让这个工作更加简单。 4. 条件渲染（Conditional Rendering）组件定义内部是不能使用 if/else 条件语句的，但是可以使用条件表达式。 if 123&#123; condition &amp;&amp; &lt;span&gt;Rendered when `truthy`&lt;/span&gt;;&#125; else 123&#123; condition || &lt;span&gt;Rendered when `falsey`&lt;/span&gt;;&#125; if-else (tidy one-liners) 123&#123; condition ? &lt;span&gt;Rendered when `truthy`&lt;/span&gt; : &lt;span&gt;Rendered when `falsey`&lt;/span&gt;;&#125; if-else (big blocks) 123&#123; condition ? &lt;span&gt;Rendered when `truthy`&lt;/span&gt; : &lt;span&gt;Rendered when `falsey`&lt;/span&gt;;&#125; 5. Children 类型（Children types）React 中 children 有好几种类型，常见的有数组和字符串。 字符串 1&lt;div&gt;Hello World!&lt;/div&gt; array 1&lt;div&gt;&#123;['Hello ', &lt;span&gt;World&lt;/span&gt;, '!']&#125;&lt;/div&gt; children 也可以是函数，但是必须和父组件协作才能用。 function 123&lt;div&gt; &#123;() =&gt; &#123; return "hello world!"&#125;()&#125;&lt;/div&gt; 6. 数组类型的 children（Array as children）数组类型的 children 是非常常见的，列表就是这么渲染出来的。使用map函数就可以创建 React 元素数组。 12345&lt;ul&gt; &#123;['first', 'second'].map(item =&gt; ( &lt;li&gt;&#123;item&#125;&lt;/li&gt; ))&#125;&lt;/ul&gt; 和下面这个数组字面量方式等价 1&lt;ul&gt;&#123;[&lt;li&gt;first&lt;/li&gt;, &lt;li&gt;second&lt;/li&gt;]&#125;&lt;/ul&gt; 为了更加简洁，可以结合解构，JSX 展开属性，其他组件一起使用。 12345&lt;ul&gt; &#123;arrayOfMessageObjects.map((&#123; id, ...message &#125;) =&gt; ( &lt;Message key=&#123;id&#125; &#123;...message&#125; /&gt; ))&#125;&lt;/ul&gt; 7. 函数类型的 children（Function as children）函数类型的 children 不是天然有用的。 1&lt;div&gt;&#123;() =&gt; &#123; return "hello world!"&#125;()&#125;&lt;/div&gt; 这种技术通常被称为渲染回调，可以给组件创作带来更多空间和便利。比如ReactMotion使用这种高能技术以后，渲染逻辑可以由使用者提供，而不是被类库写死。更多细节，请参考下一章渲染回调。 8. 渲染回调（Render callback）下面这个组件使用了渲染回调技术，它没什么用，但它是一个很好的开端。 1const Width = (&#123; children &#125;) =&gt; children(500); 该组件将 children 当做函数来调用，并传递了一个数字类型值为 500 的参数。 下面我们将使用该组件，并给它传递一个函数类型的 children. 1&lt;Width&gt;&#123;width =&gt; &lt;div&gt;window is &#123;width&#125;&lt;/div&gt;&#125;&lt;/Width&gt; 我们将得到以下结果。 1&lt;div&gt;window is 500&lt;/div&gt; 有了这些设置，我们可以根据宽度来决定渲染什么。 1&lt;Width&gt;&#123;width =&gt; (width &gt; 600 ? &lt;div&gt;min-width requirement met!&lt;/div&gt; : null)&#125;&lt;/Width&gt; 如果这个逻辑会被多次使用，我们可以创建一个新组件来封装可重用逻辑。 1const MinWidth = (&#123; width: minWidth, children &#125;) =&gt; &lt;Width&gt;&#123;width =&gt; (width &gt; minWidth ? children : null)&#125;&lt;/Width&gt;; 很明显这对于一个有着固定宽度的组件没有什么意义，但对一个监听浏览器窗口宽度的组件就有意义了，以下是示例代码。 1234567891011121314151617class WindowWidth extends React.Component &#123; constructor() &#123; super(); this.state = &#123; width: 0 &#125;; &#125; componentDidMount() &#123; this.setState(&#123; width: window.innerWidth &#125;); window.addEventListener('resize', (&#123; target &#125;) =&gt; &#123; this.setState(&#123; width: target.innerWidth &#125;); &#125;); &#125; render() &#123; return this.props.children(this.state.width); &#125;&#125; 很多开发者更喜欢高阶组件完成类似功能，这是个人偏好问题。 9. Children 值传（Children pass-through）有时候你可能会创建一个组件，只用来处理上下文并且直接渲染其 children. 123456789class SomeContextProvider extends React.Component &#123; getChildContext() &#123; return &#123; some: 'context' &#125;; &#125; render() &#123; // how best do we return `children`? &#125;&#125; 现在你需要作出决定，将children包裹在一个&lt;div /&gt;中，还是直接返回children。第一种做法多了一层标签（可能导致样式失效），第二种做法将会导致一个错误。 12345// option 1: extra divreturn &lt;div&gt;&#123;children&#125;&lt;/div&gt;;// option 2: unhelpful errorsreturn children; 最好的做法是将children看做一个不透明的数据类型，React提供了React.Children来合理的处理children。 1return React.Children.only(this.props.children); 10. 组件代理（Proxy component）（我不确定这个名字是否有意义）按钮（Button）在网页应用中随处可见，每一个按钮都必须有一个type属性并设成button。 1&lt;button type="button"&gt; 书写次数多了，也就容易导致错误，我们可以创建一个高阶组件代理该低阶组件。 12const Button = props =&gt; &lt;button type="button" &#123;...props&#125;&gt; 这时我们可以使用Button代替button，确保type属性总被正确使用。 12345&lt;Button /&gt;// &lt;button type="button"&gt;&lt;button&gt;&lt;Button className="CTA"&gt;Send Money&lt;/Button&gt;// &lt;button type="button" class="CTA"&gt;Send Money&lt;/button&gt; 11. 使用样式（Style component）这是一种使用样式的组件代理。假设我们通过使用class将一个button装饰成主要（primary）按钮。 1&lt;button type="button" className="btn btn-primary"&gt; 我们可以通过两个单一职责组件达到此目的。 12345const PrimaryBtn = props =&gt; &lt;Btn &#123;...props&#125; primary /&gt;;const Btn = (&#123; className, primary, ...props &#125;) =&gt; ( &lt;button type="button" className=&#123;classnames('btn', primary &amp;&amp; 'btn-primary', className)&#125; &#123;...props&#125; /&gt;); 便于理解，请看下面的图示。 1234PrimaryBtn() ↳ Btn(&#123;primary: true&#125;) ↳ Button(&#123;className: &quot;btn btn-primary&quot;&#125;, type: &quot;button&quot;&#125;) ↳ &apos;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;/button&gt;&apos; 通过这些组件，以下代码是等价的。 123&lt;PrimaryBtn /&gt;&lt;Btn primary /&gt;&lt;button type="button" className="btn btn-primary" /&gt; 对于样式维护来说真是一大福音，它将样式问题封装在单一组件中。 12. 事件切换（Event switch）在写事件回调时通过采用handle{EventName}规则。 1handleClick(e) &#123; /* do something */ &#125; 对于一个需要处理多种事件事件的组件来说，这些函数名显得非常啰嗦。函数名中也不会带有更多信息，因为他们一般直接调用其他action或function。 123handleClick() &#123; require("./actions/doStuff")(/* action stuff */) &#125;handleMouseEnter() &#123; this.setState(&#123; hovered: true &#125;) &#125;handleMouseLeave() &#123; this.setState(&#123; hovered: false &#125;) &#125; 下面只给组件写一个事件处理函数，并通过event.type区分。 123456789101112handleEvent(&#123;type&#125;) &#123; switch(type) &#123; case "click": return require("./actions/doStuff")(/* action dates */) case "mouseenter": return this.setState(&#123; hovered: true &#125;) case "mouseleave": return this.setState(&#123; hovered: false &#125;) default: return console.warn(`No case for event type "$&#123;type&#125;"`) &#125;&#125; 或者，对于简单组件，你可以通过胖箭头函数方式直接调用action或function。 1&lt;div onClick=&#123;() =&gt; someImportedAction(&#123; action: 'DO_STUFF' &#125;)&#125; /&gt; 不要担心性能问题，知道性能问题爆发。一定不要过早进行性能优化。 13. 布局组件（Layout component）布局组件会产生一些静态 DOM 元素，他们可能不会有任何改变，即使改变了也不会很频繁。下面是一个并排显示两个子组件的组件。 1&lt;HorizontalSplit leftSide=&#123;&lt;SomeSmartComponent /&gt;&#125; rightSide=&#123;&lt;AnotherSmartComponent /&gt;&#125; /&gt; 我们可以尽量去优化这个组件。虽然HorizontalSplit是两个组件的父组件，但是它绝不是这两个组件的所有者。我们可以让它永不更新，不影响组件的生命周期。 123456789101112class HorizontalSplit extends React.Component &#123; shouldComponentUpdate() &#123; return false; &#125; render() &#123; &lt;FlexContainer&gt; &lt;div&gt;&#123;this.props.leftSide&#125;&lt;/div&gt; &lt;div&gt;&#123;this.props.rightSide&#125;&lt;/div&gt; &lt;/FlexContainer&gt;; &#125;&#125; 14. 容器组件（Container component） “容器负责获取数据并渲染其子组件，这就够了”—Jason Bonta假设我们已经有了可复用的CommentList组件。 123456789const CommentList = (&#123; comments &#125;) =&gt; ( &lt;ul&gt; &#123;comments.map(comment =&gt; ( &lt;li&gt; &#123;comment.body&#125;-&#123;comment.author&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt;); 接下来我们可以创建一个新组件负责获取数据并渲染无状态的CommentList组件。 12345678910111213141516171819class CommentListContainer extends React.Component &#123; constructor() &#123; super() this.state = &#123; comments: [] &#125; &#125; componentDidMount() &#123; $.ajax(&#123; url: "/my-comments.json", dataType: 'json', success: comments =&gt; this.setState(&#123;comments: comments&#125;); &#125;) &#125; render() &#123; return &lt;CommentList comments=&#123;this.state.comments&#125; /&gt; &#125;&#125; 我们可以给不同的应用上下文创建不同的容器组件。 14. 高阶组件（Higher-order component）高阶函数是一个接受函数类型的参数或返回一个新函数的函数。那么什么是高阶组件呢？如果你已经开始使用容器组件，它们都是包裹在一个函数中的通用容器。下面我们从一个无状态的Greeting组件开始。 1234567const Greeting = (&#123; name &#125;) =&gt; &#123; if (!name) &#123; return &lt;div&gt;Connecting...&lt;/div&gt;; &#125; return &lt;div&gt;Hi &#123;name&#125;!&lt;/div&gt;;&#125;; 如果Greeting组件接到props.name，它就回去渲染这个数据，否则他会说正在连接。现在我们创建一个高阶组件。 12345678910111213141516const Connect = ComposedComponent =&gt; class extends React.Component &#123; constructor() &#123; super(); this.state = &#123; name: '' &#125;; &#125; componentDidMount() &#123; // this would fetch or connect to a store this.setState(&#123; name: 'Michael' &#125;); &#125; render() &#123; return &lt;ComposedComponent &#123;...this.props&#125; name=&#123;this.state.name&#125; /&gt;; &#125; &#125;; 它就是一个函数，返回一个渲染作为参数传递进去的组件的新组件。最后，我们需要用Connect组件将Greeting组件包裹起来，如下： 1const ConnectedMyComponent = Connect(Greeting); 高阶组件是一个功能很强的模式，可以用来获取数据并给其他无状态组件提供数据。 15. 状态提升（State hoisting）无状态组件并不持有状态，正如它名称暗示的那样。 Events are changes in state. Their data needs to be passed to stateful container components parents. This is called “state hoisting”. It’s accomplished by passing a callback from a container component to a child component. 1234567class NameContainer extends React.Component &#123; render() &#123; return &lt;Name onChange=&#123;newName =&gt; alert(newName)&#125; /&gt;; &#125;&#125;const Name = (&#123; onChange &#125;) =&gt; &lt;input onChange=&#123;e =&gt; onChange(e.target.value)&#125; /&gt;; Name组件从NameContainer组件中获得onChange回调并在事件中调用。上面的alert只是简单演示并不修改状态，下面的代码将会修改NameContainer组件的状态。 12345678910class NameContainer extends React.Component &#123; constructor() &#123; super(); this.state = &#123; name: '' &#125;; &#125; render() &#123; return &lt;Name onChange=&#123;newName =&gt; this.setState(&#123; name: newName &#125;)&#125; /&gt;; &#125;&#125; 通过回调，状态被提升到维护局部状态的容器组件中。这给无状态函数一个清晰的边界和最大限度的可重用性。 这个模式并不局限于无状态函数，因为无状态函数没有生命周期事件，该模式同样适用于无状态组件。 受控的 input 就是一个使用了状态提升的重要模式。 16. 受控的 input（Controlled input）直接讨论受控的 input 比较困难，我们先从不受控的 input 谈起。 1&lt;input type="text" /&gt; 当你在浏览器中输入框中输入时，你会看到输入框的值发生变化，这很正常。 受控的 input 禁用 DOM 突变，它的值只能被组件修改，不能被 DOM 修改。 1&lt;input type="text" value="This won't change. Try it." /&gt; 上面的输入框有着固定值没有什么意义，下面输入框的值将会从state中获取。 12345678910class ControlledNameInput extends React.Component &#123; constructor() &#123; super(); this.state = &#123; name: '' &#125;; &#125; render() &#123; return &lt;input type="text" value=&#123;this.state.name&#125; /&gt;; &#125;&#125; 接着，修改输入框的值就是修改组件状态。 1return &lt;input value=&#123;this.state.name&#125; onChange=&#123;e =&gt; this.setState(e.target.value)&#125; /&gt;; 这就是受控的 input，只有当组件的状态改变了才能改变 DOM，对于创建一致的 UI，有着非常大的作用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Chrome 开发者工具 - 设备模式]]></title>
    <url>%2F2017%2F03%2F03%2Fchrome-developer-tool-device-mode%2F</url>
    <content type="text"><![CDATA[使用 Chrome 开发者工具的设备模式可以大大减低开发移动优先响应式网站的难度，下面我们开始学习如何使用它模拟各种设备以及开发完全响应式的网站。 概述 使用设备模式的屏幕模拟器测试网站的响应式特性 自动保存设置，方便你以后继续使用。 设备模式不能代替真实设备，请熟知它的局限性。 1 打开设备模式通过切换“设备模式”按钮或者使用快捷键Command+Shift+M (Mac)或Ctrl+Shift+M (Windows, Linux) 2 viewport控制器viewport控制器共有两种模式：完全响应式：自由地改变viewport尺寸。特定的设备：模拟设备viewport尺寸和设备特性。 2.1 完全响应式我们推荐你将完全响应式模式作为你的默认模式，在开发过程中，使用它频繁调整viewport的尺寸来实现一个完全的响应式设计来适配未知或未来的设备类型。你可以拖拽调整大小的手柄或单击菜单栏中值进行细粒度的控制。也可以直接选择Mobile S - 320px, Mobile M - 375px, Mobile L - 425px, Tablet - 768px, Laptop - 1024px, Laptop L - 1440px, 4K - 2560px。 2.2 特定的设备在开发即将结束时，通过使用特定设备模式，可以查看你的网站在特定设备上被渲染成什么模样，比如特定的iPhone或Nexus。 内置设备集设备下拉框中已经内置了一组目前最流行的设备，选择了某个设备之后，Chrome 开发者工具就会模拟该设备并模拟网站在该设备上会如何渲染。 模拟用户代理（User Agent） 模拟设备分辨率以及 DPI（设备像素比） 模拟触摸事件（如果设备支持的话） 模拟滚动条和viewport 对于没有定义viewport的页面自动调整文字大小 添加自定义设备如果遇到极端情况，需要兼容特殊设备，你也可以添加自定义设备。点击设备列表下面的Edit ...选项即可打开以下窗口，你可以勾选更多设备和添加自定义设备。 设备状态和方向当模拟特定设备时，设备模式工具栏会出现一个额外的功能，用来切换设备方向横向（landscape）或纵向（portrait）。对于某些机型，不仅能切换设备方向，还能模拟特定设备状态。比如对于Nexus 5X还可以模拟以下状态： 默认的浏览器界面 带有地址栏 键盘处于打开状态 缩放到合适尺寸有时候你需要测试一个比你浏览器窗口分辨率还大的设备，这时候“缩放”这个选项就非常有用了。适合浏览器窗口（Fit to Window）会自动设置缩放级别以最大程度低利用浏览器空间，而特定的缩放比例可以用来测试 DPI 对图像显示效果的影响等是很有帮助的。 可选控制项通过单击设备工具栏右侧三个点可以启用和修改可选控制项，目前选项包括： 是否显示设备边框 是否显示媒体查询 是否显示刻度尺 设置设备像素比 设置设备类型（移动/桌面，是否支持触摸） 模拟网络状况 截屏 显示设备外框只有当你选择了某些设备（比如 iPhone 6）之后才能启用该特性，启用以后你将能够看到页面被放在设备外壳里面。 显示媒体查询媒体查询是响应式设计的重要组成部分，通过点击Show media queries可以看到媒体查询查看器，该工具会检测你样式中的媒体查询，并在顶部标尺中将其显示成彩色条。 蓝色代表最大宽度max-width 绿色代表宽度区间min-width ~ max-width 黄色代表最小宽度min-width 单击媒体查询条可以调整viewport大小来查看样式。右击媒体查询条可以在源码中查看该媒体查询的定义。 显示刻度尺 显示设备像素比如果你想通过非视网膜屏设备模拟视网膜屏设备，或者反过来，那么这个功能就是为你准备的。设备像素比就是逻辑像素和物理像素的比例。视网膜屏设备比如Nexus 6P比一般设备的像素密度更高，这会影响视觉内容的清晰度和大小。下面这些 Web 上的案例会受到设备像素比的影响： CSS 媒体查询：@media (-webkit-min-device-pixel-ratio: 2) { ... } CSSimage-set img的srcset属性 window.devicePixelRatio属性 在真正的视网膜屏上，低 DPI（每英寸点数）资源看起来像素化，而高 DPI 的资源看起来很清晰，为了能够在标准的显示器上模拟这中效果，可以将 DPR 设置成 2 并缩放视窗，一个 2X 资源看起来仍然清晰，而 1X 的资源看起来就会像素化。 设备类型单击Add device type，设备工具栏将会出现一个选项“Mobile”，共有以下几个可选值：Mobile，Mobile(not touch)，Desktop，Desktop(touch)，修改这项设置将会影响viewport，是否模拟触摸事件，用户代理字符串。因此如果你想为左面浏览器创建一个响应式网站并且向测试鼠标悬浮效果，请使用完全响应式模式并将设备类型切换到Desktop。提示：你还可以在Network conditions修改用户代理。 模拟网络状况单击Add network throttling，设备工具栏将会出现一个选项No throttling，通过这个选项可以模拟不同网络下页面加载效果。 3 模拟传感器：地理定位和重力感应大多数台式机都没有 GPS 芯片和重力传感器，因而很难测试，但是 Chrome 开发者工具提供了传感器模拟器使得测试更加容易。 打开方法： 打开开发者工具主菜单 点击Customize and control DevTools- More tools - Sensors菜单项 3.1 模拟地理定位移动设备一般使用 GPS 芯片进行定位，在传感器面板中，你可以使用地理定位 API模拟位置。你可以使用预置的几个城市或手动输入经度纬度，甚至还可以模拟定位失败的情况，这里有一个地理定位 API 的例子，可以实验一下。 3.2 模拟重力感应（加速度）在浏览器中打开以下链接实验以下吧。重力感应代码示例，切换方位看看页面如何变化。 4 参考资料 Chrome 开发者工具官方介绍，以上大部分内容来自该文档，部分甚至仅仅做了翻译，强烈推荐大家经常到该网站看看。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lodash函数以及常见用法]]></title>
    <url>%2F2016%2F09%2F06%2Flodash-functions%2F</url>
    <content type="text"><![CDATA[1 简介Lodash是一款优秀的 JavaScript 工具库，里面包含了大量的工具函数。在 2015 年就成为被依赖最多的 JavaScript 库，写这篇文档是最新版是 4.17.4，适用于常见浏览器以及 Node.js 等。 这里给出其英文文档和中文文档的链接。其中中文文档的版本较低，但是区别不大，可以参考帮助理解。 2 常见用法在这部分我们介绍一些 Lodash 的常见的优雅的用法。主要是引起大家的学习兴趣，有更多优雅用法等待大家去发现。 _.get获取一个嵌套很深的字段12345678910111213//config 初始化为 null，需要从服务器端获取权限数据let config = null;ajax.get(url, function(data) &#123; // data = &#123;basic: &#123;delete: true&#125;&#125; config = data;&#125;);//使用原生JS获取是否有删除权限let isDeletable = false;if (config &amp;&amp; config.basic) &#123; isDeletable = config.basic.delete || false;&#125;//使用lodash获取是否有删除权限let isDeletable = _.get(config, 'basic.delete', false); 对应地，可以通过_.set({}, &#39;a.b.c&#39;, 1)创建一个多级嵌套的对象。 _.map获取数组中每个对象的特定字段，并形成一个新的数组12345678//使用所有用户的 idCard 字段创建出一个数组let users = [&#123; idCard: '20160512', name: '张三' &#125;, &#123; idCard: '20160513', name: '李四' &#125;];//使用原生JSlet idCards = users.map(function(user) &#123; return user.idCard;&#125;);//使用lodashlet idCards = _.map(model, 'idCard'); _.pick取出对象的部分字段形成一个新对象1234567891011121314151617//在修改密码表单里，用户输入了如下字段并被封装到一个对象中let form = &#123; password: '123456', //密码 repeatPassword: '123456', //重复密码 code: '5489', //验证码&#125;;//这里不直接使用delete删除字段，是因为该 form 对象与 DOM 进行了绑定。//其中重复密码只用来在客户端校验，不需要发送给服务器let data = &#123;&#125;;let fields = ['password', 'code'];for (var i = 0; i &lt; fields.length; i++) &#123; data[fields[i]] = form[fields[i]];&#125;//使用lodashlet data = _.pick(form, 'password', 'code'); 对应地，还有_.omit方法表示删除部分字段形成一个新对象。 _.random获取一个随机值1234567//获取[90, 100)之内的一个随机值let min = 90;let max = 100;//使用原生JSlet random = Math.floor(Math.random() * (max - min)) + min;//使用lodashlet random = _.random(min, max); 类似地，_.sample([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])可以从数组中随机取出一个项目。 _.clamp将一个数字修改成区间中的一个值12345678//使用原生JSfunction applyRange(number) &#123; number = Math.max(number, this.props.min); number = Math.min(number, this.props.max); return number;&#125;//使用lodashlet number = _.clamp(number, min, max); _.once确保一个函数只会执行一次12345678910//使用原生JSlet inited = false;function init() &#123; if (inited) return; // init code&#125;//使用lodashlet init = _.once(function() &#123; // init code&#125;); _.chain链式操作链接调用让代码更加整洁；避免了中间变量，避免了错误引用，让代码质量更有保证；_.chain还提供了延迟计算特性，在显式或隐式调用value()方法之前是不进行任何计算的，通过合并大大降低迭代次数。下面是lodash的官方文档中的一个例子。 12345678910var users = [&#123; user: 'barney', age: 36 &#125;, &#123; user: 'fred', age: 40 &#125;, &#123; user: 'pebbles', age: 1 &#125;];var youngest = _.chain(users) .sortBy('age') .map(function(chr) &#123; return chr.user + ' is ' + chr.age; &#125;) .first() .value();// → 'pebbles is 1' 3 模块Lodash 的工具函数很多，可以分为以下几类：数组（Array），集合（Collection），函数（Function），Lang（Lang），数学（Math），数字（Number），对象（Object），字符串（String），未分类工具函数（Util）。下面将会按类别介绍常见工具函数。 4 数组获取子数组 函数名 简介 slice 获取元素第 m-n(不包含)个元素 tail 获取出第一个元素之外的其他元素 initial 获取出最后一个元素之外的其他元素 take 从左侧开始获取任意数量的元素 takeRight 从右侧开始获取任意数量的元素 takeWhile 从左侧开始获取任意数量的元素，直到断言返回假值 takeRightWhile 从右侧开始获取任意数量的元素，直到断言返回假值 drop 丢掉前面几个元素，得到剩余元素 dropWhile 丢掉前面几个元素知道迭代器返回假值，得到剩余元素 dropRight 丢掉后面几个元素，得到剩余元素 dropRightWhile 丢掉后面几个元素知道迭代器返回假值，得到剩余元素 数组常见操作 操作 不修改原数组 修改原数组 移除 without pull 相减 difference pullAll 相减 differenceBy pullAllBy 相减 differenceWith pullAllWith 反转 reverse 裁剪 at pullAt 过滤 filter remove 数组常见操作变种函数 by, with有些函数还可以稍微变化一下，接受不同的参数，提供更多灵活性。 作用 函数名 by with 相减 difference differenceBy differenceWith 交集 intersection intersectionBy intersectionWith 并集 union unionBy unionWith 异或 xor xorBy xorWith 相减 pullAll pullAllBy pullAllWith，跟difference不同的是，pullAll修改原数组 去重 uniq uniqBy uniqWith 去重 sortedUniq sortedUniqBy 获取数组某个位置上的元素 函数名 主要参数-返回值 简介 head 数组=&gt;元素 返回数组的第一个元素，和first相同 last 数组=&gt;元素 返回数组的最后一个元素，和head相反 nth 数组=&gt;元素 返回数组中某个位置上的元素 检测元素在数组中的索引 函数名 简介 indexOf 获取元素在数组中的索引 sortedIndexOf 和indexOf功能一致，只是通过二分搜索方法 lastIndexOf 获取元素在数组中的索引，最后一次出现 sortedLastIndexOf 和lastIndexOf功能一致，只是通过二分搜索方法 findIndex 寻找元素位置 findLastIndex 寻找元素位置，从后往前 检测元素在插在有序数组的什么位置 函数名 简介 sortedIndex 通过二分搜索判断元素应该插在数组的哪个位置 sortedIndexBy 同上，可以额外提供一个迭代器函数 sortedLastIndex 和sortedIndex类似，但是从右边开始 sortedLastIndexBy 同上，可以额外提供一个迭代器函数 将数组拍平 函数名 主要参数-返回值 简介 flatten 高维数组=&gt;低维数组 将数组拍平 flattenDeep 高维数组=&gt;数组 将数组拍平 flattenDepth 高维数组=&gt;低维数组 将数组拍平 Zip 函数名 主要参数-返回值 简介 zip 多个数组=&gt;二维数组 可以理解为二维数组的行列互换 zipWith 多个数组=&gt;数组 同上，但是可以自由处理行列互换后的数组中的每个数组元素 zipObject 两个数组=&gt;对象 把 keys 和 values 数组组成一个新对象 zipObjectDeep 两个数组=&gt;对象 同上，递归地处理属性名 未分类函数 函数名 主要参数-返回值 简介 chunk 数组=&gt;二维数组 分段形成二维数组 compact 数组=&gt;数组 移除假值 concat 多个数组=&gt;数组 连接多个数组形成一个数组 fill 数组=&gt;数组 填充数组 fromPairs 二维数组=&gt;对象 将键值数组变成对象。和toPairs相反 join 数组=&gt;字符串 拼接数组元素成一个字符串 5 集合为什么区分集合函数和数组函数？集合函数不单单适用于数组，还适用于字符串，对象，类数组对象（比如 Arguments，NodeList 等）。字符串是字符的集合，对象是属性值的集合。类数组对象是通过“鸭子类型”工作的，所以如果你传入一个拥有length字段并且值为数字的对象，这个对象会被当做一个数组处理。具体请参考Underscore.js文档。 范例： 1234567891011121314function printKeyVal(val, key) &#123; console.log(key, val);&#125;//普通对象_.each(&#123; a: 1 &#125;, printKeyVal);//打印结果// a 1//拥有值为数字的length字段_.each(&#123; a: 1, length: 2 &#125;, printKeyVal);//打印结果// 0 undefined// 1 undefined 下面将分类介绍集合相关函数。 遍历 函数名 简介 each 同forEach eachRight 同forEachRight 排序 函数名 简介 sortBy 排序 orderBy 同sortBy，还可以指定正序倒序 shuffle 返回一个打乱顺序的新数组 过滤 函数名 简介 filter 创建一个新数组，包含了所有让断言为真的元素 reject 创建一个新数组，包含了所有让断言为假的元素 partition 根据断言真假将一个集合分成两个集合 Map 之后再 flatten 函数名 简介 flatMap map之后再flatten flatMapDeep map之后再flattenDeep flatMapDepth map之后再flattenDepth 寻找元素 函数名 简介 find 找到第一个让断言为真的元素 findLast 同上，逆序 随机取值 函数名 简介 sample 从集合中随机选出一个元素 sampleSize 从集合中随机选出 n 个元素 迭代 函数名 简介 reduce reduceRight - 分组计数 函数名 简介 countBy 返回一个对象，属性名是迭代器的返回值，属性值该返回值出现的次数 groupBy 返回一个对象，属性名是迭代器的返回值，属性值是一个包含了相应元素的数组 未分类 函数名 简介 keyBy 返回一个对象，属性名是迭代器的返回值，属性值是元素本身 some 对于集合中的每个元素，是否至少其一返回真值 every 对于集合中的每个元素，是否都返回真值 includes 判断元素是不是在数组中，判断某个值是不是某个对象的属性值，判断一个字符串是不是包含在另一个字符串中 map 对集合的数组 invokeMap - 6 对象仅需要部分字段 函数名 简介 omit 通过忽略某些字段创建一个新对象 omitBy pick 通过指定某些字段创建一个新对象 pickBy - 合并对象 函数名 简介 assign 合并对象 assignWith 有条件地合并对象 extend 合并对象，包括原型链上的属性 extendWith 有条件地合并对象，包括原型链上的属性 assignIn 别名extend assignInWith 别名extendWith defaults 合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话 defaultsDeep 递归地合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话 merge 递归地合并对象，将后面参数的属性付给第一个参数 mergeWith 同merge，额外接受一个 customizer 参数 键值列表 函数名 简介 keys 创建一个数组，包含对象中所有的属性 keysIn 创建一个数组，包含对象中所有的属性（包含原型链上的） functions 创建一个数组，包含对象中所有值为函数的属性 functionsIn 创建一个数组，包含对象中所有值为函数的属性（包含原型链上的） values 创建一个数组，包含对象中所有的属性值 valuesIn 创建一个数组，包含对象中所有的属性值（包含原型链上的） 赋值取值 函数名 简介 at 获取对象的一组属性路径的值，肯定不会报错 get 获取对象的某个属性路径的值，肯定不会报错 result 同get，但是如果属性值是函数的话，自动执行该函数 set 设置对象的某个属性路径的值 setWith 设置对象的某个属性路径的值，遇到不存在的中间对象，使用数组呢？还是使用对象呢？等等 update 同set，只是接受一个函数作为参数 updateWith 同setWith，只是接受一个函数作为参数 unset 删除对象的某个属性路径 invoke 调用对象中某个属性路径上的函数，肯定不会报错 键值数组 函数名 简介 entries {‘a’:1}=&gt;[[‘a’,1]]。别名toPairs entriesIn 同上，但是包含原型链上的属性。别名toPairsIn 键值变换 函数名 简介 mapKeys 对对象中所有属性名做某种处理之后形成一个新对象 mapValues 对对象中所有属性值做某种处理之后形成一个新对象 invert 将对象中的属性名和属性值互换转成一个新对象 invertBy 同invert，但是转换以后的属性值是原属性值组成的数组 键值遍历 函数名 简介 forIn 遍历对象上的所有属性，包含原型链上的。 forInRight 遍历对象上的所有属性，包含原型链上的。 forOwn 遍历对象上的所有属性，不包含原型链上的。 forOwnRight 遍历对象上的所有属性，不包含原型链上的。 寻找属性 函数名 简介 findKey 同find类似，但是匹配的是对象的属性值，返回的是对象的属性名 findLastKey 同findKey类似，但是匹配的是对象的属性值，返回的是对象的属性名 判断属性是否存在 函数名 简介 has 判断对象上是否拥有某个属性，不包含原型链上的 hasIn 判断对象上是否拥有某个属性，包含原型链上的 转换对象或数组 函数名 简介 transform 同reduce，但是其迭代器函数返回的是布尔值，如果返回 false，则停止迭代 创建新对象 函数名 简介 create 创建一个对象，并指定其原型和属性 7. 函数修改参数 函数名 简介 ary 创建一个包裹函数，只将前 n 个参数传递给原函数。 unary 创建一个包裹函数，只将第一个参数传递给原函数。 flip 创建一个包裹函数，将参数逆序之后传递给原函数。 rearg 创建一个包裹函数，调整参数顺序之后在传递给原函数 rest 创建一个包裹函数，将参数合成数组之后传递给原函数 spread 创建一个包裹函数，将数组参数展开之后传给原函数，跟rest相反 overArgs 创建一个包裹函数，将参数做处理之后再传递给原函数。 修改结果 函数名 简介 negate 创建一个包裹函数，返回原函数结果的非。 缓存结果 函数名 简介 memoize 创建一个包裹函数，会缓存计算结果 降频调用 函数名 简介 debounce throttle 延迟调用 函数名 简介 defer 类似setTimeout(fn,0)，可以指定参数 delay 类似setTimeout(fn,x)，可以指定参数 延迟调用 函数名 简介 once 创建一个包裹函数，确保原函数只被执行一次。 before 创建一个包裹函数，确保原函数只被执行 n 次。 after 创建一个包裹函数，调用包裹函数时只有 n 次之后才会调用目标函数 固定参数 函数名 简介 wrap 创建一个包裹函数，固定原函数的第一个参数 partial 创建一个包裹函数，固定原函数若干个参数 partialRight 创建一个包裹函数，固定原函数若干个参数 bind 创建一个包裹函数，固定原函数若干个参数，并指定 this 对象 bindKey 和bind功能类似，但是能够处理尚未创建或被重写的函数，有点事件代理的感觉。 curry 创建一个包裹函数，可以传入任意数量的参数，如果参数不完整，则返回一个接受余下参数的新函数，否则，调用原函数获得计算结果。 curryRight 同上，逆序 8. 字符串书写格式 函数名 简介 startCase 每个单词首字母大写，多用于标题 camelCase 小驼峰 kebabCase 小写连字符 snakeCase 小写下划线 upperCase 大写加空格 lowerCase 小写加空格 大写小写 函数名 简介 capitalize 首字母大写，其余小写 upperFirst 首字母大写，其余不变 lowerFirst 首字母小写，其余不变 toUpper 大写 toLower 小写 打头结尾 函数名 简介 endsWith 是不是以特定字符串结尾 startsWith 是不是以特定字符串打头 转义 函数名 简介 escape 转义 &amp;&lt;&gt;”‘，与unescape相反 escapeRegExp 转义正则表达式中的特殊字符：^\$.*+?()[]{}\ 补全抹掉 函数名 简介 pad 使用某个字符串将特定字符串扩充至指定长度，类似地还有padStart，padEnd trim 去除字符串两边的特殊字符（默认为空格），类似地还有trimStart，trimEnd 未分类 函数名 简介 parseInt 转成整型 repeat 将某个字符串重复 n 遍 replace 替换字符串 split 拆分字符串 template 简单模板引擎 truncate 截断字符串 words 将字符串拆分成单词，可以指定拆分模式 deburr 基本拉丁字母 9. 数字 函数名 主要参数-返回值 简介 clamp 数字=&gt;数字 将数字限定在一个范围内 inRange 数字=&gt;布尔 判断数字是否在某个区间里 random 区间=&gt;数字 随机获取一个值，可以通过第三个参数指定是不是返回小数 10. 数学加减乘除 函数名 主要参数-返回值 简介 add 两个数字 =&gt; 数字 返回两个数字的和 subtract 两个数字 =&gt; 数字 返回两个数字的差 multiply 两个数字 =&gt; 数字 返回两个数字的积 divide 两个数字 =&gt; 数字 返回两个数字的商 和，最大值，最小值，平均值 函数名 主要参数-返回值 简介 sum 数组 =&gt; 数字 返回数组中的各数字之和 max 数组 =&gt; 数字 返回数组中的最大值 min 数组 =&gt; 数字 返回数组中的最小值 mean 数组 =&gt; 数字 返回数组中的平均值 数字精度 函数名 主要参数-返回值 简介 ceil 数字 =&gt; 数字 向上取整，可以指定精度 floor 数字 =&gt; 数字 向下取整，可以指定精度 round 数字 =&gt; 数字 四舍五入取整，可以指定精度 11. 语言数值比较 函数名 简介 eq 等价于=== isEqual 深度比较对象是否相等 isEqualWith 深度比较对象是否相等，可以定义相等比较函数 gt 大于 lt 小于 gte 大于等于 lte 小于等于 类型判断 函数名 简介 isArguments isArray isArrayBuffer isArrayLike isArrayLikeObject isBoolean isBuffer isDate isElement isEmpty 判断是否有可遍历的属性 isError 错误 isFinite 是否是有限的数字，基于 Number.isFinite isFunction isInteger isLength isMap isMatch isMatchWith isNaN isNative 原生函数 isNil 等价于 _.isNull(val) &#124;&#124; _.isUndefined(val) isNull isNumber isObject isObjectLike isPlainObject isRegExp isSafeInteger isSet isSet isString isSymbol isTypedArray isUndefined isWeakMap isWeakSet 类型转换 函数名 简介 castArray 强制转给数组 toArray 转成数组，对象调用 Object.values，字符串转成字符数组 toFinite toInteger toLength toNumber toPlainObject toSafeInteger toString 转成字符串， 复制对象 函数名 简介 clone cloneDeep cloneDeepWith cloneWith 检测对象 函数名 简介 conformsTo 判断一个对象的字段是否满足一些条件 12. 工具总是返回某个参数的函数 函数名 简介 constant 创建一个包裹函数，总是返回第一个参数 nthArg 创建一个包裹函数，总是返回第 n 个参数 总是返回某个特定值的函数 函数名 简介 noop 总是返回undefined的函数 stubArray 总是返回空数组的函数 stubObject 总是返回空对象的函数 stubString 总是返回空字符串的函数 stubTrue 总是返回true的函数 stubFalse 总是返回false的函数 identity 总是返回第一个参数 获取对象的属性值或者调用对象的函数 函数名 简介 method _.invoke(object, path, [args])预设path和args两个参数 methodOf _.invoke(object, path, [args])预设object和args两个参数 property _.get(object, path)预设path参数，不同的是缺少defaultValue`参数 propertyOf _.get(object, path)预设object参数，不同的是缺少defaultValue参数 判断对象是否满足某些条件 函数名 简介 conforms 创建一个包裹函数，判断一个对象的字段是否满足某个函数。conforms意思是遵守。 matches 创建一个包裹函数，判断一个对象的字段是否等于某个值，使用isEqual判断是否相等。跟isMatch类似 matchesProperty 创建一个包裹函数，判断一个对象特定字段是否等于某个值，使用isEqual判断是否相等。 把多个操作合成一个操作 函数名 简介 flow 把一组函数串起来形成一个新函数 flowRight 同上，倒序 批量进行多个操作 函数名 简介 over 创建一个新函数，并将参数传递给预先指定的一组函数，并返回其结果 overEvery 跟over类似，判断是不是所有函数都返回真值 overSome 跟over类似，判断是不是至少一个函数返回真值 等差数列 函数名 简介 range 生成等差数列，可以指定步长，步长可以是小数，也可以是负数 rangeRight 这个基本可以忽略，功能完成可以由range代替。 其他未分类 函数名 简介 attempt 使用 try-catch 包裹函数，如果出错返回错误对象 bindAll 将一个对象的多个函数中的 this 固定为该对象 cond 创建一个拥有复杂 if-else 的函数 defaultTo 如果第一个参数为 NaN,null,undefined，则返回第二个参数，否则返回第一个参数 iteratee 创建一个迭代函数 noConflict 如果_被占用，可以使用该方法 runInContext 创建一个lodash镜像对象，可以扩展修改该对象 mixin 给一个对象的原型添加属性或方法，一般配合runInContext扩展lodash。 times 执行函数 n 次，传入参数为 index toPath ‘a[0].b.c’=&gt;[‘a’,’0’,’b’,’c’] uniqueId 生成唯一 ID，可以指定前缀 13. 链式链式调用的好处省略了中间变量，让代码更加简洁，更加安全。链式调用可以优化成惰性求值（延迟计算），让代码更加高效。 _(value)创建一个经过 lodash 包装过后的对象会启用隐式链，直到调用了不支持链接调用的函数或者主动调用value方法解除链式调用。作用类似于chain lodash 包装对象上的特殊函数 函数名 简介 tap 可以在链式调用中插入普通方法，直接修改中间结果，也可以仅仅是用于调试打印中间结果 thru 同tap，但是使用函数的返回值作为中间结果 commit 立即执行链式调用中尚未进行的操作 next 获得包装对象的下一个值 plant 复制一个链式调用，并传入初始值 value 结束链式调用，并计算结果。别名valueOf，toJSON]]></content>
  </entry>
  <entry>
    <title><![CDATA[主要CSS3，HTML5特性兼容性调查]]></title>
    <url>%2F2016%2F07%2F04%2Fcss3-html5-feature-compatibility-survey%2F</url>
    <content type="text"><![CDATA[CSS3 HTML5 部分特性 特性组 特性 IE8 IE9 IE10 IE11 Edge CH FF SF 参考 values calc × √ √ √ √ √ √ √ caniuse rem × √ √ √ √ √ √ √ caniuse vw,vh × √ √ √ √ √ √ √ caniuse color currentColor × √ √ √ √ √ √ √ hsl hsla rgba × √ √ √ √ √ √ √ background border-radius × √ √ √ √ √ √ √ border-images × × × √ √ √ √ √ images linear-gradient × × √ √ √ √ √ √ radial-gradient × × √ √ √ √ √ √ repeating-linear-gradient × × √ √ √ √ √ √ repeating-radial-gradient × × √ √ √ √ √ √ animation keyframes × × √ √ √ √ √ √ requestAnimationFrame × × √ √ √ √ √ √ transform 2d × √ √ √ √ √ √ √ 3d × × √ √ √ √ √ √ postion position:sticky × - - - - - √ √ caniuse, polyfill selector querySelector querySelectorAll √ √ √ √ √ √ √ √ webfonts @font-face √ √ √ √ √ √ √ √ 小米案例 ui sizing-box √ √ √ √ √ √ √ √ dom mutation-observers × - - √ √ √ √ √ caniuse, polyfill HTML5 audio × √ √ √ √ √ √ √ video × √ √ √ √ √ √ √ ECMA5 Promises - - - - √ √ √ √ CSS 选择器 - CSS 选择器 IE8+ IE9 IE10+ CSS2.1 * 通配符 √ √ √ #foo ID 选择器 √ √ √ .foo 类选择器 √ √ √ foo 节点选择器 √ √ √ > 子选择器 √ √ √ + 后一个兄弟节点 √ √ √ [attr] 带有 attr 属性的元素 √ √ √ [attr=”val”] &lt;div attr=”val”/&gt; √ √ √ [attr~=”val”] &lt;div attr=”val val1”/&gt; √ √ √ [attr&#124;=”val”] &lt;div attr=”val-val1”/&gt; √ √ √ :first-child 第一个子元素 √ √ √ :link, :visited 伪类，仅适用于 a 标签 √ √ √ :active, :hover 伪类，适用于所有元素 √ √ √ :focus 伪类，获取焦点的元素 √ √ √ :lang() 伪类，&lt;div lang=”en”/&gt; √ √ √ CSS3 [attr^=”val”] 带有 attr 属性并且值以 val 打头 √ √ √ [attr$=”val”] 带有 attr 属性并且值以 val 结束 √ √ √ [attr*=”val”] 带有 attr 属性并且值中带有 val 字眼 √ √ √ ~ 后面兄弟选择器 √ √ √ :last-child 最后一个子元素 × √ √ :root 根元素 × √ √ :only-child 唯一的子节点 × √ √ :nth-child() 选择一个或多个子元素，参数 n 代表 0-+∞ × √ √ :nth-last-child() 选择一个或多个子元素，参数 n 代表 0-+∞，从后往前选择 × √ √ tag:only-of-type 唯一 tag 元素 × √ √ tag:nth-of-type 选择一个或多个子 tag 元素，参数 n 代表 0-+∞ × √ √ tag:nth-last-of-type() 选择一个或多个子 tag 元素，参数 n 代表 0-+∞，从后往前选择 × √ √ tag:first-of-type 选择第一个 tag 元素 × √ √ tag:last-of-type 选择最后一个 tag 元素 × √ √ :empty 匹配空节点 × √ √ :target 匹配 hash 相应的元素 × √ √ :enabled, :disabled 匹配表单中启用或禁用的元素 × √ √ :checked 匹配表单中选中的元素 × √ √ :not() 否定选择器 × √ √ 备注：没有添加伪元素。 CSS2.1 之前的一些不为人知的特性 特性 可选值以及含义 empty-cells hide：当 td 的子元素都是隐藏的时候，自动隐藏该 td 的边框和背景show：永远显示不过该属性只有在 border-collapse:separate;时才有效。 参考： CSS Current Work 这里记载着 CSS 规范子集的进度（稳定级别）：工作草案，最后通告，候选标准，推荐标准和标准。 W3C Technical Report Development Process W3C 技术报告开发过程 《W3C 技术报告开发过程》 只翻译一部分 Mozilla CSS support chart 火狐浏览器 CSS 特性支持 Safari CSS Reference Comparison of layout engines (Cascading Style Sheets)&gt;) 中文版浏览器引擎 CSS 支持比较 http://t337.org-w3c-region-chinese-html5.w3ctalk.info/w3c-t337.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES5简介]]></title>
    <url>%2F2015%2F09%2F21%2Fes5%2F</url>
    <content type="text"><![CDATA[这是我组织的 ES6 特性分享的预热篇，主要介绍 ES5 的特性。 既是入门，又是回顾 相信很多人还没有完全在项目中使用 2011年正式发布的IE9实现了几乎所有ES5的特性 ES6，ES7……都已经或将要来了 ES5 中最有用的特性：JSONJSON 简介 Douglas Crockford 在 2002 年创建， JSON JavaScript 对象标记（Notation） JavaScript 语言的一个子集 一种轻量级的数据交换格式 易于人阅读和编写，同时也易于机器解析和生成。 更多细节：RFC7159，ECMA-404，介绍 JSON 那段不堪回首的过去1var data = eval('(' + response + ')'); 或 1234&lt;script src="/javascript/json2.js"&gt;&lt;/script&gt;&lt;script&gt;var data = JSON.parse(response);&lt;/script&gt; JSON.stringify(value[, replacer [, space]])123456789101112131415161718var obj = &#123; a: 'x', b: &#123; c: 1 &#125; &#125;;var string = JSON.stringify(obj);//var string = JSON.stringify(obj, function(key, value) &#123; return typeof value === 'number' ? 0 : value;&#125;);console.log(string); //&#123;"a":"x","b":&#123;"c":0&#125;&#125;//美化JSONvar string = JSON.stringify(obj, null, '\t');var string = JSON.stringify(obj, null, 2);console.log(string);obj.toJSON = function() &#123; return 'something';&#125;;var string = JSON.stringify(obj);console.log(string); //nothing JSON.parse(text[, reviver])123456789//将字符串解析成JSON对象var data = JSON.parse('&#123;"a":1,"b":&#123;"c":1&#125;&#125;');//将字符串解析成JSON对象，并对象中的每个数值加1var data = JSON.parse('&#123;"a":1,"b":&#123;"c":1&#125;&#125;', function(key, value) &#123; console.log(key, value); return typeof value === 'number' ? value + 1 : value;&#125;);console.log(JSON.stringify(data)); //&#123;"a":2,"b":&#123;"c":2&#125;&#125; JSON 用法举例 解析 JSON 格式的 AJAX 响应 localStorage，sessionStorage 只能存储字符串 PHP 使用 SpiderMonkey 引擎创建 JS 上下并输入数据 JSON 的替代协议 Protocol BuffersProtocol Buffers，Github JSON 的替代协议 MessagePackMessagePack ES5 中最强大的特性：Object 扩展以下是 ES5 对 Object 对象的所有扩展 12345678910111213Object.definePropertyObject.definePropertiesObject.createObject.getPrototypeOfObject.keysObject.sealObject.freezeObject.preventExtensionsObject.isSealedObject.isFrozenObject.isExtensibleObject.getOwnPropertyDescriptorObject.getOwnPropertyNames Object.defineProperty(obj, prop, descriptor)直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。 1234567891011121314var obj = &#123;&#125;;Object.defineProperty(obj, 'key', &#123; value: 'val', //默认 undefined configurable: false, //默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改 enumerable: false, //默认 false，属性是否可以枚举 writable: false, //默认 false，能够使用赋值运算符改变属性值 get: function() &#123; return this.value; &#125;, set: function(newValue) &#123; this.value = newValue; &#125;,&#125;);//以上代码仅为示例，get/set 不能和 value，writable同时出现。 Object.defineProperty 数据描述符 configurable1234567891011121314151617181920var obj = &#123;&#125;;Object.defineProperty(obj, 'key', &#123; value: 'val', // 默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改 configurable: true,&#125;);Object.defineProperty(obj, 'key', &#123; value: 'changed', configurable: false &#125;);console.log(obj.key); //changedtry &#123; Object.defineProperty(obj, 'key', &#123; configurable: true, &#125;);&#125; catch (e) &#123; console.log(e);&#125; //TypeError: Cannot redefine property: key(…)delete obj.key;console.log(obj.key); //changed Object.defineProperty 数据描述符 enumerable123456789101112var obj = &#123;&#125;;Object.defineProperty(obj, 'key', &#123; value: 'val', enumerable: false, // 默认 false，属性是否可以枚举&#125;);console.log(obj.propertyIsEnumerable('key')); // falseconsole.log(Object.keys(obj)); // []for (var k in obj) &#123; console.log(k); //什么也不会打印&#125; 使用 Object.defineProperty 调试1234567891011121314function debugObject(obj, key)&#123; //将相应值保存起来 var value = obj.key; //重新定义该属性 Object.defineProperty(obj, key, &#123; get: function()&#123; return value; &#125;, set: function(val)&#123; debugger; value = val; &#125; &#125;);&#125; 在 ES7 草案中，还有一个方法Object.observe(ob, callback)可以更加方便地监听对象变化。 Object.defineProperties(obj, props)添加或修改 1+个属性，并返回该对象。 123456789var obj = &#123;&#125;;Object.defineProperties(&#123; key1: &#123; writable: false, &#125;, key2: &#123; enumerable: false, &#125;,&#125;); Object.create(prototype, descriptors)123456789101112131415var Man = &#123; race: function() &#123; console.log('race'); &#125;,&#125;;var peter = Object.create(Man, &#123; firstName: &#123; value: 'Xiaoming' &#125;, lastName: &#123; value: 'Li' &#125;, fullName: &#123; get: function() &#123; return this.firstName + ' ' + this.lastName; &#125;, &#125;,&#125;);console.log(peter.fullName); // Xiaoming Li Object.create(prototype, descriptors)123456789var obj = Object.create(null);console.log( Object.keys(obj) ); //[]console.log( typeof obj ); //objectconsole.log( Object.prototype.toString.call(obj) ); //[object Object]console.log( obj instanseof Object ); //false Object.getOwnPropertyDescriptor(obj, prop) 获取属性描述符12345678910111213var obj = &#123; a: 1 &#125;;Object.defineProperty(obj, 'b', &#123; //value: 2, enumerable: false, get: function() &#123; return 1; &#125;,&#125;);console.log(Object.getOwnPropertyDescriptor(obj, 'a'));var descriptor = Object.getOwnPropertyDescriptor(obj, 'b');console.log(descriptor); Object.getOwnPropertyNames(obj) 获取所有自有属性名获取所有自有属性名，包含可枚举以及不可枚举的，但是不包含原型链上的。 123456789101112var prototype = &#123; a: 0 &#125;;var obj = Object.create(prototype, &#123; b: &#123; value: 1, &#125;, c: &#123; value: 2, enumerable: false, &#125;,&#125;);console.log(Object.getOwnPropertyNames(obj)); // ["b", "c"] Object.freeze(obj) 冻结一个对象冻结一个对象，意味着该对象的属性不能增删改，属性的各个特性也不能改。而Object.isFrozen(obj)可以用来判断一个对象有没有冻结。 12345678910111213141516var obj = &#123; key: 'val', key1: &#123;&#125; &#125;;Object.freeze(obj);console.log(Object.isFrozen(obj)); // trueobj.key2 = 1;console.log(obj.key2); // undefineddelete obj.key;console.log(obj.key); // valobj.key = 1;console.log(obj.key); // valobj.key1.a = 2;console.log(obj.key1.a); // 2 ------冻结仅仅冻结一层//Uncaught TypeError: Cannot redefine property: keyObject.defineProperty(obj, 'key', &#123; enumerable: false &#125;); 怎样完全冻结一个对象12345678910111213function deepFreeze(obj) &#123; for (var key in obj) &#123; var val = obj[key]; //忽略原型链上的属性 if (!obj.hasOwnProperty(key)) continue; //忽略不是对象的属性 if (typeof val !== 'object') continue; //忽略已经冻结的属性 if (Object.isFrozen(val)) continue; //递归地冻结对象属性 deepFreeze(val); &#125;&#125; Object.seal(obj) 密封一个对象密封，比冻结宽松一点，仅仅能修改属性的值。而Object.isSealed(obj)可以用来判断一个对象有没有密封。 12345678910111213141516var obj = &#123; key: 'val', key1: &#123;&#125; &#125;;Object.seal(obj);console.log(Object.isSealed(obj)); // trueobj.key2 = 1;console.log(obj.key2); // undefineddelete obj.key;console.log(obj.key); // valobj.key = 1;console.log(obj.key); // 1----跟冻结唯一不同的地方obj.key1.a = 2;console.log(obj.key1.a); // 2//Uncaught TypeError: Cannot redefine property: keyObject.defineProperty(obj, 'key', &#123; enumerable: false &#125;); Object.preventExtensions(obj) 不能添加新属性Object.isExtensible用来检查一个对象能不能添加新属性 123456789101112131415161718var obj = &#123; key: 'val', key1: &#123;&#125; &#125;;Object.preventExtensions(obj);console.log(Object.isExtensible(obj)); // falseobj.key2 = 1;console.log(obj.key2); // undefined，不能添加新属性obj.key = 'value';console.log(obj.key); // value，能够修改已有属性Object.defineProperty(obj, 'key', &#123; enumerable: false &#125;);console.log(Object.keys(obj)); // ["key1"]，能够修改属性特性delete obj.key;console.log(obj.key); // undefined，能够删除已有属性obj.key1.a = 'a';console.log(obj.key1.a); // a，不影响给扩展已有属性 Object.getPrototypeOf(obj)1234567function Car() &#123;&#125;var prototype = (Car.prototype = &#123;&#125;);Object.getPrototypeOf(new Car()) === prototype; // truevar prototype = &#123;&#125;;var car = Object.create(prototype);Object.getPrototypeOf(car) === prototype; // true Array 扩展Array.isArray(obj) 判断一个对象是不是数组 123456789var array = [1, 2, 3];Array.isArray(array); //true，//等价于function isArray(obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]';&#125; Array 实例扩展1234var array = [1, 2, 2, 3];array.indexOf(2); // 1array.lastIndexOf(2); // 2 保留字作为属性名12345678var obj = &#123; if: 1, var: 's', switch: true,&#125;;console.log(obj.if);console.log(obj.var);console.log(obj.switch); 使用 get/set 进行属性初始化12345678910111213141516171819var obj = &#123; firstName: &apos;&apos;, lastName: &apos;&apos;, get fullName()&#123; return (this.firstName + &apos; &apos; + this.lastName).trim(); &#125;, set fullName(fullName)&#123; if(!fullName) return; var index = fullName.indexOf(&apos; &apos;); this.firstName = fullName.substring(0, index); this.lastName = fullName.substring(index+1); &#125; &#125;;console.log( obj.fullName ); // 空字符串obj.fullName = &apos;San Zhang&apos;;console.log( obj.firstName ); // Sanconsole.log( obj.lastName ); // Zhangconsole.log( obj.fullName ); // San Zhang 全局 undefined 对象以前，undefined 对象是这样产生的。 1234567891011var undef;console.log(typeof undef === 'undefined'); // truevar undef = 1;undef = void 0;console.log(typeof undef === 'undefined'); // true//jQuery 1.8.3源码片段(function(window, undefined) &#123; console.log(typeof undefined === 'undefined'); // true&#125;)(window); 在 ES5 中有了不可变的全局的undefined对象。 12345678910var undefined = 1;console.log(undefined); // undefined(function(undefined) &#123; undefined = 1; console.log(undefined); // 1 window.undefined = 1; console.log(window.undefined); // undefined&#125;)(); Function 实例扩展Function.prototype.bindfun.bind(thisArg[, arg1[, arg2[, ...]]]) 123456789function a() &#123; console.log(this, arguments);&#125;a.bind(&#123; key: 'a' &#125;, 1, 2); // function bound a() &#123; [native code] &#125;a.bind('ab', 1, 2)(); //String &#123;0: "a", 1: "b", length: 2, [[PrimitiveValue]]: "ab"&#125; [1, 2]a.bind(&#123; key: 'a' &#125;, 1, 2).bind(&#123; key: 'b' &#125;, 3, 4)(); // &#123;key: 'a'&#125;, [1,2,3,4] Curry（柯里化）预先设定函数的前面若干个实参，生成一个接受剩余实参的新函数。 1234567function curry(fn) &#123; var slice = Array.prototype.slice, args = slice.call(arguments, 1); return function() &#123; return fn.apply(null, args.concat(slice.apply(arguments))); &#125;;&#125; 柯里化案例1234567891011121314model.groups = _.filter(model.groups, function(g) &#123; return g.id !== group.id;&#125;);model.groups = _.sortBy(model.groups, 'updateTime');model.groups = _.map(model.groups, 'name');// _.prototype 上的方法都是 _ 上相应方法的柯里化model.groups = _.chain(groups) .filter(function(g) &#123; return g.id !== group.id; &#125;) .sortBy('updateTime') .map('name') .value(); _.curry &amp; _.curryRight1234567891011var abc = function(a, b, c) &#123; return [a, b, c];&#125;;var curried = _.curry(abc);curried(1)(2)(3); //[1,2,3]curried(1, 2)(3); //[1,2,3]curried(_, 2)(_, 3)(1); //[1,2,3] 严格模式把整段代码或某个函数放在严格操作的环境中运行，严格环境有诸多限制： 将失误转成异常 简化变量的使用 让 eval 和 arguments 变的简单 “安全的” JavaScript 为未来的 ECMAScript 版本铺平道路 严格模式：将失误转成异常 意外地创建全局变量 123456789101112131415(function() &#123; 'use strict'; variable = 10;&#125;)(); // ReferenceError//解决方法1：明确指定我要创建全局变量(function() &#123; 'use strict'; window.variable = 10;&#125;)();//解决方法2：事先定义好全局变量var variable;(function() &#123; 'use strict'; variable = 10;&#125;)(); 不再静默失败，而是抛出异常 123var fixed = &#123;&#125;;Object.preventExtensions(fixed);fixed.attr = 'value'; // SyntaxError 形参命名不能重复 1(function(a, a)&#123;'use strict'; &#125;)(); //SyntaxError 注意：严格模式下，ES5 中定义变量时，字段名也不能重复，但是 ES6 又允许了。 严格模式禁止八进制数字语法 1234//FireFox: SyntaxError, Chrome/IE10: SyntaxError(function()&#123;'use strict'; console.log(010); &#125;)();//FireFox: SyntaxError, Chrome/IE10: 19(function()&#123;'use strict'; console.log(019); &#125;)(); 严格模式：简化变量的使用 禁用with 12345678(function()&#123; 'use strict'; var key = 'attr'; var obj = &#123;key: 1&#125;; with(obj)&#123; //SyntaxError console.log(key); &#125;&#125;)(); eval不再为上层作用域引入新变量 123456(function() &#123; 'use strict'; var x = 1; var y = eval('var x = 2; x'); //== eval('"use strict"; var x = 2; x') console.log(x, y); // 1, 2 在正常模式下，返回2, 2&#125;)(); 严格模式：简化变量的使用 call &amp; apply对this的修改规则简化 123456789(function() &#123; 'use strict'; function printThis() &#123; console.log(this); &#125; printThis.call(2); // 2 ，不再包装成对象类型 printThis.call(null); // null，不再自动替换成window对象 printThis.call(); // undefined，不再自动替换成window对象&#125;)(); 不能使用caller和callee 1234567(function restricted(a) &#123; 'use strict'; console.log(restricted.caller); //TypeError console.log(restricted.arguments); //TypeError console.log(arguments.caller); //TypeError console.log(arguments.callee); //TypeError&#125;)(1); 其他小的特性1. Date.prototype.toISOString转换成 YYYY-MM-DDTHH:mm:ss.sssZ 这种格式 2. Date.now()和 new Date().getTime() 一样。 3. String.prototype.trim和$.trim，_.trim一样。 4. 把字符串当做数组一样访问1'foobar'[1] === 'o'; // true 5. parseInt 忽略前置 012parseInt(&apos;012&apos;); // 12，在ES3中，因为前置0而按照八进制解析成10parseInt(&apos;0X12&apos;); // 18，仍然因为前置0X而按照十六进制解析成18 思考题 以下这种情况是为什么？ 123var array = [];console.log( array.length ); // 0console.log( Object.keys(array) ); // [] 参考 MDN Javascript 参考文档 es5-shim Douglas Crockford]]></content>
  </entry>
  <entry>
    <title><![CDATA[Knockout简介]]></title>
    <url>%2F2015%2F09%2F06%2Fknockout%2F</url>
    <content type="text"><![CDATA[1. MVVM 的概念1.1 MVVM 的概念MVC 模型示意图 MVVM 模型示意图 1.2 双向绑定的概念页面中每次状态的变化，一般都伴随着多次 DOM 操作，每次 DOM 操作一般都需要先找到该输入框元素，然后修改其相应属性，即便后来有了jQuery这种 DOM 操作神器，仍然非常繁琐。随着前端逻辑的日益复杂，前端越来越难以维护。此时双向绑定应运而生了。 双向绑定，简单地说，就是模型（数据）和 DOM 自动保持同步，模型变化了，会自动更新 DOM，用户操作了 DOM，会自动更新更新模型，并且触发相应事件。这样一来，我们只需要更新模型，以及监听模型变化就可以了，不再像以前一边更新模型，一边进行 DOM 操作了。 2. Knockout 的简介Knockout是一个可以轻松实现双向绑定的库。它有以下特性： 2.1 模型和 DOM 双向绑定这点不需要多作说明，这就是 Knockout 最大的意义所在。 2.2. 声明式绑定使用简明易读的自定义属性data-bind将模型字段关联到 DOM 元素上。比如以下代码就将输入框和模型中的 name 关联起来。 1&lt;input type="text" data-bind="value:name" /&gt; 2.3 依赖跟踪对于通过组合或转换而来的数据，保持其依赖链。请看如下例子。 123456789function ViewModel() &#123; this.firstName = ko.observable(''); this.lastName = ko.observable(''); //声明 fullName 是由 firstName 和 lastName计算出来的 //当 firstName 和 lastName 其一发生变化时，fullName都会自动重新计算 this.fullName = ko.computed(function() &#123; return this.firstName() + ' ' + this.lastName(); &#125;, this);&#125; 2.4 模板也不用多解释，与模型关联的DOM就是一个模板。 2.5 其他一些特点轻量（库，不是框架，侵入性低，很容和其他框架和库一起使用），全浏览器支持（包括IE6），没有依赖，免费（这是必须的）。 3. 简单入门3.1 Bindings123456789101112131415161718192021222324-dom |-visible---------------elem.style.display |-text------------------elem.innerText |-html------------------elem.innerHTML |-css-------------------elem.className |-style-----------------elem.style |-attr------------------elem.setAttribute-flow |-foreach |-if/ifnot |-with |-component-------------自定义组件-form |-click |-submit |-event-----------------用法：event:&#123;keydown:onKeyDown&#125; |-enable/disable--------elem.disabled |-value-----------------elem.value |-textInput-------------elem.value(输入框值变化，model立即更新) |-hasFocus--------------elem.focus() |-checked---------------elem.checked |-options---------------select的选项 |-selectedOptions-------select的选中选项 |-uniqueName------------如果:input 没有 name，则生成唯一的name。 3.2 官网链接官网示例链接。系统自带绑定链接 4. 高级进阶4.1 创建自定义绑定使用方法： 1&lt;textarea data-bind="textInput:query"&gt;&lt;/textarea&gt; &lt;button data-bind="preview:query"&gt;&lt;/button&gt; 创建方法： 1234567891011ko.bindingHandlers.preview = &#123; init: function(element, valueAccessor, allBindings, viewModel, bindingContext) &#123; var query = ko.utils.unwrapObservable(valueAccessor()); //做一些初始化工作，比如事件绑定。 &#125;, update: function(element, valueAccessor, allBindings, viewModel, bindingContext) &#123; //这一行如果不加的话，query发生变化时，该方法不会被调用。 var query = ko.utils.unwrapObservable(valueAccessor()); //当query发生变化时，要做什么处理。 &#125;,&#125;; 详细参考：knockout-preview.js 4.2 创建自定义组件使用方法： 12&lt;!-- ko component:&#123;name:"ko-dropmenu",params:&#123;name:"agl-search-order",items:sorts&#125;&#125;--&gt;&lt;!-- /ko --&gt; 创建方法： 12345ko.components.register('ko-dropmenu', &#123; viewModel: function(params)&#123; this.name = ko.observable(params.name); &#125;， template: '&lt;div data-bind="attr:&#123;name:name&#125;"&gt;&lt;/div&gt;' 详细参考：knockout-dropmenu.js 4.3 computed 和 pureComputedcomputed和pureComputed均表示该字段是由其他一个或多个字段转化而来，其区别在于pureComputed会做一些优化，比如当前字段并没有显示在页面上时，该字段并不会被计算，当该字段显示时，才开始计算。 5. 最佳实践5.1 label&gt;radio/checkbox1234567891011121314&lt;div data-bind="visible:status==='show'"&gt; &lt;span data=bind="text:name"&gt;&lt;/span&gt; &lt;label&gt; &lt;input type="radio" value="edit" data-bind="checked:status"&gt; &lt;span&gt;编辑&lt;/span&gt; &lt;/label&gt;&lt;/div&gt;&lt;div data-bind="visible:status==='edit'"&gt; &lt;input type="text" data-bind="value:name"&gt; &lt;label&gt; &lt;input type="radio" value="show" data-bind="checked:status"&gt; &lt;span&gt;保存&lt;/span&gt; &lt;/label&gt;&lt;/div&gt; 5.2 模型数据合理分块当模型数据变化了以后，跟这些数据相关的 DOM 都会重新渲染，所以模型数据需要尽可能做到动静分离。以收藏夹页面专利列表的详情模式为例，选中一个收藏夹，首先获取该收藏夹第一页的 50 条专利并渲染，然后再获取这 50 条专利的缩略图和 PDF 地址并渲染，用户可以选择全部选中和全部反选，也可以选择部分，然后标记为已读或未读。如果将缩略图和 PDF 地址，是否选中，是否已读等字段作为专利数据的一部分，那么必然将造成多次专利列表的重新渲染。一种可行的做法如下： 123456789101112this.patents = ko.observableArray([]);this.selected = ko.observableArray([]);this.isAllSelected = ko.pureComputed(&#123; read: function() &#123;&#125;, write: function() &#123;&#125;, owner: this,&#125;);this.readMap = ko.observable(&#123;&#125;);this.thumbMap = ko.observable(&#123;&#125;);this.pdfMap = ko.observable(&#123;&#125;); 5.3 全选12345&lt;input type="checkbox" data-bind="checked:isAllSelected" /&gt;&lt;ul data-bind="foreach:patents"&gt; &lt;li&gt;&lt;input type="checkbox" data-bind="value:$data.PN,checked:$parent.selected" /&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516171819this.selected = ko.observableArray([]);this.isAllSelected = ko.pureComputed(&#123; read: function() &#123; return this.selected().length === this.patents().length; &#125;, write: function(checked) &#123; var selected = null; //如果全部选中 if (checked) &#123; selected = _.map(this.patents(), 'PN'); &#125; //如果全部反选 else &#123; selected = []; &#125; this.selected(selected); &#125;, owner: this,&#125;); 5.4 ViewModel 的重复利用如果两个 ViewModel 都需要拥有一些相同的数据，我们当然可以通过pubsub事件模型来同步，但是这样可能导致 ViewModel 中导出都是同步逻辑，他们没有任何业务价值，并且影响后来维护者理解这段代码。有什么方法解决这个问题吗？答案是肯定的，请看一下代码。 123456789var userViewModel = &#123; user: ko.observable(&#123;&#125;);&#125;;var model1 = &#123; user: userViewModel&#125;var model2 = &#123; user: userViewModel&#125; 在以上这段代码中，model1和model2中拥有同一份user数据，自然是自动同步的。 6. 踩过的坑6.1 声明绑定时忘记带括号如果直接绑定字段，才可以省略括号，如果是表达式，则必须带括号，这点初学者很容易犯错，建议所有的绑定都带括号。 1this.index = ko.observable(0); 12345678&lt;!-- 正确，绑定单个字段可以不带括号 --&gt;&lt;span data-bind="text:index"&gt;&lt;/span&gt;&lt;!-- 正确，绑定单个字段带括号也是对的 --&gt;&lt;span data-bind="text:index()"&gt;&lt;/span&gt;&lt;!-- 错误，绑定表达式时必须带括号 --&gt;&lt;span data-bind="text:'NO.:' + index"&gt;&lt;/span&gt;&lt;!-- 正确，绑定表达式时必须带括号 --&gt;&lt;span data-bind="text:'NO.:' + index()"&gt;&lt;/span&gt; 6.2 Class 属性的绑定Class 绑定方法有两种：css 1&lt;div data-bind="css:&#123;disabled:status()==='disabled'&#125;"&gt;&lt;/div&gt; class 1&lt;div data-bind="attr:&#123;'class':status&#125;"&gt;&lt;/div&gt; 假设 ViewModel 中 status 的值为 ‘disabled’，则以上两种绑定都会给元素添加一个disabled类名。使用后者时需要注意class一定要加上引号，否则在 IE8 中报错。 6.3 jQuery.fn.data 的缓存在jQuery中，jQuery.fn.data方法是有缓存的，如果要获取正确的结果，必须通过jQuery.fn.data进行设置data属性，而不使用原生方法HTMLElement.prototype.getAttribute。 12&lt;!-- 分页器中的页面跳转链接 --&gt;&lt;span data-bind="click:goToPage,attr:&#123;'data-page':page()-1&#125;"&gt;上一页&lt;/span&gt; 1234567this.page = ko.observable(0);this.goToPage = function(model, e) &#123; //错误，因为缓存问题，导致第二次获取页面时出错。 var page = $(e.target).data('page'); //正确 var page = e.target.getAttribute('data-page');&#125;; 6.4 坑爹的性能问题 Knockout 的模板是基于 DOM 的，遇到循环就会通过原生的 clone 方法复制出若干个 DOM 片段，这个方法性能很差，当复制的 DOM 节点数达到一定程度，就会变得很慢，尤其在 IE8 中，收藏夹中渲染专利列表时就遇到了这种问题，在 IE8 甚至出现了“是否停止运行此脚本对话框”。由于该问题是在测试阶段发现的，没有时间进行大的修改。但是 IE8 中的对话框又是不能接受的，所以改为首次渲染前 25 条（如果有的话）专利，异步等 100 毫秒之后再渲染后 25 条（如果有的话）专利。这样，所有专利渲染出来的时间虽然延长了一点，但是保证了不会弹出让人费解的对话框，并且对用户体验基本没有更坏的影响。 7. 参考链接 Knockout 官网 MVC，MVP 和 MVVM 的图示]]></content>
  </entry>
  <entry>
    <title><![CDATA[IE 浏览器的阻止 XSS 攻击功能]]></title>
    <url>%2F2015%2F08%2F12%2Fie-prevent-xss%2F</url>
    <content type="text"><![CDATA[昨天接到一个专利搜索结果页面的 bug：在某个搜索条件下，IE10 浏览器不能正常显示。 1. 重现问题我们这里没有 IE10 浏览器，一般都是通过 Windows8.1 上的 IE11 浏览器模拟实现，所以我立即在 IE11 上验证，没有想到 IE11 竟然也重现了这个问题，所以我也没有必要去模拟 IE10 了。 开发环境：我们组有三台服务器，一台装 Ubuntu 用来做普通服务器用，剩下两台都用来测试网站在 IE 上兼容性，一台是 Windows Server 2012 安装了 IE8，一台是 Windows 8.1 安装了 IE11。IE9，IE10 都是通过 IE11 模拟测试的。 重现的时候发现两个问题，一个是页面顶部给出提示“Invalid input”(非法输入)，这是我们系统给出的错误提示。另一个就是 IE 给的提示信息“Internet Explorer has modified this page to help prevent cross-site scripting.” 2. 从错误提示着手进行调试因为有我们系统“非法输入”的错误提示，所以我决定通过调试来确定是哪里出错了。 根据经验猜测这个错误很可能是由某个 AJAX 请求出错造成的，在锁定了 AJAX 之后，又对比该请求在 Chrome 和 IE11 浏览器中的不同，发现某个字段中括号（英文的左右括号）被替换成了#，由于该字段是由后台写在&lt;script&gt;&lt;/script&gt;，所以首先去查看网页源代码，令人吃惊的是网页源代码中竟然括号也变成#，这不得不让我怀疑是后台针对 IE 浏览器做了特殊处理。虽然我们知道后台不应该这么做，并且得到后台确切的答案（他们不会这么做）以后，我们决定通过 Fiddler 代理来查看请求和响应数据，而通过 Fiddler 查看到的响应是正确的，难道是 IE 浏览器在搞鬼？ 3. 从 IE 浏览器的关于 XSS 的提示着手在网上搜索了“Internet Explorer has modified this page to help prevent cross-site scripting.”，找到了一些文章，大致说这是由于 IE 检测到页面中可能带有跨站脚本攻击代码，而对页面代码做了一些修改，以保护用户免受跨站脚本攻击。并且提供了一些解决方案：点击Tools-&gt;Internet Options-&gt;Security-&gt;Custom level，在弹出的对话框中禁用 XSS Filter。这样设置以后页面确实正常显示了。可见该问题确实是有 IE 误判造成的。 但是我们做为在线网络服务的提供商，不能依靠用户修改浏览器设置来解决问题，并且该设置并不是针对某个具体网站，而是整个互联网，意味着用户彻底放弃了 IE 针对 XSS 攻击的保护，得不偿失。还要继续寻找其他方案。终于在另一篇文章中找到答案。给页面添加一个响应头 1X-XSS-Protection: 0 这样就通过禁用响应头彻底解决了该问题。 ###4. 解决问题以后的一些思考问题解决了，但是还是有写疑问，我们很容易找到 IE 误判为 XSS 攻击的代码，却不知道为什么会被判断为 XSS 攻击代码。只在这篇文章中找了一些示例，但是我们的页面源代码中都不符合这些规则。估计 IE 官方也不会给出这些规则，否则很容易被黑客利用，设计能够避开这些规则的 XSS 攻击代码。 另外还想谈谈 IE 的阻止 XSS 攻击的功能，我们有时也会在 Chrome 看到相似的提示，但是 Chrome 给出另外一种选择，大概意思是我已经了解可能的风险，并且要继续访问，通过次选项用户可以比较方便地继续浏览其非常信任的网站。在这件事件上，IE 显得非常保守，没有给出第二种选择，用户遇到这种情况，只会怀疑网站除了问题，也不会知道怎样才能查看网页内容。经过 IE 修改后的代码一般很难正确运行，而 IE 却尝试继续运行。远不如 Chrome 实在，检测到危险代码，干脆放弃执行代码，并给用户醒目提示。 IE 对（疑似）XSS 代码处理也真够不遗余力的，连查看源代码都不放弃，个人认为这是 IE 设计上的缺陷，查看源代码，我看的是“源”代码，将响应当做普通的不可执行的文档处理，不可能出现 XSS 攻击，还有就此时 IE 修改了源代码，却没有给出任何提示。 打完收工，睡觉。]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计规范]]></title>
    <url>%2F2014%2F06%2F05%2Fhtml-code-guide%2F</url>
    <content type="text"><![CDATA[一. 命名规则 !important list information //正确list information //错误id 与 class 均采用中划线命名法，不得驼峰命名法二. 合理命名side information //推荐side information //不推荐根据内容而不是表象给 id 和 class 合理命名三. 标签语义化这里是强调文本 //用em标签标识强调文本这里是重点强调文本 //用strong标签标识重点强调文本根据内容选择合适的html标签，尽量避免写入无意义标签，尝试使用微格式(MicroFormats)人可以通过视觉的划分判断内容的语义,搜索引擎看到的只是代码。搜索引擎只能通过标签来判断内容的语义。页面的很大一部分流量是来自搜索引擎的，所以我们要使页面尽可能地对搜索引擎友好h标签的语意是标题，搜索引擎对这个标签比较敏感，特别是h1,和h2。一个语义良好的页面，h标签应该是完整有序没有断层的。也就是说，要h1,h2,h3,h4这样推下来，不要h1,h3,h4，漏掉h2。一个结构良好的网页，h标签可以组织起一个网页的大纲四. 良好的文档结构清晰合理的文档结构，对SEO更友好，方便行为层操控DOM结构，使之易于维护、扩展和阅读五. 分离的思想sidebar information //直接插入样式，不推荐sidebar information //直接注册事件，不推荐结构层、表现层和行为层的分离，尽可能的不要在 HTML 结构标签中直接插入样式或者 JavaScript 脚本代码书写规范一. 标签的元素和属性名都必须小写 !important备注：1. IE 另存为的 html 文件，会把标签全改为大写，这是不符合标准的，不能直接复制粘贴复用。如有这方面的需要，请用 Firefox 保存，或者用工具(比如:dreamwaver)将标签全部转为小写。2. 另一个值得注意的是，通过内联方式(link)注册的事件，事件名必须全部小写。 //错误 //正确 二. 标签必须关闭 !important 备注：自封闭的标签必须自封闭，如：, 等，所有自封闭的 HTML 标签请点击 这里 备注：标签未关闭的错误常见于模版输出和挖天窗的过程中，请相关人员要特别注意分析好页面结构 //错误 //错误 //正确 (最后的斜杠“/”与前面的字符串之间要有一个空格) 三. 标签必须正确嵌套 !important text //错误 text //正确 扩展阅读: HTML 标签嵌套规则 四. 标签属性必须使用双引号 !important //错误 //正确 五. 属性值不能简写，必须是名值对的形式(name=”value”) !important selected=”selected” //类似的还有 disabled , checked , readonly , noresize 六. 自定义属性，必须以 data-开头(data-name=”value”)，多个单词用‘-’连接 !important context //错误 context //正确 使用 data-开头的自定义属性，是 HTML5 新增加的功能，可以使用更多 HTML5 的新特性 HTML5 JavaScript API 提供了访问这些自定义属性的方法（除了 setAttribute/getAttribute 以外）DOM.dataset 点击查看 七. 使用自定义属性(data-role=”xxx”)代替 class 做“js 钩子” !important context //不推荐 context //推荐使用 使用 data-role=”xxx”来代替原来的 class=”J-xxx”可以更好地将 css 与 js 分离，利于发展维护 八. 属性值特别是依赖后端输出的属性值必须经过 html encode，以防止 XSS 攻击 !important 其中 a 标签 href 属性 PATH 部分必须经过 encode. 前端操作 Cookie 时，涉及用户输入数据的部分也要特别注意这一点，比如: 网站中的 Recent Search 记录 安全输出 velocity 变量的宏请猛击这里 九. 标签内容，服务器端输出的，根据情况确定是否需要经过 encode !important 纯文本，必须。比如:链接文本 包含 html 输出时不能编码的，要有意识地联系工程师做好后端输入过滤。比如：富媒体编辑器内容 安全输出 velocity 变量的宏请猛击这里 十. 特殊字符尽量用相应的符号实体代替 特殊字符 对应的符号实体 &amp; &amp; &lt; &lt; &gt; &gt; 空格 &nbsp; 查看更多？猛击这里下载整理的电子书 十一. 关于 table 标签 table 标签中，如果使用 thead、tfoot 以及 tbody 元素之一，就必须使用全部的元素，它们的出现次序是：thead、tfoot、tbody 。 扩展阅读: 标准化 table 标签 十二. 代码缩进 在书写代码的时候, 缩进并不会影响页面的最终表现, 但使用适当的缩进能使代码更具可读性, 我们推荐的缩进方法是当你开始一个新的元素时缩进一个 Tab 位(按一次 Tab 键——4 个空格的长度). 另外, 记得, 关闭元素的标签与开始标签对齐.示例： hello, Alibaba! 注释规范如非必要，HTML 代码中不允许出现 HTML 注释（系统自动生成的除外），用 velocity 的注释代替。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS编码规范]]></title>
    <url>%2F2014%2F06%2F04%2Fcss-code-guide%2F</url>
    <content type="text"><![CDATA[为了提高 CSS 的可读性、维护性、扩展性、复用性，制定以下书写规范。 ##1 命名规范 Id 和 Class 全部小写，并用中划线隔开。 ##2 书写规范 样式和内容分离，不使用 style 属性定义样式。 【建议】属性书写顺序显示属性display, position, float盒模型属性width, max-width, min-width,height, max-height, min-height,bordermargin, margin-top, margin-right, margin-bottom, margin-left,padding, padding-top, padding-right, padding-bottom, padding-left,文本属性(color, font, text-decoration, text-align, vertical-align, white-space, other text, content)1. （由于性能问题）不许使用表达式expression，请使用 Javascript 替代。 【建议】在模块的开头和结尾通过注释。 12/* XX模块 开始*//* XX模块 结束*/ http://blog.segmentfault.com/tychio/1190000000531277 CSS 命名规范一、类名 !important全部采用中划线命名法More // 错误More // 正确二、文件名 !importantCSS 文件名统一采用小写字母加下划线的方式，单词之间用中划线(-)分割, 不允许出现大写或者其他符号。正确的如：feedback-send.cssCSS 文件默认情况下的编码必须采用 utf-8（无 bom），其他编码方式均不可！！！（某些专门给中文用户使用的网页中的 CSS 除外） 书写规范一. 不得在 css 中使用 expression !important//由于性能的问题，不准使用 (通过重置触发该 Expression 的 CSS 属性来优化性能，但是也可能有其他问题)，请用 js 代替.header {height:expression(document.documentElement.height)} 五. CSS 选择符组如果是选择符组，则这些选择符(selector)各占一行.style1,.style2 {background:url(xxx.gif) no-repeat ;} 七. 采用属性缩写方式.style {margin:10px 5px; font:normal 12px/1.5 Verdana; color:#F60; } //颜色值能简写的使用简写属性缩写所代表的意思请点击 这里七. 写成一行.yellowish-btn,.yellow-btn{display:inline-block;zoom:1;border:0 none;background:none;}.yellowish-btn:hover,.yellow-btn:hover {text-decoration:none;}.yellowish-btn input,.yellow-btn input, .yellowish-btn button,.yellow-btn button {float:left;width:100%;border:0 none;}.yellowish-btn input, .yellowish-btn button {height:27px;color:#7A2D01;}为了方便区域阅读，属性写成一行。 框架设计原则 在使用中避免不必要的复杂能用 CSS 完成的不动用其他资源手段 有原则的优雅退化加速远古浏览器的消亡, 让现代浏览器更舒适 统一风格让代码和使用方式以同一种机理对外服务 框架实现原则 科学的模块化, 减少不必要的依赖,降低耦合的可能性以模块和模块组的概念提供积木, 不需要使用者做过多的额外编码工作使用独立完整的代码片段, 结构化和规范化所有管辖范围内的编码方式多组合, 少复写HTML 结构设计原则 完整封闭的模块结构语义化和可及性杜绝不必要的冗余, 保留合理结构增强定义灵活性 命名规约 normalize(reset &amp; typegraphy)直接以 HTML 元素作为选择器定义, 无额外 class 或 id 定义.structure(grids &amp; layouts)遵循定义中的命名方式, 无特殊要求.utility 以 util-作为前缀, 标识为工具类, 无视觉样式定义.mod 中各模块以 ui-作为前缀, 标识为与视觉样式相关模块.以_(下划线)作为前缀, 标识为内部未开放/不开放对外服务的部分.模块名尽量让人看到名字就能知道是什么模块. good case: ui-button 模块内部实现结构同样借鉴 YUI3 widget 文档中对于 widget 在结构上的规约, 模块同样存在 bounding box 和 content box, 但会根据模块本身的复杂度将这两层分层模型的规约进行合并, 分解或者省略, 而 bounding box 和 content box 指的都是 DOM 结构上的设计, 并非 CSS 的 class 声明. bounding box bounding box 是指模块最外层的包裹容器的 DOM 结构, 她更多时候承担的是申明独立模块边界的职责, 而她基本不会定义和视觉渲染样式相关的声明. 在 bounding box 上附着模块名 ui-{MOD_NAME}, 而 ui-{MOD_NAME}负责定义的包括: display, position, float在 bounding box 上附着模块的矩阵(在下文中有详细描述)中的主维度状态 ui-{MOD_NAME}-{STATUS}, 例如-system, -customizecontent box content box 是定义具体模块内容的 DOM 结构, 她更多时候承担的是申明模块内部内容包裹的职责. 完整情况下, 在 content box 上附着 ui-{MOD_NAME}-content, 仅用以申明该结构承担具体模块内容在 content box 上附着模块矩阵(在下文中有详细描述)中的次维度类型 ui-{MOD_NAME}-{TYPE}, 例如-error, -success, 她负责具体的样式声明bounding box 和 content box 在模块实现中的具体操作说明 Q: 任何时候都需要定义 bounding box 和 content box 吗? A: bounding box 在任何情况下都需要定义, 因为 bounding box 标示模块的最外围容器.content box 是否定义的情况就相对复杂了, 它是否需要声明, 或者是否需要独立声明是由模块在设计定义中区分出来的维度和一些认为判断性的原则决定的.如果设计定义的分类能够在一个维度进行抽象, 那可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.如果设计定义的分类是多维度的矩阵情况, 而设计定义作用的元素本身在语义结构合理性上判断不应由多层结构构成, 且能够通过复写的方式实现多维度定义的情况下, 可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.如果设计定义的分类是多维度的矩阵情况, 在语义允许的情况下, 并且在使用复写的方式存在比较大的兼容性问题时, 那 content box 这层结构就必须存在, 为了让 bounding box 和 content box 上彼此附着的不同维度进行组合, 从而实现模块复杂多样性的矩阵.就 bounding box 和 content box 在抽象过程中的示例: 多维度必须交叉组合实现定义的多样性example: DPL 中对 feedback 的定义, 根据分析结果(如何分析设计定义就不展开了), 我们就能够建立一个简单的矩阵来描述设计定义中抽象出来的组合矩阵: [ [‘standalone’,’addon’],[‘alert’,’error’,’success’] ] 第一维度我们定义成: standalone(独立使用)和 addon(作为附属) 第二维度我们定义成: alert(警告), error(出错)和 success(成功) ps. 两类维度并没有强制的规约, 仅从语义上描述分类的便利性上做出区分. 只有两个维度互相组合才能描述清楚模块在设计上的分类, 那在具体的 HTML 结构设计上, 就会变成这样: …some contents here bounding box 上附着两种 class: ui-feedback : MOD_NAME 部分, 仅声明当前这个闭合 DOM 文档结构是何种模块. 该声明对应的样式部分仅包含(如有需要): display, position, float 等和模块整体形式位置相关的定义. ui-feedback-addon 或者 ui-feedback-standalone : MOD_NAME-{STATUS}部分, 作为多维度中模块的状态声明, 为多维度的划分方式提供第一级的 namespace. content box 上附着两种 class: ui-feedback-content : 与 ui-feedback 所起作用基本一致, 声明当前容器是 feedback 模块中具体内容的包裹容器, 不做样式定义声明用. ui-feedback-error 或者 ui-feedback-alert 或者 ui-feedback-success : MOD_NAME-{TYPE}部分, 作为多维度中模块的类型声明, 为多维度的划分方式提供第二级的 namespace. 利用状态声明(bounding box 上)和类型声明(content box 上)来进行组合实现多重维度的设计定义: ui-feedback-addon|- ui-feedback-error|- ui-feedback-alert|- ui-feedback-success ui-feedback-standalone|- ui-feedback-error|- ui-feedback-alert|- ui-feedback-success当然也能是: ui-feedback-error|- ui-feedback-addon|- ui-feedback-standalone…多重维度可通过复写实现多样性example: DPL 中对 button 的定义, 照例按照分析结果, 我们得到一个简单的矩阵来描述设计定义中抽象出来的组合矩阵: [ [primary, normal] , [large, medium, small] ] 第一维度我们定义成: primary(主要的)和 normal(普通的) 第二维度我们定义成: large(大号), medium(中号)和 small(小号) 从定义分解上看, 也需要多重维度才能描述清楚模块的分类, 但是对于一个简单的 button 结构来说, 使用两层 DOM 来描述真的不靠谱且没意义. 再设计定义的维度分类之上我们在加入一个语义结构合理性的原则, 那由此, 具体的 HTML 结构设计就会是这样: 在这个例子中 bounding box 依旧坚挺的存在,而对于模型而言, content box 同样存在, 只是在实际情况下隐形了. ps. 考虑到单一结构承担 bounding box 和 content box 时 class 值过长等人性判断介入的信息, 在实际声明中如果出现 content box 声明(注意, 不是 content box 模型)可有可无, 原则性选择不声明 content box 的 class. 单一维度example: DPL 中对 balloon 的定义, 根据设计定义分类, balloon 模块只有一个维度需要描述–箭头出现的位置, 那在 HTML 结构上的设计是: …some contents here在这个例子中, bounding box 中的 STATUS 声明就足够将设计定义中的维度表达清楚了, 那content box的声明就没有为多维度构建可组合的职责了, 当然它可以继续充当其他职责, 比如(1)表达模块内部内容或(2)区分与内容无关的区块. 用balloon来举例, 在目前的实现中: balloon top left 在该示例中同样存在ui-balloon-content的申明, 在结构上和上文中的ui-feedback-content很类似, 但是在balloon中更多承担的是区分在balloon内部内容和balloon的指向性箭头结构, 让其在语义化和操作便利性上更加合理. 对于某些特殊场景下需要的模块属性example : DPL 中对 button 的定义, 还是用 button 来举例, button 除了在上文中具备的二维分类外, 还有一个特殊场景 disabled(禁用), 在模块多维度组合的抽象结构, disable 是和其他两个维度处于同等维度上, 但是在实现上基本可以用复写的方式完成, 以减少因为组合的维度增加导致代码组织上的大量重定义. 对于复写场景的编码技巧这里阐述的是一种小技巧, 在出现.class-a.class-b 声明的场景时由于需要照顾到低级浏览器(shit!)的兼容性问题, 要想办法让在高级浏览器中能够工作的多 class 声明的方式同样在低级浏览器中同样生效, 运气好的话可以直接用 class-b 的声明完全复写成想要的实现, 但是遇到 class-b 同样也要单独服务或者需要和其他一个命名空间配合服务(比如.class-c.class-b)的时候, 这样的情况运气就用完了. 好吧, 只能在有限的条件下将 class-a 和 class-c 这两个命名空间区分开, 比方, 在.class-a.class-b 的前面加个 p…这只能小范围解决问题, 无法杜绝问题的发生, 认命吧, 骚年! 给一些命名后缀的建议对于模块的分类维度, 在这里给出一些常见的命名建议, 省的大家在写模块时抓破头皮. 状态(STATUS) system / customizestandalone / addonhorizontal / verticalfrontend / backendwrap / separatenormal / primary类型(TYPE) error / alert / successsmall / medium / largeblock / nonblock属性(ATTRIBUTE) disabled / readonlycurrent / activefixed / locked]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript编码规范]]></title>
    <url>%2F2014%2F06%2F01%2Fjavascript-code-guide%2F</url>
    <content type="text"><![CDATA[1 变量 如非必要，请不要使用全局变量；局部变量应该尽可能缩小其作用域。 声明全局变量必须使用window.前缀；声明局部变量必须使用var关键字。比如 123456(function() &#123; // 局部变量 var config = &#123;&#125;; // 全局变量 window.global = &#123;&#125;;&#125;)(); 同时声明多个变量时，每个变量独立申明。 1234// 好的做法var var1 = 1;var var2 = 'string';var var3 = 3; 以前我们经常看到以下写法，以下做法会导致在末尾新增变量声明或者删除第一个变量声明时不方便。 1234// 不好的做法var var1 = 1, var2 = 'string', var3 = 3; 鼓励延迟初始化 123456```1. 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如：```jsvar isInited = false; 例外：在循环体内可以使用 i, j, k 等无意义但是被广泛使用的变量。 2 常量 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如Math的常量PI,SQRT1_2等等。 1var SECONDS_IN_A_DAY = 60 * 60 * 24; 3 语句3.1 行 语句必须以分号结束。 每一行要控制在 120 字符以内。 3.2 空格 数值操作符(如, +/-/*/% 等)两边留空; 赋值操作符/等价判断符两边留一空格; for 循环条件中, 分号后留一空格; 变量声明语句, 数组值, 对象值及函数参数值中的逗号后留一空格; 行尾不要有空格; 逗号和冒号后一定要跟空格; 点号前后不要出现空格; 函数名末尾和左括号之间不要出现空格; 3.3 空行 函数与函数声明之间，加一空行 逻辑上独立的代码片段之间，加一空行。 3.4 缩进 缩进使用 2 个空格 3.5 小括号 if/else if/while/for条件表达式必须有小括号; 一元操作符(如 delete, typeof, void)或在某些关键词(如return, throw, case, new) 之后, 不要使用括号; 3.6 大括号 if/else if/else/while/for代码块中必须要有{}。例外：函数体顶部出现的某中条件下函数直接返回的情况：if(typeof arg !== &#39;string&#39;) return false;，这时可以省略大括号并且将条件表达式和代码块写在同一行中。 3.7 内置对象 禁止增加，删除或修改内置对象的方法，除非是 polyfill（在旧浏览器上实现最新的规范）。 3.8 with 禁止使用with，除非用于接续序列化字符串。 3.9 使用 Array/Object 直接量 尽量使用使用 Array/Object 直接量，避免使用 Array/Object 构造器 3.10 字符串 字符串应使用单引号。 多行字符串应该使用+或者Array.prototype.join拼接字符串，避免使用\拼接。 4 注释4.1 注释格式 行级注释// comment主要用与代码行或代码片段 块状注释/* comment */主要用于函数。 1234567/* * @desc 记忆函数，对于耗时的运算，运算一次以后就讲结果保存起来，下次就直接返回结果。 * @param &#123;function&#125; func 运算非常耗时的函数。 * @param &#123;object&#125; thisObject func的主体对象 * @param &#123;function&#125; serialize 参数序列化函数，将参数序列化为一个字符串。 */function memorize(func, thisObject, serialize) &#123;&#125; 4.2 注释书写原则 在写注释之前，看看是否能够通过修改方法名，函数名让其变得见名知意，从而不需要注释。 注释应该记录代码不能明显体现出来的思路或你对代码的评价。 注释和代码一样，同样会占用屏幕空间，同样会分散阅读者的注意力，所以请保持言简意赅。 修改代码的同时，请修改注释以保证注释的有效性。 4.3 注释标记 TODO 还没有完成的逻辑 FIXME 有错误的逻辑 5 函数 函数行数不得超过 40 行，否则考虑拆分成小的函数。 函数体内变量声明应尽可能集中在顶部。 不要在块作用域中声明函数不要写成: 123if (x) &#123; function foo() &#123;&#125;&#125; 虽然有很多 JS 引擎都支持块做域内声明函数，但它不是 ECMAScript 规范(见ECMA-262, 第 13 和 14 条)。各个浏览器的实现可能不兼容, 也可能与未来的 ECMAScript 草案相违背。ECMAScript 只允许在脚本的根语句或函数中声明函数，如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量: 123if (x) &#123; var foo = function() &#123;&#125;;&#125; 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如： 123function returnTrue() &#123; return true;&#125; Getter/Setter 命名这里单独说明 Getter/Setter 命名规范，一般情况下不需要使用 Getter/Setter 方法，直接暴露相应地对象属性即可。如确有必要，请使用 getXxx 和 setXxx 命名，对于 boolean 值，可以使用 isXxx/hasXxx/canDoXxx 等命名。 6 模块 建议按照 CMD 或 AMD 规范实现模块，并使用 seajs 或 requirejs 等库加载或管理模块。 123456define(function(require, exports, module) &#123; var $ = require('$'); exports.init = function() &#123; // do something &#125;;&#125;); 7 文件 命名规范：命名应能表达该文件的作用。全部小写，单词以连字符分隔，比如category-manager.js。 编码规范：统一使用 UTF-8（无 BOM）格式。 8 HTML，CSS 和 Javascript HTML 中引用 javascript 文件时，建议去掉 type 属性。只有当 script 标签存放的不是 javascript 时才需要特别声明。 123456789&lt;script src="path/to/js.js"&gt;&lt;/script&gt;&lt;script&gt; $(function() &#123; // do something &#125;);&lt;/script&gt;&lt;script type="text/template"&gt; &lt;div&gt;&#123;i18n.noData&#125;&lt;/div&gt;&lt;/script&gt; ##终极条款 在修改别人的代码时，应该先学习别人的编码规范，并遵守该规范，如果有的话。 ##参考 Google JavaScript Style Guidehttp://codeguide.bootcss.com/]]></content>
  </entry>
  <entry>
    <title><![CDATA[讨论一例交互--常用类目]]></title>
    <url>%2F2014%2F05%2F22%2Fhow-to-select-category%2F</url>
    <content type="text"><![CDATA[问题在我们的网站后台有个很重要的功能，就是让用户发布产品，发布产品之前需要给该产品选择一个类目。类目的选择有以下三种方式。 1.直接浏览类目树操作方法：选择次级类目……依次类推下去，最多有四级类目。 2.通过关键字搜索操作方法：在“请输入产品关键字”之后的输入框中输入关键字后，点击搜索按钮就可以看到相应类目。 3.常用类目选择为了用户操作遍历，我们提供了更好用的功能，常用类目列表。我们网站的客户是外贸企业，他们的产品类型一般比较单调，比如一般不会有一个企业既卖大型机械，又卖 MP3，所以一个客户的类目也就那么几种，并且越是常用的类目越是靠前，很容易在常用列表中找到。操作方法：点击“您经常使用的类目”Tab，然后选择一个常用类目。 以上三种方法都介绍完了，请你猜一猜有多少用户选择了方法 1（浏览），多少用户选择了方法 2（搜索），又有多少用户选择了方法 3（常用类目）。如果你是用户，你会使用那种方法呢？ 针对该问题我进行了 Google Analytics 打点，得到如下表格。 从表格中可以看出。50%的用户发现搜索起来更快更容易找到自己想要的类目，有 14%的用户不负我们网站的苦衷，使用常用类目快速找到其想要的类目，但是仍然有 36%的用户选择直接浏览器类目，不厌其烦地一级一级选择类目。这个数据让我大失所望，我一直认为应该由更多的用户选择常用类目。 失望归失望，我们还是要分析问题，解决问题。 分析1.常用类目过于隐蔽由于页面上要显示的内容很多，而页面就那么大一块地方，所以我们就需要让内容折叠起来，这时候 Tab 作为一种很好的展现方式，被大多数网站所使用，但是不得不说，用户为了看到 Tab 中隐藏的内容，需要用户将鼠标移动到相应 Tab 头上，甚至需要多一次点击，比起默认显示的内容，多了一个操作步骤，这些都是用户需要付出的操作成本。另外一个问题，就是当初我们实现扁平化设计以及简约的网站风格，将Tab 头的背景色调的很淡。如果用户不仔细看都看不到还不到“您经常使用的类目”这几个字，即使看到了，还不一定知道这是 Tab 头，还可以点击，其背后还有一个桃花源。 关于操作步骤，在《点石成金 访客之上的网页设计秘笈》（也就《别让我思考》）一书中，作者也强调这个问题，比如作者就十分痛恨为了节省空间，使用 Select 下拉框的行为。他认为下拉框具有以下缺陷，① 用户必须点击下拉框才能看到其所有选项，多了一个操作 ② 当选项过多时，很难看清楚，很容易选错。即使设计师意识到这一点，想为其设置更加友好优美的样式，也很难，因为在很多浏览器其样式不可更改或者不能完全更改，等等。 2.首次使用网站时，常用类目列表为空当用户第一次进入该网站时，假如说他注意到了还有常用类目这一项，他可能会点进去看个究竟，但是进去之后却发现空空如也，没有我想要的东西，用户失望地回到 Tab 的第一页，他也不知道该用什么关键字来搜索他想要的类目，只能一级一级地找寻，一级一级的选择，就这样该用户一直延续这个习惯。 我们的网站在设计的时候还是犯了一个错误，在新用户第一次进入网站，还没有发布任何产品，系统也不为其生成常用类目的时候，仍然在页面上显示了这样一个 Tab，用户点进去什么也看不到，就可能形成一种意识，这里没有任何东西，并有可能以后再也不会点击这个 Tab 了。 3.常用类目使用 Iframe 加载使用 iframe 加载较慢，部分用户可能因为无法忍受又多一次加载过程，而放弃。 以上只是结合 GA 打点结果，针对常用类目做的一些 YY 猜想，不一定准确的，但是在找到更好的办法之前，需要针对以上几点做一个改变，希望更多的用户使用搜索类目或者常用类目。做到真正的方便用户，用户第一。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何计算首屏加载时间？]]></title>
    <url>%2F2014%2F05%2F07%2Ffirst-screen%2F</url>
    <content type="text"><![CDATA[在网站开发中，首屏是我们最需要关注的指标之一，它基本代表着用户眼中的网站加载时间。但是如何衡量它呢？ 在我们公司有这样的一种做法，将以下代码放入需要首屏最后一个元素后面 123456789&lt;script type="text/javascript"&gt; /* &lt;![CDATA[ */ PAGE_TIMING.firstScreenImage = new Image(); PAGE_TIMING.firstScreenImage.onload = function() &#123; PAGE_TIMING.firstScreen = new Date().getTime(); &#125;; PAGE_TIMING.firstScreenImage.src = 'http://sample.com/wimg/monitor/first-screen.png'; /* ]]&gt; */&lt;/script&gt; 其中first-screen.png是用了缓存。我们将PAGE_TIMING.firstScreen作为首屏加载时间，这样也只是一个近似时间。不知道各位看官你们是如何处理的呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[IE6，7，8(Q)中同一元素重复定义的style属性会被合并]]></title>
    <url>%2F2014%2F05%2F06%2FIE678-muti-style-attribute%2F</url>
    <content type="text"><![CDATA[这个问题发生了有段时间了，现在把他记下来，一般人不会这么做，也不会遇到这种问题。但是你还是不能阻止有人不小心这么做了。出了问题就要解决，谁让咱是开发呢？ 某次项目发布前，测试同事报出 Bug：产品编辑页面原本有的产品分组输入框不见了。 翻出我们的 VM 文件，代码中 #if 等是 velocity 语法。代码如下： 123456&lt;div id="productTeamSelect" class="ui-form-item" #if(!$webProductPolicy.canDisplayGroupName)style="display:none;" #end&gt;&lt;/div&gt; 既然是该 Div 不显示看了吗？那么我只需要打印下$webProductPolicy.canDisplayGroupName的值即可，该字段表示用户是否可以进行产品分组。如果其值是false，那么该用户不可以进行产品分组，就不显示。否则显示分组。通过打印发现其值为false，表示该用户不可以进行产品分组。那么不显示就是正常的。查看 Javascript 代码也发现：控制产品分组元素是否显示只出现在两个地方，但是都在 Click 事件回调中，并不会在加载页面之后就执行。所以不显示就是因为后端传来的值$webProductPolicy.canDisplayGroupName为false导致，交给后端同事处理。 很快后端同事给出了回复，他们没有修改任何有关于此的代码，并且提出线上$webProductPolicy.canDisplayGroupName的值也同样为false，但是线上却显示了产品分组元素，该产品已经下架，不能分组，也符合业务需求，所以后端认为当前线上显示了分组是错误的，而现在却是意外地改正了。 此时已经证明前端和后端都没有错误，而是当前线上代码有问题。线上代码是这样的： 1234567&lt;div id="productTeamSelect" class="productTeamSelect" style="float:left;" #if(!$webProductPolicy.canDisplayGroupName)style="display:none;" #end&gt;&lt;/div&gt; 生成的页面源代码是： 1&lt;div id="productTeamSelect" class="productTeamSelect" style="float:left;" style="display:none;"&gt;&lt;/div&gt; 没有什么不对啊？display属性被设置为none，本不该显示的啊？为什么显示了呢？ 只好通过window.getComputedStyle方法获取display属性值，看看浏览器是解析这段 HTML 的。实验发现display属性值竟然是block。奇怪了，为什么第二个 style 没有生效，难道是因为最近刚刚修改的 document type 造成的。然后我编写了两个测试页面，他们都有一个 DIV 元素，且都有两个 style 属性。唯一不同的是 document type，分别是 HTML5 的 document type：&lt;!DOCTYPE html&gt;，和旧的 document type 声明 1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; 测试发现，结果一致，后定义的 style 都没有生效。这个有点出乎我的意料，虽然之前没有看到规范中如何定义，但是潜意识中认为应该是两个 style 会整合在一起，并且在后定义覆盖先定义的。难道我的认识有误？ 谷歌了一下，发现一篇文章：IE6 IE7 IE8(Q) 中同一元素重复定义的 style 属性会被合并，文章介绍了 IE6-8 的这个 Bug，并且指出“不要依赖 IE 的容错机制，避免重复定义 HTML 元素属性”。这个知识点比较冷，并且一般人都不会这么写，也不会遇到这个问题。现在回头看时才注意到通过 Firefox 产看源代码时style=&quot;display:none;&quot;是被红色标注的。Firefox 意在提示我们第二个 style 属性没有生效，可惜这个重要信息被忽略了。 下架产品在 IE6，7 下不能分组，而在 IE8 和其他浏览器中却可以进行分组，为什么该代码的作者没有发现该问题呢，就不得而知了。难道该代码是很多年前的，那时候还没有 IE8+，Firefox 还不够流行，chrome 还没有诞生？ 锁定根本原因就好办了，要么是继续保持网站内部逻辑，下架产品不能分组，即产品分组输入框不可见，修复线上故障。要么是取消以前的网站内部逻辑，下架产品也可以进行分组，这样后端输出的$webProductPolicy.canDisplayGroupName值改成true即可，最终效果保持和线上一致。最终由 PD 拍板决定采用后一个方法，修改网站内部逻辑，保持对最终用户的逻辑不变，下架产品也能进行分组。 以上 Bug 是解决了，但是我们应该吸取教训，经常梳理业务逻辑，经常审核代码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网站使用条款的处理]]></title>
    <url>%2F2014%2F05%2F05%2Fterms-of-use%2F</url>
    <content type="text"><![CDATA[网站使用条款，Terms Of Use，也有简称为网规（以下都简称网规）的。前段时间有个需求，就是在用户访问量很大的页面的一个页面添加网规，当时因为时间问题就直接放在动态页面中了，最近开始考虑优化该页面时，才开始考虑如何优化网规。 我们知道网规有如下特点：① 文本量大，② 非常稳定不易变，并且可能③ 出现在多个页面，且有可能会网站下次改版时就使用链接，点击链接才能看到网规。还有一个很重要的特点，就是这东西④ 很重要但是没人愿意看。最为常见的网规出现在注册页面，敢问你是不是从来不看网规就直接划勾了？针对以上 ①② 两个特点，网规适合使用浏览器缓存，这样可以减少网络传输内容，提高页面加载性能。针对以上第 ③ 个特点，网规适合使用独立完成，多个宿主页面可以方便地通用 iframe 加载网规，并且宿主页面和网规样式上互不影响。针对第 ④ 个特点，网规适合延时加载，等到必须要用户看的时候才显示出来，要么以链接的形式出现，感兴趣的用户点击查看；或者放在页面靠近底部的地方，让网规占用首屏实在是浪费。 根据以上对网规的特点分析得知，处理网规最好的办法是：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。那么怎么处理呢？如果放在静态资源项目（该项目包含 js，css，image 等静态资源）或应用（后端）中，都需要有个发布过程，并且网规页面也会引用静态资源项目中的某些基础样式文件，如果放在静态资源项目中，不好处理被引用样式文件的版本。后来想到公司内部有个 CMS 系统叫做 TMS，它可以创建独立 php 页面。 将网规放进 TMS 系统以后，发现了一个并不奇怪但出于预料的问题，该系统对一些词汇做了限制，比如“性虐待”，后来通过&lt;script&gt;document.write(&#39;性&#39; + &#39;虐&#39; + &#39;待&#39;)；&lt;/script&gt;或者使用 php 语法&lt;?php echo &#39;性&#39;.&#39;虐&#39;.&#39;待&#39;; ?&gt;两中方法解决。还有一个预料之内的问题，就是如何设置浏览器缓存，最开始以为 TMS 系统应该对此有一套处理方法的，但是后来通过想 TMS 负责人咨询才发现没有，需要手动写 php 代码。好吧，那么我就写 php 代码吧。 123456789&lt;?php $etag = 'v1'; if ($_SERVER['HTTP_IF_NONE_MATCH'] == $etag)&#123; header('Etag:'.$etag, true, 304); exit; &#125;else&#123; header('Etag:'.$etag); &#125;?&gt; 在以上代码中，我们使用 Etag/If-None-Match 这对响应头/请求头来做缓存处理，在文档没有变化的情况下，设置 HTTP Code 304，告诉浏览器使用缓存，而不用每次都给用户发一次网规文档。一旦网规文档有任何修改，都必须修改$etag变量的值，否则客户浏览器仍然使用缓存看不到最新网规。不过呢，虽然减少了响应内容，但是每次还是需要一个完整的 HTTP 请求和响应（虽然该响应只有 header，没有 body）。所以啊，我们还需要一个很常用的响应头Cache-Control: max-age=86400来告诉浏览器我给你的文档很新很稳定，在以后的这一天内你都不用再来找我了。Cache-Control是 HTTP1.1 规范中的，为了兼容性，可以使用Expires响应头作为 fallback 方案。由于Expires响应头使用的绝对时间，用来告诉浏览器我给你的文档有效期是某某时候，在那时之前你都不用来找我了。所以如果用户设备日期时间有较大偏差的话，Expires可能会失效。Cache-Control响应头使用相对时间，就不会这个问题，这也是为什么在 HTTP1.1 中增加了Cache-Control响应头的原因之一。废话不多说，上代码。 123456789101112&lt;?php $etag = 'v1'; $maxAge = 3600 * 24; // 86400s, 1 day if ($_SERVER['HTTP_IF_NONE_MATCH'] == $etag)&#123; header('Etag:'.$etag, true, 304); exit; &#125;else&#123; header('Etag:'.$etag); header('Cache-Control: max-age=' . $maxAge); header('Expires: ' .gmdate('D, d M Y H:i:s', time()+$maxAge). ' GMT'); &#125;?&gt; 最后一点，如果可能，延迟加载网规文档。这点很简单，就不多讲了。 至此，我们就完成了针对网规的优化：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Backbone中的几个小问题]]></title>
    <url>%2F2014%2F05%2F04%2Fbackbone-problems%2F</url>
    <content type="text"><![CDATA[Backbone 用起来还行，但是在某些方面还是有不方便之处。比如， 需要手动将数据填充到 DOM 中，需要手动从 DOM 中抽取数据 1234// 手动填充数据this.$el.html(this.template(this.model.toJSON()));// 手动收集用户输入的表单数据var arr = $('form-id').serializeArray(); 需要重复绑定事件，由于其模板引擎是基于字符串的，所以在 model 更新时，需要替换掉相应 DOM 树，而不是在原有 DOM 上更新，每次 DOM 替换后，都需要重复绑定事件。当然你可以选择使用事件代理，但是并不是什么时候都可以使用事件代理的，比如你依赖的组件不支持事件代理，这时候就很郁闷啦。 同样由于其模板引擎是基于字符串的，所以如果你监听了 model 的 change 事件，那么你需要注意，你需要尽可能的批量更新 model，否则会导致连续的多次大块 DOM 替换。 123456789// 不好，可能导致多次大块DOM渲染model.set(&#123; name: 'Name' &#125;);model.set(&#123; age: 28 &#125;);// 好，只有一次DOM渲染。model.set(&#123; name: 'Name', age: 28,&#125;); 除了这一点外，还需要考虑缩小监听范围，比如 12// 仅仅监听isShown字段是否被修改，忽略其他字段model.bind('change:isShown', this.display); 今天又遇到一个问题，先说一下背景吧。最近网站由于故障频发，要求后端必须灰度发布，就是首先发布到线上的一台机器，测试，如果没有问题再发布到所有机器上，否则回滚；而且前端和后端是分别发布，并且前端没有灰度发布。这样一来，前端需要同时兼容后端的新旧两个版本。所以前端发布时需要测试两种情况：新后端+新前端，旧后端+新前端。在新后端+新前端测试通过后，测试旧后端+新前端时，发现了ReferenceError: XXX is not defined这样的错误。根据 Chrome 控制台提供的信息可以看到，是由于Backbone 的模板引擎是通过 with 实现的。我们知道 with 有一个问题：在 with 作用域内引用对象上不存在的属性，则会报出 ReferenceError 错误。比如： 12345var obj = &#123; a: 1 &#125;;with (obj) &#123; console.log(a); // OK console.log(unExistedAttr); // ReferenceError: unExistedAttr is not defined&#125; 在新版本中某个 Ajax 请求中增加一个字段，假定为 f，在前端模板中通过&lt;% if(f){ %&gt; ... &lt;% } %&gt;引用了该字段，没有任何问题，而在旧版本后端中没有该字段，就会报ReferenceError: f is not defined错误。 针对这个问题，一般可以给 model 设置默认属性值，但是总归还是比较麻烦的。也幸好 Chrome 的 Debug 能力很强，通过点击错误就看到了编译后的模板方法。如果使用 Firefox 浏览器，只能看到报了ReferenceError: f is not defined，恐怕你还很难猜测到是模板里引用了该变量导致的呢。 顺便说一下，我不太喜欢 backbone 模板引擎的语法的，使用&lt;% %&gt;看起来和 html 标签太像，看起来总是觉得不太舒服。还是比较喜欢 doT 的语法风格， 12&lt;div&gt;Hi &#123;&#123;=it.name&#125;&#125;!&lt;/div&gt;&lt;div&gt;&#123;&#123;=it.age || ''&#125;&#125;&lt;/div&gt; 在编辑器中使用了语法高亮之后，看起来好整洁。 以上就是我使用 Backbone 遇到的一些问题，以后有新问题再补充。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】优秀的用户界面设计（二）]]></title>
    <url>%2F2013%2F11%2F23%2FGood-UI-2%2F</url>
    <content type="text"><![CDATA[译者注：几个月之前翻译了Good UI前 20 个最佳实践【翻译】优秀的用户界面设计。最近又看到有了更多的最佳实践。现在翻译出来，与您分享。 渐变而不是立即变化 Try Transitions instead of showing changes instantly. Interface elements often appear, hide, move, shift, and resize as users do their thing. As elements respond to our interactions, it sometimes is a little easier to comprehend what just happened when we sprinkle in the element of time. A built in intentional delay in the form of an animation or transition, respects cognition and gives people the required time to understand a change in size or position. Keep in mind of course that as we start increasing the duration of such transitions beyond 0.5 seconds, there will be situations where people might start feeling the pain. For those who just wish to get things done quickly, too long of a delay of course can be a burden.]]></content>
  </entry>
  <entry>
    <title><![CDATA[npm install时连接超时的解决办法]]></title>
    <url>%2F2013%2F10%2F11%2FConnect-Timeout-When-Npm-Install%2F</url>
    <content type="text"><![CDATA[今天在电脑上安装 node-inspector，用于在浏览器中调试 node。但是却遇到了如下连接超时错误。 1234567sudo npm install -g node-inspectornpm http GET https://registry.npmjs.org/node-inspectornpm http GET https://registry.npmjs.org/node-inspectornpm http GET https://registry.npmjs.org/node-inspectornpm ERR! Error: connect ETIMEDOUTnpm ERR! at errnoException (net.js:863:11)... 想到可能是伟大的长城在作怪，所以首先想到的是加上代理，这里使用的是 Goagent。因为下载过程中使用的 https 协议，所以设置的应该是 https-proxy。设置方法如下： 1npm config set https-proxy http://127.0.0.1:8087 依然失败，报错如下： 123456sudo npm install -g node-inspectorGET https://registry.npmjs.org/node-inspectornpm http GET https://registry.npmjs.org/node-inspectornpm http GET https://registry.npmjs.org/node-inspectornpm ERR! Error: UNABLE_TO_VERIFY_LEAF_SIGNATUREnpm ERR! at SecurePair.&lt;anonymous&gt; (tls.js:1271:32) 根据以上错误，猜测应该是代理出现问题，网站证书无法验证。既然 https 协议走不通，那么是否可以使用 http 协议呢？有些网站都同时支持这两种协议，比如 cdn.staticfile.org，cdnjs.com 等 CDN 服务。向谷哥寻求帮忙才找到了答案，可以使用如下命令设置： 1npm config set registry &quot;http://registry.npmjs.org/&quot; 还是失败，报错如下： 123456sudo npm install -g node-inspectornpm http GET http://registry.npmjs.org/node-inspectornpm http GET http://registry.npmjs.org/node-inspectornpm http GET http://registry.npmjs.org/node-inspectornpm ERR! Error: connect ETIMEDOUTnpm ERR! at errnoException (net.js:863:11) 长城真是密不透风啊！为 http 设置代理： 1npm config set proxy http://127.0.0.1:8087 然后终于看到亲切的200字眼。 1234567sudo npm install -g node-inspectornpm http GET http://registry.npmjs.org/node-inspectornpm http 200 http://registry.npmjs.org/node-inspectornpm http GET http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgznpm http 200 http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgznpm http GET http://registry.npmjs.org/strong-data-urinpm http GET http://registry.npmjs.org/async 以上就是今天遇到的通过npm install安装 node 包时遇到的问题以及解决过程。在遇到这些问题之前，还不知道npm config命令。所以在这里简单复习一下。在控制台中输入npm config：得到如下结果： 12345678910npm confignpm ERR! Usage:npm ERR! npm config set &lt;key&gt; &lt;value&gt;npm ERR! npm config get [&lt;key&gt;]npm ERR! npm config delete &lt;key&gt;npm ERR! npm config listnpm ERR! npm config editnpm ERR! npm set &lt;key&gt; &lt;value&gt;npm ERR! npm get [&lt;key&gt;]npm ERR! not ok code 0 npm config命令的使用方法都列出来了。如果想看到完全的信息，还是使用npm help config命令吧。这个命令会通过vim打开一个npm config命令的说明书，非常详尽，包括所有命令，各种类型的配置的优先级（比如命令行参数--proxy http://server:port优先级最高，文章中我们使用的方法是修改用户配置，优先级与命令行参数相比较低。）以及所有的配置选项（比如文章中我们修改了 proxy，https-proxy 和 registry.）。说明书篇幅很长，不再赘述。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP缓存头部入门指南]]></title>
    <url>%2F2013%2F09%2F28%2FA-Beginner's-Guide-to-HTTP-Cache-Headers%2F</url>
    <content type="text"><![CDATA[本文结合 CDN 行为，探索 HTTP 缓存头部。如果你正要了解怎么书写缓存头部以适应现代 WEB，或者你很好奇你周围的人都在谈论什么，那么你可以阅读本文。 如果你已经了解了缓存头部的好处，并且想了解更多，那么我推荐你去查看W3 文档。 缓存头部能做什么？简单地说，缓存能让你将 Web 资源保存在通往用户浏览器的每一个远程节点。当然浏览器本身也维护着一个私有缓存，它让浏览器不用每次都从服务器获取资源。 配置缓存，对于节省站点流量是非常重要的，一个经济的站点可以减少带宽支出，或者希望保持 Web 专业开发者的声誉，你必须了解缓存的作用以及如何使用。 对于这些资源文件，比如你公司的 logo，站点的 favicon，以及那些核心的各个请求之间通用的 CSS，告诉浏览器将此文件的备份保存一段时间，是非常安全的。如果你的用户是一个后座上的小孩，总是不停的问：“我们到了吗？”，你很可能会告诉他，“没有，20 分钟以后才到，请不要再问了。” 通过减少对服务器请求的数量，你可以处理更多的请求，用户也可以享受更快的浏览体验。一般来讲，像图片，Javascript 脚本，样式表等资源文件都可以大量使用缓存，但是像 dashboard，论坛等动态产生的内容，就很少能使用缓存。如果你关注性能，可以将动态产生的内容和静态的资源文件分离，前者使用 Ajax 获取，后者则可以大量使用缓存。 客户端和 CDN最初，缓存设置都是针对客户端浏览器的，所以我们应该适当地考虑客户端以及它是如何保存资源的。但是，进来伴随着 CDN 的出现，在网络传输的中间节点上如何做好缓存成为一个重大关切。 什么是 CDN？如果你不愿意查看 Wiki 的话，我在这里给你一个简单的说明。本质上，CDN 就是一组服务器（注意是一组），它位于用户和站点之间。每一个服务器都会根据你设定的缓存头部缓存你站点的内容。 配置适当的话，CDM 会使用最快的（一般是距离用户最近的）服务器向用户传递内容。另外，CDN 起到站点和用户之间的缓冲的作用。我们最关心的数字是缓存命中率，它描述了 CDN 不需要向服务器请求就可以直接响应的请求的百分比。取决于流量和架构，它可以高达 90%。即使没有这么高，你也会受益良多。注意，低频率的请求会被更多地传给服务器，所以命中率只有和缓存次数和平均负载放在一起时才有意义。如果你配置了缓存，但是缓存头部设置不当，很可能导致 这是一个 CDN 网络中的基本的数据流图。你的 Web 服务器提供内容给 CDN 中间服务器，而 CDN 中间服务器分布在全球不同地区。懒一点的话，可以在这里画一片云。 Beyond their intended use for caching, CDNs also have a pleasant side-effect; provided you’re dealing with a website, or a particularly well-crafted web application, in the event that your servers experience a momentary outage, your CDN may be able to buffer the experience for your end users, ensuring they never even notice. The Basic Headers So, you know what a CDN is, and you know you want to configure your response headers to make use of them. Most web servers make it trivial to set response headers, so I’ll leave it to you, Google, and the man pages to figure that part out. For now, let’s move onto what headers you should care about. cache-control If there were a default super-header for caching behavior, this would be it. Typically you will see a string of settings for this header along the lines of: cache-control: private, max-age=0, no-cacheThese settings are called cache response directives, and are as follows: private | publicEssentially they let intermediary caches know that a given response is specific to the end user and should not be cached. Do not make the mistake of assuming that this in any way provides you with some kind of security or privacy: Keep using SSL for that. no-cacheWhen used alone, this guy lets you specify that caches should revalidate this resource every time, typically using the “etag” header outlined below. The fun bit comes when you specify a field name after the no-cache directive, which lets caches know that you can cache the response, provided that the named fields are stripped out; cookies would be a good example of why you might want to do this. I should note that older User Agents won’t respect this trick, so you shouldn’t depend on it too much. no-storeThis guy lets you specify that caches should not store this response. I know that may be surprising given the name, but there it is. Actually, if the cache in question is following the rules, it will also ensure that no part of the request is stored either. “no-store” was designed with sensitive information requirements in mind, and so is kind of like the G-Man of cache headers. max-ageTraditionally, you would let caches know when an asset is expired by using the aptly-named “expires” header, discussed below. However, if you want to be more explicit, you may set a max-age, in seconds, which will override the expires header. Further reasons to use this directive are discussed below under the Caveats section. s-maxageUsing our keen deductive skills, we can see some similarities between this header and the last one. “s-“ is for shared, as in “shared cache”, as in CDN. These directives are explicitly for CDNs and other intermediary caches. When present, this directive overrides both the max-age and expires header, and most well behaved CDNs will obey it. must-revalidateThis one is fun, although not applicable to most of us. For the sake of completeness, and in case your dev-team has some kind of trivia night where free beer is involved, we’ll discuss it. Essentially, if your responses include this directive, you are telling the cache that it needs to revalidate a cached asset on any subsequent request, and that it may not, under any circumstance, serve stale content (which is sometimes a desired behaviour). Of course, I say “under any circumstances”, but what I really mean is that there’s a big fat asterisk next to that claim. If your users are under “severe connectivity constraints”, (perhaps they are browsing from low-earth-orbit), then their user agents may serve stale content, provided they pinky-swear to tell their users that they’ve done so. Apparently this directive exists because some protocols require it, typically involving transactions. no-transform“Transform into what?”, you’re surely asking. Some proxies will convert image formats and other documents to improve performance. Presumably this was thought to be a feature that you should have to opt out of. If you don’t like the idea of your CDN making automated guesses about how your content should be encoded or formatted, I suggest including this header. proxy-revalidateEssentially the same as the “must-revalidate” directive, except it’s just for the shared caches. Why didn’t they call it “s-mustrevalidate”? I’m sure there exists a mailing list somewhere where you could find that debate, but for now, just know that like “s-maxage”, this directive is designed for intermediary proxies and not user agents. The idea here is that you validate each end-user only once between the proxy and their agent, but each new user should revalidate back to the server. I suspect if your service requires this feature, you probably already know about it. As always, you should check out the spec for these settings if you need any clarification. expires Back in the day, this was the standard way to specify when an asset expired, and is just a basic date-time stamp. It is still fairly useful for older user agents, which crypto webologists assure us still roam in the uncharted territories. On most modern systems, the “cache-control” headers “max-age” and “s-maxage” will take precedence, but it’s always good practice to set a matching value here for compatibility. Just make sure you format the date correctly, or it will be evaluated as an expired date: Thu, 01 Dec 1983 20:00:00 GMTTry to avoid setting the value to more than one year out as that breaks the specification, (see below for a discussion on cache time settings). etag Short for “entity-tag”, the etag is a unique identifier for the resource being requested, typically comprised of the hash of that resource, or a hash of the timestamp the resource was updated. Basically, this lets a client ask smarter questions of the CDNs, like “give me X if it’s different than the etag I already have.” There’s a neat trick you can do with etags, which is to make them weak validators. This basically tells the user that although they are not the same, the two resources are functionally equivalent. Support for this feature is considered optional though, so you will want to do some testing with your providers, (discussed below). vary Oh wow. This one is fun. The “vary” header is extremely powerful, but can trip up what would otherwise be a simple caching scheme. IE has had issues handling the “vary” header in the past, and at one point, even Chrome was handling this in a funny way. Essentially, “vary” lets the caches know which of the headers to use to figure out if they have a valid cache for a request; if a cache were a giant key-value store, adding “vary” fields appends those values to the key, thus changing which requests are considered valid matches for what exists in the cache. You would commonly set this to something like “Accept-Encoding” to make sure your gzip’ed assets get served where appropriate, saving you all that bandwidth you might otherwise waste. Additionally, setting: vary: User-Agentwill put you in the SEO good-books if you happen to be serving different versions of your HTML/CSS depending on the User-Agent of the request. Google will note the header and have the Googlebot crawl your mobile content as well. pragma Another beast from the days of yore, the “pragma” header does many things, and most of them are honoured by newer implementations. The directive we’re most concerned with is: pragma: no-cachewhich gets interpreted by newer implementations as: cache-control: no-cacheI would not generally recommend worrying about it, but for the sake of completeness, there it is. No new HTTP directives will be defined for “pragma” going forward. Some Caveats Now that we’ve gotten some of the standard and expected behaviors out of the way, we should probably mention that not every CDN or User Agent will behave according to the specification, which I’m sure is not news to anyone familiar with browser compatibility issues. For this reason, it is a good idea to test your services before launching a live resource to make sure the behavior you get is what you expected; it will save you money. Also, you may have noted that a lot of the headers seem to be either duplicated or overlapping. Some of this is because there are subtle differences between the different methods, and also because the web is shifting over from HTTP/1.0 to HTTP/1.1, which uses the “cache-control” much more heavily. Generally it is safe to set both and let the CDNs and User Agents figure out which one they care to listen to. Compression Remember that “Accept-Encoding” example for the “vary” header we talked about? That’s your new best friend if you intend to serve compressed content, which I hope you do to increase performance and save on bandwidth. CDN providers that get a request with “gzip” as an accepted encoding are expected to request the compressed asset from the origin server, or to serve a cached version of that compressed asset. Historically, this has been a sticking point for some CDNs, and for people wishing to use something like S3 to serve their files, although modern CDNs are able to perform the compression operation themselves if need be. Things to watch out for when the CDN serves compressed assets is that they’ll often ensure that both uncompressed (AKA identity) and gzip’ed version are in their cache, regardless of which was requested. There is a time delay as they perform that operation, so any testing you do will have to take that delay into account. SSL A CDN is basically a Man-In-The-Middle, meaning you need to think about your HTTPS traffic and how it gets back to your server. Many CDNs will pipe a request for https://somesite.com/asset to your servers as http://somesite.com/asset, so if your server logic depended on that being SSL, either reconsider your logic or ask your CDN to redirect to an HTTPS origin URL. Most CDNs are capable of doing so, with varying degrees of flexibility. But What about Dynamic Content? Generally the rule of thumb for dynamic content, like the HTML files of a WordPress blog, is to set “cache-control: no-cache” and prevent the CDNs or User Agents from storing the asset. For most applications, serving your own dynamic content is probably fine, however if you need to boost performance, read on. Typical Dynamic ContentHTTP/1.1 200 OKServer: ApacheX-Rack-Cache: missETag: “e6811cdbcedf972c5e8105a89f637d39-gzip”Status: 200Content-Type: text/html; charset=utf-8Expires: Mon, 29 Apr 2013 21:44:55 GMTCache-Control: max-age=0, no-cache, no-storePragma: no-cacheDate: Mon, 29 Apr 2013 21:44:55 GMTAn example of a section of a header for dynamic content. Note the missed cache status, and the cache-control directives all set to 0 seconds. Most dynamic content has a shelf-life and is not nearly as volatile as we assume. Things like “Active Users” are probably valid for 10 or 20 seconds, depending on your site. Dashboards that report daily figures could certainly stand to be cached for a few minutes. News feeds could certainly stand to be cached for a while, especially if you remember to set an “etag”. If your site is seeing lots of load, it may be worth trying out a short cache on your dynamic assets. An Analysis of Cache Time So what types of cache times should you consider setting? Again, this will require you to consider things like the rate of traffic to your site, how sizeable your assets are, and how large your cache is, (yes, there are space allocations, so don’t go over them). Additionally, you should consider the main tradeoff: speed and performance vs. control. If you want to update an asset and need the new version to be live immediately, you may run into trouble if you thought a one-year cache time was a good idea, especially if you set that for Users (max-age) and not just CDNs (s-maxage). The longest you can set your headers and still be following the specification is one year, or 31536000 seconds, but this is not a very good idea. That’s like getting a face tattoo; it stays around forever, barring expensive or painful removal surgery, which accurately describes the annoyances of having to trick caches into refetching an asset through name changes or hoping you remembered to correctly set your etag and that your users and CDNs implemented them correctly. If your servers can’t stand to have your CDNs ask once a day if your profile picture has changed you should upgrade your servers. Sane Static Content HeadersHTTP/1.1 200 OKCache-Control: no-transform,public,max-age=300,s-maxage=900Content-Type: text/html; charset=UTF-8Date: Mon, 29 Apr 2013 16:38:15 GMTETag: “bbea5db7e1785119a7f94fdd504c546e”Last-Modified: Sat, 27 Apr 2013 00:44:54 GMTServer: AmazonS3Vary: Accept-EncodingX-Cache: HITA sample of cache settings for a static asset served from S3. Here we see that the cache has been asked to store the asset for 900 seconds rather than the 300 seconds set for User Agents. Also note the “x-cache: HIT” header, indicating the CDN served the request. There is one exception to the “thou-shalt-not-set-one-year-headers” commandment, or more accurately, there’s a bit of a hack to get around their pitfalls: if you’ve configured your site to generate resource names, you can rename your assets each time you publish a new version. Typically, this will involve an incrementing version number, a date-time stamp, or a hash of the contents, much like an “etag”, being appended to the file name, so that you end up with things like “core.E89A123FFDB…432D687B.css” and the like. It’s not pretty, but really, who cares? Also, this lets you set one-year-headers without worrying about updating your resources. A handy table best explains the cache time trade-off. Assuming a web asset get 500 requests per minute, then the following Hit Ratios are possible for each cache time: Cache time (minutes) Hit Ratio Request to Origin / Hr1 99.8% 605 99.96% 1220 99.99% 360 99.997% 186400 99.9998% &lt;1There. It’s spelt out. What kind of Hit Ratio do you need? Typically 60 seconds to an hour is an ideal trade-off. For pseudo-dynamic content, you can still use CDNs, just start working in the under-60-seconds range, as appropriate for the request. Testing Your CDN So, onto the testing. Always check that the headers are coming through CDNs the way you expect when setting up new services. Typically a CDN will insert some kind of “x-“ header to indicate that it hit, missed, or served expired content. What we’re looking for is a convenient way to look at this and other headers, and to set them on our requests for testing. There are more than a few tools out there to help, though these are the ones I’ve found most handy. Web Inspector Probably the most accessible method, simply right-click on a webpage in Chrome, click Inspect Element, navigate to the Network tab, hit refresh, and click on the HTML asset at the top. If it’s not selected by default, checkout the Headers tab to see all your request and response headers. Chrome also lets you set the user agent you request with, and gives you the option to not use your local cache, which is handy when you’re testing. Charles Proxy et al. Tools like Charles Proxy will let you route traffic through them and manipulate DNS lookups, record headers, and see performance statistics, all in a clean, easy-to-use GUI. These tools are generally more task-specific than the Web Inspector and other browser tools, and generally worth the small licensing fee if you work with web requests in any significant way. cURL Quick, easy, and highly flexible, cURL lets you make web requests directly from the command line and check out the responding headers. Helpful flags include -A for user agents, -b for cookies, -F for form data, -H for setting headers, and -I to request the header only. Very handy for sanity checks, and extremely powerful. hurl.it hurl.it is essentially cURL with a prettier interface, and in a web browser. You’re able to set the headers you pass in to the request, as well as view the full header and body response. Although you don’t quite get the robustness of the command line, it’s still very useful for a quick header examination, and is probably the fastest way to get access to headers if you’re in a hurry. Python and Requests Requests is a great Python package for making web requests, and is useful for quick checks from the REPL, or from slightly more complex scripted checks. Using Requests comes with the added benefit of letting you write a test-suite for your web assets to assert the status of response headers. Notes from the Field and Parting Thoughts So now you’ve made it all the way through our quick guide to cache headers, and you’re eager to get going on setting your own. Excellent. However, now it’s time to put some of this in perspective. Most web servers, like Apache and Nginx, will do a lot of this work for you. Really, the “cache-control” header is the only one you’re going to have to work with. Web browsers are typically set up to cache aggressively to improve user experience, so often you’ll be fighting to prevent caching rather than ensuring it. Generally this means that you set a “/static” path and configure its caching headers to allow caching up to some reasonable interval like 300 seconds. Next, you would ensure that your root path “/” has “cache-control: no-cache” enabled, or better yet route dynamic content straight to your servers and only have “/static” use your CDN. This is a healthy starting point for most purposes. If your hosting bill is astronomical, or you get to use operations cost savings as beer money, then consider tweaking your settings. CDNs will often give you the option of breaking protocol and will cache for whatever period you like, regardless of the headers. They also take liberties with the protocols depending on their interpretation of expected behavior, which is why it’s important to test the headers you get out of your CDN and compare them to your servers. Consider the expected behavior outlined here to be a baseline and keep an eye out for variance. Good luck, and happy caching!]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】图片优化工具]]></title>
    <url>%2F2013%2F09%2F27%2FTools-for-Image-Optimization%2F</url>
    <content type="text"><![CDATA[原文地址 As we saw a few weeks ago, the weight of an average web page is now almost 1.5MB (median ~1MB), with &gt; 50% of this being images. It’s a harsh reminder that many of our pages on the web are still quite fat, a big concern for slower mobile data connections.zipjszip BigQuery calculated medians for a HTTP Archive runBigQuery calculated medians for a HTTP Archive run thanks to Ilya GrigorikThere have been plenty of well documented cases of page weight being heavy, with the Oakley site Brad Frost mentioned in April clocking in at ~ 25MB worth of images alone. Insanity. Just think of this on mobile: slower data, CPU, GPU..and it’s just ONE page. Images are a non-trivial problem to solve because they occasionally need to be high-res, but at the same time small enough to not kill your users mobile data cap. My hope is that srcset will help us improve this long-term. Thankfully Blink, WebKit and soon FF will have it. The page cost of using images on the web is however not a new problem but we’re at least moving beyond blaming scripts as the main culprit. As a reminder, here’s a quote from Adam Sontag who suggested “One less JPG” as a solution to our bickering about framework sizes back in 2012: Tools Where possible, it’s best to try automating image optimization so that it’s a first-class citizen in your build chain. To help, I thought I’d share some of the tools I use for this. As a general rule run lossy optimizers first, then lossless. Most developers forget that optimizers optimize a particular file rather than the image. This means that it doesn’t make sense to optimize an image file and then resize/crop or convert it as any changes to the file will completely undo lossless optimizations and make lossy ones a lot less effective. Grunt tasks Grunt is a fantastic task runner I use daily and there are a number of reliable tasks that can assist with image weight reduction: Recompressing JPG/PNG/GIF to save on bytes:OptiPNG/jpegtran/gifsicle: grunt-contrib-imageminImageOptim-CLI companion: grunt-imageoptimConvert to WebP: grunt-webpSpriting to reduce HTTP requests:grunt-spritefilesgrunt-montagePrescaling (normalization) to avoid excessive image resize/decode work:grunt-imageNormalizegrunt-image-resizeResponsive image generation/handling:Generate multi-resolution images: grunt-responsive-imagesClowncar technique: grunt-clowncarInline images as data URIs (careful as costly on mobile):grunt-image-embedOf course, not everyone uses Grunt so let’s take a look at some individual tools you can use regardless of your tooling choices. Individual tools Some of the image compressions tools I recommend checking out include: PNG:pngcrushoptipngadvpngFor Windows, see pngout and pngwolf.zopfli-png and Pngnq S9 by KornelPNG Quantizerpngquant ~ recommendedpngnqJPG:jpegminijpegcrushjpegoptimjpgtranGIF:gifsicleThe Yeoman team have a Node.js wrapper called node-gifsicle that makes this available as a local dependency on OS X, Linux and Windows in case you’re interested.We have wrappers for optipng, jpegtran, pngquant too. SVGSVGO which has a Grunt task called grunt-svgminSVGCleanerYou may also find that removing EXIF data and unneeded color profile information from images also leads to some gains. List of tools? Argh. What should I use? Image compression expert Kornel Lesiński was kind enough to reach out with some recommendations for what to use based on research and usage of them. If opting for your own tooling chain: For JPEG: JPEGMini – lossy (30-50% reduction)JPEGMini sets the quality of your JPEG to the lowest setting the human eyes can tolerate. It’s quite good at doing this. If you’re unable to use it, consider manually adjusting the quality as low as possible. Be careful though as you shouldn’t just save all JPEGs at “80%”. The quality setting is only a weak approximation and quality that you actually achieve can vary from image to image. JPEGMini doesn’t really have an open-source/CLI equivalent (ImageOptim-CLI scripts it though) but the closest equivalent is adept-jpg-compressor. jpegcrush (same as jpegrescan) is lossless (5-10% reduction), beating jpegoptim in 99% of cases. jpegcrush is a Perl script utilizing jpegtran, so there’s little need to use jpegtran separately.For PNG: There are 3 steps involved in PNG compression: first lossy conversion (50-70% reduction), then search for optimal filters (5-10%), and then optimal gzip (5-30%). pngquant2 provides a competitive filesize and quality compression option for PNG. Windows users can use Tinypng.org which is pngquant2+optipng (and Kraken.io is the same thing again). Note that most “stable” Linux distributions ship pngquant 1.0. This is quite old and offers significantly poorer quality encodes. pngquant is worth using from version 1.6 up.pngnq-s9, pngnq and Photoshop export (if you don’t have alpha) are also decent options worth trying (they’re okay). I would suggest staying away from RIOT, PHP-libgd and if at all possible ImageMagick and IrfanView as they aren’t great at PNG8 and don’t fully support alpha either. cryopng is also worth checking out and (if you have time) pngwolf, which was mentioned earlier. Alternatively Optipng or pngcrush.advpng probably has the best speed/compression ratio and I believe that’s what punypng and Kraken.io use too. If you have time, then Zopflipng is also worth considering. It’s quite slow, but beats everything else 95% of the time. PNGOUT is a close second (and pretty slow too).Online tools There are also a number of free online tools you can use for optimization including some of those mentioned already: Kraken.io, punypng, smush.it, tinypng and jpegmini. Also check out Spriteme for combining background images into CSS sprites. Desktop tools If you’re primarily a designer or don’t have a build process setup, please consider at least running your images through tools like ImageOptim or ImageAlpha as they will shave bytes off your images and keep your pages a little more lean. You might also find this write-up on image compression for web developers by Colt McAnlis of interest. mod_pagespeed For those looking for a more automated server-side solution to image optimization, mod_pagespeed is an Apache module created by some of my colleagues at Google to speed up pages to reduce latency and bandwidth. A list of image optimization techniques it supports is available and includes inlining and recompression. Others? If there are other tools or Grunt tasks you’ve found helpful for image optimization, please feel free to share them. I know that both I and others are always interested in benchmarking new alternatives. Wrapping up Mobile users are the biggest victims of image bloat on web pages. They take ages to load on slow connections and when used without any optimization can make for a costly user experience. Respect your user’s time, try to keep your pages lean and with some luck we’ll make the web just a little bit faster.]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5应用缓存基础知识]]></title>
    <url>%2F2013%2F09%2F25%2FHTML5-Application-Cache-Basic%2F</url>
    <content type="text"><![CDATA[下面简单的介绍一下应用缓存的基本知识： 1. 应用缓存的作用让浏览器内 WebApp 像本地应用一样，多数或者全部资源都保存在本地，在没有网络，或者服务器宕掉的情况下，仍然能够使用大多数或者全部功能。有三个特点：离线浏览，更快的速度，以及减轻服务器负担。 2. 使用了应用缓存的页面的加载流程当浏览器访问一个包含了应用缓存的页面时， 如果应用缓存已经存在，那么直接使用应用缓存，并且仅仅加载manifest文件，判断该文件是否和缓存中的manifest文件是否相同，如果相同，则什么也不做，如果有任何一点不同，则重新加载manifest文件中列出的一系列缓存文件，并且在此过程中，会触发一些列的事件，可以通过监听这些时间，来重新加载该页面，以使用网站的最新版本。， 否则浏览器加载文档，然后获取manifest文件列出的 CACHE 和 FALLBACK 文件，生成第一版的应用缓存。 3. 使用方法：1. 创建manifest文件以下是manifest文件的模板 1234567891011CACHE MANIFEST# version 1CACHE:path/to/cached/file/a.htmlpath/to/cached/file/b.jsNETWORK:path/to/network/request/apath/to/network/folder/bFALLBACK:path/to/network/request/c path/to/fallback/file/cpath/to/network/folder/d path/to/fallback/file/d manifest文件对路径，文件名和后缀名没有限制。但是一般推荐放在项目根目录下面，因为在manifest文件里面定义的相对路径是相对于manifest文件的，而不是引用该manifest文件的 html 页面。后缀名虽然没有限制，但是该文件的 MIME 类型必须是text/cache-manifest，因此假如后缀名是manifest，那么必须做如下配置：Apache： 在相应的.htaccess文件中增加 AddType text/cache-manifest .manifestNginx： 在mime.types文件中加上text/cache-manifest manifest; 第一行必须是CACHE MANIFEST；第二行建议是注释，标明当前manifest文件版本。注释以#开始。为什么要有这样一个注释呢，这是因为浏览器在判断是否需要更新应用缓存时，是根据当前获得的manifest文件内容和缓存中的manifest文件内容有没有不同，如有不同，才会更新应用缓存。有时候我们仅仅更改某个文件的内容，但是manifest文件却不需要更改，但是如果不更改，那么浏览器就不会去获取新的资源文件。所以一个最佳实践就是一旦有文件修改，总是去更新manifest文件中的版本号。在以后的若干行中，可以是1）空白行2）注释行3）段落标题 可以是CACHE:，NETWORK:或FALLBACK:，可以出现零次或多次。4）段落数据CACHE 段落以CACHE:段落标题（可省略）开始，每行都是一个 URL，表示该资源要被缓存起来。不允许使用通配符*。NETWORK 段落以NETWORK:段落标题开始，每行都是一个 URL，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取。FALLBACK 段落以FALLBACK:段落标题开始，每行都包含两个 URL，第一个 URL 是资源地址，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取，第二个 URL 是后备资源地址，该资源会放入应用缓存中。如果前者获取失败，则从应用缓存获取后备资源替代。 2. 引入manifest文件123&lt;html manifest="example.manifest"&gt; ...&lt;/html&gt; 3. 前面已经提到，需要给manifest文件设置正确的 MIME 类型注意事项1. 自动缓存包含manifest文件的 HTML 页面这一点是有必要的，因为如果不缓存该页面，该页面必须通过网络加载，这样就不能达到离线应用的目的。如果你只想缓存这些资源，减少网络资源请求，并不想做成离线应用，那么你可以在页面中增加一个隐藏的 iframe，并且该 iframe 正确地引用了manifest文件。 2. 一旦manifest文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次这是应用缓存的一个巨大缺陷，不过可以结合 localStorage 实现一个更加灵活的缓存系统，即实现了离线应用，又避免的资源的全量更新。 参考MDN]]></content>
  </entry>
  <entry>
    <title><![CDATA[网页性能优化]]></title>
    <url>%2F2013%2F09%2F24%2FWeb-Page-Optimization%2F</url>
    <content type="text"><![CDATA[提到网页性能优化，一般分为两部分，加载性能优化和交互性能优化。 1.加载性能优化当在浏览器中输入一个 URL 或者在其他页面点击一个链接时，浏览器要做以下工作：DNS 查询，建立 TCP 链接，发送请求，接受响应，渲染页面，执行 Load 监听事件，至此页面加载就完成了。下面我们按照这个步骤思考如何优化页面加载性能？ 1.DNS 查询1.减少 DNS 查询2.使用 DNS Prefetching（DNS 预获取）特性缩短 DNS 查询时间。DNS 查询一般占用带宽少，但是延迟可能很高，典型的一次 DNS 查询需要 20-120ms。而 DNS 预获取为了获得较低的延迟，牺牲 DNS 查询次数。参考：Mozilla Developer Network参考：DNS Prefetching Implications 减少请求使用 Data URI，使用 CSS Spriteshttp://www.csdn.net/article/2013-09-13/2816925-CSS-Sprites-vs.-Data-URIs:-Which-is-Faster-on-Mobile? 2.TCP 连接1.使用 keep-alive 保持持久连接2.交互性能优化]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5应用缓存与百度地图服务]]></title>
    <url>%2F2013%2F09%2F23%2FHTML5-Application-Cache-and-Baidu-Map-Service%2F</url>
    <content type="text"><![CDATA[本文假设你基本了解 HTML5 应用缓存。 前几天，一个同事联系到我，说他们项目想使用 HTML5 的应用缓存，但是遇到了脚本执行错误问题，但是如果去掉 manifest 配置，即不使用应用缓存，则一切正常运行。我让他将项目代码简化一下，剥离业务相关部分，然后打包发给我。 在浏览器中打开该页面以后，发现如下两个错误： 12Uncaught ReferenceError: BMap is not defined index.html:18GET http://api.map.baidu.com/getscript?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2&amp;services=&amp;t=20130916115231 以上两个错误很明显是脚本加载失败造成的。 通过代码可以看到，项目中使用了百度地图，使用方法是引入一个script标签. 1&lt;script src="http://api.map.baidu.com/api?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2"&gt;&lt;/script&gt; 以上script标签从服务器端获取的代码是： 123456(function() &#123; window.BMap_loadScriptTime = new Date().getTime(); document.write( '&lt;script type="text/javascript" src="http://api.map.baidu.com/getscript?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2&amp;services=&amp;t=20130916115231"&gt;&lt;/script&gt;' );&#125;)(); 我们可以看到它使用了document.write方法，插入另一个script标签。然而在manifest文件中，却没有说明该脚本应该如何处理。 123CACHE MANIFESTNETWORK:http://api.map.baidu.com/api?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2 这时候浏览器尝试从应用缓存中寻找http://api.map.baidu.com/getscript?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2&amp;services=&amp;t=20130916115231却没有找到，所以脚本加载失败。因为这个脚本网址不是公开 API 的一部分，今天是这个 URL，明天也许就是另一个 URL 了，所以我们不能写在manifest文件里面。再者地图相关资源肯定不适合应用缓存，一是我们不能枚举需要调用的脚本，图片和其他资源，从而罗列在CACHE:配置中，二是应用缓存在每个域下只有 25M 的配额，甚至更少。那么对于这种不固定的网址或者不可枚举的网址该怎么处理呢？ 这时候我们有两种做法，第一种比较简单，在manifest文件中 NETWORK 一栏中使用*这个通配符，表示如果某个 URL 没有显式定义出来，则从互联网上获取该资源。于是manifest文件就变成： 12NETWORK:* 另外一种做法就是将这些不固定的网址（在这里，是百度地图服务）封装在一个固定地址的页面中，不使用应用缓存，并且通过 iframe 元素引入。比如： 12NETWORK:map.html 其中 map.html 负责渲染地图，并且不使用应用缓存。 现在问题看似解决了，但是我们的目的是使用应用缓存，那么当百度地图服务不可用（没有网络或者百度地图服务宕掉）时，打开页面是怎样的呢？我关闭了网络连接后，刷新页面，看到是一个块空白，以及如下错误： 123Application Cache Error event: Manifest fetch failed (-1) http://192.168.0.100/github/map/map.manifest map.html:1Uncaught ReferenceError: BMap is not defined map.html:18GET http://api.map.baidu.com/api?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2 直接给用户一个空白的地图似乎不是那么友好，更好的一种做法就是在使用一张静态的百度地图的截图代替，或者通过文字告诉用户，地图加载失败。 这时候有两种做法，一种做法是判断 BMap 是否定义，如果已定义则认为百度地图服务可用，否则认为不可用，此时可以提示用户地图服务不可用。这种做法很简单，这就不多说了。另一种做法更加适合上面使用 iframe 的情形，使用用应用缓存中的 FALLBACK 配置项。在 FALLBACK 配置中，每一行包括两个 URL，用空格分隔。第一个 URL 是正常情况下的资源地址，第二个 URL 是后备资源地址，当前者不可用时，由后者顶上。 使用 FALLBACK 时，我们可以定义一个 nomap.html 作为百度地图 API 的后备处理方案。代码如下： 12FALLBACK:map.html nomap.html FALLBACK 有个坑，就是 FALLBACK 中配置中第一个 URL 不能出现在 NETWORK 中，否则 FALLBACK 配置可能失效。 总结： 可以使用NETWORK中统配符*来告诉浏览器，对于那些未显式指定的资源总是从网络上获取。 对于iframe让应用的一部分使用应用缓存，另一部分不使用。 配合FALLBACK，可以让网络不可用时或者服务不可用时，界面更加友好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】使用 Chrome 开发者工具调试 Canvas]]></title>
    <url>%2F2013%2F09%2F20%2FCanvas-Inspection-using-Chrome-DevTools%2F</url>
    <content type="text"><![CDATA[简介使用过 Canvas 元素的人都知道 Canvas 很难调试。使用 Canvas 通常要调用一长串难以跟踪的 API。 12345678function draw() &#123; context.clearRect(0, 0, 258, 258); context.fillStyle = '#EEEEEE'; context.beginPath(); context.arc(129, 129, 127, 0, 6.28, true); context.closePath(); context.fill();&#125; 有时候你希望记录发送给 Canvas 上下文的指令，并且逐条执行指令。幸运的是在 Chrome 开发者工具里有一个新的 Canvas 审查特性可以帮你做到这一点。 在这篇文章里，我会给你演示怎样使用这个特性来调试你的 Canvas 行为。它支持 2D 和 WebGL 上下文，所以无论你在使用哪个，都可以使用它直接获取调试信息。 准备开始在 Chrome 地址栏打开about:flags页面，并选中“启用开发者工具实验”（英文：Enable Developer Tools experiments，以上是 Chrome 中文版翻译）。 接下来，打开开发者工具并点击右下角的齿轮图标，在新打开配置页面中可以找到实验（Experiments）一栏，然后在该栏中启用Canvas inspection（Canvas 审查）。 为了让这些修改生效，你必须关闭然后再打开开发者工具。当开发者工具再次打开时，找到 Profiles 一栏，你可以看到 Canvas Profile 选项，它是禁用状态，如果某个页面有你想要调试的 Canvas，你可以按下 Enable 按钮然后页面会重新载入，准备记录 Canvas 调用。 然后你需要决定你是记录单帧（Single Frame），还是看起来很像开发者工具中时间轴的连续多帧（Consecutive Frames）。 ||一帧表示页面中的一次事件循环，涉及到执行 JavaScript 代码，事件处理，更新 DOM，修改样式，布局和重绘。为了让动画更加平滑，你要让每帧耗时小于 1/60 秒，即 16.6 毫秒。 单帧仅仅记录本帧结束前所有的 API 调用，多帧则记录你手动停止之前的所有 API 调用。选择哪一种取决于你如何使用 canvas 元素。对于一个持续的动画，选择单帧更好，而那些用于响应用户事件的短暂动画，就应该使用多帧。 这样我们就做完了所有的准备工作可以记录帧了。 记录帧按下 Start 按钮，像平常一样与应用交互，你可以看到它已经在记录了。如果你要记录多帧，那你还需要回到开发者工具按下 Stop 按钮来结束记录。 现在你可以看到左侧有一个 profile 列表中有了一个新的 profile，里面记录了所有 canvas 元素上下文的调用。点击 profile 就可以看到如下界面： 你可以看到一组已经记录下来的帧，并且一步一步地浏览它们。一旦你点击了其中一个，你就可以看到该帧结束时 Canvas 的屏幕截图。如果有多个 Canvas 元素，你可以通过屏幕截图下面的菜单选择显示哪个 Canvas。 在帧里你可以看到多个绘画调用组（Draw Call Group），每个绘画调用组包含一个绘画调用，并且是该组的最后一个调用。那什么是绘画调用呢？对于一个 2D 上下文来讲，它包括 clearRect(), drawImage(), fill(), stroke(), putImageData()和其他文字渲染方法；对于一个 WebGL 上下文来讲，它包括 clear(), drawArrays()和 drawElements()。本质上讲，任何会修改当前绘画缓存内容的调用都是绘画调用（如果你不熟悉图形编程，你可以认为缓存就是一个我们正在操作的像素位图）。 你可以在帧，绘画调用组和调用这三个级别依次查看该列表。无论哪一种，你都可以看到那时的上下文，这意味着你可以迅速发现和修正 Bug。 找出属性变化另一个有用特性就是可以找出两次调用之间属性和变量发生了什么变化。 （译者注：在 Chrome29 上没有找到该按钮，但是 canary Chrome31 上可以找到）点击右侧按钮会打开一个新的面板，随着一步一步地查看 API 调用，你可以看到属性的变化，当鼠标放在任何 Buffer 和数组上时，你可以看到他们的内容。 注意了！现在你已经知道了怎样在 Chrome 开发者工具中调试 Canvas。如果你对这个工具有任何回馈，请提交一个 bug或者写信给Chrome 开发者工具工作组，告诉我们，你发现了 bug 或者在调试过程中你想看到哪些信息，因为只有开发者的回馈才能让它更好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[innerText vs textContent]]></title>
    <url>%2F2013%2F09%2F17%2Finnertext-vs-textcontent%2F</url>
    <content type="text"><![CDATA[为什么 innerText 会导致重排？我在我的上篇关于重排的文章末尾提出了这个问题。这里简单地总结一下，有些 DOM API 可能会因为不必要的重排，从而导致严重的性能问题。我将在这些文章中，着重提出这些年我发现的关于 Web 性能的古怪问题。 As with many other things in browsers, innerText’s behavior seemed to have happened due to overlapping (and, perhaps, under-defined) use cases. 当你要获取 DOM 节点中的文本时，你会遇到两个问题，节点中原始文本是什么？用户看到的文本是什么？虽然类似，但是显然有所不同。在浏览器中，可以通过 textContent 获得前者，通过 innerHTML 获得后者。 我们用以下例子来解释他们的最重要的不同点，看看以下 HTML 节点的 innerText 和 textContent。 1234&lt;div id="t"&gt; &lt;div&gt;lions, tigers&lt;/div&gt; &lt;div style="visibility:hidden"&gt;and bears&lt;/div&gt;&lt;/div&gt; innerText: lions, tigerstextContent: lions,\n tigersand bears 注意以下不同点：（1）.那些没有显示出来元素也不会出现在 innerText 中（2）innerText 中的换行符遵循布局中换行符的规则。理解 innerText 最好的方式就是，它大概就是你选择该节点的内容然后拷贝获得的文本。而 textContent 是各个子节点的文本内容组成的文本。 innerText 可能不是你想要的innerText 最大的特点是需要从布局系统中获得一些信息然后决定文本是怎样显示给用户的，这就是为什么 innerText 成为一个让性能变糟的一个属性。很多库喜欢用innerText而不用textContent仅仅是因为 IE 中先有innerText。下面让我们演示选择innerText和textContent时对性能的影响。 在基于 Webkit 的浏览器中，你可以看到很大的性能差异，大概300ms对1ms。在 IE9 中，你可以看到较好的性能以及较小的差异，这是因为 innerText 可能不是你想要的另一个原因虽然 innerText 被广泛使用，但它不是规范的属性。它能够存活下来是因为 IE 时代的广泛使用。On a WebKit browser, you should see a significant performance difference (~300ms vs ~1ms). On IE9, you’ll see better performance and a much smaller difference. It is clear that IE avoids computing a full layout and probably uses a special code path that computes only what is needed for innerText (which really isn’t much). If you are using Firefox or Opera, you may be scatching your head. Keep reading. While one could certainly conceive of use cases for innerText, most callers just assume that innerText and textContent are identical. You will see the expression node.innerText || node.textContent still being used in a number of libraries. Unfortunately, that leaves the door open for some unexpected performance problems. It is much wiser to prefer textContent these days. Another reason innerText is probably not what you wantWhile it is still widely used, innerText is not standard. It is a bit of behavior that has lived on due to wide use during the Internet Explorer era. It’s heavy use back then is probably the reason IE seems to have a specialized code path. To this day, it is not present in Firefox (wise decision on their part) and its behavior still varies widely in the browsers that do support it. Opera, for instance, merely computes textContent when you try to access innerText. This is why it outperforms WebKit in the example I show. When I use the expression “browser landmine”, innerText is what I have in mind. To quote my good friend, Joel Webber, “it’s slower, but at least it doesn’t work as you would expect.”]]></content>
  </entry>
  <entry>
    <title><![CDATA[透过用户的要求理解用户的关切]]></title>
    <url>%2F2013%2F09%2F16%2FWhy-the-User-Need-this-Feature%2F</url>
    <content type="text"><![CDATA[先介绍一下项目背景：公司生产了一些电视机和照相机，同时公开了一些接口，允许开发者基于此开发一些第三方应用。有些开发者可能没有电视机和照相机真机，或者团队中真机不足，为了能够是他们顺利地进行开发，所以我们开发一款软件，让开发者可以申请虚拟设备。该软件中实现了 SSDP 协议让第三方应用发现虚拟设备。 前些天，Tony 作为用户又作为项目的负责人提出一个要求：不能让一个账号同时在两个电脑（或者浏览器）上登录。这下可难倒了我们外包团队。他们的开发人员 W 找到我，说这个该怎么做呢？W 也提出一种方案，就是使用 WebSocket，对于不支持 WebSocket 的浏览器使用轮询来作为 fallback 方案。这个方案可以使用现有的 socket.io 库来轻松实现。 首先讲一下，不让一个账号同时两处登录，这样做的站点一般有聊天室等，有了这样的限制以后，一个用户在某个浏览器上登录以后，再不退出的情况下直接关闭浏览器，用户就不能在其他浏览器上登录了，直到 Session 过期。Session 自动过期时间可长可短，一般是半个小时。用户体验非常不好，更好的策略是，后登录的把先登录的踢掉。 以前我在 J2EE 企业级应用框架时实现了这样的功能，虽然实现了，但是还没有在任何一个项目中实际使用了。实现了，更多是为了功能的完备性。还有一点，在一个实现了完整的认证授权系统中，实现这样的功能是非常简单的。实现的方法如下： 首次成功登录以后，会再数据库的 Session 表中添加一条记录。字段一般包括 Session ID，用户 ID，Cookie，登录时间，最后操作时间（初始化为登录时间）。 以后用户没操作一次，都会修改 Session 表中的最后登录时间。这个在 J2EE 中一般通过 filter 实现。并且服务器端会定期执行一个任务，清除 Session 表中过期 Session。一个 Session 何时过期，一般判断条件是当前距离最后操作时间大于半个小时（可配置）。 当用户再次登录时，首先判断用户名和密码是否正确，如果正确，然后用户是否已经在别处登录，即 Session 表是否有该用户的未过期 Session，如果是，则给用户一个错误提示，否则才判定位登录成功。 在我们当前的应用中，服务器端语言使用的 Node，框架是 Express。Session 管理我们可以使用的是 Express 自带的 Session 中间件。代码如下： 123var express = require('express');var app = new express();app.use(express.session()); Express 的 Session 中间件没有 API 可以得到用户是否已经在别处登录。另外一个问题就是即便我们自己实现 Session 控制，那么也是不可取的，因为项目特殊性，用户在登录以后就加在几乎所有的资源，也只有在登录，申请设备和获取已申请设备清单时才会发送一个服务器端的请求。之后用户只需要按下启动按钮，之后虚拟设备就运行在 Web App 中了，第三方应用就可以通过 SSDP 协议发现设备并与该设备进行 HTTP 通信了。以后只有部分静态资源文件会从 Node Server 上获取之后，就没有其他的请求了。所以自从获取已申请设备清单以后，就没有会修改最后操作时间的请求了。 W 给出的一个方案：使用 socket.io，保持与服务器端通信。可行倒是可行，但是我们要为了一个需求大动干戈吗？这个要划一个问号。然后我跟 W 说，我去跟 Tony 商量一下，看看他的目的是什么，再决定怎么做。 在跟 Tony 的交流中，发现他有过这样的经历：开发阶段两个人使用了同一个账号同时登录，这两个浏览器中自然有着同样的设备列表，然后都启动了某个设备，这时候在局域网中就有了两个有着同样 UUID 的虚拟设备，他们 IP 不同，设别描述文件地址也不同，设备状态也不同。有些 SSDP 客户端会因此而崩溃掉。所以他想让一个账号不能同时在两处登录就能解决该问题了。 我告诉 Tony，既然你是为了解决这样的问题，那么我们能否换个思路，让每个浏览器上的设备 UUID 都不相同，在生成 UUID 时，不仅加入设备 ID，还加入浏览器所在电脑的 IP，时间戳，随机值等。这样一来，团队成员可以共享一个账号，在同一个局域网中也可以独立使用，互不影响。然后 Tony 认同了这一做法。到此，这个需求就这么解决了，仅仅修改一下 UUID 的生成算法。 在上面的案例中，可以发现，用户提出的要求可能只是他们所关切的问题的一个表象，或者是他们认为的这个问题的一个解决方案。我们不能仅仅局限于此，而要透过他们的要求去探索他们真正关切的问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】RequireJS的五个有用的小技巧]]></title>
    <url>%2F2013%2F09%2F12%2FFive-Helpful-Tips-When-Using-RequireJS%2F</url>
    <content type="text"><![CDATA[查看原文 RequireJS–Javascript 的文件和模块加载器–是 Web 应用中组织，管理，构建和加载 Javascript 的一种很强大的方式。我已经使用它好几年了，and while it’s admittedly difficult to limit myself to only five, 我要是早点知道这几条提示就好了。注意，该文章假定你了解 RequireJS，或者至少知道 AMD，CommonJS 和脚本加载器。RequireJS 官方网站是一个让你知其然并且知其所以然的很好的站点。 在这篇文章中，我们仅仅关注在 RequireJS 本身，而不包括 r.js（RequireJS 的优化工具）。我打算以后写一篇关于 r.js 的文章。 1. 知道定义模块的几种方式大多数使用 RequireJS 的人都知道以下这种定义模块的方法。 1234define(['dependencyA', 'dependencyB'], function(depA, depB) &#123; /* module code here using depA and depB */ return myModule;&#125;); 在 98%的情况下，我使用上面的方法。但是还有其他几种选择，选择哪种，取决于你的需要。一个模块不需要任何依赖，那么你可以这么做： 1234567define(&#123; someProp: 'Oooh, how interesting!', someMethod: function() &#123; // do interesting work return compellingValue; &#125;,&#125;); 如果这个模块没有任何依赖，但是你需要做一些准备工作或者保存私有状态，那么你可以这么做： 123456789101112define(function()&#123; var secretValue = 'seekret'; // do other initialization work here... return &#123; someProp: 'Oooh, how interesting!', tellMeSecrets: function()&#123; // do interesting work return secretValue; &#125; &#125;;&#125;&#125;); 2. 怎么配合非 AMD 库一起工作世界上有非常多的很好的 Javascript 库，大多数都没有遵循 AMD 规范，但是不用担心，你照样可以使用它们。从 RequireJS 2.1.0 版本开始，RequireJS 有了一个叫做‘shim’的特性，让你设置你要用到的哪些不满足 AMD 规范的库，并且像其他 AMD 库一样加载进来。下面我们来看个非 AMD 库的例子。加载没有依赖的非 AMD 库你获取还记得 Backbone 和 Underscore 取消 AMD 支持的情景，多亏了 shim 特性，我们依然可以容易地在 RequireJS 中使用这些库。 12345678910require.config(&#123; paths: &#123; underscore: 'libs/underscore.min', &#125;, shim: &#123; underscore: &#123; exports: '_', &#125;, &#125;,&#125;); 上面的 require.config 调用中我们提供了压缩后的 underscore.js 文件路径，后面在 shim 对象中，添加了一个和同样的属性，并且值是一个对象，它有一个 exports 属性，用来告诉 RequireJS 全局对象（如果是浏览器的话当然就 window 对象了）上某个属性就是这个模块实际值。既然 Underscore 把自己声明为 window 上的属性，那么我们就让 exports 的值为。从此以后，如果有一个 AMD 模块依赖 Underscore，RequireJS 会用全局对象的_值代替。这个例子很简单，因为 Underscore 没有任意依赖。那么如果加载一个有其他依赖的非 AMD 库吗？加载有依赖的非 AMD 库下面我们看看怎么加载依赖于 Underscore 和 jQuery 的 Backbone 吧。 12345678910111213141516require.config(&#123; paths: &#123; jquery: 'libs/jquery.min', backbone: 'libs/backbone.min', underscore: 'libs/underscore.min', &#125;, shim: &#123; underscore: &#123; exports: '_', &#125;, backbone: &#123; deps: ['jquery', 'underscore'], exports: 'Backbone', &#125;, &#125;,&#125;); Backbone 的 shim 配置除了 exports 属性外还有 deps 属性，deps 是一个包含了 Backbone 所有依赖的库名字数组，他们必须先于 Underscore 加载，一旦这些依赖加载完成之后，Backbone 也会被加载，然后 RequireJS 就会从全局对象上获取 Backbone 属性来作为 backbone 模块的值。那么 CommonJS 又是怎样的呢？假定你要 RequireJS 中使用一个 CommonJS 模块，没问题，你可以定义一个模块，并提供一个带有三个参数的工厂函数，这三个函数分别是：require，exports 和 module。多数情况下你都可以忽略其他两个参数，而只考虑如何使用 require 参数。通过 require 参数可以通过 CommonJS 的语法获取一个模块，比如： 12345678910111213141516define(function(require, exports, module) &#123; var cjs = require('myCommonJSModule'); return &#123; findDroids: function(droids) &#123; var res = [], i = 0, len = droids.length; for (; i &lt; len; i++) &#123; if (cjs.isDroidWareLookingFor(droids[i])) &#123; res.push(droids[i]); &#125; &#125; return res; &#125;, &#125;;&#125;); 特别注意我接下来的一片关于 r.js 的文章，当你使用 r.js 优化工具时，也可以使用更多的 CommonJS 工具库。你可以选择将 CommonJS 模块转换成用 deine()方法包裹起来的模块。你还需要知道，如果你的 CommonJS 模块有分支逻辑去有条件地调用 require，那么转换方法就会失效。比如上面的 myCommonJSModule 有以下内部逻辑（参考代码片段中去思考是什么让它不能和 RequireJS 不能一起工作）： 1234567891011121314// inside myCommonJSModulemodule.exports = &#123; isDroidWeAreLookingFor: function(droid) &#123; var finder; // OHSNAP! The conditional logic around require // means we cannot wrap it with define in RequireJS if (isObiWanPresent) &#123; finder = require('forceFilter'); &#125; else &#123; finder = require('normalFilter'); &#125; return finder.find(droid); &#125;,&#125;; 3. CND Fallbacks虽然 CDN（内容分发网络）可以提高站点的加载性能，但是不希望万一 CDN 挂掉时，你的站点也会挂掉。幸好 RequireJS 可以容易地设置后备地址。一般配置如下： 12345require.config(&#123; paths: &#123; kendoui: 'http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js', &#125;,&#125;); 当然我们希望 CDN 永远不会挂掉，但是如果它挂掉了，我们可以通过修改配置来使用后备地址： 12345require.config(&#123; paths: &#123; kendoui: ['http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js', 'libs/kendoui/kendoui.min'], &#125;,&#125;); 我们给 kendoui 设置了一个地址数组，而不再是一个字符串，根据以上配置，RequireJS 将会尝试从 CDN 上加载，如果失败了，再尝试从第二个地址加载。使用后备地址的确会使得脚本加载时间变长，但是总比站点不可用要好得多。 4. 插件RequireJS 中最好的一个增值点或许就是加载插件。加载插件可以用来加载各种非 Javascript 资源，就像其他依赖模块一样加载他们。最常见的是文本插件，它允许你加载一个普通文本文件（比如 HTML 或者 CSS 等），这对加载模板特别有用。为了让你理解它多么有用，让我们看看今天人们是怎么使用它的。 下面的代码片段展示了 Backbone 视图怎样获取 unders.js 模板内容，预编译，然后渲染页面，但是代码中你却看不到 RequireJS/text 插件的痕迹。 12345678var MyView = Backbone.View.extends(&#123; initialize: function() &#123; this.template = _.template($('generated-gif-template').text()); &#125;, render: function() &#123; this.$el.html(this.template(this.model.toJSON())); &#125;,&#125;); 注意到这个视图应该放在页面里面。很多人会添加一个script标签，并给出一个假冒的type属性（这样就不会被当做 Javascript 执行），将模板内容放进去，如下： 1234567891011&lt;script type="text/underscore-template" id="generated-gif-template"&gt; &lt;span class="glyphicon glyphicon-remove"&gt;&lt;/span&gt; &lt;a href="&lt;%= dataURL %&gt;" download="&lt;%= id %&gt;"&gt; &lt;span class="glyphicon glyphicon-save"&gt;&lt;/span&gt; &lt;/a&gt; &lt;img src="&lt;%= dataURL %&gt;" class="img-thumbnail gif-item"&gt; &lt;div&gt; &lt;input style="display:none" type="text" id="fileName" value="&lt;%= fileName %&gt;" /&gt; &lt;span id="lblFileName"&gt;&lt;%= fileName %&gt;&lt;/span&gt; &lt;/div&gt;&lt;/script&gt; 这方法肯定是可行的，但是有一些缺点。把模板内容嵌套在 script 标签中会丧失语法高亮和其他 IDE 提供的功能。这个模板必须出现在所有要使用它的页面。在一个多页面的站点中，这意味着你可能要多次拷贝模板内容，或者额外的构建步骤将模板嵌入每个目标 HTML 页面。在 AMD 应用中，像这样将模板保存在 DOM 中意味着该模块除了显示传递给它的依赖之外，还依赖其他东西。这使得你的应用比较脆弱。理想情况下，我们希望将模板传递给我们的模块，就像其他的脚本依赖一样。这就是文本插件产生的原因。 12345678910define(['backbone', 'text!templates/generated-gif.html'], function(Backbone, template) &#123; return Backbone.View.extend(&#123; initialize: function() &#123; this.template = _.template(template); &#125;, render: function() &#123; this.$el.html(this.template(this.model.toJSON())); &#125;, &#125;);&#125;); 我们将模板路径作为依赖加进来，用text!作为前缀，来告诉 RequireJS 使用一个叫做 text 的插件来处理。模板的文本内容作为template参数传递给模块。使用这个方法有如下好处：（一）开发过程中，模板作为一个单独的文件存在，因此我们使用 IDE 带给我们的便利（语法高亮等），还避免了我们必须穿过数百行甚至更多的 HTML 代码去编辑代码。（二）模板可以和其他模块同等对待，显示传递到模块中，让模块对模板的依赖更加显而易见。这和当模块执行时期望模板在 DOM 中正好相反。当我们使用 r.js 构建和优化 RequireJS 应用时，模板可以和其他模板一起部署，因为文本插件可以有效地将模板包装在模块定义调用中，创建一个返回模板文件内容的模块。以上就是对文本插件的惊鸿一瞥，下面是其他一些插件。i18n - 国际化image - 像加载其他模块一样加载图片mdown - 加载 markdown 文件，它会给你编译成 htmlfont - 加载 Web 字体 5. 故障检修小技巧你可以在代码中使用以下 API，我还发现在 Chrome 控制台中也非常有用。require.defined(moduleId) - 返回 true 如果该模块已经被定义并且可用。require.specified(moduleId) - 返回 true 如果该模块被其他模块依赖。该函数返回 true 并不意味着该模块可用。requirejs.s.contexts._.config - 我从Vernon Kesner那里学来的这招。这是一个技术上的后门，文档中没有说明的方法，所以它可能在没有任何警告的情况下被修改或者去除。但是它返回一个非常有用的包含配置信息的对象。以下是在 Chrome 控制台中它返回结果：以上就是我在 Devlink 用来演示Web Worker的一个生成 GIF 示例应用中调用 requirejs.s.contexts._.config 返回的结果。你可以看到所有相关配置数据：根 URL，路径，shim 配置等。当进行 Debug 时其他两个关键是errbacks和requirejs.onError方法。RequireJS ‘errbacks’当你调用require时，可以传入第三个参数-发生错误时的回调，允许你对错误做出反应，而不是产生一个未捕获的异常。比如： 1234567891011121314require(['backbone'], function(Backbone) &#123; return Backbone.View.extend(&#123; /* your magic here */ &#125;);&#125;, function(err) &#123; /* err has err.requireType (timeout, nodefine, scripterror) and err.requireModules (an array of module Ids/paths) Inside here you could requirejs.undef('backbone') to clear the module from require locally - and you could even redefine it here or fetch it from a different location (though the fallback approach earlier takes care of this use-case more succinctly) */&#125;); requirejs.onErrorRequireJS 有一个全局的错误处理函数，它可以捕捉到所有未被errbacks处理的异常。代码如下： 123456789requirejs.onError = function(err) &#123; /* err has the same info as the errback callback: err.requireType &amp; err.requireModules */ console.log(err.requireType); // Be sure to rethrow if you don't want to // blindly swallow exceptions here!!!&#125;; 总结无论你是刚接触 RequireJS 或者已有很多经验的用户，就像我前面提到的，我将会在另一篇文章中介绍r.js，敬请期待。你是否发现了其他有用的关于 RequireJS 使用的技巧，方法和 API，期待你的交流。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用页面跳转完成登录和认证]]></title>
    <url>%2F2013%2F09%2F06%2FUsing-Redirect-to-Login-and-Authentication%2F</url>
    <content type="text"><![CDATA[在上篇文章我们提到如何使用 WWW-Authenticate 实现登录和认证。这一次我们讲一下另一种实现方式。服务器端提供一个登录认证页面，浏览器端需要跳转到该页面，用户输入 PIN 码之后，发送请求，浏览器验证之后跳转当前页面来。以下是更详细的步骤。 浏览器端点击认证按钮，然后请求电视机（服务器端，下同）提供的一个认证页面。 1GET http://192.168.1.199:7999/webauth/auth_default?app_name=Sample%20Web%20App&amp;app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&amp;return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&amp;auth_level=generic HTTP/1.1 该请求中包含一些重要的参数信息：app_name 该应用的名称，显示给用户确认。app_url 该应用的网址，显示给用户确认。return_url 认证完成之后，通过该网址跳回本应用。auth_level 认证等级，将会体现到该应用对电视机操控权限上。 电视机接收到认证页面请求，创建 PIN 码并显示在电视机上（如下图），返回该页面源码。 12HTTP/1.1 200 OK&lt;!DOCTYPE HTML&gt; 浏览器端显示该页面（如下图），用户输入 PIN 码并发送认证请求。 123POST http://192.168.1.199:7999/webauth/auth_default_submit HTTP/1.1Content-Type: application/x-www-form-urlencodedpin_code=5184&amp;response=allow&amp;token=1378462608431&amp;app_name=Sample+Web+App&amp;app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&amp;return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&amp;auth_level=generic 电视机收到认证请求，判断 PIN 码是否正确，如果不正确，则再次回到第二步中的认证页面，并提示错误，如下图。如果正确，则跳转到 return_url 页面。 123HTTP/1.1 302 FoundLocation: http://192.168.1.199:3000/test/bravia.html?server=192.168.1.199&amp;port=7999&amp;device_id=3&amp;x=1&amp;y=2&amp;result=authorized#zzzSet-Cookie: auth=9336226396260589431055355817107579663142096251022247731126844883; path=/; max-age=1209600; expires=Fri, 20 Sep 2013 10:49:56 GMT]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用WWW-Authenticate实现登录认证]]></title>
    <url>%2F2013%2F09%2F06%2FUsing-WWW-Authenticate-to-Login-Authentication%2F</url>
    <content type="text"><![CDATA[在当前的项目中，我们做了虚拟电视机设备，手机应用必须连接并通过认证才能控制电视机。认证步骤如下，首先由手机应用向电视机发送认证请求，电视机收到后会显示 PIN 码，用户在手机应用中输入 PIN 码，再发送请求验证即可。 其中一种认证实现，我们采用了 WWW-Authenticate，这种在互联网初期比较常见的认证方式。优点是非常简单，标准化的，浏览器支持完善。缺点是用户名和密码是经 Base64 编码传输。大家都知道 Base64 就是个简单的障眼法，是那种防君子不防小人的做法。解密过程特别简单，与明文传输基本无异。 下面就简单描述一下过程吧。 浏览器向电视机（服务器端，下同）发送请求。 1POST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1 电视机没有收到认证信息，创建 PIN 码并显示在电视机上（如下图），返回 401 未认证错误。 12HTTP/1.1 401 UnauthorizedWWW-Authenticate: Basic realm=&quot;Private Page&quot; 浏览器收到 401 未认证错误，将会显示一个如下登录框。并显示出服务器端给的提示信息Private Page.用户在密码一栏中输入 PIN 码之后点击登录，浏览器将会重新再发一次请求。这次请求跟上次请求唯一不同就是多了一个 header。 12POST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1Authorization: Basic OjgyNzU= 我们在 Chrome 的控制台执行以下代码atob(&#39;OjgyNzU=&#39;)，可以看到结果是:8275，也就是: + PIN。也许你已经猜到了，Authorization 的值就是Basic base64(&lt;username&gt;:&lt;password&gt;)。 电视机收到带有 Authorization 头部的请求以后，调用类似atob的方法解码，得到 PIN 码判断是否正确，如果正确则验证成功，如果不正确则继续返回和第 2 步一样的响应。在这里，我们输入了正确的 PIN 码，所以服务器端返回了 200 状态吗。 12HTTP/1.1 200 OKSet-Cookie: auth=0757981464307829417712055147089187584491446610025428754976019263; path=/; max-age=1209600; expires=Fri Sep 20 2013 17:09:39 GMT 以上这种方法的客户端并不一定要是浏览器，在手机原生应用中也可以做到，一般需要 HTTP 客户端库来辅助发送请求并解析响应。当然还需要自己做一个登录框。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【Chrome Extension】如何获取Extension的版本号]]></title>
    <url>%2F2013%2F08%2F26%2FGet-Version-Info-in-Chrome-Extension%2F</url>
    <content type="text"><![CDATA[Chrome 中有两种扩展应用类型，一种是 Extension，它通过往页面中添加 script 脚本来达到其目的。另外一种是 Packaged Application，它是基于 Chrome 的本地应用。具体用法以后再总结。 这两种扩展都是需要用户手动安装的，也是可以自动更新的。但是有些时候，我们还是需要去检查 Extension 的版本。下面我们就看看如何去做？ 首先，我们知道，在编写 Extension 时，我们都需要写一个manifest.json文件，它里面包含着关于这个 Extension 的信息。比如name，description，version等很多信息。那么我就可以通过获取该文件来获取本扩展的版本。 那么如何获取manifest.json文件呢？ 首先我们知道 Extension 中可以通过XMLHttpRequest来获取资源文件，而manifest.json也可以看做是普通的一个资源文件，那么我们就可以通过XMLHttpRequest获取manifest.json。 1234567891011(function() &#123; var url = 'manifest.json'; var xhr = new XMLHttpRequest(); xhr.onload = function() &#123; var manifest = JSON.parse(xhr.response); var version = manifest.version; // do something here &#125;; xhr.open('GET', url, true); xhr.send();&#125;)(); 以上方法放在 Extension 的 content script 中，报如下错误：GET http://[ip]:[port]/manifest.json 404 (Not Found)。这个很容易理解，因为在 Extension 中，该脚本是通过 script 标签插入到 DOM 中执行的。那么我们如何来获取 manifest.json 的实际路径呢？答案是chrome.extension.getURL，这个 API 就是根据扩展中资源文件的相对路径来获取其绝对路径。而在 Packaged App 中则可以直接使用相对路径。所以在 Extension 中的做法是： 1234567891011(function() &#123; var url = chrome.extension.getURL('manifest.json'); var xhr = new XMLHttpRequest(); xhr.onload = function() &#123; var manifest = JSON.parse(xhr.response); var version = manifest.version; // do something here &#125;; xhr.open('GET', url, true); xhr.send();&#125;)(); 还要记住，我们需要在manifest.json中声明manifest.json是一种可以访问的资源。 123&#123; "web_accessible_resources": ["manifest.json"]&#125; 否则我们会看到如下错误： 1Denying load of chrome-extension://ongmmjdilaoifhglgibpinckpckeclch/manifest.json. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension. 以上我们把manifest.json当做一个普通的资源文件来访问。那么manifest.json作为一种很关键很通用（所有 Extension 中都有该文件）的一个配置文件，那么有没有更简单的方法呢？答案是肯定的。在最新的 Chrome（v22+）中提供了chrome.runtime.*API，他们提供了获取 background 页面，manifest.json 文件，以及和其他 Extension 通信的各种 API。代码如下： 123var manifest = chrome.runtime.getManifest();var version = manifest.version;// do something here 很明显，直接使用chrome.runtime.getManifest来获取 Extension 的版本号，最为简单，代码少，还是同步的。 总结：文章总结了获取 Extension 版本号（在manifest.json中）的两种方法，一种把manifest.json当做普通资源文件访问，一种直接使用chrome.runtime.getManifest访问，后者更为简单易用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员困境]]></title>
    <url>%2F2013%2F08%2F19%2FProgrammer-Dilemma%2F</url>
    <content type="text"><![CDATA[这两天有一篇叫做《程序员困境》（英文原文 Programmer’s dilemma，中文解读版本，程序员困境：底层编码能力正逐步丧失）的文章很火，激起了程序员们的一系列讨论。 作者讲了他最近经历，面试数十人，发现虽然他们的简历闪亮，但是底层编码能力很差。然后作者尝试分析其原因，提到了两个名词：1）专家陷阱：过于深入研究某些既有代码，成为这一方面的专家，但是这些经验阻挡了他的视野，也限制了他把握大局的能力。当换了一个环境时，他就什么也不是了。个人认为这个不算个很大的问题，人的精力有限，专精是有代价的，是要有所舍弃，来成全某一方面的专精的。2）程序员困境：我们通过给大公司写代码谋生，而大公司却意图摧毁我们谋生的能力。 首先整体来讲，我个人不支持作者观点。 ###术业有专攻有人负责生产，就要有人负责消费。不能全部都去生产，也不能全部都去消费。 程序员的工作就是让所有人失业，包括程序员自身。]]></content>
  </entry>
  <entry>
    <title><![CDATA[没有后端的应用]]></title>
    <url>%2F2013%2F06%2F30%2FNo-Backend%2F</url>
    <content type="text"><![CDATA[在 infoQ 上这篇文章不用后端：noBackend 是什么？有什么好处？，阿里的王涛对这种没有后端的架构做了介绍和探讨。以下是文章引言。 在近期举办的前端趋势 2013大会上，Gregor Martynus 做了一场题为“各位快看，不用后端！”的报告，站在前端的视角谈应用开发，服务端组件只退化到实现浏览器尚不支持的特性，这种方式与传统开发方式截然相反，后者首先要关注应用服务端，然后再利用前端技巧来提升应用。他们还建了一个名为noBackend 的网站来深入传播这种理念。 王涛认为：这种模式给了前端开发人员更大的挑战和机遇。这种模式也不是横空出世的，它是经历了后端为主，前后端分离的阶段之后的另一个发展方向。当前前后端分离的模式正在大规模使用中。 诚然，在当前流行的前后端分离开发的模式中，也越来越体现出这种模式，前端越来越重，对于安全性，机密性不强的逻辑都慢慢地放到前端来做。在我第二家雇主做的那款网页游戏中也很有体现。前后端的人员比例已经在 1：1，很多公司会更高，前端开发不仅要处理 UI，还要处理越来越多的业务逻辑。很多时候前端逻辑和后端逻辑有很大的重复。前端用于快速响应用户行为，后端用于验证后保存到数据库。比如根据当前属性，能不能穿上某种装备。前端判断可以，那么就让用户穿上装备，并且通知后端。后端判断可以，就保存到数据库，如果不可以（可能是用户使用外挂修改了自身属性），就返回错误让前端取消刚才的行为。 前面我们提到很多应用中，后端就相当于是个数据库，前端才是应用的主体，有着完整的业务逻辑。但是后端着不可替代的验证作用。检验用户数据格式，数值，用户有没有作弊，以及保存到数据库中。 所以这种没有后端的模式比较适合于这样的情况： (1)用户于用户之间没有关系的应用。比如 TODO List 等。一个人数据一般不会共享给其他人，也不会对其他人有任何影响，此时我们完全可以完全相信前端传来的数据。后端就完全退化成数据库，仅仅有着数据存储的功能了。 (2)应用所有的操作都是比较通用的，云服务已经提供了这样的接口，比如博客应用，对文章的增删改查，博主的个人页面。在 Gregor Martynus 的讲稿中还有信用卡付费等接口，相信越来越多的操作会集成到这些云服务中，会有越来越多的应用适合种没有后端的模式。 对于不少应用中，可能不是所有的数据都能满足以上条件，那么也可以仅仅将这部分数据拆分出来，减少后端人力的投入。对于以上模式，个人也是充满期待。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】优秀的用户界面设计]]></title>
    <url>%2F2013%2F06%2F28%2FGood-UI%2F</url>
    <content type="text"><![CDATA[一个好的用户界面不但容易使用，还可以带来很高的转化率。换句话说，它兼顾了商业利益的同时，也让用户更加容易使用。以下是一个不断更新的最佳实践的列表。 ###用一列布局代替多列布局一列布局让你对故事有着更多的控制能力，它能够以你预期的方式引导用户从顶部浏览到底部。然而多列布局却有一定风险让用户忽视了该页面的主要目的。用单一故事和底部一个显眼的 Call To Action 引导用户。 ###回赠礼物而不是立即关闭页面以一种友好的姿态，比如回赠顾客一个礼物。更深一个层面讲，回赠礼物是一种有效的基于互惠规则的说服策略。通过礼物表达谢意，将来用户会用好感来报答你。 ###整合相似的功能点，而不是分布的到处都是在整个构建过程中，我们很容易去创建具有相同功能的多个区域，元素和特性。注意有着不同标签的相同功能点，因为他们给用户造成一种压力。通常界面中片段越多，用户的学习曲线越陡峭。一旦你需要将相似功能点放在一个页面时，请考虑重构用户界面。 ###使用社交化证据而不是自卖自夸社交化证据是提高转化率的另一个说服策略。看到别人对你的认可并在讨论你提供的产品和服务，是促使用户 call to action 的一个伟大的方法。尝试使用证书和数据来证明别人在使用你的产品和服务。 ###重复显示主要 action，而不要仅仅显示一次较长的页面中适合重复多次显示 Call to Action，你也可以在多个页面中重复显示。当然你不会在同一屏中显示 10 次来激怒用户。长页面变得越来越流行，在顶部提供一个软的可点击按钮，在底部也提供一个，没有坏处。当人们浏览到底部时，他们停下来思考该干什么————a potential solid place to make an offer or close a deal. ###对可点击和已选择的条目使用不同的样式可视化的样式，比如颜色，深度，对比等，是帮助用户了解界面导航的一种可靠的暗示：我在那里，我能去哪里。为了能够清楚的告诉用户这些东西，可点击条目（链接，按钮），已选择条目和普通文本应该使用不同的样式，并且在所有界面中达到统一。在下面的例子中，我使用蓝色去标志可点击条目，使用黑色标志已选择条目或者说用户当前位置。样式应用得当的话，用户可以很容易地学会并使用这些暗示。模糊不清的样式会让用户使用起来更加困难。 ###推荐，而不是没有区别的显示各种选择当你提供多种选择时，特别强调和推荐其中一个会比较好，因为大家都需要被怂恿一下。我相信有心理学研究表明，选择越多，做出最后决定的机会越小。为了避免这种现象，请尝试高亮某个选项。 ###不让用户确认，而是提供取消操作的功能假设你刚刚按下了一个按钮或者链接，提供取消操作功能会尊重你的意愿，让操作正常执行下去。而确认行为则假定用户不知道他们的操作并且总要确认一下。我相信大多数情况下，用户正确地根据意愿做出操作，只有少数操作是意外。需要重复地确认信息，这是多么低效和丑陋的。通过提供取消操作功能，让你的用户有一切都在掌握之中的感觉，而不是每次都请求用户确认。 ###告诉你的目标客户群，这是特地为你做的。告诉你的用户，这是为你做的，而不是为所有人做的。你的产品是面向所有用户的吗？还是有着清晰的目标群体？通过限定目标客户，给予一种独占的感觉，你可以更他们交流的更多。这个策略的风险就是限制了潜在的用户群体，透明成就信任。 ###更加直接而不要犹豫不决你可以以不确定的语气，也可以以非常肯定的的语气传达你的意思。如果你的消息以问号结束，使用“也许”，“可能”，“是否感兴趣？”， “想要”这样的词汇，那么你还可以加强一下语气，告诉用户接下来做什么，对于转化率优化还是有一定空间的。 ###使用更大的差异让 CTA 更加突出，与周边其他元素差别更大，会使得 UI 更加强劲。突出主要的 CAT 有以下几种方法，色调可以让某个元素颜色变深或者变浅。最后，也可以使用色环中的互补色（比如黄色和紫色）让差别更大。总之要考虑 CTA 和其他内容的差异。 ###告诉用户该产品的产地告诉用户你在哪里，也就是告诉用户产品或者服务产在何处，同时，留下你个人的联系方式。人们在自我介绍时通常会提及国家，省份或者城市。如果你这么做了，用户会认为你很友好。通常，指出产品的产地也会让用户感觉产品的质量更高一些。这是双赢的。 ###减少表单项人们生来讨厌劳动密集的任务，这同样适用于填写表单。每一个表单项都增加了用户放弃的风险。每个人的打字速度不同，在手机上打字一般都是个苦差事。思考每个表单项是不是必须的，并尽可能多地删除它们。如果有一些可选的表单项，可以考虑把它们移到表单提交后的另一个页面。繁琐的表单很容易，然后更少的表单项转化率更高。 ###暴露选项每个下拉菜单都隐藏了一些选项，你要做一些操作才能找到它们。如果这些隐藏的选项是用户完成任务的主线操作，你应该考虑将它们放在明面上。保留哪些可预料的不需要用户思考的下拉菜单，比如日历中的日期和时间，或者国家，省份等地理位置。有时候下拉菜单还可以用于那些用户一直反复使用的行为。当心不要在转化途中的主要项目上使用下拉菜单。 ###内容的连续性（章节之间没有大的空隙）错误的底部是转化率杀手。是的，滚动到底部是 OK 的，但是注意不要在节与节之间，给访客一个页面已经结束的感觉。如果页面需要滚屏，那么尝试建立一种可视的模式，用户可以学习这种模式并信赖它去往下读取更多内容。 ###保持关注，而不要淹没在链接中。为了尽可能满足用户的各种需求，很容易就在一个页面中放置了很多链接。然而如果你是为了页面底部的一个特定的 Call to Action 而创建的故事型页面，那你就要再考虑一下了。你要意识到在 CTA 前面的任何链接都有可能带走用户。关注页面中链接数量，平衡好探索性性页面（链接比较重）和通道型页面（更少的链接，更高的转化率）。减少无关的链接可以有效地提高访客到达重要按钮的几率。 ###显示状态在用户界面中，可能需要显示有着不同状态的元素。邮件可能是已读，也可能是未读。发票可能是已支付，也可能是未支付。提示用户每一个元素所处的特定状态，是提供反馈的好方法。界面状态可以帮助人们理解他们刚才的操作是否已经执行，以及是否应该进行某项操作。 ###Try Benefit Buttons instead of just task based ones.假设页面上有两个简单的按钮，一个写着“省钱”，一个写着“注册”。我敢打赌第一个按钮有着更高点击率。因为“注册”没有内在的价值。注册过程费事并且通常要填写长长的表单。注明有利可图的按钮有着更高的转化率。或者也可以将利益信息放在操作按钮旁边，来提醒用户为什么他们将要做此操作。当然了，在不是那么需要说服用户并且重复多次使用的情况，还是可以保留任务型按钮的。 ###不要使用没有上下文的菜单，而是使用更加直观的操作按钮。相对于列举一些无关的普通操作选项，能够直接操作特定元素更有意义。举个例子，当显示一组数据时，通常允许用户操作某个数据项。点击或者鼠标悬停在某数据项时，可以显示该数据项可以进行的操作（比如删除，重命名等）。再举一个例子，当点击某个数据项（比如一个地址文本），就会变成一个可编辑的输入框。与那些没有上下文的普通操作，启用这样的交互方式，会减少一些不必要操作步骤。 ###直接显示表单，而不使用单独页面当创建落地页面来表达价值时，表单最好显示在该页面。相比额外创建几张注册页面，整合注册表单和落地页面带来以下好处：首先，我们去除了流程中额外的步骤，并且占用用户更少的时间。其次，在落地页显示几个表单项，也给用户一种注册过程只要很短时间的感觉。表单越短越容易，当然表单就应该尽可能精简。 点击我查看英文原版]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些有意思的交互设计]]></title>
    <url>%2F2013%2F06%2F22%2FSome-Interesting-Interactive%2F</url>
    <content type="text"><![CDATA[1. 网易邮箱当用户在很短的时间内三次点击“收信”按钮之后，如果还没有收到新邮件，系统提示用户注意查看“垃圾邮件”。当用户做出这样的动作时，基本都是用户被其他系统提示给他发送了一封邮件，然后用户急于查看邮件内容。如果该邮箱启动了垃圾邮件过滤功能，那么在多次刷新无果的情况下，就有可能是被当做垃圾邮件处理了，所以给出用户一种提示。这是几年前我注意到的交互行为，但是现在消失了。不知道是网易对自己的垃圾邮件判断准确率得到了大幅提高，还是其他原因，就不得而知了。 2. 隐藏的菜单在一些系统中，受到设备尺寸的限制或者是设计上的权衡，最后将菜单隐藏或者最小化处理。那么怎么才能告诉用户这里有菜单呢？有种做法在系统启动时，将执行菜单从隐藏渐变到完全显示再渐变到隐藏这样一个动画效果，以提示用户这里有个菜单，可以点击（或滑动）附近区域来显示菜单。这样也有一个问题，每次启动系统或者页面刷新时都会执行这样的动画会对用户造成一定骚扰。首先就是动画执行要快，不要影响用户的正常操作，然后就是当用户第一次弹出菜单以后，我们就认为用户学会了如何弹出菜单，以后就不再显示该动画效果。为什么会想到这样一个案例呢，是因为前几天午饭时，一个同事谈起他的新手机，底部 Back，Home，Settings 等菜单突然找不到了，重启机器也不会出现。然后上网搜索才知道是被不小心手指下滑隐藏了菜单，需要手指上滑来显示菜单。试想如果在用户重启以后会有上述的动画效果，或许能够提示用户。 3. 鲸鱼岛的冬天（摘自程序员杂志 201209 P71）将游戏首页加上模糊处理，使它看起来像是玻璃上结了一层水雾。小朋友都会很自然的去擦，从而获得清晰的页面。据说很多小朋友都把整个页面擦干净才开始游戏。ABCKit 等知名应用的开发者 Karina Ibarra 在 Designing Apps For Kids 一文中提出了儿童应用的设计要点：简短的启动画面（儿童缺乏耐心）、首页的设计（低龄儿童难以被其吸引）、应用相关设置简单（防止儿童误操作）、从大处着眼（易于识别）、任务机制简单（易用性原则）以及随时的赞美和鼓励。孩子如果想重启或者恢复一个游戏，故事或者活动时，他们不会按返回键来恢复游戏或者返回主页，大多数孩子会直接按下 iPad 或 iPhone 的 Home 键，先退出游戏，再重新开始游戏。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Javascript的坑]]></title>
    <url>%2F2013%2F06%2F20%2FJavascript-Trick%2F</url>
    <content type="text"><![CDATA[以下题目摘自饮水思源。 语言基础篇0. this 的指代12345678function getThis() &#123; return this;&#125;console.log(getThis.call(1) === 1);console.log(getThis.call('test') === 'test');console.log(getThis.call() === undefined);console.log(getThis.call(null) === null);console.log(getThis.call(false) === false); 在 ECMA5 严格模式中，this 都会 call 和 apply 的第一个实参，哪怕传入的实参是原始值甚至是 null 或者 undefined。在 ECMA3 和非严格模式中，传入的 null 和 undefined 会被替换成全局对象。如果 call 和 apply 的第一个实参是原始类型，那么会先包装成对象。所以以上 全部 false 1. bind &amp; call123456789function getThisAndArguments() &#123; return &#123; this: this, arguments: arguments &#125;;&#125;console.log( getThisAndArguments .bind(1, 2) .bind(3, 4) .call(5, 6)); bind 和 call 以及 apply 一样，如果第一个实参是原始类型，会包装成对象做为 this 的值。bind 一旦绑定 this 之后就不可以再次绑定，所以 this 最终指向一个 Number 对象，其原始值 1.arguments 最终指向一个类似[2,4,6]的 Arguments 对象。 2. 解释一下 fn 是做什么用的，以及它的声明语句为啥这么长。1234var fn = Function.prototype.call.bind(Array.prototype.forEach);fn(document.querySelectorAll('*'), function(a) &#123; console.log(a);&#125;); 如果说只看代码声明还不知道 fn 是干什么的话，那么看了 fn 的调用就可以肯定它是干什么的。不完全准确地说，bind 就是将一个函数作为一个对象的成员函数来执行。所以以上代码等价于以下代码： 123456// 该行代码是废话，可以忽略Array.prototype.forEach.call = Function.prototype.call;//Array.prototype.forEach.call(document.querySelectorAll('*'), function(a) &#123; console.log(a);&#125;); 看到上面的代码相比大家都明白了。 3. Object &amp; Function结果分别是？解释一下 12console.log(Object instanceof Function);console.log(Function instanceof Object); 因为可以调用new Object()，所以 Object 肯定是函数。另外任何对象都是 Object 的实例，包括 Object 自身。以上答案经过 Chrome 验证是正确的。 实战篇以下题目是比较常见的场景，所以可能已经存在很好的 JS 库，请尽量不要参考。 4.我们有一个 Node.js 爬虫，和一堆需要它去爬的连接，爬完后用 log()记录内容，现在请你改写这例子，控制爬虫并发请求数&lt;=10。如果你能写出一个类似 Pythonmultiprocessing.Pool 的可复用的东西，有加分噢。 12345var urlArr = [...];var url = urlArr[0];crawl(url, callback(err, response)&#123; log(url, response);&#125;); 5. 多层嵌套的优化我们要用 Nodejs 查询若干次数据库，生成一个简单的博客页面，请你把如下例子尽可能改得优雅些。如果你能实现一个可复用的东西，有加分噢~ 123456789101112131415161718db.getArticles(function(err, articles) &#123; if (err) return handle(err); db.getTags(function(err, tags) &#123; if (err) return handle(err); db.getCategories(function(err, categories) &#123; if (err) return handle(err); db.getComments(function(err, comments) &#123; if (err) return handle(err); render('index', &#123; articles: articles, tags: tags, categories: categories, comments: comments, &#125;); &#125;); &#125;); &#125;);&#125;); 6.由于历史的原因，我们有一个很傻的异步 API： 12345window.getSomeInfo = function(info)&#123; console.log(info); //info.url 是请求的url&#125;;var url = 'http://www.baidu.com/;window.external.getSomeInfo(url); //异步执行，请求完成后会调用window.getSomeInfo() 如你所见，这个 API 没法支持两对及以上的 url-&gt;callback 组合。你能不能改写出一个稍微灵活点的 wrapper？]]></content>
  </entry>
  <entry>
    <title><![CDATA[YouTube 开放 API 中返回数据不一致]]></title>
    <url>%2F2013%2F06%2F09%2FTotalResults-filed-in-Youtube-Open-API%2F</url>
    <content type="text"><![CDATA[在YouTube 的开放 API中，totalResults 字段只是近似值，而不是准确值。比如返回的 totalResults 为 48，但是只返回 46 条记录。所以应用中不能依赖该字段来确定总共有多少页，然后允许用户直接跳到最后一页。因为最后一页很有可能就不存在。 为什么会出现这种情况呢？我们从以下几个概念开始说起。 CAP 理论CAP 理论由 Eric Brewer 教授提出：在设计和部署分布式应用时，存在以下三个核心的系统需求：一致性（Consistency），可用性（Availability）和分区容错性（Partition Tolerance）， 针对特定数据，最多只能同时满足两个。一致性：又称为原子性或者事务性。表示一组操作是不可分割的，要么全部完成，不会出现部分完成的情况。可用性：是指系统能够很好的为用户服务，不会出现操作失败或者访问超时等用户体验不好的情况。可以通过数据冗余，负载均衡等手段实现。分区容错性：一个良好的分布式系统，在其中一个或者几个节点宕掉的情况下仍然能够工作。 从这里可以大胆的猜测，YouTube 系统应该舍弃了一致性，保证了可用性和分区容错性。 身为前端开发人员，还是更加看重这样的决策对前端的影响。 1）就是不能使用传统的分页方式，可以采用无限滚动列表，或者只有“上一页”和“下一页”两个按钮的分页方式。在 BDP 项目中，我们使用无限列表的方式，当然是用这种方式的更大原因，电视机上没有鼠标操作，只有遥控器的上下左右键，而左右键被用切换页面，所以只能使用上下键来选择记录了。 2）前端需要良好的容错机制。首先会假设 totalResults 字段是准确的，并显示给用户看。随着用户的操作，持续地发送请求获取更多记录，直到 ① 当前已经获取的记录数大于等于 totalResults，或者 ② 请求出错，就将 totalResults 修正为当前已经获取的记录的个数，并且比较圆润地处理错误，使得用户操作正常，就像没有出错一样。用户希望提前看到 totalResults，并不一定要看到一个准确的结果，多数时候他们需要的是个预期，大概多少条记录，我要滚动页面多长时间才能浏览一遍。]]></content>
  </entry>
  <entry>
    <title><![CDATA[强迫注册和注册强迫症]]></title>
    <url>%2F2013%2F06%2F07%2Fessay%2F</url>
    <content type="text"><![CDATA[关于用户体验，我们经常听到这样的言论，除非到了非注册不可的时候，才让用户注册账号。过早地强迫用户注册，只会吓走用户。以今天看到的一个站点孢子社区为例，首页是一张背景图片，一张 LOGO 图标，一个登陆按钮和一个注册按钮，可谓非常简洁。“孢子”这个名字对我来说比较亲切，我挺喜欢玩《植物大战僵尸》，里面有个孢子射手。背景图片也很亲切，是一群光着身子的小孩子欢笑跳跃，对我也说，也非常亲切，我很想知道这个网站是干什么的，但是孢子社区的首页并没有告诉我，而是在门口安排了两个保安（登录按钮和注册按钮），要检查我的身份证，刚才提及的亲切感顿时灰飞烟灭。 当我意识是他们强迫我注册，才让我不想进去看看里面有什么东西的，并且我又临时决定写这样一篇博客时，我决定去注册一下，去看看里面有什么东西。注册页面也挺简单：要填写一个邮箱，一个昵称，和一个密码。注意这里并没有要我再填写一次密码，这是最近比较流行的注册方式。顺便看看内容，还好。其中一个图片令人捧腹，所谓百鸟朝凤，图片有色。 使用一小段时间之后，发现都不是非注册不可。我不发帖不留言。所以该网站就因为首页的注册按钮丢失了我这个潜在的用户。 本公司是一家家电产业的公司，生产基于 Android 系统的手机，相机，电视等，为了丰富他们的使用价值，希望吸引开发者多多开发其上的应用。但是考虑到如下因素，以电视机为例，为了开发电视机上的应用，不是每个个人开发者都可以去买一台电视机，也不是每家公司都有足够电视机供员工调试开发使用。所以本公司就想开发一个模拟应用，称之为应用 D，它能够模拟电视机开放出来的接口。我的建议很简单，用户打开应用 D 以后，就看到一堆可以申请的设备，包括电视机，相机等，一键申请设备之后，就会显示在用户设备列表中，用户就可以使用他们。当用户关掉应用 D，所有的设备都消失，当应用再次打开应用 D 时，需要重新申请才可以继续使用。当然如果感觉这样比较麻烦，那么可以在应用 D 本地数据中保留用户已经申请的设备，使得用户再次打开应用 D 时，可以看到以前申请的各种设备。但公司领导还是希望用户打开应用 D 之后，首先注册账号，以便把申请的设备保存到服务器端，然后本公司可以跟踪用户喜欢申请那些设备，以及使用时间长短等等。我也提出，这些问题也可以通过记录用户的操作，比如点击申请等来跟踪，但是注册不是必须的。还有很重要的一点，如果你要用户注册账号，你就要保证用户账号安全。近几年来，已经发生了不少大公司用户信息被盗取的案例。不幸的是本公司也在其列。 面对每天要登录的各种应用各种网站，我总是在想，苹果拥有那么多终端，那么多的用户账号，为什么不提供一种功能，类似 Open ID，不管是网页还是本地 APP，开发者只需要一个添加一句话，甚至只要在 APP 的配置中给予权限，用户就可以使用 Apple ID 一键该网站或者 APP。这是一种多么令人向往的美好。 关于 Open ID，国内用的比较多的，当属新浪微博，腾讯 QQ，校内网等等。令人郁闷的是很多网站在我使用 Open ID 首次登录以后，还让我填写昵称和邮箱，他妈的这和我重新注册账号有什么区别？？？使用新浪微博账号登录以后，还很有能会在我不知情的情况下，替我发条微博，趁机给自己的产品做个广告。让我的隐私暴露的体无完肤啊！！！你们能有点节操吗？ 顺便吐槽一下海丁网，每次报名参加一次讲座的时候，都要填写邮箱，手机号码，职位和公司名称。我从来没有见过这么 SB 的网站。 标题中还有一个词叫做注册强迫症，就是我看到一个新的网站，就想使用我的常用 ID 把它注册了。我有轻微的强迫注册症，但是这不妨碍我讨厌被强迫注册。我有三个常用 ID，第一个是被逼的没办法只能注册时，或者对网站内容或者网站所有者不屑时使用的 ID，再或者像上一段中提及的那些没有节操的网站，即便当时填写了一些个人信息，你可以想象，有多大的可信度，有多大的数据挖掘价值。第二个是全世界唯一的 UUID，用于常用 ID 已经被注册的情况。第三个是我真实姓名，用于我很喜欢的一些网站。有时候最初觉得某个网站不好，所以没有使用真实姓名注册，而后来越来越觉得好时，我还会使用真实姓名注册下来。我也会因为没有使用我的真实姓名注册到 gmail 邮箱而遗憾。所以从我的个人习惯来看，强迫用户注册真不是好主意。 真是希望网站开发者或者老板能够认识到这一点，你有好用的产品，有有价值的内容，还怕没有用户？]]></content>
  </entry>
  <entry>
    <title><![CDATA[通过 body 的 error 事件捕获页面中所有图片的 error 事件]]></title>
    <url>%2F2013%2F06%2F06%2FEvents-in-Capture-Phase%2F</url>
    <content type="text"><![CDATA[在 BDP 项目中，根据用户输入的关键字搜索视频并显示出来，后端返回的每条记录中有一个数组字段image_urls表示该视频的缩略图地址，它共有三种类型，分别是 small, medium 和 large。 1234567&#123; "image_urls": &#123; "small": "http://...", "medium": "http://...", "large": "http://..." &#125;&#125; 需求是：在显示该条记录时，如果有 small，就显示 small，没有 small 但是有 medium，就显示 medium，如果没有 small 和 medium 但是有 large，就显示 large。如果三者都没有，那么显示一个默认的图片。实现起来非常简单。如下： 12var default_icon = '/images/default_icon.png';item.icon = image_urls.small || image_urls.medium || image_urls.large || default_icon; 这个时候已经隐隐觉得不妥，因为给该缩略图的准备的位置只有 84*84px。也就是说 1234.icon &#123; max-width: 84px; max-height: 84px;&#125; 如果某条记录只有 large 缩略图，并且尺寸远远大于 84*84px，那么非常浪费带宽，对于性能很差的蓝光机浏览器来说，浏览器渲染若干张那么大的图片，使得性能更加低下。通知需求方以后，他们回复是这些记录有可能是从第三方服务获取，后端不可能准备合适尺寸的缩略图，但是他们又想尽可能显示缩略图，所以只能这样。 还有另外一个问题：当一条记录有 small 和 medium 缩略图，但是 small 缩略图地址是无效地址，此时并不会显示 medium 缩略图。跟需求方沟通这种情况能否接受，但是需求方没有妥协，他们希望越完善越好。希望后端不要返回无效的地址，因为这样第一做起来比较复杂，第二这样可能无故增加很多无效的 404 请求。但是后端的回复仍然是有些记录来自第三方服务，后端不会判断缩略图地址是否有效。所以这时候的需求就变成：在显示某条记录时，如果有 small 地址有效，那么显示 small，如果 small 地址无效，但是 medium 地址有效，那么显示 medium，如果 small 和 medium 地址都无效，但是 large 地址有效，那么显示 large，如果三者都无效，那么显示默认图片。 由于 img 的 error 事件并不会冒泡，只能分别处理，要在所有的 img 元素上都监听 error 事件真是令人头大。所幸我们使用基于字符串的模板引擎，onerror 方法只需写在模板中即可。实现如下。 1234567&lt;!-- use doT as template engine --&gt;&lt;img src="&#123;&#123;=item._src&#125;&#125;" images="&#123;&#123;=item._images&#125;&#125;" imageIndex="1" onerror="var images=this.getAttribute('images').split('|');var index=parseInt(this.getAttribute('imageIndex'),10);if(index&lt;images.length)&#123;this.src=images[index];this.setAttribute('imageIndex', index+1)&#125;"/&gt; 12345678910var images = [];var urls = item.image_urls;if (urls) &#123; if (urls.small) images.push(urls.small); if (urls.medium) images.push(urls.medium); if (urls.thumbnail) images.push(urls.thumbnail);&#125;images.push(default_thumb);item._images = images.join('|');item._src = images[0]; 就像我们想象中的一样，解决了问题。但是在《Javascript 权威指南（第六版）》中 17.2.2 节中提到，以上的做法有着坏味道，第一点，将 html 视图和 js 控制逻辑混和在一起；第二点，当指定一个字符串作为事件处理程序时，浏览器会做以下事情： 123456789function(event) &#123; with(document) &#123; with(this.form || &#123;&#125;) &#123; with(this) &#123; /* your code here */ &#125; &#125; &#125;&#125; 这样通过onXxx=&quot;&quot;属性绑定事件处理程序的方法是每一个热爱代码热爱前端的人所不能忍受的。 后来持续地在网上寻找更好的解决方案，终于老天开眼，找到下面这篇文章Error events don’t bubble from images and how to work around that，文章中指出在 W3C 的 DOM Level 2 规范中指定error 事件应该冒泡，但是只有 Opera 实现了这点。应该是由于其他的浏览器的反对，最后在 DOM Level 3 规范中取消的 error 事件的冒泡。作者还指出一种解决办法就是：使用 body 元素的捕获处理程序。 1document.body.addEventListener('error', handleResourceError, true); 顺便提及一下，作者最后提出&lt;body onerror=&quot;handleResourceError()&quot;&gt;相当于在 window 上注册了事件并可以监听到脚本（运行时）错误。这个论点在 Chrome27 没有 得到支持。 所以最后的比较完美的解决方案是： 1&lt;img src="&#123;&#123;=item._src&#125;&#125;" images="&#123;&#123;=item._images&#125;&#125;" imageIndex="1" /&gt; 123456789101112131415// 部分代码同上，略去document.body.addEventListener( 'error', function(e) &#123; var target = e.target; if (!target || target.tagName !== 'IMG') return; var images = target.getAttribute('images').split('|'); var index = parseInt(target.getAttribute('imageIndex'), 10); if (index &lt; images.length) &#123; target.src = images[index]; target.setAttribute('imageIndex', index + 1); &#125; &#125;, true); 在《Javascript 权威指南（第六版）》中 17.3.6 节中提到：事件传播的捕获阶段就像反向的冒泡阶段，一次调用 window，document，body…直至父节点之上的捕获处理程序，在目标对象绑定的捕获事件处理程序不会被调用。事件捕获提供了在事件还没有传播到目标节点之前查看他们的机会，可以用于调试，或者过滤事件。比如用于拖放，拖放的处理通常不是鼠标点击的目标元素。]]></content>
  </entry>
  <entry>
    <title><![CDATA[在DOM操作中，如何减少 reflow 或 repaint]]></title>
    <url>%2F2013%2F05%2F25%2FReduce-reflow-repaint%2F</url>
    <content type="text"><![CDATA[在这篇博客中，我们列举一些可以减少 reflow 或者 repaint 的方法。下面先讲述一下这两个概念。reflow，翻译为重排，意为重新布局。当一个元素的形状位置发生改变时，浏览器会对该元素以及子元素（也可能包括同级元素）进行布局和重绘。称之为重排。repaint，翻译为重绘。当一个元素的颜色等发生改变时，浏览器会对该元素进行重绘。为了减少重排和重绘，可以从以下几个方面着手。 批量增删节点通过elem.innerHTML批量删除和添加子节点。通过elem.insertAdjacentHTML批量添加子节点。通过创建一个 fragment 来批量添加子节点。123456var fragment = document.createDocumentFragment();for (var i = 0; i &lt; 10; i++) &#123; var div = document.createElement('div'); fragment.addChild(div);&#125;elem.appendChild(fragment); 通过创建一个 range 来批量删除一组连续节点。12345678function removeChildren(parent, start, end) &#123; var range = document.createRange(); var children = parent.children; range.setStartBefore(children[start]); range.setEndAfter(children[end]); children = null; range.deleteContents();&#125; 批量修改节点和样式通过修改 class 属性代替多次修改 style 属性不好的做法： 12elem.style.width = '200px';elem.style.height = '200px'; 较好的做法： 1234.another-style &#123; width: 200px; height: 200px;&#125; 1elem.className = 'another-style'; 将节点隐藏或者删除后，批量修改，然后再显示或者添加到 DOM 树中。不管修改了多少次，只重新布局两次。先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。尽量缩小修改的影响让对经常变化的节点脱离文档流，比如使用 absolute 或者 fixed 的 position。这样，当该节点重排时不会影响其以后的兄弟节点。少使用 table 布局，很小的改动会导致整个 table 的重新布局。访问 DOM 节点的某些属性比如 offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop/Left/Width/Height, clientTop/Left/Width/Height, getComputedStyle()等等，参考When does DOM access slow down rendering?。文章中也提到浏览器越来越聪明，会尽量避免这些不太必要的重排重绘。我暂时还不知道怎么验证是否发生了重排重绘。 留个问题，CSS3 Transition 动画能不能减少重排呢？重绘肯定是少不了的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】使用SVG]]></title>
    <url>%2F2013%2F05%2F18%2FUsing%20SVG%2F</url>
    <content type="text"><![CDATA[原文地址：css-tricks.com SVG 是一种矢量图片格式。字面意为可伸缩矢量图形（Scalable Vector Graphics）。也就是你通过 Adobe Illustrator 做出来的东西。在网页中可以很简单地使用 SVG，但是有些东西是你应该了解的。 为什么要使用 SVG？ 压缩量好，文件小 高保真伸缩到任意尺寸（除了尺寸很小的情况下会失真） 适合视网膜屏（retina）显示 Design control like interactivity and filters ###Getting some SVG to work with下图是在 Adobe Illustrator 中设计的一只鹬鸵站在一个椭圆上。Notice the artboard is cropped up right agains the edges of the design. Canvas matters in SVG just like it would in PNG or JPG. 在 Adobe Illusatrator 可以将图形直接保存为 SVG 文件。保存时，你会看到另一个关于 SVG 选项的对话框。关于这个对话框，我了解的不多。这里有一个SVG 说明书。SVG1.1 可以正常工作。最有趣的是你可以按下 OK 保存文件，也可以按下“SVG Code…”通过 TextEdit（在 Mac 上）打开 SVG 代码。 当做 img 使用 SVG如果刚才我将 SVG 保存到一个文件中，那么我现在可以将它用在一个 img 标签中。 1&lt;img src="kiwi.svg" alt="Kiwi standing on oval" /&gt; 在 Illustrator 中，绘图板大小是 612x502px。以下是该图片在网页中显示尺寸。你可以选择 img 节点并修改其 width 或者 height 来改变其大小，就跟 PNG 或 JPG 图片一样。这儿有一个例子。 浏览器支持情况这样使用 SVG 要注意它的浏览器支持情况总体来讲，除了 IE8 及以下，Android2.3 及以下都支持的很好。 如果你想使用 SVG，但是又要支持这些不支持 SVG 的浏览器，你有一些选择，在包含了一些我使用过的一些技术。 一个方法是通过 Modernizr 测试是否支持冰替换 img 的 src 属性。 123if (!Modernizr.svg) &#123; $('.logo img').attr('src', 'images/logo.png');&#125; David Bushell 提出了一个更简单的方法。如果可以在标签中使用 javascript。 1&lt;img src="image.svg" onerror="this.onerror=null; this.src='image.png'" /&gt; SVGeezy也很有用，在以下文章中我们会讲到更多的 fallback 技术。 作为 background-image 使用 SVG跟将 SVG 作为 img 使用一样简单，也可以将它作为 backgorund-image。 1&lt;a href="/" class="logo"&gt; Kiwi Corp &lt;/a&gt; 12345678.logo &#123; display: block; text-indent: -9999px; width: 100px; height: 82px; background: url(kiwi.svg); background-size: 100px 82px;&#125; [未完]]]></content>
  </entry>
  <entry>
    <title><![CDATA[【翻译】Webkit图片擦拭效果]]></title>
    <url>%2F2013%2F05%2F10%2FWebkit-Image-Wipes%2F</url>
    <content type="text"><![CDATA[来源Webkit 浏览器支持遮罩，虽然它还不是标准。就像 PhotoShop 中一样，你声明一张图片作为遮罩，黑色部分是不透明的，将会遮住其后面的元素。白色部分透明，其后面的元素是可见的。灰色部分是半透明的。所以下面的图片： 1&lt;img src="orig.jpg" alt="trees" class="circle-mask" /&gt; 以及遮罩图片：应用如下 CSS： 123.circle-mask &#123; -webkit-mask-box-image: url(mask.png);&#125; 将会得到如下效果： ###遮罩并不一定要真正的图片这里用到的第一个技巧是，声明为遮罩webkit-mask-box-image的图片并不是真正的图片，而是使用-webkit-gradient来实现。当然我们可以使用渐变创建一张图片，但是通过编程创建渐变遮罩更容易修改，并且减少一次 HTTP 请求。 123456789101112-webkit-mask-position: 0 0;-webkit-mask-size: 200px 200px;-webkit-mask-image: -webkit-gradient( linear, left top, right bottom, color-stop(0, rgba(0, 0, 0, 1)), color-stop(0.45, rgba(0, 0, 0, 1)), color-stop(0.5, rgba(0, 0, 0, 0)), color-stop(0.55, rgba(0, 0, 0, 0)), color-stop(1, rgba(0, 0, 0, 0))); 在以上的 CSS 中，我们创建了一个 200X200 像素的图片，顺着 45 度角方向，从左上角的完全不透明，到差不多一半的地方渐变到完全透明。就像下面的图片： ###移动遮罩在上面我们通过-webkit-mask-position设置遮罩的位置，因为可以设置其位置，所以也就可以移动它。我们可以在:hover伪类上移动， 123456.circle-mask &#123; -webkit-mask-position: 0 0;&#125;.circle-mask:hover &#123; -webkit-mask-position: -300px -300px;&#125; 也可以使用-webkit-animation来自动移动遮罩。 12345678910111213@-webkit-keyframes wipe &#123; 0% &#123; -webkit-mask-position: 0 0; &#125; 100% &#123; -webkit-mask-position: -300px -300px; &#125;&#125;.circle-mask &#123; -webkit-animation: wipe 6s infinite; -webkit-animation-delay: 3s; -webkit-animation-direction: alternate;&#125; ###创建擦拭效果我相信聪明的你已经将他们联系在一起。这个主意就是将一张图片放在另一张图片上面，上面的图片作为遮罩，根据需要移动遮罩。 1234&lt;div id="banner"&gt; &lt;div&gt;&lt;img src="images/banner-1.jpg" alt="Skyline 1" /&gt;&lt;/div&gt; &lt;div&gt;&lt;img src="images/banner-2.jpg" alt="Skyline 2" /&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829#banner &#123; width: 800px; /* Size of images, will collapse without */ height: 300px; position: relative; /* For abs. positioning inside */ border: 8px solid #eee; -webkit-box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.75);&#125;#banner div &#123; position: absolute; /* Top and left zero are implied */&#125;/* Second one is on top */#banner div:nth-child(2) &#123; -webkit-animation: wipe 6s infinite; -webkit-animation-delay: 3s; -webkit-animation-direction: alternate; -webkit-mask-size: 2000px 2000px; -webkit-mask-image: -webkit-gradient( linear, left top, right bottom, color-stop(0, rgba(0, 0, 0, 1)), color-stop(0.45, rgba(0, 0, 0, 1)), color-stop(0.5, rgba(0, 0, 0, 0)), color-stop(0.55, rgba(0, 0, 0, 0)), color-stop(1, rgba(0, 0, 0, 0)) );&#125; ###示例和下载在下载文件中，有另一个例子，水平方向上擦拭而不是顺着某个角度，并且使用-webkit-transition而不是动画。查看例子下载 ###比两个更多？我花了更多时间在尝试能否连续擦拭三张照片。这是可能的但是我不能让它足够平滑，以及像我想象的那么方便，所以我放弃了。我仍然非常确信这是可以的，也许使用两个不同的有着不同延迟的动画。如果你尝试了并成功了，一定要给我看看。 ###更多要了解更多请查看 webkit 在 2008 年的一个关于遮罩的通告，那里有很多有用的信息，比如遮罩图片可以伸展（像full page backgrounds）以及重复。实际上他的作用和带有九宫格border-image有很大相似之处， ###Credit我从Doug Neiner那里偷来了这个想法，他给我展示了一些关于这些想法的例子。经他允许发此文章。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS3 Transition过渡属性探索]]></title>
    <url>%2F2013%2F04%2F27%2FCSS3-Transition-Research%2F</url>
    <content type="text"><![CDATA[背景介绍在前面的文章蓝光机 WebApp-无尽列表优化中提到无尽列表，通过上下键可以查看前两个或者后两个记录。这时候需要做出动画效果。 解决问题这里首先要说明 Opera 的一个问题，Opera 从 9.8 版本以后就定格为 9.8，如果要查看其真正版本，只有通过其 UserAgent 中‘Version/12.11’类似的文本来确定。在Oprea 的怪异识别码说明了这一问题的由来。 Opera 的工程师在测试中发现，Opera 10 Alpha 在很多老网站上的运作很不正常。原来，有很多网站使用了“浏览器嗅探”技术，也就是说网站会针对不同的浏览器提供不同的内容或功能。然而不幸的是，这些网站无法识别两位数的浏览器版本号，于是 Opera 就成了首当其冲的受害者——它们把 Opera 10.0 误认为是 Opera 1.0，并因此向 Opera 10 提供不完整的功能，甚至有些网站干脆拒绝 Opera 10 的访问。这当然是 Opera 不愿意看到的。于是，Opera 的工程师们决定，将用户代理信息中的版本号定格在 9.8，并另外启用 Version 字段来标识真正的版本号。当然他们也考虑过选用 9.99 这个最接近 10 的可用作版本号的数字，不过出于预留空间的考虑，最终还是决定采用 9.8 作为象征性的版本号——它正好介于（Opera 9 的最后一个版本号）9.6 与 10 之间。 正是因为 Opera 这么委曲求全的决策，所以一直以为蓝光机中是 Opera9.8。而很多 CSS3 特性都不被 Opera9.8 支持。包括我们这里将会被用到的 CSS3 Transition。所以很自然地使用 jQuery 提供的 animate 方法实现。 1234// top from 0 to 94$list.animate(&#123; top: top &#125;, 'fast', function() &#123; // do some thing&#125;); 在蓝光机中该动画只会执行三步，分别是 top = 0, ~59, 94px，所以会给人一种很不平滑的感觉。 很长时间以后才注意到蓝光机中的浏览器是 Opera12.11. 然后开始尝试使用 CSS3 Transition。 1transition: top 300ms linear; 1$list.css('top', top); 以上动画效果在桌面浏览器上运行的非常好，但是在蓝光机上依然没有明显改善，反而感觉有点晃动。优化失败。 在尝试将其他部分动画也使用 CSS3 Transition 时发现一个问题，就是修改某个属性之前，如果该属性没有显式声明，那么各个浏览器处理方式不同。以 width 为例，这时通过elem.style.width得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。这个小问题让我耽误了不少时间。 ###使用方法 transition ： [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; || &lt;’transition-timing-function’&gt; || &lt;’transition-delay’&gt; [, [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; || &lt;’transition-timing-function’&gt; || &lt;’transition-delay’&gt;]]_或者transition-property ： none | all | [ ][ ‘,’ ]；transition-duration ： [, ]transition-timing-function ： ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , ) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(, , , )]_transition-delay ： [, ]* transition-property 支持的属性参见W3C 标准。transition-duration 和 transition-delay 支持如1s，200ms的值。 ###总结 CSS3 Transition 可以在设置 CSS 属性时使其效果平滑过渡，但是过渡过程中，通过elem.style.attr获取其相应属性值时，得到的都是其最终值，这点和 jQuery 实现的动画效果不同。 如果属性值为显式声明时，各个浏览器处理方式不同。以 width 为例，这时通过elem.style.width得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。 Opera 在 9.8 版本以后就将版本定格为 9.8，在以后的 Opera 版本中只能通过其 UserAgent 中的’Version/12.11’之类的字符串来确定其版本号。 如果设置的属性值跟设置前一样，那么并不会触发 transitionend。这点需要特别注意。]]></content>
  </entry>
  <entry>
    <title><![CDATA[在客户端高亮关键字]]></title>
    <url>%2F2013%2F04%2F24%2FHighlight-Keywords-in-Client%2F</url>
    <content type="text"><![CDATA[背景介绍在某个项目中遇到这样的需求，用户输入几个关键字，然后根据关键字去后端搜索相关记录。后端返回记录中但是没有高亮这些关键字，这就需要前端来做这件事。按道理，高亮应该由后端完成，因为后端如何解析这些关键字，也知道如何去匹配，前端不知道也不应该知道后端为什么返回这些结果，英语中名词有复数形式，动词有现在式，过去式，过去完成式等，其他诸如德语，葡萄牙语有没有词性变换更是不得而知。后端依赖强大的知识库可以处理词性变换甚至近义词都是可能的，前端不可能完成工作，即便可能，也远比后来来处理高亮要复杂的多。但是这就是客户需求，我们还是要实现。 整个流程：获取用户输入，比如 ‘search by keyword’，发送 JSONP 请求获取后端搜索到的记录。在关键的几个字段中，搜索‘search’，‘by’和‘keyword’这三个关键字，并在单词两边分别加上&lt;span class=&quot;highlight&quot;&gt;和&lt;/span&gt;，给.highlight定义一个合适的样式，比如粗体等，就完成了高亮的效果。 步骤第一步，首先把关键字用空白符分隔开，得到一个一个的关键字。 1var keywords = keyword.split(/\s+/); 第二步，将第一步中得到的字符串数组，转变成正则数组。 12345keywords.map(function(it) &#123; // g replace all // i case-insensitive return new RegExp(it, 'gi');&#125;); RegExp 的第一个参数是传 it 呢，还是&#39;\b&#39; + it + &#39;\b&#39;呢？如果是前者，关键字a可以匹配take中的a。如果是后者，teach不可以匹配teaches中的teach。都不完美，这也是在文章开头提及的不适合前端做高亮的原因。如果你够细心，你应该已经感觉到隐隐有些不妥，因为在通过 RegExp 创建正则表达式时，第一个参数不能包含正则中预定义的一些字符，除非在前面加上了一个反斜线，比如[?就不可以，而\[\?才是真正地匹配[?。所以在这之前，我们添加一步： 第〇步：给所有的正则预定义字符之前添加一个反斜线（backslash）。找出所有的预定义字符char并替换为&#39;\\&#39; + char。通过强大的String.prototype.replace方法很方便的完成。 123keyword = keyword.replace(/[\\\&#123;\&#125;\[\]\(\)\*\+\?\^\$\,\-\=\!]/g, function(char) &#123; return '\\' + char;&#125;); 需要特别说的是，还有一处可以改进。在前面的一片文章【正则表达式】使用逗号将数字三位三位地分开中，我们使用了零宽断言。它匹配了这样一个位置（是为零宽），它后面的字符满足一定条件（是为断言）。在这里，我们可以使用正则表达式匹配预定义字符前面的位置，将该位置替换为&#39;\\&#39;。 1keyword = keyword.replace(/(?=[\\\&#123;\&#125;\[\]\(\)\*\+\?\^\$\-\=\!])/g, '\\'); 换了一种思路，顿时感觉清爽多了。 第三步，遍历正则数组，然后替换所有的关键字。 12345keywords.forEach(function(it) &#123; string = string.replace(it, function(val) &#123; return '&lt;span class="highlight"&gt;' + val + '&lt;/span&gt;'; &#125;);&#125;); 如果你足够细心或者以前遇到过类似问题，你可能已经知道，这一步中隐藏着一些问题，就是如果用户在一次搜索中，输入了两个相同的关键字，比如take take，那么匹配以后可能会出现&#39;&lt;span class=&quot;highlight&quot;&gt;&lt;span class=&quot;highlight&quot;&gt;take&lt;/span&gt;&lt;/span&gt;&#39;这种情况，不会出错，只是浏览器需要多创建一些 DOM 元素。更甚的是，当用户输入多个关键字以后，第一次替换时会引入&#39;&lt;span class=&quot;highlight&quot;&gt;&#39;和&#39;&lt;/span&gt;&#39;片段，这两段字符是不应被匹配并替换的。比如替换字符是&#39;programer&#39;，关键字是&#39;a span&#39;，匹配关键字a以后，变成 1progr&lt;span class="highlight"&gt;a&lt;/span&gt;mer 匹配关键字span以后： 1progr&lt;&lt;span class="highlight"&gt;span&lt;/span&gt; class="highlight"&gt;a&lt;/&lt;span class="highlight"&gt;span&lt;/span&gt;&gt;mer 完全乱套了。为了保证以上span两端字符不会被匹配并替换，有一种做法是仅仅记住需要插入span的位置，并延迟替换。如果记住位置，考虑使用一种基本不会被用到的字符，比如 0X2611(☑)以及 0X2612（☒）。 12345keywords.forEach(function(it) &#123; string = string.replace(it, function(val) &#123; return String.fromCharCode(0x2611) + val + String.fromCharCode(0x2612); &#125;);&#125;); 匹配关键字a以后，变成 1progr☑a☒mer 匹配不到span字符串，匹配结束。 最后再将这两个特殊符号替换为&#39;&lt;span class=&quot;highlight&quot;&gt;&#39;和&#39;&lt;/span&gt;&#39;，在正则中使用+，可以匹配多个特殊字符，也就解决了用户输入输了两个以上相同的关键字并造成浏览器额外创建span元素的情况，当然你也可以再一开始就去重。所以最终正确结果是 1string = string.replace(/\u2611+/g, '&lt;span class="highlight"&gt;').replace(/\u2612+/g, '&lt;/span&gt;'); 1progr&lt;span class="highlight"&gt;a&lt;/span&gt;mer 以上答案正确与否，取决于 ☑ 和 ☒ 会不会出现在被替换文字中。 最终代码12345678910111213var keyword = input.value;var string = 'The string will be highlighted'；// replace all preserved characters in regular express.keyword = keyword.replace(/(?=[\\\&#123;\&#125;\[\]\(\)\*\+\?\^\$\-\=\!])/g, '\\');// split keyword by space characters.var keywords = keyword.split(/\s+/);keywords.forEach(function(it)&#123; string = string.replace(it, function(val)&#123; return String.fromCharCode(0X2611) + val + String.fromCharCode(0X2612); &#125;);&#125;);string = string.replace(/\u2611+/g, '&lt;span class="highlight"&gt;') .replace(/\u2612+/g, '&lt;/span&gt;'); 123.highlight &#123; font-weight: bold;&#125; 总结 高亮根据关键字搜索出来的记录不适合在客户端做，即时实现了，很可能是该高亮的没有高亮，不该高亮的高亮了。后端可以依靠巨大的知识库来高亮词性变换后的单词，甚至近义词。 使用好强大的String.prototype.replace方法。 正则中零宽断言在适当的时候，可以简化代码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用 drawImage 和 putImageData 缓存 Canvas 中间数据]]></title>
    <url>%2F2013%2F04%2F22%2FCanvas-drawImage-vs-putImageData%2F</url>
    <content type="text"><![CDATA[API12345void drawImage(Object image, float dx, float dy[float dw, float, dh]);void drawImage(Object image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);ImageData getImageData(float sx, float sy, float sw, float sh);void putImageData(ImageData imageData, float dx, float dy[, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight]); drawImage 的第一个参数可以是 HTMLImageElement（绘图），HTMLCanvasElement（复制）或者 HTMLVideoElement（截屏）。 缓存 Canvas 中间数据如果我们需要在一个 Canvas 上画很多图片，其中一部分是固定（或短期内固定）存在的，那么最好的办法是将他们绘制完毕之后，将他们保存起来，等下一次需要绘制这些图片的时候，一次性绘制缓存结果。这样可以减少渲染次数，以提高渲染效率。首先想到的是 getImageData 和 putImageData。所以做了如下测试： 123456789101112131415var repeat_times = 10000;console.time('drawImage');for (var i = 0; i &lt; repeat_times; i++) &#123; context.drawImage(image, 0, 0);&#125;console.timeEnd('drawImage');console.time('putImageData');context.drawImage(image, 0, 0);var data = context.getImageData(0, 0, image.width, image.height);for (var i = 0; i &lt; repeat_times; i++) &#123; context.putImageData(data, 0, 0);&#125;console.timeEnd('putImageData'); 简单起见，这里我们仅仅绘制一张图片。打印出来的结果完全出乎意料，putImageData 非但没有更快，反而比 drawImage 慢 600 倍左右。至于为什么会这么慢，我还不知道答案。总之 putImageData 远远不是我想象中的那么高效。后来才考虑到可以将 Canvas 中的数据缓存到某个隐藏 Canvas 中去，然后再调用 DrawImage 方法。 123456789console.time('drawCanvas');var buffer = document.createElement('canvas');buffer.width = canvas.width;buffer.height = canvas.height;context.drawImage(image, 0, 0);for (var i = 0; i &lt; repeat_times; i++) &#123; context.drawImage(buffer, 0, 0);&#125;console.timeEnd('drawCanvas'); 经过测试以后发现比 drawImage 方法慢了一倍，相对于 10000 次循环，这点性能损失可以忽略不计，因为我们仅仅绘制一张图片。图片的数目每增加 1，drawImage 绘图次数增加 10000，而 drawCanvas 绘图次数仅仅增加 1。 小结putImageData的优点在于能够像素级别操作图像，但是因其效率很低，并不适合做 Canvas 的数据缓存，而drawImage(canvas, 0, 0)较为适合。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【正则表达式】使用逗号将数字三位三位地分开]]></title>
    <url>%2F2013%2F04%2F15%2FGrouping-Numbers-with-Comma%2F</url>
    <content type="text"><![CDATA[背景介绍在一个项目中，需要显示一个 YouTube 视频被观看了多少次，这个数字一般是个很长的数字，为了更好的体验，也是国际标准，三位三位地断开，对应千（thousand），百万（million），十亿（billion），当然对中国用户来讲，不是特别友好，中国人喜欢四位四位隔开，对应万，亿，万亿。。。但是无论如何，都比看到 567232349723 这样的一串数字好很多。言归正传，这个该如何实现呢？以下就以 567232349723 数字为例。 普通的解决办法首先，可以这样理解，就是从数字的最后一位开始，往前数，数到 3，加一个逗号，如此循环下去……直到第一个数字（因为逗号不能加在开始位置，比如不能“,123”）。 1234567var array = '567232349723'.split('');for (var i = array.length - 1, j = 1; i &gt; 0; i--, j++) &#123; if (j % 3 === 0) &#123; array.splice(i, 0, ','); &#125;&#125;console.log(array.join('')); 受不了了，看似特别简单的问题，要写那么长一段代码。从标题你就看到了，这不是我们想要的答案，我们将要使用正则表达式来解决这个问题。首先来明确几个概念： 零宽断言（零宽度正预测先行断言）：形式为(?=exp)。零宽，就是不匹配任何内容，明确一点就是它表示的是一个位置，就像^, \$一样。断言，就是说它需要满足一定条件。 负向零宽断言（零宽度负预测先行断言）：形式为(?!exp)。所谓负向，就是不满足某种条件。 这两个别名都含有“先行”二字，它表示匹配的位置是表达式前面的位置。这么说来，肯定还会有一种用于匹配表达式后面的位置。你说的对，还有“零宽度正回顾后发断言”，形式为(?&lt;=exp)，以及“零宽度负回顾后发断言”，形式为(?&lt;!exp)。但是在 javascript 中并不支持这两中形式。这次不多说明。 ###正则表达式办法我们现在看看哪些位置需要添加逗号，首先这个位置不能是开始位置，也就是(?!^)，其次这个位置后面总是有 3n（n &gt; 0）个数字，直到结束，也就是(\d{3})+$，组合起来就是(?=(?!^)(\d{3})+$)。 所以答案就是 1'567232349723'.replace(/(?=(?!^)(\d&#123;3&#125;)+$)/g, ','); 注意了，以上正则对于整数已经足够了，加入你想也适应于小数呢？比如“123456.123456”，这时候我们只处理前面几位，所以上面的“直到结束”应该修改为“直到结束或者小数点”，那么答案来了，就是[$\.]，所以适用于小数的正则为 1'567232.49723'.replace(/(?=(?!^)(\d&#123;3&#125;)+[$\.])/g, ','); 如果想适用更多情况，会使得你的正则越来越复杂，也越来越容易出错，所以要根据你实际需要来决定，不多不少最好。 工具推荐 http://www.regexper.com/ Windows 系统上的RegExpBuddy，收费约 40 美元。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用别样的鼠标形状]]></title>
    <url>%2F2013%2F04%2F12%2FUsing-an-Especial-Cursor%2F</url>
    <content type="text"><![CDATA[某些时候，我们并不使用 CSS 中支持的鼠标形状，比如 default 箭头，pointer 手型等等，也不使用 url 指定鼠标形状，而是使用 html+css+js 渲染。例如在黑色背景的页面中，使用一个从圆心到周边透明度径向渐变的圆形图形作为鼠标形状。实现起来非常简单。首先在 html 元素上声明如下样式html{ cursor: none; }，放弃默认的箭头鼠标形状。然后创建一个绝对定位的，className 为 cursor 的 body 子元素 div。 方案一：渐变背景色实现【失败】12345678div.cursor &#123; position: absolute; width: 150px; height: 150px; margin-top: -75px; margin-left: -75px; background: -webkit-radial-gradient(50% 50%, circle contain, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));&#125; 但是这样就有一个问题，当按下鼠标时，mouse 事件的 target 属性永远指向该 DIV 元素。如果想监听页面上其他元素的 mouse 事件，就变得很繁琐，只能根据。于是首先想到的是用after 伪元素实现。 方案二：伪元素背景色实现【失败】1234567891011121314div &#123; position: absolute; width: 0; height: 0;&#125;div:after &#123; position: absolute; content: ''; width: 150px; height: 150px; margin-top: -75px; margin-left: -75px; background: -webkit-radial-gradient(50% 50%, circle contain, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));&#125; 实现以后发现 mouse 事件的 target 属性仍然指向该 div 元素。思考一下，这个是符合逻辑的，因为 first 和 after 伪元素本来就相当于子元素的。 方案三：box-shadow 效果实现【成功】也许你还记得，很多阴影效果都有模糊渐变的效果，在 box-shadow 语法中，blur 配合 spread 就可以做到。语法：box-shadow: h-shadow v-shadow blur spread color inset; 123456div &#123; position: absolute; width: 0; height: 0; -webkit-box-shadow: 0 0 75px 30px #000;&#125; 效果基本可以实现，但是对于更加特别的需求，就怕无能为力了。 方案四：CSS 属性 pointer-events 使得元素不响应事件【最佳】事件可以透过（忽视）pointer-events 值为 none 的任何元素，而触发在它后面的那个元素之上。 1pointer-events: none;]]></content>
  </entry>
  <entry>
    <title><![CDATA[脱离 UI 线程的 CSS3 动画]]></title>
    <url>%2F2013%2F04%2F11%2FCSS-animations-off-the-UI-thread%2F</url>
    <content type="text"><![CDATA[【原文】CSS animations off the UI thread我们知道浏览器是单线程的，在执行 js 脚本期间，UI 会被冻结，用户行为也得不到响应。也就是所谓的“假死”现象。在最新版本的浏览器中，开启了一种新的实现，将 CSS3 动画移出 UI 线程。 测试结果 Win7 上 Chrome25 支持 iOS6 上 Chrome 和 Safari 支持 原文中提到 IE10（估计是 Win8 上），Firefox OS 支持。 测试方法点击我打开测试页面。点击按钮以后，javascript 脚本持续执行 2 秒，在这个过程中查看红蓝绿三个方块的效果。如果三个均停止动画，说明浏览器尚不支持将 CSS transform 动画移出 UI 线程，如果红色和绿色方块继续动画，则支持。 解释红色方块的动画如下 1234567891011.spin &#123; animation: 3s rotate linear infinite;&#125;@keyframes rotate &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125;&#125; 绿色方块的动画如下 1234567891011121314.walkabout-new-school &#123; animation: 3s slide-transform linear infinite;&#125;@keyframes slide-transform &#123; from &#123; transform: translatex(0); &#125; 50% &#123; transform: translatex(300px); &#125; to &#123; transform: translatex(0); &#125;&#125; 蓝色方块的动画如下 1234567891011121314.walkabout-old-school &#123; animation: 3s slide-margin linear infinite;&#125;@keyframes slide-margin &#123; from &#123; margin-left: 0; &#125; 50% &#123; margin-left: 100%; &#125; to &#123; margin-left: 0; &#125;&#125; 结论如果有可能，尽量使用 CSS3 transform 动画。这些动画脱离了主线程，不影响主线程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[蓝光机WebApp-无尽列表优化]]></title>
    <url>%2F2013%2F04%2F07%2FBlue-ray-Web-App-Endless-List-Optimization%2F</url>
    <content type="text"><![CDATA[背景介绍该项目是一个运行于蓝光机内置浏览器 Opera 之上的单页面 WebApp，输入关键字，跨服务（视频，音频，Youtube 等）查询媒体内容。由于所有操作都是通过遥控器完成，所以通常可以使用的操作基本只有按键：上下左右以及返回键，确定键。为了显示不确定数量的媒体项，采用了通过向下/向上键来控制显示更后面/更前面的记录。使用的框架包括，使用requirejs动态加载脚本，使用jQuery操作 DOM，使用doT作为模板引擎。 优化历程分析一：根据一般的 WebApp 开发经验知道，不可能在一个页面中显示所有的媒体项。有必要分页显示。但是每页显示多少呢？通过对蓝光机的实机测试，每页显示 30 个项目，另外根据 UI 设计每屏最多显示 12 条。 方案一：首先显示第一个 30 条（0-29），随着用户按下向下键，当要显示第 30 条记录的时候，使用$container.html($(str))显示第 18-47 条，当需要显示第 48 条的时候，使用$container.html($(str))显示第 36-65 条……依次类推下去现象一：桌面浏览器没有问题，但在蓝光机中会出现闪烁，即在某个时刻页面中没有任何内容。所有的蓝光机概率为~95% 分析二：这种现象的原因很简单，$container.html($(str))确实做了一个清空容器的操作，如果性能较差，会出现闪烁现象。 方案二：显示新纪录时，当前显示在页面中 12 条记录保持不变，使用$container.find(&#39;:lt(18)&#39;).remove()去掉前面 18 条记录，再使用$container.append($(str))添加后面的 18 条记录。 现象二：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 ~20%，在较差的蓝光机中概率为 ~50% 分析三：以上仍然使用 jQuery 封装的 find，remove 以及 append 方法，这些方法的实现还是相当复杂，做了太多无用的工作。方案三：使用原生的 DOM 操作方法document.createDocumentFragment()创建一个文档片段，批量添加记录。现象三：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 ~1%，在较差的蓝光机中概率为 ~15% 分析四：仍然使用了$container.find(&#39;:lt(18)&#39;).remove()去掉前面 18 条记录，这里remove方法可以导致$container这部分内容18次的重排重绘。 这是因为并没有找到和document.createDocumentFragment相似的可以批量删除DOM节点的方法。 在桌面浏览器，移动浏览器常用的方法，比如首先将$container 从 DOM 树中删除，执行一系列的删除操作之后再添加到 DOM 树中，都会导致更频繁的闪烁现象。在即将放弃该项优化的时候，脑子里突然冒出了一个从来没有使用过的方法。既不清楚能够解决该问题，也不知道如何使用该方法，只知道这个方法通常用在富文本编辑器中，好像可以批量操作元素。 方案四：使用document.createRange批量删除元素。 12345678function removeChildren(parent, start, end) &#123; var range = document.createRange(); var children = parent.children; range.setStartBefore(children[start]); range.setEndAfter(children[end]); children = null; range.deleteContents();&#125; 现象四：桌面浏览器以及所有的蓝光机中均没有闪烁现象。 最后又发现elem.insertAdjacentHTML的执行效率在蓝光机上优于document.createDocumentFragment，基本上前者耗时是后者的 50%，但是不解的是在 Chrome26/Windows7 上前者耗时略高于后者。由于目标设备是蓝光机，所以这次优化成功，可以使用elem.insertAdjacentHTML。elem.insertAdjacentHTML第一个参数是字符串，表示插入位置，共有四个可选值，如下表说明（来源：Javascript 权威指南，P379）。第二参数也是字符串，表示要插入的 HTML 字符串。 123&lt;div id=&quot;target&quot;&gt;This is the element content&lt;/div&gt;↑ ↑ ↑ ↑beforebegin afterbegin beforeend afterend]]></content>
  </entry>
</search>
