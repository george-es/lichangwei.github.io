---
title: ES5简介
---

这是我组织的ES6特性分享的预热篇，主要介绍ES5的特性。

## 既是入门，又是回顾
* 相信很多人还没有完全在项目中使用

* `2011`年正式发布的`IE9`实现了几乎所有`ES5`的特性
* `ES6`，`ES7`……都已经或将要来了

## ES5中最有用的特性：JSON

### JSON简介
![Douglas Crockford](https://c2.staticflickr.com/4/3002/3117853012_9b2b508e94_b.jpg)
1. Douglas Crockford在2002年创建，
1. JSON JavaScript对象标记（Notation）
2. JavaScript语言的一个子集
3. 一种轻量级的数据交换格式
4. 易于人阅读和编写，同时也易于机器解析和生成。

更多细节：[RFC7159](http://www.ietf.org/rfc/rfc7159.txt)，[ECMA-404](http://www.ecma-international.org/publications/standards/Ecma-404.htm)，[介绍 JSON](http://json.org/json-zh.html)

### 那段不堪回首的过去
```javascript
var data = eval('(' + response + ')');
```
或
```xml
<script src="/javascript/json2.js"></script>
<script>
var data = JSON.parse(response);
</script>
```

### JSON.stringify(value[, replacer [, space]])
```javascript
var obj = {a: 'x', b: {c: 1}};
var string = JSON.stringify(obj);
//
var string = JSON.stringify(obj, function(key, value){
        return typeof value === 'number' ? 0 : value;
    });
console.log(string); //{"a":"x","b":{"c":0}}

//美化JSON
var string = JSON.stringify(obj, null, '\t');
var string = JSON.stringify(obj, null, 2);
console.log(string);

obj.toJSON = function(){return 'something';};
var string = JSON.stringify(obj);
console.log(string); //nothing
```

### JSON.parse(text[, reviver])
```javascript
//将字符串解析成JSON对象
var data = JSON.parse('{"a":1,"b":{"c":1}}');

//将字符串解析成JSON对象，并对象中的每个数值加1
var data = JSON.parse('{"a":1,"b":{"c":1}}', function(key, value){
            console.log(key, value);
            return typeof value === 'number' ? value + 1 : value;
        });
console.log( JSON.stringify(data) ); //{"a":2,"b":{"c":2}}
```

### JSON 用法举例
1. 解析JSON格式的AJAX响应
2. localStorage，sessionStorage只能存储字符串
3. PHP使用Spidemonkey引擎创建JS上下并输入数据

### JSON 的替代协议 Protocol Buffers
[Protocol Buffers](https://developers.google.com/protocol-buffers/)，[Github](https://github.com/google/protobuf)
![Protocol Buffers 截屏](../../../../images/protocol-buffers.png)

### JSON 的替代协议 MessagePack
[MessagePack](http://msgpack.org/)
![MessagePack 截屏](../../../../images/message-pack.png)

## ES5中最强大的特性：Object扩展
以下是ES5对Object对象的所有扩展
```
Object.defineProperty
Object.defineProperties
Object.create
Object.getPrototypeOf
Object.keys
Object.seal
Object.freeze
Object.preventExtensions
Object.isSealed
Object.isFrozen
Object.isExtensible
Object.getOwnPropertyDescriptor
Object.getOwnPropertyNames
```

### Object.defineProperty(obj, prop, descriptor)
直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。
```javascript
var obj = {};
Object.defineProperty(obj, 'key', {
        value: 'val', //默认 undefined
        configurable: false, //默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改
        enumerable: false, //默认 false，属性是否可以枚举
        writable: false, //默认 false，能够使用赋值运算符改变属性值
        get: function(){
            return this.value;
        },
        set: function(newValue){
            this.value = newValue;
        }
    });
//以上代码仅为示例，get/set不能和value，writable同时出现。
```

### Object.defineProperty 数据描述符 configurable

```javascript
var obj = {};
Object.defineProperty(obj, 'key', {
        value: 'val',
        // 默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改
        configurable: true
    });

Object.defineProperty(obj, 'key', {value: 'changed', configurable: false});
console.log(obj.key); //changed

try{
    Object.defineProperty(obj, 'key', {
        configurable: true
    });
}catch(e){ console.log(e); } //TypeError: Cannot redefine property: key(…)

delete obj.key;
console.log(obj.key); //changed
```

### Object.defineProperty 数据描述符 enumerable

```javascript
var obj = {};
Object.defineProperty(obj, 'key', {
        value: 'val',
        enumerable: false, // 默认 false，属性是否可以枚举
    });

console.log(obj.propertyIsEnumerable('key')); // false

console.log( Object.keys(obj) ); // []
for(var k in obj){
    console.log(k); //什么也不会打印
}
```

### 使用Object.defineProperty调试
```
function debugObject(obj, key){
    //将相应值保存起来
    var value = obj.key;
    //重新定义该属性
    Object.defineProperty(obj, key, {
            get: function(){
                return value;
            },
            set: function(val){
                debugger;
                value = val;
            }
        });
}
```
在ES7草案中，还有一个方法`Object.observe(ob, callback)`可以更加方便地监听对象变化。

### Object.defineProperties(obj, props)
添加或修改1+个属性，并返回该对象。
```javascript
var obj = {};
Object.defineProperties({
        'key1': {
            writable: false
        },
        'key2': {
            enumerable: false
        }
    })
```

### Object.create(prototype, descriptors)
```javascript
var Man = {
    race: function(){ console.log('race'); }
};
var peter = Object.create(Man, {
        firstName: {value: 'Xiaoming'},
        lastName: {value: 'Li'},
        fullName: {
            get: function(){
                return this.firstName + ' ' + this.lastName;
            }
        }
    });
console.log(peter.fullName); // Xiaoming Li
```

### Object.create(prototype, descriptors)
```javascript
var obj = Object.create(null);

console.log( Object.keys(obj) ); //[]

console.log( typeof obj ); //object

console.log( Object.prototype.toString.call(obj) ); //[object Object]

console.log( obj instanseof Object ); //false
```

### Object.getOwnPropertyDescriptor(obj, prop) 获取属性描述符
```javascript
var obj = {a: 1};
    Object.defineProperty(obj, 'b', {
            //value: 2,
            enumerable: false,
            get: function(){ return 1; }
        });

console.log( Object.getOwnPropertyDescriptor(obj, 'a') );

var descriptor = Object.getOwnPropertyDescriptor(obj, 'b');
console.log(descriptor);
```

### Object.getOwnPropertyNames(obj) 获取所有自有属性名
获取所有自有属性名，包含可枚举以及不可枚举的，但是不包含原型链上的。
```javascript
var prototype = {a: 0};
var obj = Object.create(prototype, {
        b: {
            value: 1
        },
        c: {
            value: 2,
            enumerable: false,
        }
    });

console.log(Object.getOwnPropertyNames(obj)); // ["b", "c"]
```

### Object.freeze(obj) 冻结一个对象
冻结一个对象，意味着该对象的属性不能增删改，属性的各个特性也不能改。
而`Object.isFrozen(obj)`可以用来判断一个对象有没有冻结。
```javascript
var obj = { key: 'val', key1:{} };
Object.freeze(obj);

console.log( Object.isFrozen(obj) ); // true

obj.key2 = 1;
console.log(obj.key2); // undefined
delete obj.key;
console.log(obj.key); // val
obj.key = 1;
console.log(obj.key); // val
obj.key1.a = 2;
console.log(obj.key1.a); // 2 ------冻结仅仅冻结一层

//Uncaught TypeError: Cannot redefine property: key
Object.defineProperty(obj, 'key', {enumerable: false});
```

### 怎样完全冻结一个对象
```javascript
function deepFreeze(obj){
    for(var key in obj){
        var val = obj[key];
        //忽略原型链上的属性
        if(!obj.hasOwnProperty(key)) continue;
        //忽略不是对象的属性
        if(typeof val !== 'object') continue;
        //忽略已经冻结的属性
        if(Object.isFrozen(val)) continue;
        //递归地冻结对象属性
        deepFreeze(val);
    }
}
```

### Object.seal(obj) 密封一个对象
密封，比冻结宽松一点，仅仅能修改属性的值。
而`Object.isSealed(obj)`可以用来判断一个对象有没有密封。
```javascript
var obj = { key: 'val', key1:{} };
Object.seal(obj);

console.log( Object.isSealed(obj) ); // true

obj.key2 = 1;
console.log(obj.key2); // undefined
delete obj.key;
console.log(obj.key); // val
obj.key = 1;
console.log(obj.key); // 1----跟冻结唯一不同的地方
obj.key1.a = 2;
console.log(obj.key1.a); // 2

//Uncaught TypeError: Cannot redefine property: key
Object.defineProperty(obj, 'key', {enumerable: false});
```

### Object.preventExtensions(obj) 不能添加新属性
`Object.isExtensible`用来检查一个对象能不能添加新属性
```javascript
var obj = { key: 'val', key1:{} };
Object.preventExtensions(obj);

console.log( Object.isExtensible(obj) ); // false

obj.key2 = 1;
console.log(obj.key2); // undefined，不能添加新属性
obj.key = 'value';
console.log(obj.key); // value，能够修改已有属性

Object.defineProperty(obj, 'key', {enumerable: false});
console.log( Object.keys(obj) ); // ["key1"]，能够修改属性特性

delete obj.key;
console.log(obj.key); // undefined，能够删除已有属性

obj.key1.a = 'a';
console.log( obj.key1.a ); // a，不影响给扩展已有属性
```

### Object.getPrototypeOf(obj)
```javascript
function Car(){}
var prototype = Car.prototype = {};
Object.getPrototypeOf(new Car()) === prototype; // true

var prototype = {};
var car = Object.create(prototype);
Object.getPrototypeOf(car) === prototype; // true
```

## Array扩展
`Array.isArray(obj)` 判断一个对象是不是数组

```javascript
var array = [1, 2, 3];

Array.isArray(array); //true，

//等价于

function isArray(obj){
    return Object.prototype.toString.call(obj) === '[object Array]'
}
```

### Array实例扩展
```javascript
var array = [1, 2, 2, 3];

array.indexOf(2); // 1
array.lastIndexOf(2); // 2

```

## 保留字作为属性名
```javascript
var obj = {
    if: 1,
    var : 's',
    switch: true
};
console.log(obj.if);
console.log(obj.var);
console.log(obj.switch);
```

## 使用get/set进行属性初始化
```
var obj = {
        firstName: '',
        lastName: '',
        get fullName(){
            return (this.firstName + ' ' + this.lastName).trim();
        },
        set fullName(fullName){
            if(!fullName) return;
            var index = fullName.indexOf(' ');
            this.firstName = fullName.substring(0, index);
            this.lastName  = fullName.substring(index+1);
        }
    };

console.log( obj.fullName );  // 空字符串
obj.fullName = 'San Zhang';
console.log( obj.firstName ); // San
console.log( obj.lastName );  // Zhang
console.log( obj.fullName );  // San Zhang
```

## 全局undefined对象
以前，undefined对象是这样产生的。
```javascript
var undef;
console.log( typeof undef === 'undefined' ); // true

var undef = 1;
    undef = void 0;
console.log( typeof undef === 'undefined' ); // true

//jQuery 1.8.3源码片段 
(function(window, undefined){
    console.log( typeof undefined === 'undefined' ); // true
})(window);
```

在ES5中有了不可变的全局的`undefined`对象。
```javascript
var undefined = 1;
console.log(undefined); // undefined

(function(undefined){
    undefined = 1;
    console.log(undefined); // 1

    window.undefined = 1;
    console.log(window.undefined); // undefined
})();
```

## Function实例扩展
### Function.prototype.bind
`fun.bind(thisArg[, arg1[, arg2[, ...]]])`
```javascript
function a(){
    console.log(this, arguments);
}

a.bind({key: 'a'}, 1, 2); // function bound a() { [native code] }

a.bind('ab', 1, 2)(); //String {0: "a", 1: "b", length: 2, [[PrimitiveValue]]: "ab"} [1, 2]

a.bind({key: 'a'}, 1, 2).bind({key: 'b'}, 3, 4)(); // {key: 'a'}, [1,2,3,4]
```

### Curry（柯里化）
预先设定函数的前面若干个实参，生成一个接受剩余实参的新函数。
```javascript
function curry(fn){
    var slice = Array.prototype.slice,
        args = slice.call(arguments, 1);
    return function() {
        return fn.apply(null,args.concat(slice.apply(arguments)));
    }
}
```

### 柯里化案例
```javascript
model.groups = _.filter(model.groups, function(g){
            return g.id !== group.id;
        });
model.groups = _.sortBy(model.groups, 'updateTime');
model.groups = _.map(model.groups, 'name');

// _.prototype 上的方法都是 _ 上相应方法的柯里化
model.groups = _.chain(groups)
        .filter(function(g){
            return g.id !== group.id;
        })
        .sortBy('updateTime')
        .map('name')
        .value();
```

### _.curry & _.curryRight
```javascript
var abc = function(a, b, c) {
  return [a, b, c];
};

var curried = _.curry(abc);

curried(1)(2)(3); //[1,2,3]

curried(1, 2)(3); //[1,2,3]

curried(_, 2)(_, 3)(1); //[1,2,3]
```

## 严格模式
把**整段代码**或**某个函数**放在严格操作的环境中运行，严格环境有诸多限制：

1. 将失误转成异常
2. 简化变量的使用
3. 让eval和arguments变的简单
4. "安全的" JavaScript
5. 为未来的ECMAScript版本铺平道路

## 严格模式：将失误转成异常
1. 意外地创建全局变量
```javascript
(function(){'use strict';  variable = 10; })(); // ReferenceError
//解决方法1：明确指定我要创建全局变量
(function(){'use strict';  window.variable = 10; })();
//解决方法2：事先定义好全局变量
var variable; (function(){'use strict';  variable = 10; })();
```

2. 不再静默失败，而是抛出异常
```javascript
var fixed = {};
Object.preventExtensions(fixed);
fixed.attr = 'value'; // SyntaxError
```

3. 形参命名不能重复
```javascript
(function(a, a){'use strict'; })(); //SyntaxError
```
注意：严格模式下，ES5中定义变量时，字段名也不能重复，但是ES6又允许了。

4. 严格模式禁止八进制数字语法
```javascript
//FireFox: SyntaxError, Chrome/IE10: SyntaxError
(function(){'use strict';  console.log(010); })();
//FireFox: SyntaxError, Chrome/IE10: 19
(function(){'use strict';  console.log(019); })();
```

## 严格模式：简化变量的使用
1. 禁用`with`
```javascript
(function(){
    'use strict';
    var key = 'attr';
    var obj = {key: 1}; 
    with(obj){ //SyntaxError
        console.log(key);
    }
})();
```

2. `eval`不再为上层作用域引入新变量
```javascript
(function(){
    'use strict';
    var x = 1;
    var y = eval('var x = 2; x'); //== eval('"use strict"; var x = 2; x')
    console.log(x, y); // 1, 2 在正常模式下，返回2, 2
})();
```

## 严格模式：简化变量的使用
3. `call` & `apply`对`this`的修改规则简化
```javascript
(function(){
    'use strict';
    function printThis(){ console.log(this); }
    printThis.call(2); // 2 ，不再包装成对象类型
    printThis.call(null); // null，不再自动替换成window对象
    printThis.call(); // undefined，不再自动替换成window对象
})();
```

4. 不能使用`caller`和`callee`
```javascript
(function restricted(a){
  "use strict";
  console.log(restricted.caller); //TypeError
  console.log(restricted.arguments); //TypeError
  console.log(arguments.caller); //TypeError
  console.log(arguments.callee); //TypeError
})(1)
```

## 其他小的特性
### 1. Date.prototype.toISOString
转换成 `YYYY-MM-DDTHH:mm:ss.sssZ` 这种格式

### 2. Date.now() 
和 `new Date().getTime()` 一样。

### 3. String.prototype.trim
和`$.trim`，`_.trim`一样。

### 4. 把字符串当做数组一样访问
```javascript
'foobar'[1] === 'o' // true
```

### 5. parseInt忽略前置0
```
parseInt('012'); // 12，在ES3中，因为前置0而按照八进制解析成10
parseInt('0X12'); // 18，仍然因为前置0X而按照十六进制解析成18
```

## 思考题
1. 以下这种情况是为什么？
```
var array = [];
console.log( array.length ); // 0
console.log( Object.keys(array) ); // []
```

## 参考
1. [MDN Javascript参考文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference)
2. [es5-shim](https://github.com/es-shims/es5-shim)
3. [Douglas Crockford](https://zh.wikipedia.org/wiki/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%C2%B7%E5%85%8B%E7%BE%85%E5%85%8B%E7%A6%8F%E7%89%B9)