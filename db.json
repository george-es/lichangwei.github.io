{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/Redirect-1.png","path":"images/Redirect-1.png","modified":0,"renderable":0},{"_id":"source/images/Redirect-2.png","path":"images/Redirect-2.png","modified":0,"renderable":0},{"_id":"source/images/Redirect-error-case.png","path":"images/Redirect-error-case.png","modified":0,"renderable":0},{"_id":"source/images/WWW-Authentication-1.png","path":"images/WWW-Authentication-1.png","modified":0,"renderable":0},{"_id":"source/images/WWW-Authentication-2.png","path":"images/WWW-Authentication-2.png","modified":0,"renderable":0},{"_id":"source/images/baoz.me-register.png","path":"images/baoz.me-register.png","modified":0,"renderable":0},{"_id":"source/images/category-browse.jpg","path":"images/category-browse.jpg","modified":0,"renderable":0},{"_id":"source/images/category-ga.jpg","path":"images/category-ga.jpg","modified":0,"renderable":0},{"_id":"source/images/category-recently.jpg","path":"images/category-recently.jpg","modified":0,"renderable":0},{"_id":"source/images/category-search.jpg","path":"images/category-search.jpg","modified":0,"renderable":0},{"_id":"source/images/headin.cn.png","path":"images/headin.cn.png","modified":0,"renderable":0},{"_id":"source/images/macos-printer-01.png","path":"images/macos-printer-01.png","modified":0,"renderable":0},{"_id":"source/images/macos-printer-02.png","path":"images/macos-printer-02.png","modified":0,"renderable":0},{"_id":"source/images/macos-printer-03.png","path":"images/macos-printer-03.png","modified":0,"renderable":0},{"_id":"source/images/iis-url-rewrite/2.server-proxy-setting.png","path":"images/iis-url-rewrite/2.server-proxy-setting.png","modified":0,"renderable":0},{"_id":"source/images/iis-url-rewrite/3.enable-proxy.png","path":"images/iis-url-rewrite/3.enable-proxy.png","modified":0,"renderable":0},{"_id":"source/images/iis-url-rewrite/5.add-rule.png","path":"images/iis-url-rewrite/5.add-rule.png","modified":0,"renderable":0},{"_id":"source/images/iis-url-rewrite/6.add-condition.png","path":"images/iis-url-rewrite/6.add-condition.png","modified":0,"renderable":0},{"_id":"source/images/macos-printer-04.png","path":"images/macos-printer-04.png","modified":0,"renderable":0},{"_id":"source/images/iis-url-rewrite/7.add-operation.png","path":"images/iis-url-rewrite/7.add-operation.png","modified":0,"renderable":0},{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"source/images/iis-url-rewrite/4.select-url-rewrite.png","path":"images/iis-url-rewrite/4.select-url-rewrite.png","modified":0,"renderable":0},{"_id":"source/images/iis-url-rewrite/1.click-iis-root-select-arr.png","path":"images/iis-url-rewrite/1.click-iis-root-select-arr.png","modified":0,"renderable":0},{"_id":"source/images/baoz.me-home.png","path":"images/baoz.me-home.png","modified":0,"renderable":0},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b08d0cfb7515258a59f00ad6e13f40970d466d5b","modified":1544144367223},{"_id":"themes/Anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1541474626461},{"_id":"themes/Anisina/README.md","hash":"69a70e00c02bf563d425c8bcaf0b301a0eed5aa6","modified":1541474626461},{"_id":"themes/Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1541474626482},{"_id":"themes/Anisina/.gitignore","hash":"7a2d5c9a8f18e75645eabbeacbf0ee83ba15e854","modified":1541474626461},{"_id":"themes/Anisina/_config.yml","hash":"5baf18c53f7635cd35aa5a8dab8abc08251023ce","modified":1541474626476},{"_id":"source/_posts/2013-04-07-Blue-ray-Web-App-Endless-List-Optimization.md","hash":"5a3e633d5f020950d817b0a8c0bcb6c75ea7d563","modified":1544151903970},{"_id":"source/_posts/2013-04-11-CSS-animations-off-the-UI-thread.md","hash":"9021421d2c3e8f83fb850a6d174a697d85549c11","modified":1544151835722},{"_id":"source/_posts/2013-04-15-Grouping-Numbers-with-Comma.md","hash":"279b57b12d0674f7a19e88e18a91638882a47ddc","modified":1544151998412},{"_id":"source/_posts/2013-04-12-Using-an-Especial-Cursor.md","hash":"589aa3acd34163598ce3a4e791d99ce548ed2c9c","modified":1544151824160},{"_id":"source/_posts/2013-04-22-Canvas-drawImage-vs-putImageData.md","hash":"6af46c0230eef0aaf0db86e4bfcb0ae68a3d365a","modified":1544152011547},{"_id":"source/_posts/2013-04-24-Highlight-Keywords-in-Client.md","hash":"210455d7eefb1d03730402955ab9b3d9c56f07df","modified":1544151986462},{"_id":"source/_posts/2013-04-27-CSS3-Transition-Research.md","hash":"c46797508c1340d5cdc0cd86447348711160d6eb","modified":1544151809351},{"_id":"source/_posts/2013-05-10-Webkit-Image-Wipes.md","hash":"31ba4ef6898fe78e07eb3736ea5e70d23d6173f7","modified":1544152046636},{"_id":"source/_posts/2013-05-12-Javascript-Interview-Questions.md","hash":"9b7fbbd5f8766537ade9c2a8aab972aa4ad5611a","modified":1544152053103},{"_id":"source/_posts/2013-05-13-HTML-CSS-Interview-Questions.md","hash":"4fef286a554b00d622ae340361828c3ffdc9f98d","modified":1544151793670},{"_id":"source/_posts/2013-05-13-Unskilled-Interview-Questions.md","hash":"0ad686483c44080c100d3f2a7b02c778095e14e1","modified":1544151788335},{"_id":"source/_posts/2013-05-17-jQuery-Interview-Questions.md","hash":"cc7b73a274f0d360a1b36038fd36b8845f5511f2","modified":1544151783754},{"_id":"source/_posts/2013-05-18-Using SVG.md","hash":"101ee3038fbb92826871b8aca92f71c7e5d4dedb","modified":1544151778046},{"_id":"source/_posts/2013-05-25-Reduce-reflow-repaint.md","hash":"9894ebddebe206eafaa39624e4b9a730a180fdf2","modified":1544152069376},{"_id":"source/_posts/2013-06-06-Events-in-Capture-Phase.md","hash":"b8f89324370adc762577564363af8de93ab7d6b6","modified":1544151703207},{"_id":"source/_posts/2013-06-07-essay.md","hash":"f50741b6cdb24641dc4cd09f106522639ff67e22","modified":1544151689734},{"_id":"source/_posts/2013-06-09-TotalResults-filed-in-Youtube-Open-API.md","hash":"360cbd14c7615892fa29d4607b15ec1d07982998","modified":1544151686213},{"_id":"source/_posts/2013-06-20-Javascript-Trick.md","hash":"f8d3a896ceae531701ca2a6342270adec5518ae0","modified":1544151643022},{"_id":"source/_posts/2013-06-22-Some-Interesting-Interactive.md","hash":"2b0b1ca0cadeb09e946c54856a69085c1e025186","modified":1544151639226},{"_id":"source/_posts/2013-06-28-Good-UI.md","hash":"143d240ebf342c369fa15efb86a916c86998b633","modified":1544151629322},{"_id":"source/_posts/2013-06-30-No-Backend.md","hash":"93c65cc265f02430c3e781f5029eb03d2c4eb962","modified":1544151621245},{"_id":"source/_posts/2013-07-19-API-Design.md","hash":"288298917833287cc168873706f4d54c21412877","modified":1544151611556},{"_id":"source/_posts/2013-08-19-Programmer-Dilemma.md","hash":"bb8e5150ac0aefe8a0d95905fd1f57a5a04686da","modified":1544151606101},{"_id":"source/_posts/2013-08-26-Get-Version-Info-in-Chrome-Extension.md","hash":"bceaf9b8d077a50141cb2b01e8755dd21f3329fd","modified":1544151601240},{"_id":"source/_posts/2013-09-01-Ways-to-Cross-Domain.md","hash":"3c9db3e17c70c5e2ae698b19cbd9fa0721a914ea","modified":1544151598097},{"_id":"source/_posts/2013-09-06-Using-Redirect-to-Login-and-Authentication.md","hash":"bd8cdf322a50afe72258b11ee247994deb023e5f","modified":1544151594150},{"_id":"source/_posts/2013-09-06-Using-WWW-Authenticate-to-Login-Authentication.md","hash":"8f1038c07bde2cc95647b6e6cf65148b129f55ae","modified":1544151590424},{"_id":"source/_posts/2013-09-11-Software-Product-Quality-Cannot-be-rely-on-Test.md","hash":"1b6ccef0da9a6a57d0caf4a4fdb4ede3f7504df0","modified":1544151585802},{"_id":"source/_posts/2013-09-12-Five-Helpful-Tips-When-Using-RequireJS.md","hash":"8896d774a093d74a266cf74ca7871b3ff829fc97","modified":1544151579819},{"_id":"source/_posts/2013-09-16-Why-the-User-Need-this-Feature.md","hash":"dea4b564f0abf46b3f7689225371df1377c97c2f","modified":1544151505514},{"_id":"source/_posts/2013-09-17-innertext-vs-textcontent.md","hash":"626cc4855a74a2e21590c18f200db5c9bd86c6ae","modified":1544151481285},{"_id":"source/_posts/2013-09-20-Canvas-Inspection-using-Chrome-DevTools.md","hash":"5bb4e72b98f010e7b4603123a43ad280edf03a90","modified":1544151467766},{"_id":"source/_posts/2013-09-23-Browser-Cache.md","hash":"01cc9bc04b9fb4912e9b1709cc00d64205643b46","modified":1544151431187},{"_id":"source/_posts/2013-09-23-HTML5-Application-Cache-and-Baidu-Map-Service.md","hash":"2327c09fcaa190a761f6b8a79913541c2aa6ac00","modified":1544151427424},{"_id":"source/_posts/2013-09-25-HTML5-Application-Cache-Basic.md","hash":"c2c7ca7aed8fdc336c90a34c0bf75ae307df5f55","modified":1544151413972},{"_id":"source/_posts/2013-09-27-Tools-for-Image-Optimization.md","hash":"9aa383ed923c0ce8c9420ccea1cc7e8a2f4a0ad3","modified":1544151398681},{"_id":"source/_posts/2013-11-23-Good-UI-2.md","hash":"cf522606540cd77eb4d25967fa10e576e3fae228","modified":1544151290181},{"_id":"source/_posts/2013-09-24-Web-Page-Optimization.md","hash":"8445865af6c84eca26fb4c7dc7305b3c4e62142f","modified":1544151423886},{"_id":"source/_posts/2013-10-11-Connect-Timeout-When-Npm-Install.md","hash":"01df3724877643d9e666779e6705391865e10b3f","modified":1544151294956},{"_id":"source/_posts/2014-05-06-IE678-muti-style-attribute.md","hash":"c378d05d306dd88783a26858a4632941a3942fc1","modified":1544151194652},{"_id":"source/_posts/2014-05-04-backbone-problems.md","hash":"b9d9645b7100f223507c257445c1696c318cbfd5","modified":1544151284927},{"_id":"source/_posts/2014-05-05-terms-of-use.md","hash":"6db2fb9ea11d887c6da06d8f05367716fdd02992","modified":1544151219428},{"_id":"source/_posts/2014-05-07-first-screen.md","hash":"6a11960e94bcdd467e938c8e628ea2058e17e223","modified":1544151172622},{"_id":"source/_posts/2014-05-08-scrollIntoView.md","hash":"c6d197b18a8afb24e37e24aeda05417e7aeb37bf","modified":1544095266442},{"_id":"source/_posts/2014-05-22-how-to-select-category.md","hash":"f07b4a2131adcb1adccb4b7c6f598126ee44a1b2","modified":1544151154698},{"_id":"source/_posts/2014-06-01-javascript-code-guide.md","hash":"00a81047a7f465e5833348cb54135b883eebb815","modified":1544151145678},{"_id":"source/_posts/2014-06-05-html-code-guide.md","hash":"7e4e9f5918c8777ae2e41abf0242173b22c150ab","modified":1544150932737},{"_id":"source/_posts/2015-08-12-ie-prevent-xss.md","hash":"d626d48e66e5dbf60b1a4d6ead05c72fe9f8f741","modified":1544150858815},{"_id":"source/_posts/2014-06-04-css-code-guide.md","hash":"fe45ab48bc4eaa992c5a88c8312561aeadafe803","modified":1544151100161},{"_id":"source/_posts/2015-09-06-knockout.md","hash":"546cffb900df1fcee78547055c954f59ca17fae1","modified":1544150813897},{"_id":"source/_posts/2016-07-04-css3-html5-feature-compatibility-survey.md","hash":"5c076741ba597cac8c4af0a12675a7e6cd7fecc7","modified":1544150622959},{"_id":"source/_posts/2015-09-21-es5.md","hash":"b2ccddc7d96a5608c20a7c8d8f06ebb4987a7e0c","modified":1544150699399},{"_id":"source/_posts/2017-03-03-chrome-developer-tool-device-mode.md","hash":"d84812c402a8903eed376cda2fddc2c12fa624f2","modified":1544150436545},{"_id":"source/_posts/2017-05-04-react-patterns.md","hash":"74211d2b662559af0aab881487e672e8dddde3aa","modified":1544150407905},{"_id":"source/_posts/2017-10-24-shared-cookie.md","hash":"120a582bfb1bf591fbe81a018530e846edc07279","modified":1544150318123},{"_id":"source/_posts/2018-01-12-iis-url-rewrite.md","hash":"507e5ff3d01d1908bef320917bdd75853a3583da","modified":1544150285653},{"_id":"source/_posts/2018-02-08-webpack-public-path.md","hash":"cb5a222966e3e57786edcab045d4258bded212f4","modified":1544150299483},{"_id":"source/_posts/2018-12-06-macos-printer.md","hash":"453f004c08f767ae40e1cfe5aebe155d4058f86c","modified":1544150302092},{"_id":"source/images/Redirect-1.png","hash":"80b8e88d307f1d58d998c8a1d29e3caf877f2ae6","modified":1544095266452},{"_id":"source/images/Redirect-2.png","hash":"d80e9226ecd02d79a24cc5cbd03df74226957d03","modified":1544095266452},{"_id":"source/images/Redirect-error-case.png","hash":"d0687d80c58d12be6ae90c02b3cac382b71aca90","modified":1544095266452},{"_id":"source/images/WWW-Authentication-1.png","hash":"b994d5194a3efc3be6c91b5d0ef1dc92a26f1bb2","modified":1544095266453},{"_id":"source/images/WWW-Authentication-2.png","hash":"d40bc096d2fabec98ca72b39b81a9fab5804e9ad","modified":1544095266453},{"_id":"source/images/baoz.me-register.png","hash":"dfd339279e1ecefda8b5220d17ed94330c0b2975","modified":1544095266456},{"_id":"source/images/.DS_Store","hash":"1c6557494386c1ff858341b5a6a42bcb3f9bdc22","modified":1544094705873},{"_id":"source/images/category-browse.jpg","hash":"b28e18f9813d47eda18180fa516251b2982cbee0","modified":1544095266457},{"_id":"source/images/category-ga.jpg","hash":"8ecaa6ebbea3a15b6d82360f371b3bf0beccbd06","modified":1544095266457},{"_id":"source/images/category-recently.jpg","hash":"43d8dacdf7569b6821e04ee5d4134886fef6e2a1","modified":1544095266457},{"_id":"source/images/category-search.jpg","hash":"37eb50dfcb0716b5f8eee975f5ebe9ec8cd93937","modified":1544095266458},{"_id":"source/images/headin.cn.png","hash":"b3c91fb56776440785e448b37dab652058916dfb","modified":1544095266458},{"_id":"themes/Anisina/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1541474626455},{"_id":"themes/Anisina/.git/config","hash":"050bd84e438fe3cde46d681fefd19a7d07cb0f15","modified":1541474626457},{"_id":"themes/Anisina/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1541474613777},{"_id":"themes/Anisina/.git/packed-refs","hash":"c8658adf463acb48ddf19b2f107577577af2fb72","modified":1541474626453},{"_id":"themes/Anisina/.git/index","hash":"ce12dbb196fad69df9c83105f73efb0b067d632a","modified":1541474811290},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1541474626477},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1541474626477},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1541474626477},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1541474626477},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1541474626477},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1541474626478},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1541474626478},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1541474626478},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1541474626478},{"_id":"themes/Anisina/layout/.DS_Store","hash":"fd623c7cbe0d8fd902f6ca242127fd8db7da6c18","modified":1541474626479},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1541474626479},{"_id":"themes/Anisina/layout/layout.ejs","hash":"b728827bf3ec55baf96a882032397e6c74c65f34","modified":1541474626480},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1541474626481},{"_id":"themes/Anisina/layout/index.ejs","hash":"a0eaee13571e79c3632e23a9e94ccc991761d1f5","modified":1541474626480},{"_id":"themes/Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1541474626482},{"_id":"themes/Anisina/layout/page.ejs","hash":"e9990327469aa94a98a3dae92bdc9326a5b99c8a","modified":1541474626480},{"_id":"themes/Anisina/layout/post.ejs","hash":"05203c1f8414ffc237a00be77a156264df2c7971","modified":1541474626481},{"_id":"themes/Anisina/layout/tags.ejs","hash":"a5b73e70540e12532aa92f12609b3a937a8bc28b","modified":1541474626481},{"_id":"source/images/macos-printer-01.png","hash":"1569e7d2495b017ec82bafe74794f274ed5c92f5","modified":1544095266465},{"_id":"source/images/macos-printer-02.png","hash":"a4880aea4ebc9dc987b2b2ee4bb642e9fb069dc2","modified":1544095266467},{"_id":"source/images/macos-printer-03.png","hash":"160557efcb6ffd1fc63423a292f2311c32ead580","modified":1544095266468},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1541474626463},{"_id":"source/_posts/2017-06-30-callback-hell-and-async-program.md","hash":"e1b54a8a6995d35f01accf8cfdf847239337e143","modified":1544150361055},{"_id":"source/images/iis-url-rewrite/2.server-proxy-setting.png","hash":"3b5c8c0fcf1de0ecf922461d647ae67f936041cd","modified":1544095266459},{"_id":"source/images/iis-url-rewrite/3.enable-proxy.png","hash":"1722774e3c0047c08f6821f17c47ee0d76d51ec8","modified":1544095266460},{"_id":"source/images/iis-url-rewrite/5.add-rule.png","hash":"9f94a5fc33e096556ae999309508904233987a21","modified":1544095266462},{"_id":"source/images/iis-url-rewrite/6.add-condition.png","hash":"1620607b15c08174f787315def654c432c1ffacf","modified":1544095266462},{"_id":"source/images/macos-printer-04.png","hash":"bf00d2532e8697614543bbfbe0b51ca20cbaf2e4","modified":1544095266470},{"_id":"source/images/iis-url-rewrite/7.add-operation.png","hash":"d82493c2e2d9b3eb48f72ae4240d1a0dd4a12a55","modified":1544095266462},{"_id":"themes/Anisina/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1541474613779},{"_id":"themes/Anisina/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1541474613778},{"_id":"themes/Anisina/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1541474613780},{"_id":"themes/Anisina/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1541474613782},{"_id":"themes/Anisina/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1541474613782},{"_id":"themes/Anisina/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1541474613779},{"_id":"themes/Anisina/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1541474613782},{"_id":"themes/Anisina/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1541474613779},{"_id":"themes/Anisina/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1541474613780},{"_id":"themes/Anisina/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1541474613781},{"_id":"themes/Anisina/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1541474613783},{"_id":"themes/Anisina/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1541474613777},{"_id":"themes/Anisina/.git/logs/HEAD","hash":"84d8794ebc5c1e1d266393acc3584401746a41ea","modified":1541474626456},{"_id":"source/_posts/2013-09-28-A-Beginner's-Guide-to-HTTP-Cache-Headers.md","hash":"b27d38430385ecaf80d1d59cd90b485a66667499","modified":1544151394099},{"_id":"source/_posts/2016-09-06-lodash-functions.md","hash":"1519aa4df087bb55a41ec9be9175e1948a13a775","modified":1544150556722},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1541474626462},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"4e0d96cac503d4e3a5b254d8b8175c392971ce38","modified":1541474626479},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"0235c9e7497e94fa036c3d21117834e4464a64e6","modified":1541474626479},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1541474626480},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"3baa41d595e951efa1db34dd1789c6f8d3b094da","modified":1541474626479},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1541474626484},{"_id":"themes/Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1541474626486},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"c6830e31138e412c2aa05228c4cd6035063fe651","modified":1541474626482},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1541474626487},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1541474626490},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1541474626490},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1541474626486},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1541474626486},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1541474626484},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1541474626485},{"_id":"source/images/iis-url-rewrite/4.select-url-rewrite.png","hash":"ec57c78cb12fea100678c38e8122753f40856a34","modified":1544095266461},{"_id":"source/images/iis-url-rewrite/1.click-iis-root-select-arr.png","hash":"89db4c491b40d4b7f0dde9967c369a724d88a3ab","modified":1544095266459},{"_id":"source/images/baoz.me-home.png","hash":"7e7030c84b75b4d07f1dc6c248fa267b3ea4ce20","modified":1544095266454},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1541474626489},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1541474626485},{"_id":"themes/Anisina/.git/objects/pack/pack-1f50a0bcce631adc1f0f9611732d0487807c6579.idx","hash":"394ebd5a04fb4ec3b07c897859b9d71e9cbeef14","modified":1541474626443},{"_id":"themes/Anisina/.git/refs/heads/master","hash":"b891986a2ba8683ef6dce7c7e853f9175a1ab59e","modified":1541474626455},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1541474626476},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1541474626483},{"_id":"themes/Anisina/.git/logs/refs/heads/master","hash":"84d8794ebc5c1e1d266393acc3584401746a41ea","modified":1541474626456},{"_id":"themes/Anisina/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1541474626454},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1541474626465},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1541474626488},{"_id":"themes/Anisina/.git/logs/refs/remotes/origin/HEAD","hash":"84d8794ebc5c1e1d266393acc3584401746a41ea","modified":1541474626454},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1541474626468},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1541474626473},{"_id":"themes/Anisina/.git/objects/pack/pack-1f50a0bcce631adc1f0f9611732d0487807c6579.pack","hash":"8db6f8b888ecc056501e3d660a3667bb8efc11bb","modified":1541474626443},{"_id":"public/2018/02/08/webpack-public-path/index.html","hash":"00dbff06bd5ef317f614117a2b0a9133c1e1a220","modified":1544164202294},{"_id":"public/2018/12/06/macos-printer/index.html","hash":"424a7313d60b5d643f1a953fa95fd1cade20554e","modified":1544164202294},{"_id":"public/2018/01/12/iis-url-rewrite/index.html","hash":"afc6c3e71f1989f18f3615317d825b4c3d2a9903","modified":1544164202295},{"_id":"public/2014/05/08/scrollIntoView/index.html","hash":"3207282b2e2f24fa163943e843e5030b35f561dd","modified":1544164202295},{"_id":"public/2014/05/07/first-screen/index.html","hash":"7284723884b879fc026c7067192a8d4766ab105e","modified":1544164202295},{"_id":"public/2013/11/23/Good-UI-2/index.html","hash":"52cad246980d09dae40c6ac12a30390808ffcc6b","modified":1544164202295},{"_id":"public/2013/09/24/Web-Page-Optimization/index.html","hash":"73e96945dd6970e84f6acc4e22776ef298252668","modified":1544164202295},{"_id":"public/2013/09/23/Browser-Cache/index.html","hash":"0695fbbd36b8cdf576d56e40728b3de5455795ad","modified":1544164202295},{"_id":"public/2013/09/11/Software-Product-Quality-Cannot-be-rely-on-Test/index.html","hash":"73f2b93c6f745f157b49bc211b9065212e8abefc","modified":1544164202295},{"_id":"public/2013/09/06/Using-WWW-Authenticate-to-Login-Authentication/index.html","hash":"25b8f46fe435e66c17074be4074df777a1995fba","modified":1544164202295},{"_id":"public/2013/09/06/Using-Redirect-to-Login-and-Authentication/index.html","hash":"abb8fcfaf066b67882b7e85ff8492a29a793a600","modified":1544164202295},{"_id":"public/2013/09/01/Ways-to-Cross-Domain/index.html","hash":"2c2f3e80bdb08b0bb5b4911b66c1f5b22b7318e6","modified":1544164202295},{"_id":"public/2013/08/19/Programmer-Dilemma/index.html","hash":"eb3cbf5c1458547e36c6fa49cc9aa898aa759881","modified":1544164202295},{"_id":"public/2013/07/19/API-Design/index.html","hash":"7c683ca0df631fac8e3257b704344c9127e47c91","modified":1544164202295},{"_id":"public/2013/06/30/No-Backend/index.html","hash":"8fd4fd8bf6bf61103dd0394f03282893c9d67e40","modified":1544164202295},{"_id":"public/2013/06/22/Some-Interesting-Interactive/index.html","hash":"fc608b6885bb034cfad644d02bb64a2c2138f4be","modified":1544164202295},{"_id":"public/2013/06/09/TotalResults-filed-in-Youtube-Open-API/index.html","hash":"51372277fc7873e9998432ffde3b2246781f730c","modified":1544164202296},{"_id":"public/2013/05/17/jQuery-Interview-Questions/index.html","hash":"109fab2af1d96126ffd9a152f7191dd1cd5ef657","modified":1544164202296},{"_id":"public/2013/05/13/Unskilled-Interview-Questions/index.html","hash":"15603bf65a9716f1f2f12bf40dca7b6f0ca55bd1","modified":1544164202296},{"_id":"public/archives/page/8/index.html","hash":"cee24543c3ab0ad4c587ff0310b7337f30833396","modified":1544164202296},{"_id":"public/archives/2013/07/index.html","hash":"327e0ad8e69140193dbcd37485712f1032b35901","modified":1544164202296},{"_id":"public/archives/2013/08/index.html","hash":"33bd012bd028e91f5e6899d153677fc5c16bede8","modified":1544164202296},{"_id":"public/archives/2013/09/page/2/index.html","hash":"4150de51c62865113356656e41157ace0a6e0633","modified":1544164202296},{"_id":"public/archives/2013/10/index.html","hash":"ee309ece5ab96e70843f8a1c810caeaef7d1b20b","modified":1544164202296},{"_id":"public/archives/2013/11/index.html","hash":"5cc46857003c9204ac43ecb7d9a82fb5026cd4c0","modified":1544164202296},{"_id":"public/archives/2014/page/2/index.html","hash":"cf1c4b3a8c61426489fd1f44703055d05f545fd6","modified":1544164202296},{"_id":"public/archives/2014/06/index.html","hash":"602485499a250fc99140f94034bd2ea200b2b169","modified":1544164202297},{"_id":"public/archives/2015/index.html","hash":"e135766f89b464952884b4462a2e6cdbd3428793","modified":1544164202297},{"_id":"public/archives/2015/08/index.html","hash":"8775dcf8052cb3863e45a5b9bf9df7a0db4496ed","modified":1544164202297},{"_id":"public/archives/2015/09/index.html","hash":"977dc093244a1c9ef0405dee7c4e024177f159c8","modified":1544164202297},{"_id":"public/archives/2016/index.html","hash":"dc9988860bcb6d9af8c049343a4f14f161eff432","modified":1544164202297},{"_id":"public/archives/2016/07/index.html","hash":"81cd6d62341166bb785ceb4a938497c5a9dcdee7","modified":1544164202297},{"_id":"public/archives/2016/09/index.html","hash":"4a27c30c037058bfd24989c369ec8c896dda8b43","modified":1544164202297},{"_id":"public/archives/2017/index.html","hash":"2db1539c84c21dfdaa7c6032e3e7e846e72c9f73","modified":1544164202297},{"_id":"public/archives/2017/03/index.html","hash":"8b84f0514c752f59d95916cee52ca89cc9da8e10","modified":1544164202297},{"_id":"public/archives/2017/05/index.html","hash":"83b3092f87a1eba63b3c3671219229a5dcf70616","modified":1544164202298},{"_id":"public/archives/2017/06/index.html","hash":"7dff9db03c0a5deaf013fddee97b236d6559cdda","modified":1544164202298},{"_id":"public/archives/2017/10/index.html","hash":"608e5c528cf19862c86a80dee77bd62aedad6ee1","modified":1544164202298},{"_id":"public/archives/2018/index.html","hash":"9bc53f5dc14b8a33d2fb3ec8a6a9b3b4980ae5d4","modified":1544164202298},{"_id":"public/archives/2018/01/index.html","hash":"cd71097d00cd6218fc05d7aa0d03addad4a436c2","modified":1544164202298},{"_id":"public/archives/2018/02/index.html","hash":"b36a4e3384217276d36042a880649f45ebc0c945","modified":1544164202298},{"_id":"public/archives/2018/12/index.html","hash":"0dd066cdbb4fa51c75471dd680476725b9ecba61","modified":1544164202298},{"_id":"public/2017/10/24/shared-cookie/index.html","hash":"9e8d4d4d355bb2727a5a810d26e884ea0c1e46b4","modified":1544164202298},{"_id":"public/2017/06/30/callback-hell-and-async-program/index.html","hash":"110bbc38b55383d35a613768b3fb35b64b7617a2","modified":1544164202298},{"_id":"public/2017/05/04/react-patterns/index.html","hash":"3e57ff456541ece013109c736d6ca5aef8f37799","modified":1544164202298},{"_id":"public/2017/03/03/chrome-developer-tool-device-mode/index.html","hash":"8c4652fe2547199352e1bbb42557cb5820682c82","modified":1544164202298},{"_id":"public/2016/09/06/lodash-functions/index.html","hash":"0f99f71d28058d7b4d93b40422192b5dc0dbb0cd","modified":1544164202298},{"_id":"public/2016/07/04/css3-html5-feature-compatibility-survey/index.html","hash":"d30a0c303be9cff4fd91829cceddc529b907838a","modified":1544164202298},{"_id":"public/2015/09/21/es5/index.html","hash":"c5bba913dc5c1b27536fd8c34b3b2beb4dcba510","modified":1544164202298},{"_id":"public/2015/09/06/knockout/index.html","hash":"35bc93a30843c8309aef6c6ef13e54f10e1c12d6","modified":1544164202298},{"_id":"public/2015/08/12/ie-prevent-xss/index.html","hash":"f431aed25d72896cfa2734b9af9098365f364abb","modified":1544164202298},{"_id":"public/2014/06/05/html-code-guide/index.html","hash":"c83a6ff99f54a3cc14761176e4e7766ebca4bbc5","modified":1544164202298},{"_id":"public/2014/06/04/css-code-guide/index.html","hash":"5acbce192a9f32be3db9b126a6900e0499c50160","modified":1544164202298},{"_id":"public/2014/06/01/javascript-code-guide/index.html","hash":"4b9de092d1d4546ae9aad58ee80ba8037328b9e1","modified":1544164202299},{"_id":"public/2014/05/22/how-to-select-category/index.html","hash":"22a0b30e2f5493c44630269ab1cea9ed9646e9d8","modified":1544164202299},{"_id":"public/2014/05/06/IE678-muti-style-attribute/index.html","hash":"6576b477707ba80afd08d21cf62778b18ae3be0a","modified":1544164202304},{"_id":"public/2014/05/05/terms-of-use/index.html","hash":"d5edf74503beae834445198e6fabecf1fe832603","modified":1544164202305},{"_id":"public/2014/05/04/backbone-problems/index.html","hash":"284c9e4fd31a4827f2b680fb721cd4a454d64a2e","modified":1544164202305},{"_id":"public/2013/10/11/Connect-Timeout-When-Npm-Install/index.html","hash":"7bb2aca08b40a2ce81aa1dd9078cd3ba3238045e","modified":1544164202305},{"_id":"public/2013/09/28/A-Beginner's-Guide-to-HTTP-Cache-Headers/index.html","hash":"569402b0375883d076ba2a36739ae20ea0effcdd","modified":1544164202305},{"_id":"public/2013/09/27/Tools-for-Image-Optimization/index.html","hash":"cd3dd4f78692b99d1bbf00b4efcbe7b1117155b1","modified":1544164202305},{"_id":"public/2013/09/25/HTML5-Application-Cache-Basic/index.html","hash":"4f96e5eb8edd56e64826c17a4caf3ef40c96b5f2","modified":1544164202305},{"_id":"public/2013/09/23/HTML5-Application-Cache-and-Baidu-Map-Service/index.html","hash":"0256e193888d8bb23daca1f7bf6f521a45b8c841","modified":1544164202305},{"_id":"public/2013/09/20/Canvas-Inspection-using-Chrome-DevTools/index.html","hash":"b7682c7292af6818287fb4c2616d6e62e1c57a56","modified":1544164202305},{"_id":"public/2013/09/17/innertext-vs-textcontent/index.html","hash":"7562941c48c4764c02d1d5ca4fef31e994b155fa","modified":1544164202305},{"_id":"public/2013/09/16/Why-the-User-Need-this-Feature/index.html","hash":"5cf785f486e52aeb4d3a877799e4647ff7704a2a","modified":1544164202305},{"_id":"public/2013/09/12/Five-Helpful-Tips-When-Using-RequireJS/index.html","hash":"1fa85945f21b30188eda11e9285136c3d947becd","modified":1544164202305},{"_id":"public/2013/08/26/Get-Version-Info-in-Chrome-Extension/index.html","hash":"9ab21279c62b093a9652f3b4dc970f691f91d935","modified":1544164202305},{"_id":"public/2013/06/28/Good-UI/index.html","hash":"b70072ceac5019b02df873ab69a9a7ee825ece1f","modified":1544164202305},{"_id":"public/2013/06/20/Javascript-Trick/index.html","hash":"ddfd14e367c0118fa3b5436fbcf24c32952b7908","modified":1544164202305},{"_id":"public/2013/06/07/essay/index.html","hash":"c9d3965c85e115d052bc32808afd480a87e82508","modified":1544164202306},{"_id":"public/2013/06/06/Events-in-Capture-Phase/index.html","hash":"e38e7ea00ca5c8e4cdf716da65a254b893cdd8f8","modified":1544164202306},{"_id":"public/2013/05/25/Reduce-reflow-repaint/index.html","hash":"e2cad65203e8d7ecebee2b1db7c83aae2f3f711f","modified":1544164202306},{"_id":"public/2013/05/18/Using SVG/index.html","hash":"509cdc87d455b5e710759666c3184dd286788f28","modified":1544164202306},{"_id":"public/2013/05/13/HTML-CSS-Interview-Questions/index.html","hash":"f6331b91d62419e75a702d3b753eb00dccfc4b87","modified":1544164202306},{"_id":"public/2013/05/12/Javascript-Interview-Questions/index.html","hash":"7fb2a95ef8caa3c0315efba5076c67a6102a069a","modified":1544164202306},{"_id":"public/2013/05/10/Webkit-Image-Wipes/index.html","hash":"da98bb78ca3f9c12564e71c22fa93c5a281e21f3","modified":1544164202306},{"_id":"public/2013/04/27/CSS3-Transition-Research/index.html","hash":"b3f4677a5ba8daa1ca217f628925ba7490946239","modified":1544164202306},{"_id":"public/2013/04/24/Highlight-Keywords-in-Client/index.html","hash":"1bda4ecd76c66025f1a85c346af5c9906ad6d8b1","modified":1544164202306},{"_id":"public/2013/04/22/Canvas-drawImage-vs-putImageData/index.html","hash":"45750f84103536d4d9afd3e8d660ad114f0efbeb","modified":1544164202307},{"_id":"public/2013/04/15/Grouping-Numbers-with-Comma/index.html","hash":"74577c17422420b04af538be7f18aa77bb979488","modified":1544164202307},{"_id":"public/2013/04/12/Using-an-Especial-Cursor/index.html","hash":"c256fda9f51c0739043cd23cee566aadb4edbcb6","modified":1544164202307},{"_id":"public/2013/04/11/CSS-animations-off-the-UI-thread/index.html","hash":"51c6ecba713596cdd52e8d2c12674d1d65209c4d","modified":1544164202307},{"_id":"public/2013/04/07/Blue-ray-Web-App-Endless-List-Optimization/index.html","hash":"016c18b5f4203a0d926c2d484a28a9e7bf3f83cc","modified":1544164202307},{"_id":"public/index.html","hash":"92b159caabedabf74d27851de05b6d9b14a30111","modified":1544164202307},{"_id":"public/page/2/index.html","hash":"8d95fb7da74f07b8615e75b9cfcf79b2a48b93e3","modified":1544164202307},{"_id":"public/page/3/index.html","hash":"6051e600e3987af850c0578219c42bccba27e9b7","modified":1544164202307},{"_id":"public/page/4/index.html","hash":"8ae3d1a61b804a1269607e226bcca5a172f19a4d","modified":1544164202307},{"_id":"public/page/5/index.html","hash":"80c6f4366f4cd3df2afc3311036d62c1fd8202cd","modified":1544164202307},{"_id":"public/page/6/index.html","hash":"af6ae01e467b6d8bc4771b17c501b3ec08ee63ae","modified":1544164202307},{"_id":"public/page/7/index.html","hash":"bb3de28320c8f78de8b8f04ac6399d2cb094c878","modified":1544164202307},{"_id":"public/page/8/index.html","hash":"975adfe493a28c3a2928246c67be03acc477fb56","modified":1544164202308},{"_id":"public/archives/index.html","hash":"a2432f9343ef6caa4c14d385223a7004294638d1","modified":1544164202308},{"_id":"public/archives/page/2/index.html","hash":"1b7be64b06619f153196247008a18ee32cab8d7e","modified":1544164202308},{"_id":"public/archives/page/3/index.html","hash":"faee60a3f7210057f6831dc903e646b2317d564c","modified":1544164202308},{"_id":"public/archives/page/4/index.html","hash":"77dbf1aad743060e72f1d786e0885d4e1ad89254","modified":1544164202308},{"_id":"public/archives/page/5/index.html","hash":"79d1a585e5ad241b8cc17a838934e69d739e1e30","modified":1544164202308},{"_id":"public/archives/page/6/index.html","hash":"e2c72f53dbe77ccbf82879dbd594063efcd1b062","modified":1544164202308},{"_id":"public/archives/page/7/index.html","hash":"c052709b1f47c165fc886b709b7d9ab0ca6483ec","modified":1544164202308},{"_id":"public/archives/2013/index.html","hash":"d7a62cef470f49eb1039f1f747268ef0479b9080","modified":1544164202308},{"_id":"public/archives/2013/page/2/index.html","hash":"57f4ee74a088965dde18353567179184e248f33e","modified":1544164202308},{"_id":"public/archives/2013/page/3/index.html","hash":"22a393d562362552c09dba1b048213a374a223ec","modified":1544164202308},{"_id":"public/archives/2013/page/4/index.html","hash":"14dc8887cfc7cfe5499737fa98b8a208b538a864","modified":1544164202308},{"_id":"public/archives/2013/page/5/index.html","hash":"1c5fc6af1e99b04051a5740634d3ade106f0799d","modified":1544164202309},{"_id":"public/archives/2013/04/index.html","hash":"2a7e05344f470ffa1dfc16f62034d60040489abc","modified":1544164202309},{"_id":"public/archives/2013/05/index.html","hash":"ba34a2e026858cdbabd556f1f4113fff0d2f127f","modified":1544164202309},{"_id":"public/archives/2013/06/index.html","hash":"e88ff008c265ce1e128d6c95b2f672e39b69943a","modified":1544164202309},{"_id":"public/archives/2013/09/index.html","hash":"627aefd512baaac645e3647a6f2bab2185cd51a9","modified":1544164202309},{"_id":"public/archives/2014/index.html","hash":"58b5e2c13699fc319250806de207bc82a3d86df7","modified":1544164202309},{"_id":"public/archives/2014/05/index.html","hash":"a6416b518ba2285a98a1206fff95377b33be7c66","modified":1544164202309}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"脱离 UI 线程的 CSS3 动画","_content":"\n【原文】[CSS animations off the UI thread](http://www.phpied.com/css-animations-off-the-ui-thread/)  \n我们知道浏览器是单线程的，在执行 js 脚本期间，UI 会被冻结，用户行为也得不到响应。也就是所谓的“假死”现象。  \n在最新版本的浏览器中，开启了一种新的实现，将 CSS3 动画移出 UI 线程。\n\n## 测试结果\n\n-   Win7 上 Chrome25 支持\n-   iOS6 上 Chrome 和 Safari 支持\n-   原文中提到 IE10（估计是 Win8 上），Firefox OS 支持。\n\n## 测试方法\n\n[点击我打开测试页面](http://www.phpied.com/files/css-thread/thread.html)。点击按钮以后，javascript 脚本持续执行 2 秒，在这个过程中查看红蓝绿三个方块的效果。如果三个均停止动画，说明浏览器尚不支持将 CSS transform 动画移出 UI 线程，如果红色和绿色方块继续动画，则支持。\n\n## 解释\n\n红色方块的动画如下\n\n```css\n.spin {\n    animation: 3s rotate linear infinite;\n}\n@keyframes rotate {\n    from {\n        transform: rotate(0deg);\n    }\n    to {\n        transform: rotate(360deg);\n    }\n}\n```\n\n绿色方块的动画如下\n\n```css\n.walkabout-new-school {\n    animation: 3s slide-transform linear infinite;\n}\n@keyframes slide-transform {\n    from {\n        transform: translatex(0);\n    }\n    50% {\n        transform: translatex(300px);\n    }\n    to {\n        transform: translatex(0);\n    }\n}\n```\n\n蓝色方块的动画如下\n\n```css\n.walkabout-old-school {\n    animation: 3s slide-margin linear infinite;\n}\n@keyframes slide-margin {\n    from {\n        margin-left: 0;\n    }\n    50% {\n        margin-left: 100%;\n    }\n    to {\n        margin-left: 0;\n    }\n}\n```\n\n## 结论\n\n如果有可能，尽量使用 CSS3 transform 动画。这些动画脱离了主线程，不影响主线程。\n","source":"_posts/2013-04-11-CSS-animations-off-the-UI-thread.md","raw":"---\ntitle: 脱离 UI 线程的 CSS3 动画\n---\n\n【原文】[CSS animations off the UI thread](http://www.phpied.com/css-animations-off-the-ui-thread/)  \n我们知道浏览器是单线程的，在执行 js 脚本期间，UI 会被冻结，用户行为也得不到响应。也就是所谓的“假死”现象。  \n在最新版本的浏览器中，开启了一种新的实现，将 CSS3 动画移出 UI 线程。\n\n## 测试结果\n\n-   Win7 上 Chrome25 支持\n-   iOS6 上 Chrome 和 Safari 支持\n-   原文中提到 IE10（估计是 Win8 上），Firefox OS 支持。\n\n## 测试方法\n\n[点击我打开测试页面](http://www.phpied.com/files/css-thread/thread.html)。点击按钮以后，javascript 脚本持续执行 2 秒，在这个过程中查看红蓝绿三个方块的效果。如果三个均停止动画，说明浏览器尚不支持将 CSS transform 动画移出 UI 线程，如果红色和绿色方块继续动画，则支持。\n\n## 解释\n\n红色方块的动画如下\n\n```css\n.spin {\n    animation: 3s rotate linear infinite;\n}\n@keyframes rotate {\n    from {\n        transform: rotate(0deg);\n    }\n    to {\n        transform: rotate(360deg);\n    }\n}\n```\n\n绿色方块的动画如下\n\n```css\n.walkabout-new-school {\n    animation: 3s slide-transform linear infinite;\n}\n@keyframes slide-transform {\n    from {\n        transform: translatex(0);\n    }\n    50% {\n        transform: translatex(300px);\n    }\n    to {\n        transform: translatex(0);\n    }\n}\n```\n\n蓝色方块的动画如下\n\n```css\n.walkabout-old-school {\n    animation: 3s slide-margin linear infinite;\n}\n@keyframes slide-margin {\n    from {\n        margin-left: 0;\n    }\n    50% {\n        margin-left: 100%;\n    }\n    to {\n        margin-left: 0;\n    }\n}\n```\n\n## 结论\n\n如果有可能，尽量使用 CSS3 transform 动画。这些动画脱离了主线程，不影响主线程。\n","slug":"CSS-animations-off-the-UI-thread","published":1,"date":"2013-04-10T16:00:00.000Z","updated":"2018-12-07T03:03:55.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm8p0000w8wku7xkikro","content":"<p>【原文】<a href=\"http://www.phpied.com/css-animations-off-the-ui-thread/\" target=\"_blank\" rel=\"noopener\">CSS animations off the UI thread</a><br>我们知道浏览器是单线程的，在执行 js 脚本期间，UI 会被冻结，用户行为也得不到响应。也就是所谓的“假死”现象。<br>在最新版本的浏览器中，开启了一种新的实现，将 CSS3 动画移出 UI 线程。</p>\n<h2 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h2><ul>\n<li>Win7 上 Chrome25 支持</li>\n<li>iOS6 上 Chrome 和 Safari 支持</li>\n<li>原文中提到 IE10（估计是 Win8 上），Firefox OS 支持。</li>\n</ul>\n<h2 id=\"测试方法\"><a href=\"#测试方法\" class=\"headerlink\" title=\"测试方法\"></a>测试方法</h2><p><a href=\"http://www.phpied.com/files/css-thread/thread.html\" target=\"_blank\" rel=\"noopener\">点击我打开测试页面</a>。点击按钮以后，javascript 脚本持续执行 2 秒，在这个过程中查看红蓝绿三个方块的效果。如果三个均停止动画，说明浏览器尚不支持将 CSS transform 动画移出 UI 线程，如果红色和绿色方块继续动画，则支持。</p>\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>红色方块的动画如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.spin</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: <span class=\"number\">3s</span> rotate linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> rotate &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(0deg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(360deg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>绿色方块的动画如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.walkabout-new-school</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: <span class=\"number\">3s</span> slide-transform linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> slide-transform &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translatex</span>(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    50% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translatex</span>(300px);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translatex</span>(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>蓝色方块的动画如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.walkabout-old-school</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: <span class=\"number\">3s</span> slide-margin linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> slide-margin &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">margin-left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    50% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">margin-left</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">margin-left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>如果有可能，尽量使用 CSS3 transform 动画。这些动画脱离了主线程，不影响主线程。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>【原文】<a href=\"http://www.phpied.com/css-animations-off-the-ui-thread/\" target=\"_blank\" rel=\"noopener\">CSS animations off the UI thread</a><br>我们知道浏览器是单线程的，在执行 js 脚本期间，UI 会被冻结，用户行为也得不到响应。也就是所谓的“假死”现象。<br>在最新版本的浏览器中，开启了一种新的实现，将 CSS3 动画移出 UI 线程。</p>\n<h2 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h2><ul>\n<li>Win7 上 Chrome25 支持</li>\n<li>iOS6 上 Chrome 和 Safari 支持</li>\n<li>原文中提到 IE10（估计是 Win8 上），Firefox OS 支持。</li>\n</ul>\n<h2 id=\"测试方法\"><a href=\"#测试方法\" class=\"headerlink\" title=\"测试方法\"></a>测试方法</h2><p><a href=\"http://www.phpied.com/files/css-thread/thread.html\" target=\"_blank\" rel=\"noopener\">点击我打开测试页面</a>。点击按钮以后，javascript 脚本持续执行 2 秒，在这个过程中查看红蓝绿三个方块的效果。如果三个均停止动画，说明浏览器尚不支持将 CSS transform 动画移出 UI 线程，如果红色和绿色方块继续动画，则支持。</p>\n<h2 id=\"解释\"><a href=\"#解释\" class=\"headerlink\" title=\"解释\"></a>解释</h2><p>红色方块的动画如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.spin</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: <span class=\"number\">3s</span> rotate linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> rotate &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(0deg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">rotate</span>(360deg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>绿色方块的动画如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.walkabout-new-school</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: <span class=\"number\">3s</span> slide-transform linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> slide-transform &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translatex</span>(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    50% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translatex</span>(300px);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">transform</span>: <span class=\"built_in\">translatex</span>(0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>蓝色方块的动画如下</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.walkabout-old-school</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">animation</span>: <span class=\"number\">3s</span> slide-margin linear infinite;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@<span class=\"keyword\">keyframes</span> slide-margin &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">from</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">margin-left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    50% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">margin-left</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">to</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">margin-left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>如果有可能，尽量使用 CSS3 transform 动画。这些动画脱离了主线程，不影响主线程。</p>\n"},{"title":"蓝光机WebApp-无尽列表优化","_content":"\n## 背景介绍\n\n该项目是一个运行于蓝光机内置浏览器 Opera 之上的单页面 WebApp，输入关键字，跨服务（视频，音频，Youtube 等）查询媒体内容。由于所有操作都是通过遥控器完成，所以通常可以使用的操作基本只有按键：上下左右以及返回键，确定键。为了显示不确定数量的媒体项，采用了通过向下/向上键来控制显示更后面/更前面的记录。  \n使用的框架包括，使用[requirejs](http://requirejs.org/)动态加载脚本，使用[jQuery](http://jquery.com/)操作 DOM，使用[doT](http://olado.github.io/doT/)作为模板引擎。\n\n## 优化历程\n\n分析一：根据一般的 WebApp 开发经验知道，不可能在一个页面中显示所有的媒体项。有必要分页显示。但是每页显示多少呢？通过对蓝光机的实机测试，每页显示 30 个项目，另外根据 UI 设计每屏最多显示 12 条。\n\n**方案一**：首先显示第一个 30 条（0-29），随着用户按下向下键，当要显示第 30 条记录的时候，使用`$container.html($(str))`显示第 18-47 条，当需要显示第 48 条的时候，使用`$container.html($(str))`显示第 36-65 条……依次类推下去  \n现象一：桌面浏览器没有问题，但在蓝光机中会出现闪烁，即在某个时刻页面中没有任何内容。所有的蓝光机概率为**~95%**\n\n分析二：这种现象的原因很简单，`$container.html($(str))`确实做了一个清空容器的操作，如果性能较差，会出现闪烁现象。\n\n**方案二**：显示新纪录时，当前显示在页面中 12 条记录保持不变，使用`$container.find(':lt(18)').remove()`去掉前面 18 条记录，再使用`$container.append($(str))`添加后面的 18 条记录。\n\n现象二：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 **~20%**，在较差的蓝光机中概率为 **~50%**\n\n分析三：以上仍然使用 jQuery 封装的 find，remove 以及 append 方法，这些方法的实现还是相当复杂，做了太多无用的工作。  \n**方案三**：使用原生的 DOM 操作方法`document.createDocumentFragment()`创建一个文档片段，批量添加记录。  \n现象三：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 **~1%**，在较差的蓝光机中概率为 **~15%**\n\n分析四：仍然使用了`$container.find(':lt(18)').remove()`去掉前面 18 条记录，这里`remove`方法可以导致$container这部分内容18次的重排重绘。 这是因为并没有找到和`document.createDocumentFragment`相似的可以批量删除DOM节点的方法。 在桌面浏览器，移动浏览器常用的方法，比如首先将$container 从 DOM 树中删除，执行一系列的删除操作之后再添加到 DOM 树中，都会导致更频繁的闪烁现象。  \n在即将放弃该项优化的时候，脑子里突然冒出了一个从来没有使用过的方法。既不清楚能够解决该问题，也不知道如何使用该方法，只知道这个方法通常用在富文本编辑器中，好像可以批量操作元素。\n\n**方案四**：使用`document.createRange`批量删除元素。\n\n```javascript\nfunction removeChildren(parent, start, end) {\n    var range = document.createRange();\n    var children = parent.children;\n    range.setStartBefore(children[start]);\n    range.setEndAfter(children[end]);\n    children = null;\n    range.deleteContents();\n}\n```\n\n现象四：桌面浏览器以及所有的蓝光机中均没有闪烁现象。\n\n最后又发现`elem.insertAdjacentHTML`的执行效率在蓝光机上优于`document.createDocumentFragment`，基本上前者耗时是后者的 **50%**，但是不解的是在 Chrome26/Windows7 上前者耗时略高于后者。由于目标设备是蓝光机，所以这次优化成功，可以使用`elem.insertAdjacentHTML`。  \n`elem.insertAdjacentHTML`第一个参数是字符串，表示插入位置，共有四个可选值，如下表说明（来源：Javascript 权威指南，P379）。第二参数也是字符串，表示要插入的 HTML 字符串。\n\n```txt\n<div id=\"target\">This is the element content</div>\n↑                ↑                          ↑    ↑\nbeforebegin      afterbegin                 beforeend afterend\n```\n","source":"_posts/2013-04-07-Blue-ray-Web-App-Endless-List-Optimization.md","raw":"---\ntitle: 蓝光机WebApp-无尽列表优化\n---\n\n## 背景介绍\n\n该项目是一个运行于蓝光机内置浏览器 Opera 之上的单页面 WebApp，输入关键字，跨服务（视频，音频，Youtube 等）查询媒体内容。由于所有操作都是通过遥控器完成，所以通常可以使用的操作基本只有按键：上下左右以及返回键，确定键。为了显示不确定数量的媒体项，采用了通过向下/向上键来控制显示更后面/更前面的记录。  \n使用的框架包括，使用[requirejs](http://requirejs.org/)动态加载脚本，使用[jQuery](http://jquery.com/)操作 DOM，使用[doT](http://olado.github.io/doT/)作为模板引擎。\n\n## 优化历程\n\n分析一：根据一般的 WebApp 开发经验知道，不可能在一个页面中显示所有的媒体项。有必要分页显示。但是每页显示多少呢？通过对蓝光机的实机测试，每页显示 30 个项目，另外根据 UI 设计每屏最多显示 12 条。\n\n**方案一**：首先显示第一个 30 条（0-29），随着用户按下向下键，当要显示第 30 条记录的时候，使用`$container.html($(str))`显示第 18-47 条，当需要显示第 48 条的时候，使用`$container.html($(str))`显示第 36-65 条……依次类推下去  \n现象一：桌面浏览器没有问题，但在蓝光机中会出现闪烁，即在某个时刻页面中没有任何内容。所有的蓝光机概率为**~95%**\n\n分析二：这种现象的原因很简单，`$container.html($(str))`确实做了一个清空容器的操作，如果性能较差，会出现闪烁现象。\n\n**方案二**：显示新纪录时，当前显示在页面中 12 条记录保持不变，使用`$container.find(':lt(18)').remove()`去掉前面 18 条记录，再使用`$container.append($(str))`添加后面的 18 条记录。\n\n现象二：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 **~20%**，在较差的蓝光机中概率为 **~50%**\n\n分析三：以上仍然使用 jQuery 封装的 find，remove 以及 append 方法，这些方法的实现还是相当复杂，做了太多无用的工作。  \n**方案三**：使用原生的 DOM 操作方法`document.createDocumentFragment()`创建一个文档片段，批量添加记录。  \n现象三：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 **~1%**，在较差的蓝光机中概率为 **~15%**\n\n分析四：仍然使用了`$container.find(':lt(18)').remove()`去掉前面 18 条记录，这里`remove`方法可以导致$container这部分内容18次的重排重绘。 这是因为并没有找到和`document.createDocumentFragment`相似的可以批量删除DOM节点的方法。 在桌面浏览器，移动浏览器常用的方法，比如首先将$container 从 DOM 树中删除，执行一系列的删除操作之后再添加到 DOM 树中，都会导致更频繁的闪烁现象。  \n在即将放弃该项优化的时候，脑子里突然冒出了一个从来没有使用过的方法。既不清楚能够解决该问题，也不知道如何使用该方法，只知道这个方法通常用在富文本编辑器中，好像可以批量操作元素。\n\n**方案四**：使用`document.createRange`批量删除元素。\n\n```javascript\nfunction removeChildren(parent, start, end) {\n    var range = document.createRange();\n    var children = parent.children;\n    range.setStartBefore(children[start]);\n    range.setEndAfter(children[end]);\n    children = null;\n    range.deleteContents();\n}\n```\n\n现象四：桌面浏览器以及所有的蓝光机中均没有闪烁现象。\n\n最后又发现`elem.insertAdjacentHTML`的执行效率在蓝光机上优于`document.createDocumentFragment`，基本上前者耗时是后者的 **50%**，但是不解的是在 Chrome26/Windows7 上前者耗时略高于后者。由于目标设备是蓝光机，所以这次优化成功，可以使用`elem.insertAdjacentHTML`。  \n`elem.insertAdjacentHTML`第一个参数是字符串，表示插入位置，共有四个可选值，如下表说明（来源：Javascript 权威指南，P379）。第二参数也是字符串，表示要插入的 HTML 字符串。\n\n```txt\n<div id=\"target\">This is the element content</div>\n↑                ↑                          ↑    ↑\nbeforebegin      afterbegin                 beforeend afterend\n```\n","slug":"Blue-ray-Web-App-Endless-List-Optimization","published":1,"date":"2013-04-06T16:00:00.000Z","updated":"2018-12-07T03:05:03.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm8z0001w8wkomtg4kxt","content":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>该项目是一个运行于蓝光机内置浏览器 Opera 之上的单页面 WebApp，输入关键字，跨服务（视频，音频，Youtube 等）查询媒体内容。由于所有操作都是通过遥控器完成，所以通常可以使用的操作基本只有按键：上下左右以及返回键，确定键。为了显示不确定数量的媒体项，采用了通过向下/向上键来控制显示更后面/更前面的记录。<br>使用的框架包括，使用<a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"noopener\">requirejs</a>动态加载脚本，使用<a href=\"http://jquery.com/\" target=\"_blank\" rel=\"noopener\">jQuery</a>操作 DOM，使用<a href=\"http://olado.github.io/doT/\" target=\"_blank\" rel=\"noopener\">doT</a>作为模板引擎。</p>\n<h2 id=\"优化历程\"><a href=\"#优化历程\" class=\"headerlink\" title=\"优化历程\"></a>优化历程</h2><p>分析一：根据一般的 WebApp 开发经验知道，不可能在一个页面中显示所有的媒体项。有必要分页显示。但是每页显示多少呢？通过对蓝光机的实机测试，每页显示 30 个项目，另外根据 UI 设计每屏最多显示 12 条。</p>\n<p><strong>方案一</strong>：首先显示第一个 30 条（0-29），随着用户按下向下键，当要显示第 30 条记录的时候，使用<code>$container.html($(str))</code>显示第 18-47 条，当需要显示第 48 条的时候，使用<code>$container.html($(str))</code>显示第 36-65 条……依次类推下去<br>现象一：桌面浏览器没有问题，但在蓝光机中会出现闪烁，即在某个时刻页面中没有任何内容。所有的蓝光机概率为<strong>~95%</strong></p>\n<p>分析二：这种现象的原因很简单，<code>$container.html($(str))</code>确实做了一个清空容器的操作，如果性能较差，会出现闪烁现象。</p>\n<p><strong>方案二</strong>：显示新纪录时，当前显示在页面中 12 条记录保持不变，使用<code>$container.find(&#39;:lt(18)&#39;).remove()</code>去掉前面 18 条记录，再使用<code>$container.append($(str))</code>添加后面的 18 条记录。</p>\n<p>现象二：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 <strong>~20%</strong>，在较差的蓝光机中概率为 <strong>~50%</strong></p>\n<p>分析三：以上仍然使用 jQuery 封装的 find，remove 以及 append 方法，这些方法的实现还是相当复杂，做了太多无用的工作。<br><strong>方案三</strong>：使用原生的 DOM 操作方法<code>document.createDocumentFragment()</code>创建一个文档片段，批量添加记录。<br>现象三：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 <strong>~1%</strong>，在较差的蓝光机中概率为 <strong>~15%</strong></p>\n<p>分析四：仍然使用了<code>$container.find(&#39;:lt(18)&#39;).remove()</code>去掉前面 18 条记录，这里<code>remove</code>方法可以导致$container这部分内容18次的重排重绘。 这是因为并没有找到和<code>document.createDocumentFragment</code>相似的可以批量删除DOM节点的方法。 在桌面浏览器，移动浏览器常用的方法，比如首先将$container 从 DOM 树中删除，执行一系列的删除操作之后再添加到 DOM 树中，都会导致更频繁的闪烁现象。<br>在即将放弃该项优化的时候，脑子里突然冒出了一个从来没有使用过的方法。既不清楚能够解决该问题，也不知道如何使用该方法，只知道这个方法通常用在富文本编辑器中，好像可以批量操作元素。</p>\n<p><strong>方案四</strong>：使用<code>document.createRange</code>批量删除元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeChildren</span>(<span class=\"params\">parent, start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> range = <span class=\"built_in\">document</span>.createRange();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> children = parent.children;</span><br><span class=\"line\">    range.setStartBefore(children[start]);</span><br><span class=\"line\">    range.setEndAfter(children[end]);</span><br><span class=\"line\">    children = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    range.deleteContents();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现象四：桌面浏览器以及所有的蓝光机中均没有闪烁现象。</p>\n<p>最后又发现<code>elem.insertAdjacentHTML</code>的执行效率在蓝光机上优于<code>document.createDocumentFragment</code>，基本上前者耗时是后者的 <strong>50%</strong>，但是不解的是在 Chrome26/Windows7 上前者耗时略高于后者。由于目标设备是蓝光机，所以这次优化成功，可以使用<code>elem.insertAdjacentHTML</code>。<br><code>elem.insertAdjacentHTML</code>第一个参数是字符串，表示插入位置，共有四个可选值，如下表说明（来源：Javascript 权威指南，P379）。第二参数也是字符串，表示要插入的 HTML 字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;target&quot;&gt;This is the element content&lt;/div&gt;</span><br><span class=\"line\">↑                ↑                          ↑    ↑</span><br><span class=\"line\">beforebegin      afterbegin                 beforeend afterend</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>该项目是一个运行于蓝光机内置浏览器 Opera 之上的单页面 WebApp，输入关键字，跨服务（视频，音频，Youtube 等）查询媒体内容。由于所有操作都是通过遥控器完成，所以通常可以使用的操作基本只有按键：上下左右以及返回键，确定键。为了显示不确定数量的媒体项，采用了通过向下/向上键来控制显示更后面/更前面的记录。<br>使用的框架包括，使用<a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"noopener\">requirejs</a>动态加载脚本，使用<a href=\"http://jquery.com/\" target=\"_blank\" rel=\"noopener\">jQuery</a>操作 DOM，使用<a href=\"http://olado.github.io/doT/\" target=\"_blank\" rel=\"noopener\">doT</a>作为模板引擎。</p>\n<h2 id=\"优化历程\"><a href=\"#优化历程\" class=\"headerlink\" title=\"优化历程\"></a>优化历程</h2><p>分析一：根据一般的 WebApp 开发经验知道，不可能在一个页面中显示所有的媒体项。有必要分页显示。但是每页显示多少呢？通过对蓝光机的实机测试，每页显示 30 个项目，另外根据 UI 设计每屏最多显示 12 条。</p>\n<p><strong>方案一</strong>：首先显示第一个 30 条（0-29），随着用户按下向下键，当要显示第 30 条记录的时候，使用<code>$container.html($(str))</code>显示第 18-47 条，当需要显示第 48 条的时候，使用<code>$container.html($(str))</code>显示第 36-65 条……依次类推下去<br>现象一：桌面浏览器没有问题，但在蓝光机中会出现闪烁，即在某个时刻页面中没有任何内容。所有的蓝光机概率为<strong>~95%</strong></p>\n<p>分析二：这种现象的原因很简单，<code>$container.html($(str))</code>确实做了一个清空容器的操作，如果性能较差，会出现闪烁现象。</p>\n<p><strong>方案二</strong>：显示新纪录时，当前显示在页面中 12 条记录保持不变，使用<code>$container.find(&#39;:lt(18)&#39;).remove()</code>去掉前面 18 条记录，再使用<code>$container.append($(str))</code>添加后面的 18 条记录。</p>\n<p>现象二：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 <strong>~20%</strong>，在较差的蓝光机中概率为 <strong>~50%</strong></p>\n<p>分析三：以上仍然使用 jQuery 封装的 find，remove 以及 append 方法，这些方法的实现还是相当复杂，做了太多无用的工作。<br><strong>方案三</strong>：使用原生的 DOM 操作方法<code>document.createDocumentFragment()</code>创建一个文档片段，批量添加记录。<br>现象三：桌面浏览器没有问题，但在性能较好的蓝光机中出现闪烁的概率为 <strong>~1%</strong>，在较差的蓝光机中概率为 <strong>~15%</strong></p>\n<p>分析四：仍然使用了<code>$container.find(&#39;:lt(18)&#39;).remove()</code>去掉前面 18 条记录，这里<code>remove</code>方法可以导致$container这部分内容18次的重排重绘。 这是因为并没有找到和<code>document.createDocumentFragment</code>相似的可以批量删除DOM节点的方法。 在桌面浏览器，移动浏览器常用的方法，比如首先将$container 从 DOM 树中删除，执行一系列的删除操作之后再添加到 DOM 树中，都会导致更频繁的闪烁现象。<br>在即将放弃该项优化的时候，脑子里突然冒出了一个从来没有使用过的方法。既不清楚能够解决该问题，也不知道如何使用该方法，只知道这个方法通常用在富文本编辑器中，好像可以批量操作元素。</p>\n<p><strong>方案四</strong>：使用<code>document.createRange</code>批量删除元素。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeChildren</span>(<span class=\"params\">parent, start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> range = <span class=\"built_in\">document</span>.createRange();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> children = parent.children;</span><br><span class=\"line\">    range.setStartBefore(children[start]);</span><br><span class=\"line\">    range.setEndAfter(children[end]);</span><br><span class=\"line\">    children = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    range.deleteContents();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现象四：桌面浏览器以及所有的蓝光机中均没有闪烁现象。</p>\n<p>最后又发现<code>elem.insertAdjacentHTML</code>的执行效率在蓝光机上优于<code>document.createDocumentFragment</code>，基本上前者耗时是后者的 <strong>50%</strong>，但是不解的是在 Chrome26/Windows7 上前者耗时略高于后者。由于目标设备是蓝光机，所以这次优化成功，可以使用<code>elem.insertAdjacentHTML</code>。<br><code>elem.insertAdjacentHTML</code>第一个参数是字符串，表示插入位置，共有四个可选值，如下表说明（来源：Javascript 权威指南，P379）。第二参数也是字符串，表示要插入的 HTML 字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;target&quot;&gt;This is the element content&lt;/div&gt;</span><br><span class=\"line\">↑                ↑                          ↑    ↑</span><br><span class=\"line\">beforebegin      afterbegin                 beforeend afterend</span><br></pre></td></tr></table></figure>\n"},{"title":"【正则表达式】使用逗号将数字三位三位地分开","_content":"\n## 背景介绍\n\n在一个项目中，需要显示一个 YouTube 视频被观看了多少次，这个数字一般是个很长的数字，为了更好的体验，也是国际标准，三位三位地断开，对应千（thousand），百万（million），十亿（billion），当然对中国用户来讲，不是特别友好，中国人喜欢四位四位隔开，对应万，亿，万亿。。。但是无论如何，都比看到 567232349723 这样的一串数字好很多。  \n言归正传，这个该如何实现呢？以下就以 567232349723 数字为例。\n\n## 普通的解决办法\n\n首先，可以这样理解，就是从数字的最后一位开始，往前数，数到 3，加一个逗号，如此循环下去……直到第一个数字（因为逗号不能加在开始位置，比如不能“,123”）。\n\n```js\nvar array = '567232349723'.split('');\nfor (var i = array.length - 1, j = 1; i > 0; i--, j++) {\n    if (j % 3 === 0) {\n        array.splice(i, 0, ',');\n    }\n}\nconsole.log(array.join(''));\n```\n\n受不了了，看似特别简单的问题，要写那么长一段代码。从标题你就看到了，这不是我们想要的答案，我们将要使用正则表达式来解决这个问题。首先来明确几个概念：\n\n**零宽断言（零宽度正预测先行断言）**：形式为`(?=exp)`。**零宽**，就是不匹配任何内容，明确一点就是它表示的是一个位置，就像^, \\$一样。**断言**，就是说它需要满足一定条件。\n\n**负向零宽断言（零宽度负预测先行断言）**：形式为`(?!exp)`。所谓负向，就是不满足某种条件。\n\n这两个别名都含有“先行”二字，它表示匹配的位置是表达式前面的位置。这么说来，肯定还会有一种用于匹配表达式后面的位置。你说的对，还有“零宽度正回顾后发断言”，形式为`(?<=exp)`，以及“零宽度负回顾后发断言”，形式为`(?<!exp)`。但是在 javascript 中并不支持这两中形式。这次不多说明。  \n###正则表达式办法\n我们现在看看哪些位置需要添加逗号，首先这个位置不能是开始位置，也就是`(?!^)`，其次这个位置后面总是有 3n（n > 0）个数字，直到结束，也就是`(\\d{3})+$`，组合起来就是`(?=(?!^)(\\d{3})+$)`。\n\n所以答案就是\n\n```js\n'567232349723'.replace(/(?=(?!^)(\\d{3})+$)/g, ',');\n```\n\n注意了，以上正则对于整数已经足够了，加入你想也适应于小数呢？比如“123456.123456”，这时候我们只处理前面几位，所以上面的“直到结束”应该修改为“直到结束或者小数点”，那么答案来了，就是`[$\\.]`，所以适用于小数的正则为\n\n```js\n'567232.49723'.replace(/(?=(?!^)(\\d{3})+[$\\.])/g, ',');\n```\n\n如果想适用更多情况，会使得你的正则越来越复杂，也越来越容易出错，所以要根据你实际需要来决定，不多不少最好。\n\n## 工具推荐\n\n1. [http://www.regexper.com/]()\n2. Windows 系统上的[RegExpBuddy](http://www.regexbuddy.com/)，收费约 40 美元。\n","source":"_posts/2013-04-15-Grouping-Numbers-with-Comma.md","raw":"---\ntitle: 【正则表达式】使用逗号将数字三位三位地分开\n---\n\n## 背景介绍\n\n在一个项目中，需要显示一个 YouTube 视频被观看了多少次，这个数字一般是个很长的数字，为了更好的体验，也是国际标准，三位三位地断开，对应千（thousand），百万（million），十亿（billion），当然对中国用户来讲，不是特别友好，中国人喜欢四位四位隔开，对应万，亿，万亿。。。但是无论如何，都比看到 567232349723 这样的一串数字好很多。  \n言归正传，这个该如何实现呢？以下就以 567232349723 数字为例。\n\n## 普通的解决办法\n\n首先，可以这样理解，就是从数字的最后一位开始，往前数，数到 3，加一个逗号，如此循环下去……直到第一个数字（因为逗号不能加在开始位置，比如不能“,123”）。\n\n```js\nvar array = '567232349723'.split('');\nfor (var i = array.length - 1, j = 1; i > 0; i--, j++) {\n    if (j % 3 === 0) {\n        array.splice(i, 0, ',');\n    }\n}\nconsole.log(array.join(''));\n```\n\n受不了了，看似特别简单的问题，要写那么长一段代码。从标题你就看到了，这不是我们想要的答案，我们将要使用正则表达式来解决这个问题。首先来明确几个概念：\n\n**零宽断言（零宽度正预测先行断言）**：形式为`(?=exp)`。**零宽**，就是不匹配任何内容，明确一点就是它表示的是一个位置，就像^, \\$一样。**断言**，就是说它需要满足一定条件。\n\n**负向零宽断言（零宽度负预测先行断言）**：形式为`(?!exp)`。所谓负向，就是不满足某种条件。\n\n这两个别名都含有“先行”二字，它表示匹配的位置是表达式前面的位置。这么说来，肯定还会有一种用于匹配表达式后面的位置。你说的对，还有“零宽度正回顾后发断言”，形式为`(?<=exp)`，以及“零宽度负回顾后发断言”，形式为`(?<!exp)`。但是在 javascript 中并不支持这两中形式。这次不多说明。  \n###正则表达式办法\n我们现在看看哪些位置需要添加逗号，首先这个位置不能是开始位置，也就是`(?!^)`，其次这个位置后面总是有 3n（n > 0）个数字，直到结束，也就是`(\\d{3})+$`，组合起来就是`(?=(?!^)(\\d{3})+$)`。\n\n所以答案就是\n\n```js\n'567232349723'.replace(/(?=(?!^)(\\d{3})+$)/g, ',');\n```\n\n注意了，以上正则对于整数已经足够了，加入你想也适应于小数呢？比如“123456.123456”，这时候我们只处理前面几位，所以上面的“直到结束”应该修改为“直到结束或者小数点”，那么答案来了，就是`[$\\.]`，所以适用于小数的正则为\n\n```js\n'567232.49723'.replace(/(?=(?!^)(\\d{3})+[$\\.])/g, ',');\n```\n\n如果想适用更多情况，会使得你的正则越来越复杂，也越来越容易出错，所以要根据你实际需要来决定，不多不少最好。\n\n## 工具推荐\n\n1. [http://www.regexper.com/]()\n2. Windows 系统上的[RegExpBuddy](http://www.regexbuddy.com/)，收费约 40 美元。\n","slug":"Grouping-Numbers-with-Comma","published":1,"date":"2013-04-14T16:00:00.000Z","updated":"2018-12-07T03:06:38.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm910002w8wkff3zpt16","content":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>在一个项目中，需要显示一个 YouTube 视频被观看了多少次，这个数字一般是个很长的数字，为了更好的体验，也是国际标准，三位三位地断开，对应千（thousand），百万（million），十亿（billion），当然对中国用户来讲，不是特别友好，中国人喜欢四位四位隔开，对应万，亿，万亿。。。但是无论如何，都比看到 567232349723 这样的一串数字好很多。<br>言归正传，这个该如何实现呢？以下就以 567232349723 数字为例。</p>\n<h2 id=\"普通的解决办法\"><a href=\"#普通的解决办法\" class=\"headerlink\" title=\"普通的解决办法\"></a>普通的解决办法</h2><p>首先，可以这样理解，就是从数字的最后一位开始，往前数，数到 3，加一个逗号，如此循环下去……直到第一个数字（因为逗号不能加在开始位置，比如不能“,123”）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = <span class=\"string\">'567232349723'</span>.split(<span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = array.length - <span class=\"number\">1</span>, j = <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--, j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j % <span class=\"number\">3</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        array.splice(i, <span class=\"number\">0</span>, <span class=\"string\">','</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.join(<span class=\"string\">''</span>));</span><br></pre></td></tr></table></figure>\n<p>受不了了，看似特别简单的问题，要写那么长一段代码。从标题你就看到了，这不是我们想要的答案，我们将要使用正则表达式来解决这个问题。首先来明确几个概念：</p>\n<p><strong>零宽断言（零宽度正预测先行断言）</strong>：形式为<code>(?=exp)</code>。<strong>零宽</strong>，就是不匹配任何内容，明确一点就是它表示的是一个位置，就像^, \\$一样。<strong>断言</strong>，就是说它需要满足一定条件。</p>\n<p><strong>负向零宽断言（零宽度负预测先行断言）</strong>：形式为<code>(?!exp)</code>。所谓负向，就是不满足某种条件。</p>\n<p>这两个别名都含有“先行”二字，它表示匹配的位置是表达式前面的位置。这么说来，肯定还会有一种用于匹配表达式后面的位置。你说的对，还有“零宽度正回顾后发断言”，形式为<code>(?&lt;=exp)</code>，以及“零宽度负回顾后发断言”，形式为<code>(?&lt;!exp)</code>。但是在 javascript 中并不支持这两中形式。这次不多说明。  </p>\n<p>###正则表达式办法<br>我们现在看看哪些位置需要添加逗号，首先这个位置不能是开始位置，也就是<code>(?!^)</code>，其次这个位置后面总是有 3n（n &gt; 0）个数字，直到结束，也就是<code>(\\d{3})+$</code>，组合起来就是<code>(?=(?!^)(\\d{3})+$)</code>。</p>\n<p>所以答案就是</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'567232349723'</span>.replace(<span class=\"regexp\">/(?=(?!^)(\\d&#123;3&#125;)+$)/g</span>, <span class=\"string\">','</span>);</span><br></pre></td></tr></table></figure>\n<p>注意了，以上正则对于整数已经足够了，加入你想也适应于小数呢？比如“123456.123456”，这时候我们只处理前面几位，所以上面的“直到结束”应该修改为“直到结束或者小数点”，那么答案来了，就是<code>[$\\.]</code>，所以适用于小数的正则为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'567232.49723'</span>.replace(<span class=\"regexp\">/(?=(?!^)(\\d&#123;3&#125;)+[$\\.])/g</span>, <span class=\"string\">','</span>);</span><br></pre></td></tr></table></figure>\n<p>如果想适用更多情况，会使得你的正则越来越复杂，也越来越容易出错，所以要根据你实际需要来决定，不多不少最好。</p>\n<h2 id=\"工具推荐\"><a href=\"#工具推荐\" class=\"headerlink\" title=\"工具推荐\"></a>工具推荐</h2><ol>\n<li><a href=\"\">http://www.regexper.com/</a></li>\n<li>Windows 系统上的<a href=\"http://www.regexbuddy.com/\" target=\"_blank\" rel=\"noopener\">RegExpBuddy</a>，收费约 40 美元。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>在一个项目中，需要显示一个 YouTube 视频被观看了多少次，这个数字一般是个很长的数字，为了更好的体验，也是国际标准，三位三位地断开，对应千（thousand），百万（million），十亿（billion），当然对中国用户来讲，不是特别友好，中国人喜欢四位四位隔开，对应万，亿，万亿。。。但是无论如何，都比看到 567232349723 这样的一串数字好很多。<br>言归正传，这个该如何实现呢？以下就以 567232349723 数字为例。</p>\n<h2 id=\"普通的解决办法\"><a href=\"#普通的解决办法\" class=\"headerlink\" title=\"普通的解决办法\"></a>普通的解决办法</h2><p>首先，可以这样理解，就是从数字的最后一位开始，往前数，数到 3，加一个逗号，如此循环下去……直到第一个数字（因为逗号不能加在开始位置，比如不能“,123”）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = <span class=\"string\">'567232349723'</span>.split(<span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = array.length - <span class=\"number\">1</span>, j = <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--, j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j % <span class=\"number\">3</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        array.splice(i, <span class=\"number\">0</span>, <span class=\"string\">','</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(array.join(<span class=\"string\">''</span>));</span><br></pre></td></tr></table></figure>\n<p>受不了了，看似特别简单的问题，要写那么长一段代码。从标题你就看到了，这不是我们想要的答案，我们将要使用正则表达式来解决这个问题。首先来明确几个概念：</p>\n<p><strong>零宽断言（零宽度正预测先行断言）</strong>：形式为<code>(?=exp)</code>。<strong>零宽</strong>，就是不匹配任何内容，明确一点就是它表示的是一个位置，就像^, \\$一样。<strong>断言</strong>，就是说它需要满足一定条件。</p>\n<p><strong>负向零宽断言（零宽度负预测先行断言）</strong>：形式为<code>(?!exp)</code>。所谓负向，就是不满足某种条件。</p>\n<p>这两个别名都含有“先行”二字，它表示匹配的位置是表达式前面的位置。这么说来，肯定还会有一种用于匹配表达式后面的位置。你说的对，还有“零宽度正回顾后发断言”，形式为<code>(?&lt;=exp)</code>，以及“零宽度负回顾后发断言”，形式为<code>(?&lt;!exp)</code>。但是在 javascript 中并不支持这两中形式。这次不多说明。  </p>\n<p>###正则表达式办法<br>我们现在看看哪些位置需要添加逗号，首先这个位置不能是开始位置，也就是<code>(?!^)</code>，其次这个位置后面总是有 3n（n &gt; 0）个数字，直到结束，也就是<code>(\\d{3})+$</code>，组合起来就是<code>(?=(?!^)(\\d{3})+$)</code>。</p>\n<p>所以答案就是</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'567232349723'</span>.replace(<span class=\"regexp\">/(?=(?!^)(\\d&#123;3&#125;)+$)/g</span>, <span class=\"string\">','</span>);</span><br></pre></td></tr></table></figure>\n<p>注意了，以上正则对于整数已经足够了，加入你想也适应于小数呢？比如“123456.123456”，这时候我们只处理前面几位，所以上面的“直到结束”应该修改为“直到结束或者小数点”，那么答案来了，就是<code>[$\\.]</code>，所以适用于小数的正则为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'567232.49723'</span>.replace(<span class=\"regexp\">/(?=(?!^)(\\d&#123;3&#125;)+[$\\.])/g</span>, <span class=\"string\">','</span>);</span><br></pre></td></tr></table></figure>\n<p>如果想适用更多情况，会使得你的正则越来越复杂，也越来越容易出错，所以要根据你实际需要来决定，不多不少最好。</p>\n<h2 id=\"工具推荐\"><a href=\"#工具推荐\" class=\"headerlink\" title=\"工具推荐\"></a>工具推荐</h2><ol>\n<li><a href=\"\">http://www.regexper.com/</a></li>\n<li>Windows 系统上的<a href=\"http://www.regexbuddy.com/\" target=\"_blank\" rel=\"noopener\">RegExpBuddy</a>，收费约 40 美元。</li>\n</ol>\n"},{"title":"使用别样的鼠标形状","_content":"\n某些时候，我们并不使用 CSS 中支持的鼠标形状，比如 default 箭头，pointer 手型等等，也不使用 url 指定鼠标形状，而是使用 html+css+js 渲染。例如在黑色背景的页面中，使用一个从圆心到周边透明度径向渐变的圆形图形作为鼠标形状。\n实现起来非常简单。首先在 html 元素上声明如下样式`html{ cursor: none; }`，放弃默认的箭头鼠标形状。然后创建一个绝对定位的，className 为 cursor 的 body 子元素 div。\n\n## 方案一：渐变背景色实现【失败】\n\n```css\ndiv.cursor {\n    position: absolute;\n    width: 150px;\n    height: 150px;\n    margin-top: -75px;\n    margin-left: -75px;\n    background: -webkit-radial-gradient(50% 50%, circle contain, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n}\n```\n\n但是这样就有一个问题，当按下鼠标时，mouse 事件的 target 属性永远指向该 DIV 元素。如果想监听页面上其他元素的 mouse 事件，就变得很繁琐，只能根据。于是首先想到的是用**after 伪元素**实现。\n\n## 方案二：伪元素背景色实现【失败】\n\n```css\ndiv {\n    position: absolute;\n    width: 0;\n    height: 0;\n}\ndiv:after {\n    position: absolute;\n    content: '';\n    width: 150px;\n    height: 150px;\n    margin-top: -75px;\n    margin-left: -75px;\n    background: -webkit-radial-gradient(50% 50%, circle contain, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n}\n```\n\n实现以后发现 mouse 事件的 target 属性仍然指向该 div 元素。思考一下，这个是符合逻辑的，因为 first 和 after 伪元素本来就相当于子元素的。\n\n## 方案三：box-shadow 效果实现【成功】\n\n也许你还记得，很多阴影效果都有模糊渐变的效果，在 box-shadow 语法中，blur 配合 spread 就可以做到。\n语法：`box-shadow: h-shadow v-shadow blur spread color inset;`\n\n```css\ndiv {\n    position: absolute;\n    width: 0;\n    height: 0;\n    -webkit-box-shadow: 0 0 75px 30px #000;\n}\n```\n\n效果基本可以实现，但是对于更加特别的需求，就怕无能为力了。\n\n## 方案四：CSS 属性 pointer-events 使得元素不响应事件【最佳】\n\n事件可以透过（忽视）pointer-events 值为 none 的任何元素，而触发在它后面的那个元素之上。\n\n```css\npointer-events: none;\n```\n","source":"_posts/2013-04-12-Using-an-Especial-Cursor.md","raw":"---\ntitle: 使用别样的鼠标形状\n---\n\n某些时候，我们并不使用 CSS 中支持的鼠标形状，比如 default 箭头，pointer 手型等等，也不使用 url 指定鼠标形状，而是使用 html+css+js 渲染。例如在黑色背景的页面中，使用一个从圆心到周边透明度径向渐变的圆形图形作为鼠标形状。\n实现起来非常简单。首先在 html 元素上声明如下样式`html{ cursor: none; }`，放弃默认的箭头鼠标形状。然后创建一个绝对定位的，className 为 cursor 的 body 子元素 div。\n\n## 方案一：渐变背景色实现【失败】\n\n```css\ndiv.cursor {\n    position: absolute;\n    width: 150px;\n    height: 150px;\n    margin-top: -75px;\n    margin-left: -75px;\n    background: -webkit-radial-gradient(50% 50%, circle contain, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n}\n```\n\n但是这样就有一个问题，当按下鼠标时，mouse 事件的 target 属性永远指向该 DIV 元素。如果想监听页面上其他元素的 mouse 事件，就变得很繁琐，只能根据。于是首先想到的是用**after 伪元素**实现。\n\n## 方案二：伪元素背景色实现【失败】\n\n```css\ndiv {\n    position: absolute;\n    width: 0;\n    height: 0;\n}\ndiv:after {\n    position: absolute;\n    content: '';\n    width: 150px;\n    height: 150px;\n    margin-top: -75px;\n    margin-left: -75px;\n    background: -webkit-radial-gradient(50% 50%, circle contain, rgba(255, 255, 255, 1), rgba(255, 255, 255, 0));\n}\n```\n\n实现以后发现 mouse 事件的 target 属性仍然指向该 div 元素。思考一下，这个是符合逻辑的，因为 first 和 after 伪元素本来就相当于子元素的。\n\n## 方案三：box-shadow 效果实现【成功】\n\n也许你还记得，很多阴影效果都有模糊渐变的效果，在 box-shadow 语法中，blur 配合 spread 就可以做到。\n语法：`box-shadow: h-shadow v-shadow blur spread color inset;`\n\n```css\ndiv {\n    position: absolute;\n    width: 0;\n    height: 0;\n    -webkit-box-shadow: 0 0 75px 30px #000;\n}\n```\n\n效果基本可以实现，但是对于更加特别的需求，就怕无能为力了。\n\n## 方案四：CSS 属性 pointer-events 使得元素不响应事件【最佳】\n\n事件可以透过（忽视）pointer-events 值为 none 的任何元素，而触发在它后面的那个元素之上。\n\n```css\npointer-events: none;\n```\n","slug":"Using-an-Especial-Cursor","published":1,"date":"2013-04-11T16:00:00.000Z","updated":"2018-12-07T03:03:44.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm920003w8wk33nw7m2o","content":"<p>某些时候，我们并不使用 CSS 中支持的鼠标形状，比如 default 箭头，pointer 手型等等，也不使用 url 指定鼠标形状，而是使用 html+css+js 渲染。例如在黑色背景的页面中，使用一个从圆心到周边透明度径向渐变的圆形图形作为鼠标形状。<br>实现起来非常简单。首先在 html 元素上声明如下样式<code>html{ cursor: none; }</code>，放弃默认的箭头鼠标形状。然后创建一个绝对定位的，className 为 cursor 的 body 子元素 div。</p>\n<h2 id=\"方案一：渐变背景色实现【失败】\"><a href=\"#方案一：渐变背景色实现【失败】\" class=\"headerlink\" title=\"方案一：渐变背景色实现【失败】\"></a>方案一：渐变背景色实现【失败】</h2><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-class\">.cursor</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-radial-gradient</span>(50% 50%, circle contain, rgba(255, 255, 255, 1), <span class=\"built_in\">rgba</span>(255, 255, 255, 0));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这样就有一个问题，当按下鼠标时，mouse 事件的 target 属性永远指向该 DIV 元素。如果想监听页面上其他元素的 mouse 事件，就变得很繁琐，只能根据。于是首先想到的是用<strong>after 伪元素</strong>实现。</p>\n<h2 id=\"方案二：伪元素背景色实现【失败】\"><a href=\"#方案二：伪元素背景色实现【失败】\" class=\"headerlink\" title=\"方案二：伪元素背景色实现【失败】\"></a>方案二：伪元素背景色实现【失败】</h2><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-radial-gradient</span>(50% 50%, circle contain, rgba(255, 255, 255, 1), <span class=\"built_in\">rgba</span>(255, 255, 255, 0));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现以后发现 mouse 事件的 target 属性仍然指向该 div 元素。思考一下，这个是符合逻辑的，因为 first 和 after 伪元素本来就相当于子元素的。</p>\n<h2 id=\"方案三：box-shadow-效果实现【成功】\"><a href=\"#方案三：box-shadow-效果实现【成功】\" class=\"headerlink\" title=\"方案三：box-shadow 效果实现【成功】\"></a>方案三：box-shadow 效果实现【成功】</h2><p>也许你还记得，很多阴影效果都有模糊渐变的效果，在 box-shadow 语法中，blur 配合 spread 就可以做到。<br>语法：<code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">75px</span> <span class=\"number\">30px</span> <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果基本可以实现，但是对于更加特别的需求，就怕无能为力了。</p>\n<h2 id=\"方案四：CSS-属性-pointer-events-使得元素不响应事件【最佳】\"><a href=\"#方案四：CSS-属性-pointer-events-使得元素不响应事件【最佳】\" class=\"headerlink\" title=\"方案四：CSS 属性 pointer-events 使得元素不响应事件【最佳】\"></a>方案四：CSS 属性 pointer-events 使得元素不响应事件【最佳】</h2><p>事件可以透过（忽视）pointer-events 值为 none 的任何元素，而触发在它后面的那个元素之上。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">pointer-events</span>: <span class=\"selector-tag\">none</span>;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>某些时候，我们并不使用 CSS 中支持的鼠标形状，比如 default 箭头，pointer 手型等等，也不使用 url 指定鼠标形状，而是使用 html+css+js 渲染。例如在黑色背景的页面中，使用一个从圆心到周边透明度径向渐变的圆形图形作为鼠标形状。<br>实现起来非常简单。首先在 html 元素上声明如下样式<code>html{ cursor: none; }</code>，放弃默认的箭头鼠标形状。然后创建一个绝对定位的，className 为 cursor 的 body 子元素 div。</p>\n<h2 id=\"方案一：渐变背景色实现【失败】\"><a href=\"#方案一：渐变背景色实现【失败】\" class=\"headerlink\" title=\"方案一：渐变背景色实现【失败】\"></a>方案一：渐变背景色实现【失败】</h2><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-class\">.cursor</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-radial-gradient</span>(50% 50%, circle contain, rgba(255, 255, 255, 1), <span class=\"built_in\">rgba</span>(255, 255, 255, 0));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这样就有一个问题，当按下鼠标时，mouse 事件的 target 属性永远指向该 DIV 元素。如果想监听页面上其他元素的 mouse 事件，就变得很繁琐，只能根据。于是首先想到的是用<strong>after 伪元素</strong>实现。</p>\n<h2 id=\"方案二：伪元素背景色实现【失败】\"><a href=\"#方案二：伪元素背景色实现【失败】\" class=\"headerlink\" title=\"方案二：伪元素背景色实现【失败】\"></a>方案二：伪元素背景色实现【失败】</h2><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">75px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">-webkit-radial-gradient</span>(50% 50%, circle contain, rgba(255, 255, 255, 1), <span class=\"built_in\">rgba</span>(255, 255, 255, 0));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现以后发现 mouse 事件的 target 属性仍然指向该 div 元素。思考一下，这个是符合逻辑的，因为 first 和 after 伪元素本来就相当于子元素的。</p>\n<h2 id=\"方案三：box-shadow-效果实现【成功】\"><a href=\"#方案三：box-shadow-效果实现【成功】\" class=\"headerlink\" title=\"方案三：box-shadow 效果实现【成功】\"></a>方案三：box-shadow 效果实现【成功】</h2><p>也许你还记得，很多阴影效果都有模糊渐变的效果，在 box-shadow 语法中，blur 配合 spread 就可以做到。<br>语法：<code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">75px</span> <span class=\"number\">30px</span> <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>效果基本可以实现，但是对于更加特别的需求，就怕无能为力了。</p>\n<h2 id=\"方案四：CSS-属性-pointer-events-使得元素不响应事件【最佳】\"><a href=\"#方案四：CSS-属性-pointer-events-使得元素不响应事件【最佳】\" class=\"headerlink\" title=\"方案四：CSS 属性 pointer-events 使得元素不响应事件【最佳】\"></a>方案四：CSS 属性 pointer-events 使得元素不响应事件【最佳】</h2><p>事件可以透过（忽视）pointer-events 值为 none 的任何元素，而触发在它后面的那个元素之上。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">pointer-events</span>: <span class=\"selector-tag\">none</span>;</span><br></pre></td></tr></table></figure>\n"},{"title":"在客户端高亮关键字","_content":"\n## 背景介绍\n\n在某个项目中遇到这样的需求，用户输入几个关键字，然后根据关键字去后端搜索相关记录。后端返回记录中但是没有高亮这些关键字，这就需要前端来做这件事。按道理，高亮应该由后端完成，因为后端如何解析这些关键字，也知道如何去匹配，前端不知道也不应该知道后端为什么返回这些结果，英语中名词有复数形式，动词有现在式，过去式，过去完成式等，其他诸如德语，葡萄牙语有没有词性变换更是不得而知。后端依赖强大的知识库可以处理词性变换甚至近义词都是可能的，前端不可能完成工作，即便可能，也远比后来来处理高亮要复杂的多。但是这就是客户需求，我们还是要实现。\n\n整个流程：获取用户输入，比如 'search by keyword'，发送 JSONP 请求获取后端搜索到的记录。在关键的几个字段中，搜索‘search’，‘by’和‘keyword’这三个关键字，并在单词两边分别加上`<span class=\"highlight\">`和`</span>`，给`.highlight`定义一个合适的样式，比如粗体等，就完成了高亮的效果。\n\n## 步骤\n\n第一步，首先把关键字用空白符分隔开，得到一个一个的关键字。\n\n```js\nvar keywords = keyword.split(/\\s+/);\n```\n\n第二步，将第一步中得到的字符串数组，转变成正则数组。\n\n```js\nkeywords.map(function(it) {\n    // g replace all\n    // i case-insensitive\n    return new RegExp(it, 'gi');\n});\n```\n\nRegExp 的第一个参数是传 it 呢，还是`'\\b' + it + '\\b'`呢？如果是前者，关键字`a`可以匹配`take`中的`a`。如果是后者，`teach`不可以匹配`teaches`中的`teach`。都不完美，这也是在文章开头提及的不适合前端做高亮的原因。  \n如果你够细心，你应该已经感觉到隐隐有些不妥，因为在通过 RegExp 创建正则表达式时，第一个参数不能包含正则中预定义的一些字符，除非在前面加上了一个反斜线，比如`[?`就不可以，而`\\[\\?`才是真正地匹配`[?`。所以在这之前，我们添加一步：\n\n第〇步：给所有的正则预定义字符之前添加一个反斜线（backslash）。找出所有的预定义字符`char`并替换为`'\\\\' + char`。通过强大的`String.prototype.replace`方法很方便的完成。\n\n```js\nkeyword = keyword.replace(/[\\\\\\{\\}\\[\\]\\(\\)\\*\\+\\?\\^\\$\\,\\-\\=\\!]/g, function(char) {\n    return '\\\\' + char;\n});\n```\n\n需要特别说的是，还有一处可以改进。在前面的一片文章[【正则表达式】使用逗号将数字三位三位地分开](./2013-04-15-Grouping-Numbers-with-Comma.md)中，我们使用了零宽断言。它匹配了这样一个位置（是为零宽），它后面的字符满足一定条件（是为断言）。在这里，我们可以使用正则表达式匹配预定义字符前面的位置，将该位置替换为`'\\\\'`。\n\n```js\nkeyword = keyword.replace(/(?=[\\\\\\{\\}\\[\\]\\(\\)\\*\\+\\?\\^\\$\\-\\=\\!])/g, '\\\\');\n```\n\n换了一种思路，顿时感觉清爽多了。\n\n第三步，遍历正则数组，然后替换所有的关键字。\n\n```js\nkeywords.forEach(function(it) {\n    string = string.replace(it, function(val) {\n        return '<span class=\"highlight\">' + val + '</span>';\n    });\n});\n```\n\n如果你足够细心或者以前遇到过类似问题，你可能已经知道，这一步中隐藏着一些问题，就是如果用户在一次搜索中，输入了两个相同的关键字，比如`take take`，那么匹配以后可能会出现`'<span class=\"highlight\"><span class=\"highlight\">take</span></span>'`这种情况，不会出错，只是浏览器需要多创建一些 DOM 元素。更甚的是，当用户输入多个关键字以后，第一次替换时会引入`'<span class=\"highlight\">'`和`'</span>'`片段，这两段字符是不应被匹配并替换的。比如替换字符是`'programer'`，关键字是`'a span'`，\n匹配关键字`a`以后，变成\n\n```html\nprogr<span class=\"highlight\">a</span>mer\n```\n\n匹配关键字`span`以后：\n\n```html\nprogr<<span class=\"highlight\">span</span> class=\"highlight\">a</<span class=\"highlight\">span</span>>mer\n```\n\n完全乱套了。  \n为了保证以上`span`两端字符不会被匹配并替换，有一种做法是仅仅记住需要插入`span`的位置，并延迟替换。如果记住位置，考虑使用一种基本不会被用到的字符，比如 0X2611(☑)以及 0X2612（☒）。\n\n```js\nkeywords.forEach(function(it) {\n    string = string.replace(it, function(val) {\n        return String.fromCharCode(0x2611) + val + String.fromCharCode(0x2612);\n    });\n});\n```\n\n匹配关键字`a`以后，变成\n\n```html\nprogr☑a☒mer\n```\n\n匹配不到`span`字符串，匹配结束。\n\n最后再将这两个特殊符号替换为`'<span class=\"highlight\">'`和`'</span>'`，在正则中使用`+`，可以匹配多个特殊字符，也就解决了用户输入输了两个以上相同的关键字并造成浏览器额外创建`span`元素的情况，当然你也可以再一开始就去重。\n所以最终正确结果是\n\n```js\nstring = string.replace(/\\u2611+/g, '<span class=\"highlight\">').replace(/\\u2612+/g, '</span>');\n```\n\n```html\nprogr<span class=\"highlight\">a</span>mer\n```\n\n以上答案正确与否，取决于 ☑ 和 ☒ 会不会出现在被替换文字中。\n\n## 最终代码\n\n```js\nvar keyword = input.value;\nvar string  = 'The string will be highlighted'；\n// replace all preserved characters in regular express.\nkeyword = keyword.replace(/(?=[\\\\\\{\\}\\[\\]\\(\\)\\*\\+\\?\\^\\$\\-\\=\\!])/g, '\\\\');\n// split keyword by space characters.\nvar keywords = keyword.split(/\\s+/);\nkeywords.forEach(function(it){\n  string = string.replace(it, function(val){\n    return String.fromCharCode(0X2611) + val + String.fromCharCode(0X2612);\n  });\n});\nstring = string.replace(/\\u2611+/g, '<span class=\"highlight\">')\n  .replace(/\\u2612+/g, '</span>');\n```\n\n```css\n.highlight {\n    font-weight: bold;\n}\n```\n\n## 总结\n\n1. 高亮根据关键字搜索出来的记录不适合在客户端做，即时实现了，很可能是该高亮的没有高亮，不该高亮的高亮了。后端可以依靠巨大的知识库来高亮词性变换后的单词，甚至近义词。\n1. 使用好强大的`String.prototype.replace`方法。\n1. 正则中零宽断言在适当的时候，可以简化代码。\n","source":"_posts/2013-04-24-Highlight-Keywords-in-Client.md","raw":"---\ntitle: 在客户端高亮关键字\n---\n\n## 背景介绍\n\n在某个项目中遇到这样的需求，用户输入几个关键字，然后根据关键字去后端搜索相关记录。后端返回记录中但是没有高亮这些关键字，这就需要前端来做这件事。按道理，高亮应该由后端完成，因为后端如何解析这些关键字，也知道如何去匹配，前端不知道也不应该知道后端为什么返回这些结果，英语中名词有复数形式，动词有现在式，过去式，过去完成式等，其他诸如德语，葡萄牙语有没有词性变换更是不得而知。后端依赖强大的知识库可以处理词性变换甚至近义词都是可能的，前端不可能完成工作，即便可能，也远比后来来处理高亮要复杂的多。但是这就是客户需求，我们还是要实现。\n\n整个流程：获取用户输入，比如 'search by keyword'，发送 JSONP 请求获取后端搜索到的记录。在关键的几个字段中，搜索‘search’，‘by’和‘keyword’这三个关键字，并在单词两边分别加上`<span class=\"highlight\">`和`</span>`，给`.highlight`定义一个合适的样式，比如粗体等，就完成了高亮的效果。\n\n## 步骤\n\n第一步，首先把关键字用空白符分隔开，得到一个一个的关键字。\n\n```js\nvar keywords = keyword.split(/\\s+/);\n```\n\n第二步，将第一步中得到的字符串数组，转变成正则数组。\n\n```js\nkeywords.map(function(it) {\n    // g replace all\n    // i case-insensitive\n    return new RegExp(it, 'gi');\n});\n```\n\nRegExp 的第一个参数是传 it 呢，还是`'\\b' + it + '\\b'`呢？如果是前者，关键字`a`可以匹配`take`中的`a`。如果是后者，`teach`不可以匹配`teaches`中的`teach`。都不完美，这也是在文章开头提及的不适合前端做高亮的原因。  \n如果你够细心，你应该已经感觉到隐隐有些不妥，因为在通过 RegExp 创建正则表达式时，第一个参数不能包含正则中预定义的一些字符，除非在前面加上了一个反斜线，比如`[?`就不可以，而`\\[\\?`才是真正地匹配`[?`。所以在这之前，我们添加一步：\n\n第〇步：给所有的正则预定义字符之前添加一个反斜线（backslash）。找出所有的预定义字符`char`并替换为`'\\\\' + char`。通过强大的`String.prototype.replace`方法很方便的完成。\n\n```js\nkeyword = keyword.replace(/[\\\\\\{\\}\\[\\]\\(\\)\\*\\+\\?\\^\\$\\,\\-\\=\\!]/g, function(char) {\n    return '\\\\' + char;\n});\n```\n\n需要特别说的是，还有一处可以改进。在前面的一片文章[【正则表达式】使用逗号将数字三位三位地分开](./2013-04-15-Grouping-Numbers-with-Comma.md)中，我们使用了零宽断言。它匹配了这样一个位置（是为零宽），它后面的字符满足一定条件（是为断言）。在这里，我们可以使用正则表达式匹配预定义字符前面的位置，将该位置替换为`'\\\\'`。\n\n```js\nkeyword = keyword.replace(/(?=[\\\\\\{\\}\\[\\]\\(\\)\\*\\+\\?\\^\\$\\-\\=\\!])/g, '\\\\');\n```\n\n换了一种思路，顿时感觉清爽多了。\n\n第三步，遍历正则数组，然后替换所有的关键字。\n\n```js\nkeywords.forEach(function(it) {\n    string = string.replace(it, function(val) {\n        return '<span class=\"highlight\">' + val + '</span>';\n    });\n});\n```\n\n如果你足够细心或者以前遇到过类似问题，你可能已经知道，这一步中隐藏着一些问题，就是如果用户在一次搜索中，输入了两个相同的关键字，比如`take take`，那么匹配以后可能会出现`'<span class=\"highlight\"><span class=\"highlight\">take</span></span>'`这种情况，不会出错，只是浏览器需要多创建一些 DOM 元素。更甚的是，当用户输入多个关键字以后，第一次替换时会引入`'<span class=\"highlight\">'`和`'</span>'`片段，这两段字符是不应被匹配并替换的。比如替换字符是`'programer'`，关键字是`'a span'`，\n匹配关键字`a`以后，变成\n\n```html\nprogr<span class=\"highlight\">a</span>mer\n```\n\n匹配关键字`span`以后：\n\n```html\nprogr<<span class=\"highlight\">span</span> class=\"highlight\">a</<span class=\"highlight\">span</span>>mer\n```\n\n完全乱套了。  \n为了保证以上`span`两端字符不会被匹配并替换，有一种做法是仅仅记住需要插入`span`的位置，并延迟替换。如果记住位置，考虑使用一种基本不会被用到的字符，比如 0X2611(☑)以及 0X2612（☒）。\n\n```js\nkeywords.forEach(function(it) {\n    string = string.replace(it, function(val) {\n        return String.fromCharCode(0x2611) + val + String.fromCharCode(0x2612);\n    });\n});\n```\n\n匹配关键字`a`以后，变成\n\n```html\nprogr☑a☒mer\n```\n\n匹配不到`span`字符串，匹配结束。\n\n最后再将这两个特殊符号替换为`'<span class=\"highlight\">'`和`'</span>'`，在正则中使用`+`，可以匹配多个特殊字符，也就解决了用户输入输了两个以上相同的关键字并造成浏览器额外创建`span`元素的情况，当然你也可以再一开始就去重。\n所以最终正确结果是\n\n```js\nstring = string.replace(/\\u2611+/g, '<span class=\"highlight\">').replace(/\\u2612+/g, '</span>');\n```\n\n```html\nprogr<span class=\"highlight\">a</span>mer\n```\n\n以上答案正确与否，取决于 ☑ 和 ☒ 会不会出现在被替换文字中。\n\n## 最终代码\n\n```js\nvar keyword = input.value;\nvar string  = 'The string will be highlighted'；\n// replace all preserved characters in regular express.\nkeyword = keyword.replace(/(?=[\\\\\\{\\}\\[\\]\\(\\)\\*\\+\\?\\^\\$\\-\\=\\!])/g, '\\\\');\n// split keyword by space characters.\nvar keywords = keyword.split(/\\s+/);\nkeywords.forEach(function(it){\n  string = string.replace(it, function(val){\n    return String.fromCharCode(0X2611) + val + String.fromCharCode(0X2612);\n  });\n});\nstring = string.replace(/\\u2611+/g, '<span class=\"highlight\">')\n  .replace(/\\u2612+/g, '</span>');\n```\n\n```css\n.highlight {\n    font-weight: bold;\n}\n```\n\n## 总结\n\n1. 高亮根据关键字搜索出来的记录不适合在客户端做，即时实现了，很可能是该高亮的没有高亮，不该高亮的高亮了。后端可以依靠巨大的知识库来高亮词性变换后的单词，甚至近义词。\n1. 使用好强大的`String.prototype.replace`方法。\n1. 正则中零宽断言在适当的时候，可以简化代码。\n","slug":"Highlight-Keywords-in-Client","published":1,"date":"2013-04-23T16:00:00.000Z","updated":"2018-12-07T03:06:26.462Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm930004w8wkut062l09","content":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>在某个项目中遇到这样的需求，用户输入几个关键字，然后根据关键字去后端搜索相关记录。后端返回记录中但是没有高亮这些关键字，这就需要前端来做这件事。按道理，高亮应该由后端完成，因为后端如何解析这些关键字，也知道如何去匹配，前端不知道也不应该知道后端为什么返回这些结果，英语中名词有复数形式，动词有现在式，过去式，过去完成式等，其他诸如德语，葡萄牙语有没有词性变换更是不得而知。后端依赖强大的知识库可以处理词性变换甚至近义词都是可能的，前端不可能完成工作，即便可能，也远比后来来处理高亮要复杂的多。但是这就是客户需求，我们还是要实现。</p>\n<p>整个流程：获取用户输入，比如 ‘search by keyword’，发送 JSONP 请求获取后端搜索到的记录。在关键的几个字段中，搜索‘search’，‘by’和‘keyword’这三个关键字，并在单词两边分别加上<code>&lt;span class=&quot;highlight&quot;&gt;</code>和<code>&lt;/span&gt;</code>，给<code>.highlight</code>定义一个合适的样式，比如粗体等，就完成了高亮的效果。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><p>第一步，首先把关键字用空白符分隔开，得到一个一个的关键字。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> keywords = keyword.split(<span class=\"regexp\">/\\s+/</span>);</span><br></pre></td></tr></table></figure>\n<p>第二步，将第一步中得到的字符串数组，转变成正则数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keywords.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">it</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// g replace all</span></span><br><span class=\"line\">    <span class=\"comment\">// i case-insensitive</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(it, <span class=\"string\">'gi'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>RegExp 的第一个参数是传 it 呢，还是<code>&#39;\\b&#39; + it + &#39;\\b&#39;</code>呢？如果是前者，关键字<code>a</code>可以匹配<code>take</code>中的<code>a</code>。如果是后者，<code>teach</code>不可以匹配<code>teaches</code>中的<code>teach</code>。都不完美，这也是在文章开头提及的不适合前端做高亮的原因。<br>如果你够细心，你应该已经感觉到隐隐有些不妥，因为在通过 RegExp 创建正则表达式时，第一个参数不能包含正则中预定义的一些字符，除非在前面加上了一个反斜线，比如<code>[?</code>就不可以，而<code>\\[\\?</code>才是真正地匹配<code>[?</code>。所以在这之前，我们添加一步：</p>\n<p>第〇步：给所有的正则预定义字符之前添加一个反斜线（backslash）。找出所有的预定义字符<code>char</code>并替换为<code>&#39;\\\\&#39; + char</code>。通过强大的<code>String.prototype.replace</code>方法很方便的完成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keyword = keyword.replace(<span class=\"regexp\">/[\\\\\\&#123;\\&#125;\\[\\]\\(\\)\\*\\+\\?\\^\\$\\,\\-\\=\\!]/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">char</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'\\\\'</span> + char;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要特别说的是，还有一处可以改进。在前面的一片文章<a href=\"./2013-04-15-Grouping-Numbers-with-Comma.md\">【正则表达式】使用逗号将数字三位三位地分开</a>中，我们使用了零宽断言。它匹配了这样一个位置（是为零宽），它后面的字符满足一定条件（是为断言）。在这里，我们可以使用正则表达式匹配预定义字符前面的位置，将该位置替换为<code>&#39;\\\\&#39;</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keyword = keyword.replace(<span class=\"regexp\">/(?=[\\\\\\&#123;\\&#125;\\[\\]\\(\\)\\*\\+\\?\\^\\$\\-\\=\\!])/g</span>, <span class=\"string\">'\\\\'</span>);</span><br></pre></td></tr></table></figure>\n<p>换了一种思路，顿时感觉清爽多了。</p>\n<p>第三步，遍历正则数组，然后替换所有的关键字。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keywords.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">it</span>) </span>&#123;</span><br><span class=\"line\">    string = string.replace(it, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;span class=\"highlight\"&gt;'</span> + val + <span class=\"string\">'&lt;/span&gt;'</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你足够细心或者以前遇到过类似问题，你可能已经知道，这一步中隐藏着一些问题，就是如果用户在一次搜索中，输入了两个相同的关键字，比如<code>take take</code>，那么匹配以后可能会出现<code>&#39;&lt;span class=&quot;highlight&quot;&gt;&lt;span class=&quot;highlight&quot;&gt;take&lt;/span&gt;&lt;/span&gt;&#39;</code>这种情况，不会出错，只是浏览器需要多创建一些 DOM 元素。更甚的是，当用户输入多个关键字以后，第一次替换时会引入<code>&#39;&lt;span class=&quot;highlight&quot;&gt;&#39;</code>和<code>&#39;&lt;/span&gt;&#39;</code>片段，这两段字符是不应被匹配并替换的。比如替换字符是<code>&#39;programer&#39;</code>，关键字是<code>&#39;a span&#39;</code>，<br>匹配关键字<code>a</code>以后，变成</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">progr<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"highlight\"</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>mer</span><br></pre></td></tr></table></figure>\n<p>匹配关键字<code>span</code>以后：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">progr&lt;&lt;span class=\"highlight\"&gt;span&lt;/span&gt; class=\"highlight\"&gt;a&lt;/&lt;span class=\"highlight\"&gt;span&lt;/span&gt;&gt;mer</span><br></pre></td></tr></table></figure>\n<p>完全乱套了。<br>为了保证以上<code>span</code>两端字符不会被匹配并替换，有一种做法是仅仅记住需要插入<code>span</code>的位置，并延迟替换。如果记住位置，考虑使用一种基本不会被用到的字符，比如 0X2611(☑)以及 0X2612（☒）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keywords.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">it</span>) </span>&#123;</span><br><span class=\"line\">    string = string.replace(it, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x2611</span>) + val + <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x2612</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>匹配关键字<code>a</code>以后，变成</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">progr☑a☒mer</span><br></pre></td></tr></table></figure>\n<p>匹配不到<code>span</code>字符串，匹配结束。</p>\n<p>最后再将这两个特殊符号替换为<code>&#39;&lt;span class=&quot;highlight&quot;&gt;&#39;</code>和<code>&#39;&lt;/span&gt;&#39;</code>，在正则中使用<code>+</code>，可以匹配多个特殊字符，也就解决了用户输入输了两个以上相同的关键字并造成浏览器额外创建<code>span</code>元素的情况，当然你也可以再一开始就去重。<br>所以最终正确结果是</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">string = string.replace(<span class=\"regexp\">/\\u2611+/g</span>, <span class=\"string\">'&lt;span class=\"highlight\"&gt;'</span>).replace(<span class=\"regexp\">/\\u2612+/g</span>, <span class=\"string\">'&lt;/span&gt;'</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">progr<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"highlight\"</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>mer</span><br></pre></td></tr></table></figure>\n<p>以上答案正确与否，取决于 ☑ 和 ☒ 会不会出现在被替换文字中。</p>\n<h2 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> keyword = input.value;</span><br><span class=\"line\"><span class=\"keyword\">var</span> string  = <span class=\"string\">'The string will be highlighted'</span>；</span><br><span class=\"line\"><span class=\"comment\">// replace all preserved characters in regular express.</span></span><br><span class=\"line\">keyword = keyword.replace(<span class=\"regexp\">/(?=[\\\\\\&#123;\\&#125;\\[\\]\\(\\)\\*\\+\\?\\^\\$\\-\\=\\!])/g</span>, <span class=\"string\">'\\\\'</span>);</span><br><span class=\"line\"><span class=\"comment\">// split keyword by space characters.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> keywords = keyword.split(<span class=\"regexp\">/\\s+/</span>);</span><br><span class=\"line\">keywords.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">it</span>)</span>&#123;</span><br><span class=\"line\">  string = string.replace(it, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0X2611</span>) + val + <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0X2612</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">string = string.replace(<span class=\"regexp\">/\\u2611+/g</span>, <span class=\"string\">'&lt;span class=\"highlight\"&gt;'</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/\\u2612+/g</span>, <span class=\"string\">'&lt;/span&gt;'</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.highlight</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>高亮根据关键字搜索出来的记录不适合在客户端做，即时实现了，很可能是该高亮的没有高亮，不该高亮的高亮了。后端可以依靠巨大的知识库来高亮词性变换后的单词，甚至近义词。</li>\n<li>使用好强大的<code>String.prototype.replace</code>方法。</li>\n<li>正则中零宽断言在适当的时候，可以简化代码。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>在某个项目中遇到这样的需求，用户输入几个关键字，然后根据关键字去后端搜索相关记录。后端返回记录中但是没有高亮这些关键字，这就需要前端来做这件事。按道理，高亮应该由后端完成，因为后端如何解析这些关键字，也知道如何去匹配，前端不知道也不应该知道后端为什么返回这些结果，英语中名词有复数形式，动词有现在式，过去式，过去完成式等，其他诸如德语，葡萄牙语有没有词性变换更是不得而知。后端依赖强大的知识库可以处理词性变换甚至近义词都是可能的，前端不可能完成工作，即便可能，也远比后来来处理高亮要复杂的多。但是这就是客户需求，我们还是要实现。</p>\n<p>整个流程：获取用户输入，比如 ‘search by keyword’，发送 JSONP 请求获取后端搜索到的记录。在关键的几个字段中，搜索‘search’，‘by’和‘keyword’这三个关键字，并在单词两边分别加上<code>&lt;span class=&quot;highlight&quot;&gt;</code>和<code>&lt;/span&gt;</code>，给<code>.highlight</code>定义一个合适的样式，比如粗体等，就完成了高亮的效果。</p>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><p>第一步，首先把关键字用空白符分隔开，得到一个一个的关键字。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> keywords = keyword.split(<span class=\"regexp\">/\\s+/</span>);</span><br></pre></td></tr></table></figure>\n<p>第二步，将第一步中得到的字符串数组，转变成正则数组。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keywords.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">it</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// g replace all</span></span><br><span class=\"line\">    <span class=\"comment\">// i case-insensitive</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(it, <span class=\"string\">'gi'</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>RegExp 的第一个参数是传 it 呢，还是<code>&#39;\\b&#39; + it + &#39;\\b&#39;</code>呢？如果是前者，关键字<code>a</code>可以匹配<code>take</code>中的<code>a</code>。如果是后者，<code>teach</code>不可以匹配<code>teaches</code>中的<code>teach</code>。都不完美，这也是在文章开头提及的不适合前端做高亮的原因。<br>如果你够细心，你应该已经感觉到隐隐有些不妥，因为在通过 RegExp 创建正则表达式时，第一个参数不能包含正则中预定义的一些字符，除非在前面加上了一个反斜线，比如<code>[?</code>就不可以，而<code>\\[\\?</code>才是真正地匹配<code>[?</code>。所以在这之前，我们添加一步：</p>\n<p>第〇步：给所有的正则预定义字符之前添加一个反斜线（backslash）。找出所有的预定义字符<code>char</code>并替换为<code>&#39;\\\\&#39; + char</code>。通过强大的<code>String.prototype.replace</code>方法很方便的完成。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keyword = keyword.replace(<span class=\"regexp\">/[\\\\\\&#123;\\&#125;\\[\\]\\(\\)\\*\\+\\?\\^\\$\\,\\-\\=\\!]/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">char</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'\\\\'</span> + char;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>需要特别说的是，还有一处可以改进。在前面的一片文章<a href=\"./2013-04-15-Grouping-Numbers-with-Comma.md\">【正则表达式】使用逗号将数字三位三位地分开</a>中，我们使用了零宽断言。它匹配了这样一个位置（是为零宽），它后面的字符满足一定条件（是为断言）。在这里，我们可以使用正则表达式匹配预定义字符前面的位置，将该位置替换为<code>&#39;\\\\&#39;</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keyword = keyword.replace(<span class=\"regexp\">/(?=[\\\\\\&#123;\\&#125;\\[\\]\\(\\)\\*\\+\\?\\^\\$\\-\\=\\!])/g</span>, <span class=\"string\">'\\\\'</span>);</span><br></pre></td></tr></table></figure>\n<p>换了一种思路，顿时感觉清爽多了。</p>\n<p>第三步，遍历正则数组，然后替换所有的关键字。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keywords.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">it</span>) </span>&#123;</span><br><span class=\"line\">    string = string.replace(it, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;span class=\"highlight\"&gt;'</span> + val + <span class=\"string\">'&lt;/span&gt;'</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果你足够细心或者以前遇到过类似问题，你可能已经知道，这一步中隐藏着一些问题，就是如果用户在一次搜索中，输入了两个相同的关键字，比如<code>take take</code>，那么匹配以后可能会出现<code>&#39;&lt;span class=&quot;highlight&quot;&gt;&lt;span class=&quot;highlight&quot;&gt;take&lt;/span&gt;&lt;/span&gt;&#39;</code>这种情况，不会出错，只是浏览器需要多创建一些 DOM 元素。更甚的是，当用户输入多个关键字以后，第一次替换时会引入<code>&#39;&lt;span class=&quot;highlight&quot;&gt;&#39;</code>和<code>&#39;&lt;/span&gt;&#39;</code>片段，这两段字符是不应被匹配并替换的。比如替换字符是<code>&#39;programer&#39;</code>，关键字是<code>&#39;a span&#39;</code>，<br>匹配关键字<code>a</code>以后，变成</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">progr<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"highlight\"</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>mer</span><br></pre></td></tr></table></figure>\n<p>匹配关键字<code>span</code>以后：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">progr&lt;&lt;span class=\"highlight\"&gt;span&lt;/span&gt; class=\"highlight\"&gt;a&lt;/&lt;span class=\"highlight\"&gt;span&lt;/span&gt;&gt;mer</span><br></pre></td></tr></table></figure>\n<p>完全乱套了。<br>为了保证以上<code>span</code>两端字符不会被匹配并替换，有一种做法是仅仅记住需要插入<code>span</code>的位置，并延迟替换。如果记住位置，考虑使用一种基本不会被用到的字符，比如 0X2611(☑)以及 0X2612（☒）。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">keywords.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">it</span>) </span>&#123;</span><br><span class=\"line\">    string = string.replace(it, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x2611</span>) + val + <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0x2612</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>匹配关键字<code>a</code>以后，变成</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">progr☑a☒mer</span><br></pre></td></tr></table></figure>\n<p>匹配不到<code>span</code>字符串，匹配结束。</p>\n<p>最后再将这两个特殊符号替换为<code>&#39;&lt;span class=&quot;highlight&quot;&gt;&#39;</code>和<code>&#39;&lt;/span&gt;&#39;</code>，在正则中使用<code>+</code>，可以匹配多个特殊字符，也就解决了用户输入输了两个以上相同的关键字并造成浏览器额外创建<code>span</code>元素的情况，当然你也可以再一开始就去重。<br>所以最终正确结果是</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">string = string.replace(<span class=\"regexp\">/\\u2611+/g</span>, <span class=\"string\">'&lt;span class=\"highlight\"&gt;'</span>).replace(<span class=\"regexp\">/\\u2612+/g</span>, <span class=\"string\">'&lt;/span&gt;'</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">progr<span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"highlight\"</span>&gt;</span>a<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>mer</span><br></pre></td></tr></table></figure>\n<p>以上答案正确与否，取决于 ☑ 和 ☒ 会不会出现在被替换文字中。</p>\n<h2 id=\"最终代码\"><a href=\"#最终代码\" class=\"headerlink\" title=\"最终代码\"></a>最终代码</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> keyword = input.value;</span><br><span class=\"line\"><span class=\"keyword\">var</span> string  = <span class=\"string\">'The string will be highlighted'</span>；</span><br><span class=\"line\"><span class=\"comment\">// replace all preserved characters in regular express.</span></span><br><span class=\"line\">keyword = keyword.replace(<span class=\"regexp\">/(?=[\\\\\\&#123;\\&#125;\\[\\]\\(\\)\\*\\+\\?\\^\\$\\-\\=\\!])/g</span>, <span class=\"string\">'\\\\'</span>);</span><br><span class=\"line\"><span class=\"comment\">// split keyword by space characters.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> keywords = keyword.split(<span class=\"regexp\">/\\s+/</span>);</span><br><span class=\"line\">keywords.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">it</span>)</span>&#123;</span><br><span class=\"line\">  string = string.replace(it, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0X2611</span>) + val + <span class=\"built_in\">String</span>.fromCharCode(<span class=\"number\">0X2612</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">string = string.replace(<span class=\"regexp\">/\\u2611+/g</span>, <span class=\"string\">'&lt;span class=\"highlight\"&gt;'</span>)</span><br><span class=\"line\">  .replace(<span class=\"regexp\">/\\u2612+/g</span>, <span class=\"string\">'&lt;/span&gt;'</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.highlight</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>高亮根据关键字搜索出来的记录不适合在客户端做，即时实现了，很可能是该高亮的没有高亮，不该高亮的高亮了。后端可以依靠巨大的知识库来高亮词性变换后的单词，甚至近义词。</li>\n<li>使用好强大的<code>String.prototype.replace</code>方法。</li>\n<li>正则中零宽断言在适当的时候，可以简化代码。</li>\n</ol>\n"},{"title":"使用 drawImage 和 putImageData 缓存 Canvas 中间数据","_content":"\n## API\n\n```js\nvoid drawImage(Object image, float dx, float dy[float dw, float, dh]);\nvoid drawImage(Object image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);\n\nImageData getImageData(float sx, float sy, float sw, float sh);\nvoid putImageData(ImageData imageData, float dx, float dy[, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight]);\n```\n\ndrawImage 的第一个参数可以是 HTMLImageElement（绘图），HTMLCanvasElement（复制）或者 HTMLVideoElement（截屏）。\n\n## 缓存 Canvas 中间数据\n\n如果我们需要在一个 Canvas 上画很多图片，其中一部分是固定（或短期内固定）存在的，那么最好的办法是将他们绘制完毕之后，将他们保存起来，等下一次需要绘制这些图片的时候，一次性绘制缓存结果。这样可以减少渲染次数，以提高渲染效率。  \n首先想到的是 getImageData 和 putImageData。所以做了如下测试：\n\n```js\nvar repeat_times = 10000;\n\nconsole.time('drawImage');\nfor (var i = 0; i < repeat_times; i++) {\n    context.drawImage(image, 0, 0);\n}\nconsole.timeEnd('drawImage');\n\nconsole.time('putImageData');\ncontext.drawImage(image, 0, 0);\nvar data = context.getImageData(0, 0, image.width, image.height);\nfor (var i = 0; i < repeat_times; i++) {\n    context.putImageData(data, 0, 0);\n}\nconsole.timeEnd('putImageData');\n```\n\n简单起见，这里我们仅仅绘制一张图片。打印出来的结果完全出乎意料，putImageData 非但没有更快，反而比 drawImage 慢 600 倍左右。至于为什么会这么慢，我还不知道答案。总之 putImageData 远远不是我想象中的那么高效。  \n后来才考虑到可以将 Canvas 中的数据缓存到某个隐藏 Canvas 中去，然后再调用 DrawImage 方法。\n\n```js\nconsole.time('drawCanvas');\nvar buffer = document.createElement('canvas');\nbuffer.width = canvas.width;\nbuffer.height = canvas.height;\ncontext.drawImage(image, 0, 0);\nfor (var i = 0; i < repeat_times; i++) {\n    context.drawImage(buffer, 0, 0);\n}\nconsole.timeEnd('drawCanvas');\n```\n\n经过测试以后发现比 drawImage 方法慢了一倍，相对于 10000 次循环，这点性能损失可以忽略不计，因为我们仅仅绘制一张图片。图片的数目每增加 1，drawImage 绘图次数增加 10000，而 drawCanvas 绘图次数仅仅增加 1。\n\n## 小结\n\n`putImageData`的优点在于能够像素级别操作图像，但是因其效率很低，并不适合做 Canvas 的数据缓存，而`drawImage(canvas, 0, 0)`较为适合。\n","source":"_posts/2013-04-22-Canvas-drawImage-vs-putImageData.md","raw":"---\ntitle: 使用 drawImage 和 putImageData 缓存 Canvas 中间数据\n---\n\n## API\n\n```js\nvoid drawImage(Object image, float dx, float dy[float dw, float, dh]);\nvoid drawImage(Object image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);\n\nImageData getImageData(float sx, float sy, float sw, float sh);\nvoid putImageData(ImageData imageData, float dx, float dy[, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight]);\n```\n\ndrawImage 的第一个参数可以是 HTMLImageElement（绘图），HTMLCanvasElement（复制）或者 HTMLVideoElement（截屏）。\n\n## 缓存 Canvas 中间数据\n\n如果我们需要在一个 Canvas 上画很多图片，其中一部分是固定（或短期内固定）存在的，那么最好的办法是将他们绘制完毕之后，将他们保存起来，等下一次需要绘制这些图片的时候，一次性绘制缓存结果。这样可以减少渲染次数，以提高渲染效率。  \n首先想到的是 getImageData 和 putImageData。所以做了如下测试：\n\n```js\nvar repeat_times = 10000;\n\nconsole.time('drawImage');\nfor (var i = 0; i < repeat_times; i++) {\n    context.drawImage(image, 0, 0);\n}\nconsole.timeEnd('drawImage');\n\nconsole.time('putImageData');\ncontext.drawImage(image, 0, 0);\nvar data = context.getImageData(0, 0, image.width, image.height);\nfor (var i = 0; i < repeat_times; i++) {\n    context.putImageData(data, 0, 0);\n}\nconsole.timeEnd('putImageData');\n```\n\n简单起见，这里我们仅仅绘制一张图片。打印出来的结果完全出乎意料，putImageData 非但没有更快，反而比 drawImage 慢 600 倍左右。至于为什么会这么慢，我还不知道答案。总之 putImageData 远远不是我想象中的那么高效。  \n后来才考虑到可以将 Canvas 中的数据缓存到某个隐藏 Canvas 中去，然后再调用 DrawImage 方法。\n\n```js\nconsole.time('drawCanvas');\nvar buffer = document.createElement('canvas');\nbuffer.width = canvas.width;\nbuffer.height = canvas.height;\ncontext.drawImage(image, 0, 0);\nfor (var i = 0; i < repeat_times; i++) {\n    context.drawImage(buffer, 0, 0);\n}\nconsole.timeEnd('drawCanvas');\n```\n\n经过测试以后发现比 drawImage 方法慢了一倍，相对于 10000 次循环，这点性能损失可以忽略不计，因为我们仅仅绘制一张图片。图片的数目每增加 1，drawImage 绘图次数增加 10000，而 drawCanvas 绘图次数仅仅增加 1。\n\n## 小结\n\n`putImageData`的优点在于能够像素级别操作图像，但是因其效率很低，并不适合做 Canvas 的数据缓存，而`drawImage(canvas, 0, 0)`较为适合。\n","slug":"Canvas-drawImage-vs-putImageData","published":1,"date":"2013-04-21T16:00:00.000Z","updated":"2018-12-07T03:06:51.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm940005w8wkraf41fem","content":"<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> drawImage(<span class=\"built_in\">Object</span> image, float dx, float dy[float dw, float, dh]);</span><br><span class=\"line\"><span class=\"keyword\">void</span> drawImage(<span class=\"built_in\">Object</span> image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);</span><br><span class=\"line\"></span><br><span class=\"line\">ImageData getImageData(float sx, float sy, float sw, float sh);</span><br><span class=\"line\"><span class=\"keyword\">void</span> putImageData(ImageData imageData, float dx, float dy[, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight]);</span><br></pre></td></tr></table></figure>\n<p>drawImage 的第一个参数可以是 HTMLImageElement（绘图），HTMLCanvasElement（复制）或者 HTMLVideoElement（截屏）。</p>\n<h2 id=\"缓存-Canvas-中间数据\"><a href=\"#缓存-Canvas-中间数据\" class=\"headerlink\" title=\"缓存 Canvas 中间数据\"></a>缓存 Canvas 中间数据</h2><p>如果我们需要在一个 Canvas 上画很多图片，其中一部分是固定（或短期内固定）存在的，那么最好的办法是将他们绘制完毕之后，将他们保存起来，等下一次需要绘制这些图片的时候，一次性绘制缓存结果。这样可以减少渲染次数，以提高渲染效率。<br>首先想到的是 getImageData 和 putImageData。所以做了如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> repeat_times = <span class=\"number\">10000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'drawImage'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; repeat_times; i++) &#123;</span><br><span class=\"line\">    context.drawImage(image, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'drawImage'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'putImageData'</span>);</span><br><span class=\"line\">context.drawImage(image, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = context.getImageData(<span class=\"number\">0</span>, <span class=\"number\">0</span>, image.width, image.height);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; repeat_times; i++) &#123;</span><br><span class=\"line\">    context.putImageData(data, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'putImageData'</span>);</span><br></pre></td></tr></table></figure>\n<p>简单起见，这里我们仅仅绘制一张图片。打印出来的结果完全出乎意料，putImageData 非但没有更快，反而比 drawImage 慢 600 倍左右。至于为什么会这么慢，我还不知道答案。总之 putImageData 远远不是我想象中的那么高效。<br>后来才考虑到可以将 Canvas 中的数据缓存到某个隐藏 Canvas 中去，然后再调用 DrawImage 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'drawCanvas'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\">buffer.width = canvas.width;</span><br><span class=\"line\">buffer.height = canvas.height;</span><br><span class=\"line\">context.drawImage(image, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; repeat_times; i++) &#123;</span><br><span class=\"line\">    context.drawImage(buffer, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'drawCanvas'</span>);</span><br></pre></td></tr></table></figure>\n<p>经过测试以后发现比 drawImage 方法慢了一倍，相对于 10000 次循环，这点性能损失可以忽略不计，因为我们仅仅绘制一张图片。图片的数目每增加 1，drawImage 绘图次数增加 10000，而 drawCanvas 绘图次数仅仅增加 1。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p><code>putImageData</code>的优点在于能够像素级别操作图像，但是因其效率很低，并不适合做 Canvas 的数据缓存，而<code>drawImage(canvas, 0, 0)</code>较为适合。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> drawImage(<span class=\"built_in\">Object</span> image, float dx, float dy[float dw, float, dh]);</span><br><span class=\"line\"><span class=\"keyword\">void</span> drawImage(<span class=\"built_in\">Object</span> image, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh);</span><br><span class=\"line\"></span><br><span class=\"line\">ImageData getImageData(float sx, float sy, float sw, float sh);</span><br><span class=\"line\"><span class=\"keyword\">void</span> putImageData(ImageData imageData, float dx, float dy[, float dirtyX, float dirtyY, float dirtyWidth, float dirtyHeight]);</span><br></pre></td></tr></table></figure>\n<p>drawImage 的第一个参数可以是 HTMLImageElement（绘图），HTMLCanvasElement（复制）或者 HTMLVideoElement（截屏）。</p>\n<h2 id=\"缓存-Canvas-中间数据\"><a href=\"#缓存-Canvas-中间数据\" class=\"headerlink\" title=\"缓存 Canvas 中间数据\"></a>缓存 Canvas 中间数据</h2><p>如果我们需要在一个 Canvas 上画很多图片，其中一部分是固定（或短期内固定）存在的，那么最好的办法是将他们绘制完毕之后，将他们保存起来，等下一次需要绘制这些图片的时候，一次性绘制缓存结果。这样可以减少渲染次数，以提高渲染效率。<br>首先想到的是 getImageData 和 putImageData。所以做了如下测试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> repeat_times = <span class=\"number\">10000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'drawImage'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; repeat_times; i++) &#123;</span><br><span class=\"line\">    context.drawImage(image, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'drawImage'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'putImageData'</span>);</span><br><span class=\"line\">context.drawImage(image, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = context.getImageData(<span class=\"number\">0</span>, <span class=\"number\">0</span>, image.width, image.height);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; repeat_times; i++) &#123;</span><br><span class=\"line\">    context.putImageData(data, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'putImageData'</span>);</span><br></pre></td></tr></table></figure>\n<p>简单起见，这里我们仅仅绘制一张图片。打印出来的结果完全出乎意料，putImageData 非但没有更快，反而比 drawImage 慢 600 倍左右。至于为什么会这么慢，我还不知道答案。总之 putImageData 远远不是我想象中的那么高效。<br>后来才考虑到可以将 Canvas 中的数据缓存到某个隐藏 Canvas 中去，然后再调用 DrawImage 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'drawCanvas'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> buffer = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'canvas'</span>);</span><br><span class=\"line\">buffer.width = canvas.width;</span><br><span class=\"line\">buffer.height = canvas.height;</span><br><span class=\"line\">context.drawImage(image, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; repeat_times; i++) &#123;</span><br><span class=\"line\">    context.drawImage(buffer, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'drawCanvas'</span>);</span><br></pre></td></tr></table></figure>\n<p>经过测试以后发现比 drawImage 方法慢了一倍，相对于 10000 次循环，这点性能损失可以忽略不计，因为我们仅仅绘制一张图片。图片的数目每增加 1，drawImage 绘图次数增加 10000，而 drawCanvas 绘图次数仅仅增加 1。</p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p><code>putImageData</code>的优点在于能够像素级别操作图像，但是因其效率很低，并不适合做 Canvas 的数据缓存，而<code>drawImage(canvas, 0, 0)</code>较为适合。</p>\n"},{"title":"CSS3 Transition过渡属性探索","_content":"\n## 背景介绍\n\n在前面的文章[蓝光机 WebApp-无尽列表优化](./2013-04-07-Blu-ray-Web-App-Endless-List-Optimization.md)中提到无尽列表，通过上下键可以查看前两个或者后两个记录。这时候需要做出动画效果。\n\n## 解决问题\n\n这里首先要说明 Opera 的一个问题，Opera 从 9.8 版本以后就定格为 9.8，如果要查看其真正版本，只有通过其 UserAgent 中‘Version/12.11’类似的文本来确定。在[Oprea 的怪异识别码](http://blog.imbolo.com/oprea-version/)说明了这一问题的由来。\n\n> Opera 的工程师在测试中发现，Opera 10 Alpha 在很多老网站上的运作很不正常。原来，有很多网站使用了“浏览器嗅探”技术，也就是说网站会针对不同的浏览器提供不同的内容或功能。然而不幸的是，这些网站无法识别两位数的浏览器版本号，于是 Opera 就成了首当其冲的受害者——它们把 Opera 10.0 误认为是 Opera 1.0，并因此向 Opera 10 提供不完整的功能，甚至有些网站干脆拒绝 Opera 10 的访问。\n> 这当然是 Opera 不愿意看到的。于是，Opera 的工程师们决定，将用户代理信息中的版本号定格在 9.8，并另外启用 Version 字段来标识真正的版本号。当然他们也考虑过选用 9.99 这个最接近 10 的可用作版本号的数字，不过出于预留空间的考虑，最终还是决定采用 9.8 作为象征性的版本号——它正好介于（Opera 9 的最后一个版本号）9.6 与 10 之间。\n\n正是因为 Opera 这么委曲求全的决策，所以一直以为蓝光机中是 Opera9.8。而很多 CSS3 特性都不被 Opera9.8 支持。包括我们这里将会被用到的 CSS3 Transition。所以很自然地使用 jQuery 提供的 animate 方法实现。\n\n```js\n// top from 0 to 94\n$list.animate({ top: top }, 'fast', function() {\n    // do some thing\n});\n```\n\n在蓝光机中该动画只会执行三步，分别是 top = 0, ~59, 94px，所以会给人一种很不平滑的感觉。\n\n很长时间以后才注意到蓝光机中的浏览器是 Opera12.11. 然后开始尝试使用 CSS3 Transition。\n\n```css\ntransition: top 300ms linear;\n```\n\n```js\n$list.css('top', top);\n```\n\n以上动画效果在桌面浏览器上运行的非常好，但是在蓝光机上依然没有明显改善，反而感觉有点晃动。优化失败。\n\n在尝试将其他部分动画也使用 CSS3 Transition 时发现一个问题，就是修改某个属性之前，如果该属性没有显式声明，那么各个浏览器处理方式不同。以 width 为例，这时通过`elem.style.width`得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。这个小问题让我耽误了不少时间。\n\n###使用方法\n\n> transition ： [<'transition-property'> || <'transition-duration'> || <'transition-timing-function'> || <'transition-delay'> [, [<'transition-property'> || <'transition-duration'> || <'transition-timing-function'> || <'transition-delay'>]]_\n> 或者\n> transition-property ： none | all | [ <IDENT> ][ ',' <ident> ]_；  \n> transition-duration ： <time> [, <time>]_  \n> transition-timing-function ： ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)]_  \n> transition-delay ： <time> [, <time>]\\*\n\ntransition-property 支持的属性参见[W3C 标准](http://www.w3.org/TR/css3-transitions/#transition-property)。  \ntransition-duration 和 transition-delay 支持如`1s`，`200ms`的值。\n\n###总结\n\n1. CSS3 Transition 可以在设置 CSS 属性时使其效果平滑过渡，但是过渡过程中，通过`elem.style.attr`获取其相应属性值时，得到的都是其最终值，这点和 jQuery 实现的动画效果不同。\n1. 如果属性值为显式声明时，各个浏览器处理方式不同。以 width 为例，这时通过`elem.style.width`得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。\n1. Opera 在 9.8 版本以后就将版本定格为 9.8，在以后的 Opera 版本中只能通过其 UserAgent 中的'Version/12.11'之类的字符串来确定其版本号。\n1. 如果设置的属性值跟设置前一样，那么并不会触发 transitionend。这点需要特别注意。\n","source":"_posts/2013-04-27-CSS3-Transition-Research.md","raw":"---\ntitle: CSS3 Transition过渡属性探索\n---\n\n## 背景介绍\n\n在前面的文章[蓝光机 WebApp-无尽列表优化](./2013-04-07-Blu-ray-Web-App-Endless-List-Optimization.md)中提到无尽列表，通过上下键可以查看前两个或者后两个记录。这时候需要做出动画效果。\n\n## 解决问题\n\n这里首先要说明 Opera 的一个问题，Opera 从 9.8 版本以后就定格为 9.8，如果要查看其真正版本，只有通过其 UserAgent 中‘Version/12.11’类似的文本来确定。在[Oprea 的怪异识别码](http://blog.imbolo.com/oprea-version/)说明了这一问题的由来。\n\n> Opera 的工程师在测试中发现，Opera 10 Alpha 在很多老网站上的运作很不正常。原来，有很多网站使用了“浏览器嗅探”技术，也就是说网站会针对不同的浏览器提供不同的内容或功能。然而不幸的是，这些网站无法识别两位数的浏览器版本号，于是 Opera 就成了首当其冲的受害者——它们把 Opera 10.0 误认为是 Opera 1.0，并因此向 Opera 10 提供不完整的功能，甚至有些网站干脆拒绝 Opera 10 的访问。\n> 这当然是 Opera 不愿意看到的。于是，Opera 的工程师们决定，将用户代理信息中的版本号定格在 9.8，并另外启用 Version 字段来标识真正的版本号。当然他们也考虑过选用 9.99 这个最接近 10 的可用作版本号的数字，不过出于预留空间的考虑，最终还是决定采用 9.8 作为象征性的版本号——它正好介于（Opera 9 的最后一个版本号）9.6 与 10 之间。\n\n正是因为 Opera 这么委曲求全的决策，所以一直以为蓝光机中是 Opera9.8。而很多 CSS3 特性都不被 Opera9.8 支持。包括我们这里将会被用到的 CSS3 Transition。所以很自然地使用 jQuery 提供的 animate 方法实现。\n\n```js\n// top from 0 to 94\n$list.animate({ top: top }, 'fast', function() {\n    // do some thing\n});\n```\n\n在蓝光机中该动画只会执行三步，分别是 top = 0, ~59, 94px，所以会给人一种很不平滑的感觉。\n\n很长时间以后才注意到蓝光机中的浏览器是 Opera12.11. 然后开始尝试使用 CSS3 Transition。\n\n```css\ntransition: top 300ms linear;\n```\n\n```js\n$list.css('top', top);\n```\n\n以上动画效果在桌面浏览器上运行的非常好，但是在蓝光机上依然没有明显改善，反而感觉有点晃动。优化失败。\n\n在尝试将其他部分动画也使用 CSS3 Transition 时发现一个问题，就是修改某个属性之前，如果该属性没有显式声明，那么各个浏览器处理方式不同。以 width 为例，这时通过`elem.style.width`得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。这个小问题让我耽误了不少时间。\n\n###使用方法\n\n> transition ： [<'transition-property'> || <'transition-duration'> || <'transition-timing-function'> || <'transition-delay'> [, [<'transition-property'> || <'transition-duration'> || <'transition-timing-function'> || <'transition-delay'>]]_\n> 或者\n> transition-property ： none | all | [ <IDENT> ][ ',' <ident> ]_；  \n> transition-duration ： <time> [, <time>]_  \n> transition-timing-function ： ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)]_  \n> transition-delay ： <time> [, <time>]\\*\n\ntransition-property 支持的属性参见[W3C 标准](http://www.w3.org/TR/css3-transitions/#transition-property)。  \ntransition-duration 和 transition-delay 支持如`1s`，`200ms`的值。\n\n###总结\n\n1. CSS3 Transition 可以在设置 CSS 属性时使其效果平滑过渡，但是过渡过程中，通过`elem.style.attr`获取其相应属性值时，得到的都是其最终值，这点和 jQuery 实现的动画效果不同。\n1. 如果属性值为显式声明时，各个浏览器处理方式不同。以 width 为例，这时通过`elem.style.width`得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。\n1. Opera 在 9.8 版本以后就将版本定格为 9.8，在以后的 Opera 版本中只能通过其 UserAgent 中的'Version/12.11'之类的字符串来确定其版本号。\n1. 如果设置的属性值跟设置前一样，那么并不会触发 transitionend。这点需要特别注意。\n","slug":"CSS3-Transition-Research","published":1,"date":"2013-04-26T16:00:00.000Z","updated":"2018-12-07T03:03:29.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm950006w8wkjjkckz7a","content":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>在前面的文章<a href=\"./2013-04-07-Blu-ray-Web-App-Endless-List-Optimization.md\">蓝光机 WebApp-无尽列表优化</a>中提到无尽列表，通过上下键可以查看前两个或者后两个记录。这时候需要做出动画效果。</p>\n<h2 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h2><p>这里首先要说明 Opera 的一个问题，Opera 从 9.8 版本以后就定格为 9.8，如果要查看其真正版本，只有通过其 UserAgent 中‘Version/12.11’类似的文本来确定。在<a href=\"http://blog.imbolo.com/oprea-version/\" target=\"_blank\" rel=\"noopener\">Oprea 的怪异识别码</a>说明了这一问题的由来。</p>\n<blockquote>\n<p>Opera 的工程师在测试中发现，Opera 10 Alpha 在很多老网站上的运作很不正常。原来，有很多网站使用了“浏览器嗅探”技术，也就是说网站会针对不同的浏览器提供不同的内容或功能。然而不幸的是，这些网站无法识别两位数的浏览器版本号，于是 Opera 就成了首当其冲的受害者——它们把 Opera 10.0 误认为是 Opera 1.0，并因此向 Opera 10 提供不完整的功能，甚至有些网站干脆拒绝 Opera 10 的访问。<br>这当然是 Opera 不愿意看到的。于是，Opera 的工程师们决定，将用户代理信息中的版本号定格在 9.8，并另外启用 Version 字段来标识真正的版本号。当然他们也考虑过选用 9.99 这个最接近 10 的可用作版本号的数字，不过出于预留空间的考虑，最终还是决定采用 9.8 作为象征性的版本号——它正好介于（Opera 9 的最后一个版本号）9.6 与 10 之间。</p>\n</blockquote>\n<p>正是因为 Opera 这么委曲求全的决策，所以一直以为蓝光机中是 Opera9.8。而很多 CSS3 特性都不被 Opera9.8 支持。包括我们这里将会被用到的 CSS3 Transition。所以很自然地使用 jQuery 提供的 animate 方法实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// top from 0 to 94</span></span><br><span class=\"line\">$list.animate(&#123; <span class=\"attr\">top</span>: top &#125;, <span class=\"string\">'fast'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do some thing</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在蓝光机中该动画只会执行三步，分别是 top = 0, ~59, 94px，所以会给人一种很不平滑的感觉。</p>\n<p>很长时间以后才注意到蓝光机中的浏览器是 Opera12.11. 然后开始尝试使用 CSS3 Transition。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">top</span> 300<span class=\"selector-tag\">ms</span> <span class=\"selector-tag\">linear</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">$list.css(<span class=\"string\">'top'</span>, top);</span><br></pre></td></tr></table></figure>\n<p>以上动画效果在桌面浏览器上运行的非常好，但是在蓝光机上依然没有明显改善，反而感觉有点晃动。优化失败。</p>\n<p>在尝试将其他部分动画也使用 CSS3 Transition 时发现一个问题，就是修改某个属性之前，如果该属性没有显式声明，那么各个浏览器处理方式不同。以 width 为例，这时通过<code>elem.style.width</code>得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。这个小问题让我耽误了不少时间。</p>\n<p>###使用方法</p>\n<blockquote>\n<p>transition ： [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; || &lt;’transition-timing-function’&gt; || &lt;’transition-delay’&gt; [, [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; || &lt;’transition-timing-function’&gt; || &lt;’transition-delay’&gt;]]_<br>或者<br>transition-property ： none | all | [ <ident> ][ ‘,’ <ident> ]<em>；<br>transition-duration ： <time> [, <time>]</time></time></em><br>transition-timing-function ： ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)]_<br>transition-delay ： <time> [, <time>]*</time></time></number></number></number></number></number></number></number></number></ident></ident></p>\n</blockquote>\n<p>transition-property 支持的属性参见<a href=\"http://www.w3.org/TR/css3-transitions/#transition-property\" target=\"_blank\" rel=\"noopener\">W3C 标准</a>。<br>transition-duration 和 transition-delay 支持如<code>1s</code>，<code>200ms</code>的值。</p>\n<p>###总结</p>\n<ol>\n<li>CSS3 Transition 可以在设置 CSS 属性时使其效果平滑过渡，但是过渡过程中，通过<code>elem.style.attr</code>获取其相应属性值时，得到的都是其最终值，这点和 jQuery 实现的动画效果不同。</li>\n<li>如果属性值为显式声明时，各个浏览器处理方式不同。以 width 为例，这时通过<code>elem.style.width</code>得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。</li>\n<li>Opera 在 9.8 版本以后就将版本定格为 9.8，在以后的 Opera 版本中只能通过其 UserAgent 中的’Version/12.11’之类的字符串来确定其版本号。</li>\n<li>如果设置的属性值跟设置前一样，那么并不会触发 transitionend。这点需要特别注意。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h2><p>在前面的文章<a href=\"./2013-04-07-Blu-ray-Web-App-Endless-List-Optimization.md\">蓝光机 WebApp-无尽列表优化</a>中提到无尽列表，通过上下键可以查看前两个或者后两个记录。这时候需要做出动画效果。</p>\n<h2 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h2><p>这里首先要说明 Opera 的一个问题，Opera 从 9.8 版本以后就定格为 9.8，如果要查看其真正版本，只有通过其 UserAgent 中‘Version/12.11’类似的文本来确定。在<a href=\"http://blog.imbolo.com/oprea-version/\" target=\"_blank\" rel=\"noopener\">Oprea 的怪异识别码</a>说明了这一问题的由来。</p>\n<blockquote>\n<p>Opera 的工程师在测试中发现，Opera 10 Alpha 在很多老网站上的运作很不正常。原来，有很多网站使用了“浏览器嗅探”技术，也就是说网站会针对不同的浏览器提供不同的内容或功能。然而不幸的是，这些网站无法识别两位数的浏览器版本号，于是 Opera 就成了首当其冲的受害者——它们把 Opera 10.0 误认为是 Opera 1.0，并因此向 Opera 10 提供不完整的功能，甚至有些网站干脆拒绝 Opera 10 的访问。<br>这当然是 Opera 不愿意看到的。于是，Opera 的工程师们决定，将用户代理信息中的版本号定格在 9.8，并另外启用 Version 字段来标识真正的版本号。当然他们也考虑过选用 9.99 这个最接近 10 的可用作版本号的数字，不过出于预留空间的考虑，最终还是决定采用 9.8 作为象征性的版本号——它正好介于（Opera 9 的最后一个版本号）9.6 与 10 之间。</p>\n</blockquote>\n<p>正是因为 Opera 这么委曲求全的决策，所以一直以为蓝光机中是 Opera9.8。而很多 CSS3 特性都不被 Opera9.8 支持。包括我们这里将会被用到的 CSS3 Transition。所以很自然地使用 jQuery 提供的 animate 方法实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// top from 0 to 94</span></span><br><span class=\"line\">$list.animate(&#123; <span class=\"attr\">top</span>: top &#125;, <span class=\"string\">'fast'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do some thing</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在蓝光机中该动画只会执行三步，分别是 top = 0, ~59, 94px，所以会给人一种很不平滑的感觉。</p>\n<p>很长时间以后才注意到蓝光机中的浏览器是 Opera12.11. 然后开始尝试使用 CSS3 Transition。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">transition</span>: <span class=\"selector-tag\">top</span> 300<span class=\"selector-tag\">ms</span> <span class=\"selector-tag\">linear</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">$list.css(<span class=\"string\">'top'</span>, top);</span><br></pre></td></tr></table></figure>\n<p>以上动画效果在桌面浏览器上运行的非常好，但是在蓝光机上依然没有明显改善，反而感觉有点晃动。优化失败。</p>\n<p>在尝试将其他部分动画也使用 CSS3 Transition 时发现一个问题，就是修改某个属性之前，如果该属性没有显式声明，那么各个浏览器处理方式不同。以 width 为例，这时通过<code>elem.style.width</code>得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。这个小问题让我耽误了不少时间。</p>\n<p>###使用方法</p>\n<blockquote>\n<p>transition ： [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; || &lt;’transition-timing-function’&gt; || &lt;’transition-delay’&gt; [, [&lt;’transition-property’&gt; || &lt;’transition-duration’&gt; || &lt;’transition-timing-function’&gt; || &lt;’transition-delay’&gt;]]_<br>或者<br>transition-property ： none | all | [ <ident> ][ ‘,’ <ident> ]<em>；<br>transition-duration ： <time> [, <time>]</time></time></em><br>transition-timing-function ： ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>) [, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)]_<br>transition-delay ： <time> [, <time>]*</time></time></number></number></number></number></number></number></number></number></ident></ident></p>\n</blockquote>\n<p>transition-property 支持的属性参见<a href=\"http://www.w3.org/TR/css3-transitions/#transition-property\" target=\"_blank\" rel=\"noopener\">W3C 标准</a>。<br>transition-duration 和 transition-delay 支持如<code>1s</code>，<code>200ms</code>的值。</p>\n<p>###总结</p>\n<ol>\n<li>CSS3 Transition 可以在设置 CSS 属性时使其效果平滑过渡，但是过渡过程中，通过<code>elem.style.attr</code>获取其相应属性值时，得到的都是其最终值，这点和 jQuery 实现的动画效果不同。</li>\n<li>如果属性值为显式声明时，各个浏览器处理方式不同。以 width 为例，这时通过<code>elem.style.width</code>得到一个空字符串。Chrome26 中，width 会从 0 过渡到 XX px，而在 Opera12 以及 Firefox20 中 width 直接变成 XX px，并且不会触发 transitionend 事件。</li>\n<li>Opera 在 9.8 版本以后就将版本定格为 9.8，在以后的 Opera 版本中只能通过其 UserAgent 中的’Version/12.11’之类的字符串来确定其版本号。</li>\n<li>如果设置的属性值跟设置前一样，那么并不会触发 transitionend。这点需要特别注意。</li>\n</ol>\n"},{"title":"【翻译】Webkit图片擦拭效果","_content":"\n[来源](http://css-tricks.com/webkit-image-wipes/)  \nWebkit 浏览器支持遮罩，虽然它还不是标准。就像 PhotoShop 中一样，你声明一张图片作为遮罩，黑色部分是不透明的，将会遮住其后面的元素。白色部分透明，其后面的元素是可见的。灰色部分是半透明的。所以下面的图片：\n\n```html\n<img src=\"orig.jpg\" alt=\"trees\" class=\"circle-mask\" />\n```\n\n![orig.jpg](http://cdn.css-tricks.com/wp-content/uploads/2010/12/orig.jpg)\n以及遮罩图片：\n![mask.png](http://cdn.css-tricks.com/wp-content/uploads/2010/12/mask.png)\n应用如下 CSS：\n\n```css\n.circle-mask {\n    -webkit-mask-box-image: url(mask.png);\n}\n```\n\n将会得到如下效果：\n![masked.png](http://cdn.css-tricks.com/wp-content/uploads/2010/12/masked.png)\n\n###遮罩并不一定要真正的图片\n这里用到的第一个技巧是，声明为遮罩`webkit-mask-box-image`的图片并不是真正的图片，而是使用`-webkit-gradient`来实现。当然我们可以使用渐变创建一张图片，但是通过编程创建渐变遮罩更容易修改，并且减少一次 HTTP 请求。\n\n```css\n-webkit-mask-position: 0 0;\n-webkit-mask-size: 200px 200px;\n-webkit-mask-image: -webkit-gradient(\n    linear,\n    left top,\n    right bottom,\n    color-stop(0, rgba(0, 0, 0, 1)),\n    color-stop(0.45, rgba(0, 0, 0, 1)),\n    color-stop(0.5, rgba(0, 0, 0, 0)),\n    color-stop(0.55, rgba(0, 0, 0, 0)),\n    color-stop(1, rgba(0, 0, 0, 0))\n);\n```\n\n在以上的 CSS 中，我们创建了一个 200X200 像素的图片，顺着 45 度角方向，从左上角的完全不透明，到差不多一半的地方渐变到完全透明。就像下面的图片：\n![diagonalgradientmask.png](http://cdn.css-tricks.com/wp-content/uploads/2010/12/diagonalgradientmask.png) ###移动遮罩\n在上面我们通过`-webkit-mask-position`设置遮罩的位置，因为可以设置其位置，所以也就可以移动它。我们可以在`:hover`伪类上移动，\n\n```css\n.circle-mask {\n    -webkit-mask-position: 0 0;\n}\n.circle-mask:hover {\n    -webkit-mask-position: -300px -300px;\n}\n```\n\n也可以使用`-webkit-animation`来自动移动遮罩。\n\n```css\n@-webkit-keyframes wipe {\n    0% {\n        -webkit-mask-position: 0 0;\n    }\n    100% {\n        -webkit-mask-position: -300px -300px;\n    }\n}\n.circle-mask {\n    -webkit-animation: wipe 6s infinite;\n    -webkit-animation-delay: 3s;\n    -webkit-animation-direction: alternate;\n}\n```\n\n###创建擦拭效果\n![](http://cdn.css-tricks.com/wp-content/uploads/2010/12/wipe.jpg)\n我相信聪明的你已经将他们联系在一起。这个主意就是将一张图片放在另一张图片上面，上面的图片作为遮罩，根据需要移动遮罩。\n\n```html\n<div id=\"banner\">\n    <div><img src=\"images/banner-1.jpg\" alt=\"Skyline 1\" /></div>\n    <div><img src=\"images/banner-2.jpg\" alt=\"Skyline 2\" /></div>\n</div>\n```\n\n```css\n#banner {\n    width: 800px; /* Size of images, will collapse without */\n    height: 300px;\n    position: relative; /* For abs. positioning inside */\n    border: 8px solid #eee;\n    -webkit-box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.75);\n}\n\n#banner div {\n    position: absolute; /* Top and left zero are implied */\n}\n\n/* Second one is on top */\n#banner div:nth-child(2) {\n    -webkit-animation: wipe 6s infinite;\n    -webkit-animation-delay: 3s;\n    -webkit-animation-direction: alternate;\n    -webkit-mask-size: 2000px 2000px;\n    -webkit-mask-image: -webkit-gradient(\n        linear,\n        left top,\n        right bottom,\n        color-stop(0, rgba(0, 0, 0, 1)),\n        color-stop(0.45, rgba(0, 0, 0, 1)),\n        color-stop(0.5, rgba(0, 0, 0, 0)),\n        color-stop(0.55, rgba(0, 0, 0, 0)),\n        color-stop(1, rgba(0, 0, 0, 0))\n    );\n}\n```\n\n###示例和下载\n在下载文件中，有另一个例子，水平方向上擦拭而不是顺着某个角度，并且使用`-webkit-transition`而不是动画。  \n[查看例子](http://css-tricks.com/examples/ImageWipes/)\n[下载](http://css-tricks.com/examples/ImageWipes.zip)\n\n###比两个更多？\n我花了更多时间在尝试能否连续擦拭三张照片。这是可能的但是我不能让它足够平滑，以及像我想象的那么方便，所以我放弃了。我仍然非常确信这是可以的，也许使用两个不同的有着不同延迟的动画。如果你尝试了并成功了，一定要给我看看。\n\n###更多\n要了解更多请查看 webkit 在 2008 年的一个关于遮罩的[通告](http://webkit.org/blog/181/css-masks/)，那里有很多有用的信息，比如遮罩图片可以伸展（像[full page backgrounds](http://css-tricks.com/perfect-full-page-background-image/)）以及重复。实际上他的作用和带有九宫格[border-image](http://css-tricks.com/understanding-border-image/)有很大相似之处，\n\n###Credit\n我从[Doug Neiner](http://dougneiner.com/)那里偷来了这个想法，他给我展示了一些关于这些想法的例子。经他允许发此文章。\n","source":"_posts/2013-05-10-Webkit-Image-Wipes.md","raw":"---\ntitle: 【翻译】Webkit图片擦拭效果\n---\n\n[来源](http://css-tricks.com/webkit-image-wipes/)  \nWebkit 浏览器支持遮罩，虽然它还不是标准。就像 PhotoShop 中一样，你声明一张图片作为遮罩，黑色部分是不透明的，将会遮住其后面的元素。白色部分透明，其后面的元素是可见的。灰色部分是半透明的。所以下面的图片：\n\n```html\n<img src=\"orig.jpg\" alt=\"trees\" class=\"circle-mask\" />\n```\n\n![orig.jpg](http://cdn.css-tricks.com/wp-content/uploads/2010/12/orig.jpg)\n以及遮罩图片：\n![mask.png](http://cdn.css-tricks.com/wp-content/uploads/2010/12/mask.png)\n应用如下 CSS：\n\n```css\n.circle-mask {\n    -webkit-mask-box-image: url(mask.png);\n}\n```\n\n将会得到如下效果：\n![masked.png](http://cdn.css-tricks.com/wp-content/uploads/2010/12/masked.png)\n\n###遮罩并不一定要真正的图片\n这里用到的第一个技巧是，声明为遮罩`webkit-mask-box-image`的图片并不是真正的图片，而是使用`-webkit-gradient`来实现。当然我们可以使用渐变创建一张图片，但是通过编程创建渐变遮罩更容易修改，并且减少一次 HTTP 请求。\n\n```css\n-webkit-mask-position: 0 0;\n-webkit-mask-size: 200px 200px;\n-webkit-mask-image: -webkit-gradient(\n    linear,\n    left top,\n    right bottom,\n    color-stop(0, rgba(0, 0, 0, 1)),\n    color-stop(0.45, rgba(0, 0, 0, 1)),\n    color-stop(0.5, rgba(0, 0, 0, 0)),\n    color-stop(0.55, rgba(0, 0, 0, 0)),\n    color-stop(1, rgba(0, 0, 0, 0))\n);\n```\n\n在以上的 CSS 中，我们创建了一个 200X200 像素的图片，顺着 45 度角方向，从左上角的完全不透明，到差不多一半的地方渐变到完全透明。就像下面的图片：\n![diagonalgradientmask.png](http://cdn.css-tricks.com/wp-content/uploads/2010/12/diagonalgradientmask.png) ###移动遮罩\n在上面我们通过`-webkit-mask-position`设置遮罩的位置，因为可以设置其位置，所以也就可以移动它。我们可以在`:hover`伪类上移动，\n\n```css\n.circle-mask {\n    -webkit-mask-position: 0 0;\n}\n.circle-mask:hover {\n    -webkit-mask-position: -300px -300px;\n}\n```\n\n也可以使用`-webkit-animation`来自动移动遮罩。\n\n```css\n@-webkit-keyframes wipe {\n    0% {\n        -webkit-mask-position: 0 0;\n    }\n    100% {\n        -webkit-mask-position: -300px -300px;\n    }\n}\n.circle-mask {\n    -webkit-animation: wipe 6s infinite;\n    -webkit-animation-delay: 3s;\n    -webkit-animation-direction: alternate;\n}\n```\n\n###创建擦拭效果\n![](http://cdn.css-tricks.com/wp-content/uploads/2010/12/wipe.jpg)\n我相信聪明的你已经将他们联系在一起。这个主意就是将一张图片放在另一张图片上面，上面的图片作为遮罩，根据需要移动遮罩。\n\n```html\n<div id=\"banner\">\n    <div><img src=\"images/banner-1.jpg\" alt=\"Skyline 1\" /></div>\n    <div><img src=\"images/banner-2.jpg\" alt=\"Skyline 2\" /></div>\n</div>\n```\n\n```css\n#banner {\n    width: 800px; /* Size of images, will collapse without */\n    height: 300px;\n    position: relative; /* For abs. positioning inside */\n    border: 8px solid #eee;\n    -webkit-box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.75);\n}\n\n#banner div {\n    position: absolute; /* Top and left zero are implied */\n}\n\n/* Second one is on top */\n#banner div:nth-child(2) {\n    -webkit-animation: wipe 6s infinite;\n    -webkit-animation-delay: 3s;\n    -webkit-animation-direction: alternate;\n    -webkit-mask-size: 2000px 2000px;\n    -webkit-mask-image: -webkit-gradient(\n        linear,\n        left top,\n        right bottom,\n        color-stop(0, rgba(0, 0, 0, 1)),\n        color-stop(0.45, rgba(0, 0, 0, 1)),\n        color-stop(0.5, rgba(0, 0, 0, 0)),\n        color-stop(0.55, rgba(0, 0, 0, 0)),\n        color-stop(1, rgba(0, 0, 0, 0))\n    );\n}\n```\n\n###示例和下载\n在下载文件中，有另一个例子，水平方向上擦拭而不是顺着某个角度，并且使用`-webkit-transition`而不是动画。  \n[查看例子](http://css-tricks.com/examples/ImageWipes/)\n[下载](http://css-tricks.com/examples/ImageWipes.zip)\n\n###比两个更多？\n我花了更多时间在尝试能否连续擦拭三张照片。这是可能的但是我不能让它足够平滑，以及像我想象的那么方便，所以我放弃了。我仍然非常确信这是可以的，也许使用两个不同的有着不同延迟的动画。如果你尝试了并成功了，一定要给我看看。\n\n###更多\n要了解更多请查看 webkit 在 2008 年的一个关于遮罩的[通告](http://webkit.org/blog/181/css-masks/)，那里有很多有用的信息，比如遮罩图片可以伸展（像[full page backgrounds](http://css-tricks.com/perfect-full-page-background-image/)）以及重复。实际上他的作用和带有九宫格[border-image](http://css-tricks.com/understanding-border-image/)有很大相似之处，\n\n###Credit\n我从[Doug Neiner](http://dougneiner.com/)那里偷来了这个想法，他给我展示了一些关于这些想法的例子。经他允许发此文章。\n","slug":"Webkit-Image-Wipes","published":1,"date":"2013-05-09T16:00:00.000Z","updated":"2018-12-07T03:07:26.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm960007w8wkmf4bffwl","content":"<p><a href=\"http://css-tricks.com/webkit-image-wipes/\" target=\"_blank\" rel=\"noopener\">来源</a><br>Webkit 浏览器支持遮罩，虽然它还不是标准。就像 PhotoShop 中一样，你声明一张图片作为遮罩，黑色部分是不透明的，将会遮住其后面的元素。白色部分透明，其后面的元素是可见的。灰色部分是半透明的。所以下面的图片：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"orig.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"trees\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"circle-mask\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/orig.jpg\" alt=\"orig.jpg\"><br>以及遮罩图片：<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/mask.png\" alt=\"mask.png\"><br>应用如下 CSS：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.circle-mask</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-box-image</span>: <span class=\"built_in\">url</span>(mask.png);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将会得到如下效果：<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/masked.png\" alt=\"masked.png\"></p>\n<p>###遮罩并不一定要真正的图片<br>这里用到的第一个技巧是，声明为遮罩<code>webkit-mask-box-image</code>的图片并不是真正的图片，而是使用<code>-webkit-gradient</code>来实现。当然我们可以使用渐变创建一张图片，但是通过编程创建渐变遮罩更容易修改，并且减少一次 HTTP 请求。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-webkit-mask-position</span>: 0 0;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-mask-size</span>: 200<span class=\"selector-tag\">px</span> 200<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-mask-image</span>: <span class=\"selector-tag\">-webkit-gradient</span>(</span><br><span class=\"line\">    <span class=\"selector-tag\">linear</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">left</span> <span class=\"selector-tag\">top</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">right</span> <span class=\"selector-tag\">bottom</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(0, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 1)),</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(0<span class=\"selector-class\">.45</span>, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 1)),</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(0<span class=\"selector-class\">.5</span>, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 0)),</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(0<span class=\"selector-class\">.55</span>, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 0)),</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(1, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 0))</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>在以上的 CSS 中，我们创建了一个 200X200 像素的图片，顺着 45 度角方向，从左上角的完全不透明，到差不多一半的地方渐变到完全透明。就像下面的图片：<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/diagonalgradientmask.png\" alt=\"diagonalgradientmask.png\"> ###移动遮罩<br>在上面我们通过<code>-webkit-mask-position</code>设置遮罩的位置，因为可以设置其位置，所以也就可以移动它。我们可以在<code>:hover</code>伪类上移动，</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.circle-mask</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.circle-mask</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-position</span>: -<span class=\"number\">300px</span> -<span class=\"number\">300px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用<code>-webkit-animation</code>来自动移动遮罩。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">@-<span class=\"keyword\">webkit</span>-<span class=\"keyword\">keyframes</span> wipe &#123;</span><br><span class=\"line\">    0% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">-webkit-mask-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    100% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">-webkit-mask-position</span>: -<span class=\"number\">300px</span> -<span class=\"number\">300px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.circle-mask</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation</span>: wipe <span class=\"number\">6s</span> infinite;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation-delay</span>: <span class=\"number\">3s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation-direction</span>: alternate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###创建擦拭效果<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/wipe.jpg\" alt=\"\"><br>我相信聪明的你已经将他们联系在一起。这个主意就是将一张图片放在另一张图片上面，上面的图片作为遮罩，根据需要移动遮罩。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"banner\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/banner-1.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Skyline 1\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/banner-2.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Skyline 2\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#banner</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">800px</span>; <span class=\"comment\">/* Size of images, will collapse without */</span></span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative; <span class=\"comment\">/* For abs. positioning inside */</span></span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">8px</span> solid <span class=\"number\">#eee</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-box-shadow</span>: <span class=\"number\">1px</span> <span class=\"number\">1px</span> <span class=\"number\">3px</span> <span class=\"built_in\">rgba</span>(0, 0, 0, 0.75);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#banner</span> <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute; <span class=\"comment\">/* Top and left zero are implied */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Second one is on top */</span></span><br><span class=\"line\"><span class=\"selector-id\">#banner</span> <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:nth-child(2)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation</span>: wipe <span class=\"number\">6s</span> infinite;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation-delay</span>: <span class=\"number\">3s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation-direction</span>: alternate;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-size</span>: <span class=\"number\">2000px</span> <span class=\"number\">2000px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-image</span>: <span class=\"built_in\">-webkit-gradient</span>(</span><br><span class=\"line\">        linear,</span><br><span class=\"line\">        left top,</span><br><span class=\"line\">        right bottom,</span><br><span class=\"line\">        color-stop(0, rgba(0, 0, 0, 1)),</span><br><span class=\"line\">        <span class=\"built_in\">color-stop</span>(0.45, rgba(0, 0, 0, 1)),</span><br><span class=\"line\">        <span class=\"built_in\">color-stop</span>(0.5, rgba(0, 0, 0, 0)),</span><br><span class=\"line\">        <span class=\"built_in\">color-stop</span>(0.55, rgba(0, 0, 0, 0)),</span><br><span class=\"line\">        <span class=\"built_in\">color-stop</span>(1, rgba(0, 0, 0, 0))</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###示例和下载<br>在下载文件中，有另一个例子，水平方向上擦拭而不是顺着某个角度，并且使用<code>-webkit-transition</code>而不是动画。<br><a href=\"http://css-tricks.com/examples/ImageWipes/\" target=\"_blank\" rel=\"noopener\">查看例子</a><br><a href=\"http://css-tricks.com/examples/ImageWipes.zip\" target=\"_blank\" rel=\"noopener\">下载</a></p>\n<p>###比两个更多？<br>我花了更多时间在尝试能否连续擦拭三张照片。这是可能的但是我不能让它足够平滑，以及像我想象的那么方便，所以我放弃了。我仍然非常确信这是可以的，也许使用两个不同的有着不同延迟的动画。如果你尝试了并成功了，一定要给我看看。</p>\n<p>###更多<br>要了解更多请查看 webkit 在 2008 年的一个关于遮罩的<a href=\"http://webkit.org/blog/181/css-masks/\" target=\"_blank\" rel=\"noopener\">通告</a>，那里有很多有用的信息，比如遮罩图片可以伸展（像<a href=\"http://css-tricks.com/perfect-full-page-background-image/\" target=\"_blank\" rel=\"noopener\">full page backgrounds</a>）以及重复。实际上他的作用和带有九宫格<a href=\"http://css-tricks.com/understanding-border-image/\" target=\"_blank\" rel=\"noopener\">border-image</a>有很大相似之处，</p>\n<p>###Credit<br>我从<a href=\"http://dougneiner.com/\" target=\"_blank\" rel=\"noopener\">Doug Neiner</a>那里偷来了这个想法，他给我展示了一些关于这些想法的例子。经他允许发此文章。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://css-tricks.com/webkit-image-wipes/\" target=\"_blank\" rel=\"noopener\">来源</a><br>Webkit 浏览器支持遮罩，虽然它还不是标准。就像 PhotoShop 中一样，你声明一张图片作为遮罩，黑色部分是不透明的，将会遮住其后面的元素。白色部分透明，其后面的元素是可见的。灰色部分是半透明的。所以下面的图片：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"orig.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"trees\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"circle-mask\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/orig.jpg\" alt=\"orig.jpg\"><br>以及遮罩图片：<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/mask.png\" alt=\"mask.png\"><br>应用如下 CSS：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.circle-mask</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-box-image</span>: <span class=\"built_in\">url</span>(mask.png);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将会得到如下效果：<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/masked.png\" alt=\"masked.png\"></p>\n<p>###遮罩并不一定要真正的图片<br>这里用到的第一个技巧是，声明为遮罩<code>webkit-mask-box-image</code>的图片并不是真正的图片，而是使用<code>-webkit-gradient</code>来实现。当然我们可以使用渐变创建一张图片，但是通过编程创建渐变遮罩更容易修改，并且减少一次 HTTP 请求。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-webkit-mask-position</span>: 0 0;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-mask-size</span>: 200<span class=\"selector-tag\">px</span> 200<span class=\"selector-tag\">px</span>;</span><br><span class=\"line\"><span class=\"selector-tag\">-webkit-mask-image</span>: <span class=\"selector-tag\">-webkit-gradient</span>(</span><br><span class=\"line\">    <span class=\"selector-tag\">linear</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">left</span> <span class=\"selector-tag\">top</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">right</span> <span class=\"selector-tag\">bottom</span>,</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(0, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 1)),</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(0<span class=\"selector-class\">.45</span>, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 1)),</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(0<span class=\"selector-class\">.5</span>, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 0)),</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(0<span class=\"selector-class\">.55</span>, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 0)),</span><br><span class=\"line\">    <span class=\"selector-tag\">color-stop</span>(1, <span class=\"selector-tag\">rgba</span>(0, 0, 0, 0))</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>在以上的 CSS 中，我们创建了一个 200X200 像素的图片，顺着 45 度角方向，从左上角的完全不透明，到差不多一半的地方渐变到完全透明。就像下面的图片：<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/diagonalgradientmask.png\" alt=\"diagonalgradientmask.png\"> ###移动遮罩<br>在上面我们通过<code>-webkit-mask-position</code>设置遮罩的位置，因为可以设置其位置，所以也就可以移动它。我们可以在<code>:hover</code>伪类上移动，</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.circle-mask</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.circle-mask</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-position</span>: -<span class=\"number\">300px</span> -<span class=\"number\">300px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用<code>-webkit-animation</code>来自动移动遮罩。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">@-<span class=\"keyword\">webkit</span>-<span class=\"keyword\">keyframes</span> wipe &#123;</span><br><span class=\"line\">    0% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">-webkit-mask-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    100% &#123;</span><br><span class=\"line\">        <span class=\"attribute\">-webkit-mask-position</span>: -<span class=\"number\">300px</span> -<span class=\"number\">300px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.circle-mask</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation</span>: wipe <span class=\"number\">6s</span> infinite;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation-delay</span>: <span class=\"number\">3s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation-direction</span>: alternate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###创建擦拭效果<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2010/12/wipe.jpg\" alt=\"\"><br>我相信聪明的你已经将他们联系在一起。这个主意就是将一张图片放在另一张图片上面，上面的图片作为遮罩，根据需要移动遮罩。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"banner\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/banner-1.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Skyline 1\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/banner-2.jpg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Skyline 2\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#banner</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">800px</span>; <span class=\"comment\">/* Size of images, will collapse without */</span></span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative; <span class=\"comment\">/* For abs. positioning inside */</span></span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">8px</span> solid <span class=\"number\">#eee</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-box-shadow</span>: <span class=\"number\">1px</span> <span class=\"number\">1px</span> <span class=\"number\">3px</span> <span class=\"built_in\">rgba</span>(0, 0, 0, 0.75);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#banner</span> <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute; <span class=\"comment\">/* Top and left zero are implied */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Second one is on top */</span></span><br><span class=\"line\"><span class=\"selector-id\">#banner</span> <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:nth-child(2)</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation</span>: wipe <span class=\"number\">6s</span> infinite;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation-delay</span>: <span class=\"number\">3s</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-animation-direction</span>: alternate;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-size</span>: <span class=\"number\">2000px</span> <span class=\"number\">2000px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">-webkit-mask-image</span>: <span class=\"built_in\">-webkit-gradient</span>(</span><br><span class=\"line\">        linear,</span><br><span class=\"line\">        left top,</span><br><span class=\"line\">        right bottom,</span><br><span class=\"line\">        color-stop(0, rgba(0, 0, 0, 1)),</span><br><span class=\"line\">        <span class=\"built_in\">color-stop</span>(0.45, rgba(0, 0, 0, 1)),</span><br><span class=\"line\">        <span class=\"built_in\">color-stop</span>(0.5, rgba(0, 0, 0, 0)),</span><br><span class=\"line\">        <span class=\"built_in\">color-stop</span>(0.55, rgba(0, 0, 0, 0)),</span><br><span class=\"line\">        <span class=\"built_in\">color-stop</span>(1, rgba(0, 0, 0, 0))</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###示例和下载<br>在下载文件中，有另一个例子，水平方向上擦拭而不是顺着某个角度，并且使用<code>-webkit-transition</code>而不是动画。<br><a href=\"http://css-tricks.com/examples/ImageWipes/\" target=\"_blank\" rel=\"noopener\">查看例子</a><br><a href=\"http://css-tricks.com/examples/ImageWipes.zip\" target=\"_blank\" rel=\"noopener\">下载</a></p>\n<p>###比两个更多？<br>我花了更多时间在尝试能否连续擦拭三张照片。这是可能的但是我不能让它足够平滑，以及像我想象的那么方便，所以我放弃了。我仍然非常确信这是可以的，也许使用两个不同的有着不同延迟的动画。如果你尝试了并成功了，一定要给我看看。</p>\n<p>###更多<br>要了解更多请查看 webkit 在 2008 年的一个关于遮罩的<a href=\"http://webkit.org/blog/181/css-masks/\" target=\"_blank\" rel=\"noopener\">通告</a>，那里有很多有用的信息，比如遮罩图片可以伸展（像<a href=\"http://css-tricks.com/perfect-full-page-background-image/\" target=\"_blank\" rel=\"noopener\">full page backgrounds</a>）以及重复。实际上他的作用和带有九宫格<a href=\"http://css-tricks.com/understanding-border-image/\" target=\"_blank\" rel=\"noopener\">border-image</a>有很大相似之处，</p>\n<p>###Credit<br>我从<a href=\"http://dougneiner.com/\" target=\"_blank\" rel=\"noopener\">Doug Neiner</a>那里偷来了这个想法，他给我展示了一些关于这些想法的例子。经他允许发此文章。</p>\n"},{"_content":"1. ####什么是闭包？举个例子？\n   闭包是指一个函数可以访问其生成时各级（非顶级）作用域中局部变量的能力。\n\n```js\nvar lis = document.querySelector('#list li');\nfor (var i = 0; i < li.length; i++) {\n    li.addEventListener(\n        'click',\n        (function(index) {\n            return function() {\n                console.log(lis[index].getAttribute('name'));\n            };\n        })(i),\n        false\n    );\n}\n```\n\n在以上例子中，点击每个 li 时就会打印出该 li 的 name 属性。绑定在 click 事件上的匿名函数可以访问局部变量 index，就是利用了闭包原理。\n\n1. ####请解释一下 JavaScript 的同源策略。\n   同源是指相同的协议、域名、端口。\n   最早用来阻止一个源下面的 js 去获取或者修改另一个源下面的文档属性，比如 iframe 加载另一个源下的页面。\n   后来也被用于 AJAX 请求，是指一个源只能同一个源的服务器发起 AJAX 请求。\n\n1. ####请解释 AJAX 的工作原理，以及其优缺点。\n   传统的 Web 应用允许用户向服务器提交 Form 表单，服务器处理之后返回一个新的页面。这种做法既浪费带宽，因为前后两个页面很多相同之处，也增加了响应时间，增加了白屏时间，降低了用户体验。后来的 iframe 技术可以局部刷新页面，当时仍然没有根本改变以上状况，此时 AJAX 技术应运而生。\n   AJAX 全称是 Asynchronous Javascript and XML，异步的 Javascript 和 XML 技术。AJAX 技术允许应用只向服务器请求必须的数据，并使用 Javascript 处理和渲染。节省带宽，提高了响应时间，基本不会白屏，提高了用户体验。\n   其缺点也很明显，（1）破坏了浏览器的后退功能，最常用的解决办法是使用 URL 片段标识符（锚点，URL 中#后面的部分）来保持跟踪，允许用户回到指定的某个应用程序状态。或者使用现代浏览器都基本支持的 HTML5 规范中的 History API。\n\n```javascript\n// https://github.com/lichangwei/client-utils/blob/master/ajax.js\nvar xhr = new XMLHttpRequest();\nxhr.open('get', '/url');\nxhr.onreadystatechange = function() {\n    if (xhr.state === 4) {\n        console.log(xhr.responseText);\n    }\n};\nxhr.send(null);\n```\n\n1. ####请解释 JSONP 的工作原理，以及它为什么不是真正的 AJAX。\n   （1）客户端生成一个全局函数，比如 jsonp_callback。  \n   （2）创建一个 script 标签访问某个资源，并加上参数?jsonp=jsonp_callback.  \n   （3）服务器返回资源数据，格式为 jsonp_callback(资源数据)。  \n   （4）浏览器解析服务器返回数据，即调用 jsonp_callback 函数，参数为资源数据。  \n   JSONP 并不使用 XMLHttpRequest 对象加载资源，而是通过 script 标签把资源当做普通的 javascript 脚本来加载，所以不存在跨域问题，也不是真正的 AJAX。\n\n1. ####你如何获取浏览器 URL 中查询字符串中的参数。\n\n```javascript\n// Using RegExp\nfunction getQueryParam(key) {\n    var search = window.location.search;\n    if (!key || !search) return;\n    key = key.replace(/\\./g, '\\\\.');\n    var match = search.match(new RegExp('[?&]' + key + '=([^&]*)'));\n    if (match) {\n        return decodeURIComponent(match[1]);\n    }\n}\n```\n\n```javascript\n// Using String.split\nfunction getQueryParam(key) {\n    var search = window.location.search;\n    if (!key || !search) return;\n    var array = search.substr(1).split(/[\\?&=]/);\n    var index = array.indexOf(key);\n    if (index !== -1 && index % 2 === 0) {\n        return decodeURIComponent(array[index + 1]);\n    }\n}\ngetQueryParam('order');\n```\n\n1. ####请解释一下事件代理。\n   将事件绑定目标元素的父元素上。在父元素的相应事件中判断 event.target 或其各级父元素是不是目标元素（一般通过 css 选择器判断），如果是，则在执行相应函数。  \n   事件代理的基础是事件冒泡机制。对于部分不支持冒泡的事件时无法使用事件代理的。但是捕获阶段应该也是可以做到事件代理的，参考[通过 body 的 error 事件捕获页面中所有图片的 error 事件](./2013-06-06-Events-in-Capture-Phase.md)  \n   使用场景：在绑定事件时，相应元素还没有生成，或者这类元素经常被替换掉，再或者元素个数太多，如果每个都分别绑定，太麻烦并且浪费内存。\n\n1. ####描述一种 JavaScript memoization (避免重复运算)的策略。\n\n```javascript\n// https://github.com/lichangwei/client-utils/blob/master/memorize.js\n/*\n  JavaScript Momorization\n  @param {string} func name of function / method\n  @param {object} [obj] method's object or scope correction object\n  @param {function} serialize method for arguments to get the hash value.\n */\nfunction memorize(func, thisObject, serialize) {\n    var cache = {};\n    thisObject = thisObject || null;\n    serialize =\n        serialize ||\n        function() {\n            return Array.prototype.join.call(arguments, '_');\n        };\n    return function() {\n        var hash = serialize.apply(null, arguments);\n        if (!cache[hash]) {\n            cache[hash] = func.apply(thisObject, arguments);\n        }\n        return cache[hash];\n    };\n}\n```\n\n1. ####什么是\"use strict\"？使用它的好处和坏处分别是什么？\n   在严格模式下，以下使用方法收到影响。  \n   （1）去除 with 关键字。  \n   （2）非顶级作用域中，不使用 var 声明变量就会报错，防止误升级为全局变量。  \n   （3）对于只读属性的修改报错，而不是静默失败。  \n   （4）函数形参重名或者对象定义属性重名报错。  \n   （5）函数中 this 不再默认指向全局对象 window。  \n   （6）更加安全的 eval. eval 中声明的变量和函数都不会影响当前作用域。  \n   （7）arguments.callee 和 arguments.caller 都不在可以使用。  \n   从上面列举的严格模式下的部分特性可以看出，严格模式减少出错的机会，但是也限制 JavaScrip 语言的灵活性。\n\n1. ####解释内存泄露并说明什么时候会出现内存泄露。\n   内存泄露是指一块内存不会被释放，也不会被使用，直到浏览器进程结束。浏览器中采用垃圾自动回收机制，但是由于其实现的问题，可能会造成内存泄露。造成内存泄露大多是对象循环引用：\n\n```javascript\nfunction bindClickEvent() {\n    var elem = document.getElementById('id');\n    elem.onclick = function() {\n        // do any thing\n    };\n}\n```\n\n以上函数的每次执行都会造成匿名函数和 elem 的循环引用。elem 显式引用匿名函数，匿名函数通过作用域链隐式引用 elem 元素。可以通过两种方法解决该问题，一是将 elem 设置为 null，二是将匿名函数置于 bindClickEvent 函数外面。两者都通过取消匿名函数对 elem 的隐式引用来解决该问题。\n","source":"_posts/2013-05-12-Javascript-Interview-Questions.md","raw":"1. ####什么是闭包？举个例子？\n   闭包是指一个函数可以访问其生成时各级（非顶级）作用域中局部变量的能力。\n\n```js\nvar lis = document.querySelector('#list li');\nfor (var i = 0; i < li.length; i++) {\n    li.addEventListener(\n        'click',\n        (function(index) {\n            return function() {\n                console.log(lis[index].getAttribute('name'));\n            };\n        })(i),\n        false\n    );\n}\n```\n\n在以上例子中，点击每个 li 时就会打印出该 li 的 name 属性。绑定在 click 事件上的匿名函数可以访问局部变量 index，就是利用了闭包原理。\n\n1. ####请解释一下 JavaScript 的同源策略。\n   同源是指相同的协议、域名、端口。\n   最早用来阻止一个源下面的 js 去获取或者修改另一个源下面的文档属性，比如 iframe 加载另一个源下的页面。\n   后来也被用于 AJAX 请求，是指一个源只能同一个源的服务器发起 AJAX 请求。\n\n1. ####请解释 AJAX 的工作原理，以及其优缺点。\n   传统的 Web 应用允许用户向服务器提交 Form 表单，服务器处理之后返回一个新的页面。这种做法既浪费带宽，因为前后两个页面很多相同之处，也增加了响应时间，增加了白屏时间，降低了用户体验。后来的 iframe 技术可以局部刷新页面，当时仍然没有根本改变以上状况，此时 AJAX 技术应运而生。\n   AJAX 全称是 Asynchronous Javascript and XML，异步的 Javascript 和 XML 技术。AJAX 技术允许应用只向服务器请求必须的数据，并使用 Javascript 处理和渲染。节省带宽，提高了响应时间，基本不会白屏，提高了用户体验。\n   其缺点也很明显，（1）破坏了浏览器的后退功能，最常用的解决办法是使用 URL 片段标识符（锚点，URL 中#后面的部分）来保持跟踪，允许用户回到指定的某个应用程序状态。或者使用现代浏览器都基本支持的 HTML5 规范中的 History API。\n\n```javascript\n// https://github.com/lichangwei/client-utils/blob/master/ajax.js\nvar xhr = new XMLHttpRequest();\nxhr.open('get', '/url');\nxhr.onreadystatechange = function() {\n    if (xhr.state === 4) {\n        console.log(xhr.responseText);\n    }\n};\nxhr.send(null);\n```\n\n1. ####请解释 JSONP 的工作原理，以及它为什么不是真正的 AJAX。\n   （1）客户端生成一个全局函数，比如 jsonp_callback。  \n   （2）创建一个 script 标签访问某个资源，并加上参数?jsonp=jsonp_callback.  \n   （3）服务器返回资源数据，格式为 jsonp_callback(资源数据)。  \n   （4）浏览器解析服务器返回数据，即调用 jsonp_callback 函数，参数为资源数据。  \n   JSONP 并不使用 XMLHttpRequest 对象加载资源，而是通过 script 标签把资源当做普通的 javascript 脚本来加载，所以不存在跨域问题，也不是真正的 AJAX。\n\n1. ####你如何获取浏览器 URL 中查询字符串中的参数。\n\n```javascript\n// Using RegExp\nfunction getQueryParam(key) {\n    var search = window.location.search;\n    if (!key || !search) return;\n    key = key.replace(/\\./g, '\\\\.');\n    var match = search.match(new RegExp('[?&]' + key + '=([^&]*)'));\n    if (match) {\n        return decodeURIComponent(match[1]);\n    }\n}\n```\n\n```javascript\n// Using String.split\nfunction getQueryParam(key) {\n    var search = window.location.search;\n    if (!key || !search) return;\n    var array = search.substr(1).split(/[\\?&=]/);\n    var index = array.indexOf(key);\n    if (index !== -1 && index % 2 === 0) {\n        return decodeURIComponent(array[index + 1]);\n    }\n}\ngetQueryParam('order');\n```\n\n1. ####请解释一下事件代理。\n   将事件绑定目标元素的父元素上。在父元素的相应事件中判断 event.target 或其各级父元素是不是目标元素（一般通过 css 选择器判断），如果是，则在执行相应函数。  \n   事件代理的基础是事件冒泡机制。对于部分不支持冒泡的事件时无法使用事件代理的。但是捕获阶段应该也是可以做到事件代理的，参考[通过 body 的 error 事件捕获页面中所有图片的 error 事件](./2013-06-06-Events-in-Capture-Phase.md)  \n   使用场景：在绑定事件时，相应元素还没有生成，或者这类元素经常被替换掉，再或者元素个数太多，如果每个都分别绑定，太麻烦并且浪费内存。\n\n1. ####描述一种 JavaScript memoization (避免重复运算)的策略。\n\n```javascript\n// https://github.com/lichangwei/client-utils/blob/master/memorize.js\n/*\n  JavaScript Momorization\n  @param {string} func name of function / method\n  @param {object} [obj] method's object or scope correction object\n  @param {function} serialize method for arguments to get the hash value.\n */\nfunction memorize(func, thisObject, serialize) {\n    var cache = {};\n    thisObject = thisObject || null;\n    serialize =\n        serialize ||\n        function() {\n            return Array.prototype.join.call(arguments, '_');\n        };\n    return function() {\n        var hash = serialize.apply(null, arguments);\n        if (!cache[hash]) {\n            cache[hash] = func.apply(thisObject, arguments);\n        }\n        return cache[hash];\n    };\n}\n```\n\n1. ####什么是\"use strict\"？使用它的好处和坏处分别是什么？\n   在严格模式下，以下使用方法收到影响。  \n   （1）去除 with 关键字。  \n   （2）非顶级作用域中，不使用 var 声明变量就会报错，防止误升级为全局变量。  \n   （3）对于只读属性的修改报错，而不是静默失败。  \n   （4）函数形参重名或者对象定义属性重名报错。  \n   （5）函数中 this 不再默认指向全局对象 window。  \n   （6）更加安全的 eval. eval 中声明的变量和函数都不会影响当前作用域。  \n   （7）arguments.callee 和 arguments.caller 都不在可以使用。  \n   从上面列举的严格模式下的部分特性可以看出，严格模式减少出错的机会，但是也限制 JavaScrip 语言的灵活性。\n\n1. ####解释内存泄露并说明什么时候会出现内存泄露。\n   内存泄露是指一块内存不会被释放，也不会被使用，直到浏览器进程结束。浏览器中采用垃圾自动回收机制，但是由于其实现的问题，可能会造成内存泄露。造成内存泄露大多是对象循环引用：\n\n```javascript\nfunction bindClickEvent() {\n    var elem = document.getElementById('id');\n    elem.onclick = function() {\n        // do any thing\n    };\n}\n```\n\n以上函数的每次执行都会造成匿名函数和 elem 的循环引用。elem 显式引用匿名函数，匿名函数通过作用域链隐式引用 elem 元素。可以通过两种方法解决该问题，一是将 elem 设置为 null，二是将匿名函数置于 bindClickEvent 函数外面。两者都通过取消匿名函数对 elem 的隐式引用来解决该问题。\n","slug":"Javascript-Interview-Questions","published":1,"date":"2013-05-11T16:00:00.000Z","updated":"2018-12-07T03:07:33.103Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm970008w8wkiw39odfa","content":"<ol>\n<li>####什么是闭包？举个例子？<br>闭包是指一个函数可以访问其生成时各级（非顶级）作用域中局部变量的能力。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lis = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#list li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; li.length; i++) &#123;</span><br><span class=\"line\">    li.addEventListener(</span><br><span class=\"line\">        <span class=\"string\">'click'</span>,</span><br><span class=\"line\">        (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(lis[index].getAttribute(<span class=\"string\">'name'</span>));</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;)(i),</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在以上例子中，点击每个 li 时就会打印出该 li 的 name 属性。绑定在 click 事件上的匿名函数可以访问局部变量 index，就是利用了闭包原理。</p>\n<ol>\n<li><p>####请解释一下 JavaScript 的同源策略。<br>同源是指相同的协议、域名、端口。<br>最早用来阻止一个源下面的 js 去获取或者修改另一个源下面的文档属性，比如 iframe 加载另一个源下的页面。<br>后来也被用于 AJAX 请求，是指一个源只能同一个源的服务器发起 AJAX 请求。</p>\n</li>\n<li><p>####请解释 AJAX 的工作原理，以及其优缺点。<br>传统的 Web 应用允许用户向服务器提交 Form 表单，服务器处理之后返回一个新的页面。这种做法既浪费带宽，因为前后两个页面很多相同之处，也增加了响应时间，增加了白屏时间，降低了用户体验。后来的 iframe 技术可以局部刷新页面，当时仍然没有根本改变以上状况，此时 AJAX 技术应运而生。<br>AJAX 全称是 Asynchronous Javascript and XML，异步的 Javascript 和 XML 技术。AJAX 技术允许应用只向服务器请求必须的数据，并使用 Javascript 处理和渲染。节省带宽，提高了响应时间，基本不会白屏，提高了用户体验。<br>其缺点也很明显，（1）破坏了浏览器的后退功能，最常用的解决办法是使用 URL 片段标识符（锚点，URL 中#后面的部分）来保持跟踪，允许用户回到指定的某个应用程序状态。或者使用现代浏览器都基本支持的 HTML5 规范中的 History API。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://github.com/lichangwei/client-utils/blob/master/ajax.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">'get'</span>, <span class=\"string\">'/url'</span>);</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xhr.state === <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(xhr.responseText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">xhr.send(<span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####请解释 JSONP 的工作原理，以及它为什么不是真正的 AJAX。<br>（1）客户端生成一个全局函数，比如 jsonp_callback。<br>（2）创建一个 script 标签访问某个资源，并加上参数?jsonp=jsonp_callback.<br>（3）服务器返回资源数据，格式为 jsonp_callback(资源数据)。<br>（4）浏览器解析服务器返回数据，即调用 jsonp_callback 函数，参数为资源数据。<br>JSONP 并不使用 XMLHttpRequest 对象加载资源，而是通过 script 标签把资源当做普通的 javascript 脚本来加载，所以不存在跨域问题，也不是真正的 AJAX。</p>\n</li>\n<li><p>####你如何获取浏览器 URL 中查询字符串中的参数。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Using RegExp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQueryParam</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> search = <span class=\"built_in\">window</span>.location.search;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key || !search) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    key = key.replace(<span class=\"regexp\">/\\./g</span>, <span class=\"string\">'\\\\.'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> match = search.match(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'[?&amp;]'</span> + key + <span class=\"string\">'=([^&amp;]*)'</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (match) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(match[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Using String.split</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQueryParam</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> search = <span class=\"built_in\">window</span>.location.search;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key || !search) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> array = search.substr(<span class=\"number\">1</span>).split(<span class=\"regexp\">/[\\?&amp;=]/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> index = array.indexOf(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== <span class=\"number\">-1</span> &amp;&amp; index % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(array[index + <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getQueryParam(<span class=\"string\">'order'</span>);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####请解释一下事件代理。<br>将事件绑定目标元素的父元素上。在父元素的相应事件中判断 event.target 或其各级父元素是不是目标元素（一般通过 css 选择器判断），如果是，则在执行相应函数。<br>事件代理的基础是事件冒泡机制。对于部分不支持冒泡的事件时无法使用事件代理的。但是捕获阶段应该也是可以做到事件代理的，参考<a href=\"./2013-06-06-Events-in-Capture-Phase.md\">通过 body 的 error 事件捕获页面中所有图片的 error 事件</a><br>使用场景：在绑定事件时，相应元素还没有生成，或者这类元素经常被替换掉，再或者元素个数太多，如果每个都分别绑定，太麻烦并且浪费内存。</p>\n</li>\n<li><p>####描述一种 JavaScript memoization (避免重复运算)的策略。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://github.com/lichangwei/client-utils/blob/master/memorize.js</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  JavaScript Momorization</span></span><br><span class=\"line\"><span class=\"comment\">  @param &#123;string&#125; func name of function / method</span></span><br><span class=\"line\"><span class=\"comment\">  @param &#123;object&#125; [obj] method's object or scope correction object</span></span><br><span class=\"line\"><span class=\"comment\">  @param &#123;function&#125; serialize method for arguments to get the hash value.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memorize</span>(<span class=\"params\">func, thisObject, serialize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cache = &#123;&#125;;</span><br><span class=\"line\">    thisObject = thisObject || <span class=\"literal\">null</span>;</span><br><span class=\"line\">    serialize =</span><br><span class=\"line\">        serialize ||</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.join.call(<span class=\"built_in\">arguments</span>, <span class=\"string\">'_'</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> hash = serialize.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cache[hash]) &#123;</span><br><span class=\"line\">            cache[hash] = func.apply(thisObject, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache[hash];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####什么是”use strict”？使用它的好处和坏处分别是什么？<br>在严格模式下，以下使用方法收到影响。<br>（1）去除 with 关键字。<br>（2）非顶级作用域中，不使用 var 声明变量就会报错，防止误升级为全局变量。<br>（3）对于只读属性的修改报错，而不是静默失败。<br>（4）函数形参重名或者对象定义属性重名报错。<br>（5）函数中 this 不再默认指向全局对象 window。<br>（6）更加安全的 eval. eval 中声明的变量和函数都不会影响当前作用域。<br>（7）arguments.callee 和 arguments.caller 都不在可以使用。<br>从上面列举的严格模式下的部分特性可以看出，严格模式减少出错的机会，但是也限制 JavaScrip 语言的灵活性。</p>\n</li>\n<li><p>####解释内存泄露并说明什么时候会出现内存泄露。<br>内存泄露是指一块内存不会被释放，也不会被使用，直到浏览器进程结束。浏览器中采用垃圾自动回收机制，但是由于其实现的问题，可能会造成内存泄露。造成内存泄露大多是对象循环引用：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindClickEvent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">    elem.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do any thing</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上函数的每次执行都会造成匿名函数和 elem 的循环引用。elem 显式引用匿名函数，匿名函数通过作用域链隐式引用 elem 元素。可以通过两种方法解决该问题，一是将 elem 设置为 null，二是将匿名函数置于 bindClickEvent 函数外面。两者都通过取消匿名函数对 elem 的隐式引用来解决该问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>####什么是闭包？举个例子？<br>闭包是指一个函数可以访问其生成时各级（非顶级）作用域中局部变量的能力。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lis = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#list li'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; li.length; i++) &#123;</span><br><span class=\"line\">    li.addEventListener(</span><br><span class=\"line\">        <span class=\"string\">'click'</span>,</span><br><span class=\"line\">        (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">index</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(lis[index].getAttribute(<span class=\"string\">'name'</span>));</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;)(i),</span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在以上例子中，点击每个 li 时就会打印出该 li 的 name 属性。绑定在 click 事件上的匿名函数可以访问局部变量 index，就是利用了闭包原理。</p>\n<ol>\n<li><p>####请解释一下 JavaScript 的同源策略。<br>同源是指相同的协议、域名、端口。<br>最早用来阻止一个源下面的 js 去获取或者修改另一个源下面的文档属性，比如 iframe 加载另一个源下的页面。<br>后来也被用于 AJAX 请求，是指一个源只能同一个源的服务器发起 AJAX 请求。</p>\n</li>\n<li><p>####请解释 AJAX 的工作原理，以及其优缺点。<br>传统的 Web 应用允许用户向服务器提交 Form 表单，服务器处理之后返回一个新的页面。这种做法既浪费带宽，因为前后两个页面很多相同之处，也增加了响应时间，增加了白屏时间，降低了用户体验。后来的 iframe 技术可以局部刷新页面，当时仍然没有根本改变以上状况，此时 AJAX 技术应运而生。<br>AJAX 全称是 Asynchronous Javascript and XML，异步的 Javascript 和 XML 技术。AJAX 技术允许应用只向服务器请求必须的数据，并使用 Javascript 处理和渲染。节省带宽，提高了响应时间，基本不会白屏，提高了用户体验。<br>其缺点也很明显，（1）破坏了浏览器的后退功能，最常用的解决办法是使用 URL 片段标识符（锚点，URL 中#后面的部分）来保持跟踪，允许用户回到指定的某个应用程序状态。或者使用现代浏览器都基本支持的 HTML5 规范中的 History API。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://github.com/lichangwei/client-utils/blob/master/ajax.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">'get'</span>, <span class=\"string\">'/url'</span>);</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xhr.state === <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(xhr.responseText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">xhr.send(<span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####请解释 JSONP 的工作原理，以及它为什么不是真正的 AJAX。<br>（1）客户端生成一个全局函数，比如 jsonp_callback。<br>（2）创建一个 script 标签访问某个资源，并加上参数?jsonp=jsonp_callback.<br>（3）服务器返回资源数据，格式为 jsonp_callback(资源数据)。<br>（4）浏览器解析服务器返回数据，即调用 jsonp_callback 函数，参数为资源数据。<br>JSONP 并不使用 XMLHttpRequest 对象加载资源，而是通过 script 标签把资源当做普通的 javascript 脚本来加载，所以不存在跨域问题，也不是真正的 AJAX。</p>\n</li>\n<li><p>####你如何获取浏览器 URL 中查询字符串中的参数。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Using RegExp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQueryParam</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> search = <span class=\"built_in\">window</span>.location.search;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key || !search) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    key = key.replace(<span class=\"regexp\">/\\./g</span>, <span class=\"string\">'\\\\.'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> match = search.match(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'[?&amp;]'</span> + key + <span class=\"string\">'=([^&amp;]*)'</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (match) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(match[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Using String.split</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getQueryParam</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> search = <span class=\"built_in\">window</span>.location.search;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!key || !search) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> array = search.substr(<span class=\"number\">1</span>).split(<span class=\"regexp\">/[\\?&amp;=]/</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> index = array.indexOf(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index !== <span class=\"number\">-1</span> &amp;&amp; index % <span class=\"number\">2</span> === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(array[index + <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getQueryParam(<span class=\"string\">'order'</span>);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####请解释一下事件代理。<br>将事件绑定目标元素的父元素上。在父元素的相应事件中判断 event.target 或其各级父元素是不是目标元素（一般通过 css 选择器判断），如果是，则在执行相应函数。<br>事件代理的基础是事件冒泡机制。对于部分不支持冒泡的事件时无法使用事件代理的。但是捕获阶段应该也是可以做到事件代理的，参考<a href=\"./2013-06-06-Events-in-Capture-Phase.md\">通过 body 的 error 事件捕获页面中所有图片的 error 事件</a><br>使用场景：在绑定事件时，相应元素还没有生成，或者这类元素经常被替换掉，再或者元素个数太多，如果每个都分别绑定，太麻烦并且浪费内存。</p>\n</li>\n<li><p>####描述一种 JavaScript memoization (避免重复运算)的策略。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://github.com/lichangwei/client-utils/blob/master/memorize.js</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  JavaScript Momorization</span></span><br><span class=\"line\"><span class=\"comment\">  @param &#123;string&#125; func name of function / method</span></span><br><span class=\"line\"><span class=\"comment\">  @param &#123;object&#125; [obj] method's object or scope correction object</span></span><br><span class=\"line\"><span class=\"comment\">  @param &#123;function&#125; serialize method for arguments to get the hash value.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memorize</span>(<span class=\"params\">func, thisObject, serialize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cache = &#123;&#125;;</span><br><span class=\"line\">    thisObject = thisObject || <span class=\"literal\">null</span>;</span><br><span class=\"line\">    serialize =</span><br><span class=\"line\">        serialize ||</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.join.call(<span class=\"built_in\">arguments</span>, <span class=\"string\">'_'</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> hash = serialize.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cache[hash]) &#123;</span><br><span class=\"line\">            cache[hash] = func.apply(thisObject, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache[hash];</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####什么是”use strict”？使用它的好处和坏处分别是什么？<br>在严格模式下，以下使用方法收到影响。<br>（1）去除 with 关键字。<br>（2）非顶级作用域中，不使用 var 声明变量就会报错，防止误升级为全局变量。<br>（3）对于只读属性的修改报错，而不是静默失败。<br>（4）函数形参重名或者对象定义属性重名报错。<br>（5）函数中 this 不再默认指向全局对象 window。<br>（6）更加安全的 eval. eval 中声明的变量和函数都不会影响当前作用域。<br>（7）arguments.callee 和 arguments.caller 都不在可以使用。<br>从上面列举的严格模式下的部分特性可以看出，严格模式减少出错的机会，但是也限制 JavaScrip 语言的灵活性。</p>\n</li>\n<li><p>####解释内存泄露并说明什么时候会出现内存泄露。<br>内存泄露是指一块内存不会被释放，也不会被使用，直到浏览器进程结束。浏览器中采用垃圾自动回收机制，但是由于其实现的问题，可能会造成内存泄露。造成内存泄露大多是对象循环引用：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindClickEvent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'id'</span>);</span><br><span class=\"line\">    elem.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do any thing</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上函数的每次执行都会造成匿名函数和 elem 的循环引用。elem 显式引用匿名函数，匿名函数通过作用域链隐式引用 elem 元素。可以通过两种方法解决该问题，一是将 elem 设置为 null，二是将匿名函数置于 bindClickEvent 函数外面。两者都通过取消匿名函数对 elem 的隐式引用来解决该问题。</p>\n"},{"_content":"1. ####平常你通过什么途径接触和学习前端知识？\n   邮件订阅：Javascript Weekly, HTML5 Weekly, CSS Weekly, Web Design Weekly, Responsive Design Weekly.  \n   GitHub  \n   RSS  \n   微博\n\n1. ####你更喜欢在哪个浏览器下进行开发？你使用那些开发人员工具？\n   浏览器：最喜欢 Chrome，其次是 Firefox+firebug。  \n   编辑器或者 IDE：Sublime Text 2  \n   抓包工具：Fidder 2，Wireshark\n   其他工具：Mark Man，F5\n\n1. ####如果今年你打算熟练掌握一项新技术，那会是什么？\n   WebGL\n\n1. ####你都使用那些工作来测试代码的性能？\n   通过 console.time() && console.timeEnd()测量执行 1000 次（取决）待测代码所需时间。  \n   JSPerf (http://jsperf.com/)  \n   Benchmark.js\n\n1. ####你有什么业余项目吗？是那种类型的？  \n   [gesture](https://github.com/lichangwei/gesture)\n   支持移动终端和桌面浏览器的事件库，包括 tap，taphold，doubletap，flick，zoomin，zoomout，scroll 等。  \n   [domtemp](https://github.com/lichangwei/domtemp)\n   基于 DOM 的模板引擎  \n   [restjs](https://github.com/lichangwei/restjs)\n   类似 node 中 express 框架\n","source":"_posts/2013-05-13-Unskilled-Interview-Questions.md","raw":"1. ####平常你通过什么途径接触和学习前端知识？\n   邮件订阅：Javascript Weekly, HTML5 Weekly, CSS Weekly, Web Design Weekly, Responsive Design Weekly.  \n   GitHub  \n   RSS  \n   微博\n\n1. ####你更喜欢在哪个浏览器下进行开发？你使用那些开发人员工具？\n   浏览器：最喜欢 Chrome，其次是 Firefox+firebug。  \n   编辑器或者 IDE：Sublime Text 2  \n   抓包工具：Fidder 2，Wireshark\n   其他工具：Mark Man，F5\n\n1. ####如果今年你打算熟练掌握一项新技术，那会是什么？\n   WebGL\n\n1. ####你都使用那些工作来测试代码的性能？\n   通过 console.time() && console.timeEnd()测量执行 1000 次（取决）待测代码所需时间。  \n   JSPerf (http://jsperf.com/)  \n   Benchmark.js\n\n1. ####你有什么业余项目吗？是那种类型的？  \n   [gesture](https://github.com/lichangwei/gesture)\n   支持移动终端和桌面浏览器的事件库，包括 tap，taphold，doubletap，flick，zoomin，zoomout，scroll 等。  \n   [domtemp](https://github.com/lichangwei/domtemp)\n   基于 DOM 的模板引擎  \n   [restjs](https://github.com/lichangwei/restjs)\n   类似 node 中 express 框架\n","slug":"Unskilled-Interview-Questions","published":1,"date":"2013-05-12T16:00:00.000Z","updated":"2018-12-07T03:03:08.335Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm980009w8wkr0a14ueq","content":"<ol>\n<li><p>####平常你通过什么途径接触和学习前端知识？<br>邮件订阅：Javascript Weekly, HTML5 Weekly, CSS Weekly, Web Design Weekly, Responsive Design Weekly.<br>GitHub<br>RSS<br>微博</p>\n</li>\n<li><p>####你更喜欢在哪个浏览器下进行开发？你使用那些开发人员工具？<br>浏览器：最喜欢 Chrome，其次是 Firefox+firebug。<br>编辑器或者 IDE：Sublime Text 2<br>抓包工具：Fidder 2，Wireshark<br>其他工具：Mark Man，F5</p>\n</li>\n<li><p>####如果今年你打算熟练掌握一项新技术，那会是什么？<br>WebGL</p>\n</li>\n<li><p>####你都使用那些工作来测试代码的性能？<br>通过 console.time() &amp;&amp; console.timeEnd()测量执行 1000 次（取决）待测代码所需时间。<br>JSPerf (<a href=\"http://jsperf.com/\" target=\"_blank\" rel=\"noopener\">http://jsperf.com/</a>)<br>Benchmark.js</p>\n</li>\n<li><p>####你有什么业余项目吗？是那种类型的？<br><a href=\"https://github.com/lichangwei/gesture\" target=\"_blank\" rel=\"noopener\">gesture</a><br>支持移动终端和桌面浏览器的事件库，包括 tap，taphold，doubletap，flick，zoomin，zoomout，scroll 等。<br><a href=\"https://github.com/lichangwei/domtemp\" target=\"_blank\" rel=\"noopener\">domtemp</a><br>基于 DOM 的模板引擎<br><a href=\"https://github.com/lichangwei/restjs\" target=\"_blank\" rel=\"noopener\">restjs</a><br>类似 node 中 express 框架</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>####平常你通过什么途径接触和学习前端知识？<br>邮件订阅：Javascript Weekly, HTML5 Weekly, CSS Weekly, Web Design Weekly, Responsive Design Weekly.<br>GitHub<br>RSS<br>微博</p>\n</li>\n<li><p>####你更喜欢在哪个浏览器下进行开发？你使用那些开发人员工具？<br>浏览器：最喜欢 Chrome，其次是 Firefox+firebug。<br>编辑器或者 IDE：Sublime Text 2<br>抓包工具：Fidder 2，Wireshark<br>其他工具：Mark Man，F5</p>\n</li>\n<li><p>####如果今年你打算熟练掌握一项新技术，那会是什么？<br>WebGL</p>\n</li>\n<li><p>####你都使用那些工作来测试代码的性能？<br>通过 console.time() &amp;&amp; console.timeEnd()测量执行 1000 次（取决）待测代码所需时间。<br>JSPerf (<a href=\"http://jsperf.com/\" target=\"_blank\" rel=\"noopener\">http://jsperf.com/</a>)<br>Benchmark.js</p>\n</li>\n<li><p>####你有什么业余项目吗？是那种类型的？<br><a href=\"https://github.com/lichangwei/gesture\" target=\"_blank\" rel=\"noopener\">gesture</a><br>支持移动终端和桌面浏览器的事件库，包括 tap，taphold，doubletap，flick，zoomin，zoomout，scroll 等。<br><a href=\"https://github.com/lichangwei/domtemp\" target=\"_blank\" rel=\"noopener\">domtemp</a><br>基于 DOM 的模板引擎<br><a href=\"https://github.com/lichangwei/restjs\" target=\"_blank\" rel=\"noopener\">restjs</a><br>类似 node 中 express 框架</p>\n</li>\n</ol>\n"},{"_content":"1. ####请解释一下什么是语义化的 HTML。\n   使用拥有语义的标签，比如 h1-h6, article, section, aside, header, footer, nav, address, strong, em 等标签，而不是不分清空皂白地统一使用 div 或者 p 标签。  \n   好处：（1）方便开发人员交流。统一的标签语义，不需要使用 class 表明用意。也阻止了不同的人使用不同的单词表达同样的含义。\n   （2）对搜索引擎友好。  \n   （3）样式加载失败时，浏览器默认样式也使得页面比较清晰。  \n   （4）对 CSS 支持不好甚至不支持的浏览器友好。\n\n1. ####你能描述一下渐进增强和优雅降级之间的不同吗?\n   构建站点的两个方法，都用到了特性检测。  \n   渐进增强：Progressive enhancement。先构建站点的最少特性，然后根据浏览器特性追加功能。  \n   优雅降级：graceful degradation。先构建站点的完整版本，然后根据浏览器特性进行修复。\n\n1. ####为什么利用多个域名来存储网站资源会更有效？  \n   浏览器对同一个域的并行连接数是有限制的，当前一般浏览器 4 到 8 个，而 IE6，7 只有 2 个，如果同时下载同一个域下的很多资源，就会因为此限制而导致资源下载串行。但是使用多个域虽然可以并行下载资源，但是会使得浏览器需要解析更多的域名。所以在这对优缺点之间取一个平衡点。另外，解决此问题的办法并非只有启用多个域这一种方法，还可以合并和压缩 JS 和 CSS，使用雪碧图等等。\n\n1. ####请说出三种减低页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）\n   文件的合并以及压缩（减少了 HTTP 请求的数量）\n   使用 CSS Sprites（减少 HTTP 请求的数量）\n   使用 CDN 托管（减少了数据传输时间）\n   使用 CSS3，SVG，甚至 Canvas 替代图片。\n   有效地适度地使用缓存脚本和其他资源\n\n1. ####什么是 FOUC？你如何来避免 FOUC？\n   FOUC 全称是 Flash Of Unstyled Content，翻译为文档样式闪烁。一般指 IE 在加载网页的时候，出现短暂的 CSS 样式失效。\n   问题一：什么时候出现呢？（1）IE 浏览器（2）IE 的临时文件夹没有缓存过页面的 css 文件（3）页面 head 标签里面没有任何 link 和 script 标签（4）页面引用样式的方式是采用@import（5）外在因素（比如网速等）\n   问题二：咋解决？在 head 里面加入一个 link 或者 script 标签\n   吐槽：我可能一辈子也不会写出这种代码，也希望面试官不要因为这种题目来拒绝候选人。\n\n1. ####描述 css reset 的作用和用途。\n   浏览器都会有默认样式表，这样保证了页面中即便不写任何样式，浏览器仍然能够清晰地展示出页面内容，并突出重点。\n\n1. ####描述下 float 和它的工作原理。\n   float 最初应用于图文混排，让文字环绕图片。  \n   语法为 float: left/right/none;  \n   float box 脱离当前文档流，定位到父元素或者另一个 float box 的边缘。父元素水平方向空间不足时，向下移动知道可以放下。文档流中 inline box 环绕 float box，block box 会和 float box 重叠，除非使用 clear: both/left/right 来清除浮动。float box 会形成一个新的 block formatting context（BFC 块状格式化上下文）。float box 不会超出所在 BFC，也不会和其他 BFC 重叠。\n\n1. ####清除浮动的方法有那些，分别适用于什么情形。\n   clear: both/left/right  \n   用于清除相应元素之前的兄弟节点浮动的影响。left 和 right 指浮动方向，both 包含 left 和 right 两个方向。\n\n1. ####解释 css sprites，如何使用。\n   将数张小的背景图片拼合成一张大的图片，然后在 CSS 中结合 background-image，background-position，width 和 height 等属性显示某张小的背景图片。  \n   网上有不少小工具可以让你上传一些小图片，然后生成一个大图并生成相应的样式表。即可直接使用。  \n   优点：减少了图片的请求数量。  \n   缺点：（1）不适合需要 repeat 的背景图片。（2）需要额外的工作来拼合成大图。（3）CSS 和图片缓存失效的概率和影响更大。\n1. ####你最喜欢的图片替换方法是什么，你如何选择使用。\n   Web-Font, CSS3, SVG, Canvas  \n   关于如何选择，首先查看所要兼容的浏览器是否兼容其特性。在三者均支持的很好的情况下，选择优先级从高到低分别是 Web-Font, CSS3, SVG, Canvas  \n   Web-Font 适合单色图片，并且可以通过 font 属性来设置其大小，颜色等，特别适合用于响应式设计中。\n   CSS3 基本可以说是从 SVG 发展而来的，功能应该还不如 SVG，但是其足够简单，所以选择优先级是比较高的。\n   SVG 适合需要响应用户行为，比如 mousemove 等操作的图片，作为矢量图，适合用于响应式设计中。  \n   Canvas 适合显示动态生成的图表，不需要响应用户行为。\n\n1. ####讨论 CSS hacks，条件引用或者其他。\n\n1. ####解释 BFC（block formatting context，块状布局上下文）\n   把一组块级 box 和浮动元素放在一起布局的区域。  \n   特点：（1）不折叠边距（margin collapsing），在同一个 BFC 是折叠边距的其中一个必要条件。（2）浮动元素不会超出它的范围。（3）不会跟其他浮动元素重叠。  \n   形成新的 BFC 的条件：（1）float 属性不为 none（2）overflow 属性不为 visible（3）display 属性是 table-cell、table-caption 或 inline-block（4）position 属性不为 static 或 relative。\n   IE6/7 没有 BFC 概念，但是它们有 hasLayout 与之相似，可以通过 zoom: 1 触发。\n","source":"_posts/2013-05-13-HTML-CSS-Interview-Questions.md","raw":"1. ####请解释一下什么是语义化的 HTML。\n   使用拥有语义的标签，比如 h1-h6, article, section, aside, header, footer, nav, address, strong, em 等标签，而不是不分清空皂白地统一使用 div 或者 p 标签。  \n   好处：（1）方便开发人员交流。统一的标签语义，不需要使用 class 表明用意。也阻止了不同的人使用不同的单词表达同样的含义。\n   （2）对搜索引擎友好。  \n   （3）样式加载失败时，浏览器默认样式也使得页面比较清晰。  \n   （4）对 CSS 支持不好甚至不支持的浏览器友好。\n\n1. ####你能描述一下渐进增强和优雅降级之间的不同吗?\n   构建站点的两个方法，都用到了特性检测。  \n   渐进增强：Progressive enhancement。先构建站点的最少特性，然后根据浏览器特性追加功能。  \n   优雅降级：graceful degradation。先构建站点的完整版本，然后根据浏览器特性进行修复。\n\n1. ####为什么利用多个域名来存储网站资源会更有效？  \n   浏览器对同一个域的并行连接数是有限制的，当前一般浏览器 4 到 8 个，而 IE6，7 只有 2 个，如果同时下载同一个域下的很多资源，就会因为此限制而导致资源下载串行。但是使用多个域虽然可以并行下载资源，但是会使得浏览器需要解析更多的域名。所以在这对优缺点之间取一个平衡点。另外，解决此问题的办法并非只有启用多个域这一种方法，还可以合并和压缩 JS 和 CSS，使用雪碧图等等。\n\n1. ####请说出三种减低页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）\n   文件的合并以及压缩（减少了 HTTP 请求的数量）\n   使用 CSS Sprites（减少 HTTP 请求的数量）\n   使用 CDN 托管（减少了数据传输时间）\n   使用 CSS3，SVG，甚至 Canvas 替代图片。\n   有效地适度地使用缓存脚本和其他资源\n\n1. ####什么是 FOUC？你如何来避免 FOUC？\n   FOUC 全称是 Flash Of Unstyled Content，翻译为文档样式闪烁。一般指 IE 在加载网页的时候，出现短暂的 CSS 样式失效。\n   问题一：什么时候出现呢？（1）IE 浏览器（2）IE 的临时文件夹没有缓存过页面的 css 文件（3）页面 head 标签里面没有任何 link 和 script 标签（4）页面引用样式的方式是采用@import（5）外在因素（比如网速等）\n   问题二：咋解决？在 head 里面加入一个 link 或者 script 标签\n   吐槽：我可能一辈子也不会写出这种代码，也希望面试官不要因为这种题目来拒绝候选人。\n\n1. ####描述 css reset 的作用和用途。\n   浏览器都会有默认样式表，这样保证了页面中即便不写任何样式，浏览器仍然能够清晰地展示出页面内容，并突出重点。\n\n1. ####描述下 float 和它的工作原理。\n   float 最初应用于图文混排，让文字环绕图片。  \n   语法为 float: left/right/none;  \n   float box 脱离当前文档流，定位到父元素或者另一个 float box 的边缘。父元素水平方向空间不足时，向下移动知道可以放下。文档流中 inline box 环绕 float box，block box 会和 float box 重叠，除非使用 clear: both/left/right 来清除浮动。float box 会形成一个新的 block formatting context（BFC 块状格式化上下文）。float box 不会超出所在 BFC，也不会和其他 BFC 重叠。\n\n1. ####清除浮动的方法有那些，分别适用于什么情形。\n   clear: both/left/right  \n   用于清除相应元素之前的兄弟节点浮动的影响。left 和 right 指浮动方向，both 包含 left 和 right 两个方向。\n\n1. ####解释 css sprites，如何使用。\n   将数张小的背景图片拼合成一张大的图片，然后在 CSS 中结合 background-image，background-position，width 和 height 等属性显示某张小的背景图片。  \n   网上有不少小工具可以让你上传一些小图片，然后生成一个大图并生成相应的样式表。即可直接使用。  \n   优点：减少了图片的请求数量。  \n   缺点：（1）不适合需要 repeat 的背景图片。（2）需要额外的工作来拼合成大图。（3）CSS 和图片缓存失效的概率和影响更大。\n1. ####你最喜欢的图片替换方法是什么，你如何选择使用。\n   Web-Font, CSS3, SVG, Canvas  \n   关于如何选择，首先查看所要兼容的浏览器是否兼容其特性。在三者均支持的很好的情况下，选择优先级从高到低分别是 Web-Font, CSS3, SVG, Canvas  \n   Web-Font 适合单色图片，并且可以通过 font 属性来设置其大小，颜色等，特别适合用于响应式设计中。\n   CSS3 基本可以说是从 SVG 发展而来的，功能应该还不如 SVG，但是其足够简单，所以选择优先级是比较高的。\n   SVG 适合需要响应用户行为，比如 mousemove 等操作的图片，作为矢量图，适合用于响应式设计中。  \n   Canvas 适合显示动态生成的图表，不需要响应用户行为。\n\n1. ####讨论 CSS hacks，条件引用或者其他。\n\n1. ####解释 BFC（block formatting context，块状布局上下文）\n   把一组块级 box 和浮动元素放在一起布局的区域。  \n   特点：（1）不折叠边距（margin collapsing），在同一个 BFC 是折叠边距的其中一个必要条件。（2）浮动元素不会超出它的范围。（3）不会跟其他浮动元素重叠。  \n   形成新的 BFC 的条件：（1）float 属性不为 none（2）overflow 属性不为 visible（3）display 属性是 table-cell、table-caption 或 inline-block（4）position 属性不为 static 或 relative。\n   IE6/7 没有 BFC 概念，但是它们有 hasLayout 与之相似，可以通过 zoom: 1 触发。\n","slug":"HTML-CSS-Interview-Questions","published":1,"date":"2013-05-12T16:00:00.000Z","updated":"2018-12-07T03:03:13.670Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm99000aw8wkgz39do6o","content":"<ol>\n<li><p>####请解释一下什么是语义化的 HTML。<br>使用拥有语义的标签，比如 h1-h6, article, section, aside, header, footer, nav, address, strong, em 等标签，而不是不分清空皂白地统一使用 div 或者 p 标签。<br>好处：（1）方便开发人员交流。统一的标签语义，不需要使用 class 表明用意。也阻止了不同的人使用不同的单词表达同样的含义。<br>（2）对搜索引擎友好。<br>（3）样式加载失败时，浏览器默认样式也使得页面比较清晰。<br>（4）对 CSS 支持不好甚至不支持的浏览器友好。</p>\n</li>\n<li><p>####你能描述一下渐进增强和优雅降级之间的不同吗?<br>构建站点的两个方法，都用到了特性检测。<br>渐进增强：Progressive enhancement。先构建站点的最少特性，然后根据浏览器特性追加功能。<br>优雅降级：graceful degradation。先构建站点的完整版本，然后根据浏览器特性进行修复。</p>\n</li>\n<li><p>####为什么利用多个域名来存储网站资源会更有效？<br>浏览器对同一个域的并行连接数是有限制的，当前一般浏览器 4 到 8 个，而 IE6，7 只有 2 个，如果同时下载同一个域下的很多资源，就会因为此限制而导致资源下载串行。但是使用多个域虽然可以并行下载资源，但是会使得浏览器需要解析更多的域名。所以在这对优缺点之间取一个平衡点。另外，解决此问题的办法并非只有启用多个域这一种方法，还可以合并和压缩 JS 和 CSS，使用雪碧图等等。</p>\n</li>\n<li><p>####请说出三种减低页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）<br>文件的合并以及压缩（减少了 HTTP 请求的数量）<br>使用 CSS Sprites（减少 HTTP 请求的数量）<br>使用 CDN 托管（减少了数据传输时间）<br>使用 CSS3，SVG，甚至 Canvas 替代图片。<br>有效地适度地使用缓存脚本和其他资源</p>\n</li>\n<li><p>####什么是 FOUC？你如何来避免 FOUC？<br>FOUC 全称是 Flash Of Unstyled Content，翻译为文档样式闪烁。一般指 IE 在加载网页的时候，出现短暂的 CSS 样式失效。<br>问题一：什么时候出现呢？（1）IE 浏览器（2）IE 的临时文件夹没有缓存过页面的 css 文件（3）页面 head 标签里面没有任何 link 和 script 标签（4）页面引用样式的方式是采用@import（5）外在因素（比如网速等）<br>问题二：咋解决？在 head 里面加入一个 link 或者 script 标签<br>吐槽：我可能一辈子也不会写出这种代码，也希望面试官不要因为这种题目来拒绝候选人。</p>\n</li>\n<li><p>####描述 css reset 的作用和用途。<br>浏览器都会有默认样式表，这样保证了页面中即便不写任何样式，浏览器仍然能够清晰地展示出页面内容，并突出重点。</p>\n</li>\n<li><p>####描述下 float 和它的工作原理。<br>float 最初应用于图文混排，让文字环绕图片。<br>语法为 float: left/right/none;<br>float box 脱离当前文档流，定位到父元素或者另一个 float box 的边缘。父元素水平方向空间不足时，向下移动知道可以放下。文档流中 inline box 环绕 float box，block box 会和 float box 重叠，除非使用 clear: both/left/right 来清除浮动。float box 会形成一个新的 block formatting context（BFC 块状格式化上下文）。float box 不会超出所在 BFC，也不会和其他 BFC 重叠。</p>\n</li>\n<li><p>####清除浮动的方法有那些，分别适用于什么情形。<br>clear: both/left/right<br>用于清除相应元素之前的兄弟节点浮动的影响。left 和 right 指浮动方向，both 包含 left 和 right 两个方向。</p>\n</li>\n<li><p>####解释 css sprites，如何使用。<br>将数张小的背景图片拼合成一张大的图片，然后在 CSS 中结合 background-image，background-position，width 和 height 等属性显示某张小的背景图片。<br>网上有不少小工具可以让你上传一些小图片，然后生成一个大图并生成相应的样式表。即可直接使用。<br>优点：减少了图片的请求数量。<br>缺点：（1）不适合需要 repeat 的背景图片。（2）需要额外的工作来拼合成大图。（3）CSS 和图片缓存失效的概率和影响更大。</p>\n</li>\n<li><p>####你最喜欢的图片替换方法是什么，你如何选择使用。<br>Web-Font, CSS3, SVG, Canvas<br>关于如何选择，首先查看所要兼容的浏览器是否兼容其特性。在三者均支持的很好的情况下，选择优先级从高到低分别是 Web-Font, CSS3, SVG, Canvas<br>Web-Font 适合单色图片，并且可以通过 font 属性来设置其大小，颜色等，特别适合用于响应式设计中。<br>CSS3 基本可以说是从 SVG 发展而来的，功能应该还不如 SVG，但是其足够简单，所以选择优先级是比较高的。<br>SVG 适合需要响应用户行为，比如 mousemove 等操作的图片，作为矢量图，适合用于响应式设计中。<br>Canvas 适合显示动态生成的图表，不需要响应用户行为。</p>\n</li>\n<li><p>####讨论 CSS hacks，条件引用或者其他。</p>\n</li>\n<li><p>####解释 BFC（block formatting context，块状布局上下文）<br>把一组块级 box 和浮动元素放在一起布局的区域。<br>特点：（1）不折叠边距（margin collapsing），在同一个 BFC 是折叠边距的其中一个必要条件。（2）浮动元素不会超出它的范围。（3）不会跟其他浮动元素重叠。<br>形成新的 BFC 的条件：（1）float 属性不为 none（2）overflow 属性不为 visible（3）display 属性是 table-cell、table-caption 或 inline-block（4）position 属性不为 static 或 relative。<br>IE6/7 没有 BFC 概念，但是它们有 hasLayout 与之相似，可以通过 zoom: 1 触发。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>####请解释一下什么是语义化的 HTML。<br>使用拥有语义的标签，比如 h1-h6, article, section, aside, header, footer, nav, address, strong, em 等标签，而不是不分清空皂白地统一使用 div 或者 p 标签。<br>好处：（1）方便开发人员交流。统一的标签语义，不需要使用 class 表明用意。也阻止了不同的人使用不同的单词表达同样的含义。<br>（2）对搜索引擎友好。<br>（3）样式加载失败时，浏览器默认样式也使得页面比较清晰。<br>（4）对 CSS 支持不好甚至不支持的浏览器友好。</p>\n</li>\n<li><p>####你能描述一下渐进增强和优雅降级之间的不同吗?<br>构建站点的两个方法，都用到了特性检测。<br>渐进增强：Progressive enhancement。先构建站点的最少特性，然后根据浏览器特性追加功能。<br>优雅降级：graceful degradation。先构建站点的完整版本，然后根据浏览器特性进行修复。</p>\n</li>\n<li><p>####为什么利用多个域名来存储网站资源会更有效？<br>浏览器对同一个域的并行连接数是有限制的，当前一般浏览器 4 到 8 个，而 IE6，7 只有 2 个，如果同时下载同一个域下的很多资源，就会因为此限制而导致资源下载串行。但是使用多个域虽然可以并行下载资源，但是会使得浏览器需要解析更多的域名。所以在这对优缺点之间取一个平衡点。另外，解决此问题的办法并非只有启用多个域这一种方法，还可以合并和压缩 JS 和 CSS，使用雪碧图等等。</p>\n</li>\n<li><p>####请说出三种减低页面加载时间的方法。（加载时间指感知的时间或者实际加载时间）<br>文件的合并以及压缩（减少了 HTTP 请求的数量）<br>使用 CSS Sprites（减少 HTTP 请求的数量）<br>使用 CDN 托管（减少了数据传输时间）<br>使用 CSS3，SVG，甚至 Canvas 替代图片。<br>有效地适度地使用缓存脚本和其他资源</p>\n</li>\n<li><p>####什么是 FOUC？你如何来避免 FOUC？<br>FOUC 全称是 Flash Of Unstyled Content，翻译为文档样式闪烁。一般指 IE 在加载网页的时候，出现短暂的 CSS 样式失效。<br>问题一：什么时候出现呢？（1）IE 浏览器（2）IE 的临时文件夹没有缓存过页面的 css 文件（3）页面 head 标签里面没有任何 link 和 script 标签（4）页面引用样式的方式是采用@import（5）外在因素（比如网速等）<br>问题二：咋解决？在 head 里面加入一个 link 或者 script 标签<br>吐槽：我可能一辈子也不会写出这种代码，也希望面试官不要因为这种题目来拒绝候选人。</p>\n</li>\n<li><p>####描述 css reset 的作用和用途。<br>浏览器都会有默认样式表，这样保证了页面中即便不写任何样式，浏览器仍然能够清晰地展示出页面内容，并突出重点。</p>\n</li>\n<li><p>####描述下 float 和它的工作原理。<br>float 最初应用于图文混排，让文字环绕图片。<br>语法为 float: left/right/none;<br>float box 脱离当前文档流，定位到父元素或者另一个 float box 的边缘。父元素水平方向空间不足时，向下移动知道可以放下。文档流中 inline box 环绕 float box，block box 会和 float box 重叠，除非使用 clear: both/left/right 来清除浮动。float box 会形成一个新的 block formatting context（BFC 块状格式化上下文）。float box 不会超出所在 BFC，也不会和其他 BFC 重叠。</p>\n</li>\n<li><p>####清除浮动的方法有那些，分别适用于什么情形。<br>clear: both/left/right<br>用于清除相应元素之前的兄弟节点浮动的影响。left 和 right 指浮动方向，both 包含 left 和 right 两个方向。</p>\n</li>\n<li><p>####解释 css sprites，如何使用。<br>将数张小的背景图片拼合成一张大的图片，然后在 CSS 中结合 background-image，background-position，width 和 height 等属性显示某张小的背景图片。<br>网上有不少小工具可以让你上传一些小图片，然后生成一个大图并生成相应的样式表。即可直接使用。<br>优点：减少了图片的请求数量。<br>缺点：（1）不适合需要 repeat 的背景图片。（2）需要额外的工作来拼合成大图。（3）CSS 和图片缓存失效的概率和影响更大。</p>\n</li>\n<li><p>####你最喜欢的图片替换方法是什么，你如何选择使用。<br>Web-Font, CSS3, SVG, Canvas<br>关于如何选择，首先查看所要兼容的浏览器是否兼容其特性。在三者均支持的很好的情况下，选择优先级从高到低分别是 Web-Font, CSS3, SVG, Canvas<br>Web-Font 适合单色图片，并且可以通过 font 属性来设置其大小，颜色等，特别适合用于响应式设计中。<br>CSS3 基本可以说是从 SVG 发展而来的，功能应该还不如 SVG，但是其足够简单，所以选择优先级是比较高的。<br>SVG 适合需要响应用户行为，比如 mousemove 等操作的图片，作为矢量图，适合用于响应式设计中。<br>Canvas 适合显示动态生成的图表，不需要响应用户行为。</p>\n</li>\n<li><p>####讨论 CSS hacks，条件引用或者其他。</p>\n</li>\n<li><p>####解释 BFC（block formatting context，块状布局上下文）<br>把一组块级 box 和浮动元素放在一起布局的区域。<br>特点：（1）不折叠边距（margin collapsing），在同一个 BFC 是折叠边距的其中一个必要条件。（2）浮动元素不会超出它的范围。（3）不会跟其他浮动元素重叠。<br>形成新的 BFC 的条件：（1）float 属性不为 none（2）overflow 属性不为 visible（3）display 属性是 table-cell、table-caption 或 inline-block（4）position 属性不为 static 或 relative。<br>IE6/7 没有 BFC 概念，但是它们有 hasLayout 与之相似，可以通过 zoom: 1 触发。</p>\n</li>\n</ol>\n"},{"_content":"1. ####解释什么是 Deferred，以及优点是什么。\n   Deferred，意为延迟执行，是 jQuery 的回调函数解决方案，对所有的异步操作提供统一和更加方便的编程接口。使用 Deferred 实现的\\$.ajax 有以下几种有点。（1）链式调用（2）指定多个回调（3）为多个操作指定回调\n\n```javascript\n$.ajax('test.html')\n  .done(function(){console.log('Done.')})\n  .fail(function(){console.log('Fail.')})\n  .done(function(){console.log('OK.'));\n$.when($.ajax('test1.html'), $.ajax('test2.html'))\n  .done(function(){console.log('Done.')})\n  .fail(function(){console.log('Fail.')});\n```\n\n1. ####你如何给一个事件处理函数命名空间，为什么要这样做？\n\n```javascript\n// 主要用于jQuery插件，当需要取消某插件的效果时，可以通过unbind('.namespace')一次性删除该插件绑定的所有事件，而不会影响到其他插件或者用户手动绑定的事件。\nvar $btn = $('XXX');\n// 比如我们写了一个实现拖拽的插件，该插件监听了mousedown，mousemove和mouseup事件。\n$btn.bind('mousedown.dragdrop', function() {});\n$btn.bind('mousemove.dragdrop', function() {});\n$btn.bind('mouseup.dragdrop', function() {});\n// 当某个节点不支持拖拽时，取消拖拽相关的事件监听，就可以使用如下方法，一次性删除。\n$btn.unbind('.dragdrop');\n```\n\n1. ####请指出'$'和'$.fn'的区别？或者说出'\\$.fn'的用途。\n\n1. ####解释 chaining。\n\n```javascript\n// 链式调用，如果对象的方法不需要一个明确意义的返回值，那么可以返回自身。\n$('XXX')\n    .css('width', '100px')\n    .show()\n    .click(function() {});\n```\n\n1. ####你知道那些针对 jQuery 的优化方法。\n   （1）将一个 jQuery 对象保存起来，如果多次使用的话。\n\n1. jQuery 中 prop 和 attr 方法的异同？\n","source":"_posts/2013-05-17-jQuery-Interview-Questions.md","raw":"1. ####解释什么是 Deferred，以及优点是什么。\n   Deferred，意为延迟执行，是 jQuery 的回调函数解决方案，对所有的异步操作提供统一和更加方便的编程接口。使用 Deferred 实现的\\$.ajax 有以下几种有点。（1）链式调用（2）指定多个回调（3）为多个操作指定回调\n\n```javascript\n$.ajax('test.html')\n  .done(function(){console.log('Done.')})\n  .fail(function(){console.log('Fail.')})\n  .done(function(){console.log('OK.'));\n$.when($.ajax('test1.html'), $.ajax('test2.html'))\n  .done(function(){console.log('Done.')})\n  .fail(function(){console.log('Fail.')});\n```\n\n1. ####你如何给一个事件处理函数命名空间，为什么要这样做？\n\n```javascript\n// 主要用于jQuery插件，当需要取消某插件的效果时，可以通过unbind('.namespace')一次性删除该插件绑定的所有事件，而不会影响到其他插件或者用户手动绑定的事件。\nvar $btn = $('XXX');\n// 比如我们写了一个实现拖拽的插件，该插件监听了mousedown，mousemove和mouseup事件。\n$btn.bind('mousedown.dragdrop', function() {});\n$btn.bind('mousemove.dragdrop', function() {});\n$btn.bind('mouseup.dragdrop', function() {});\n// 当某个节点不支持拖拽时，取消拖拽相关的事件监听，就可以使用如下方法，一次性删除。\n$btn.unbind('.dragdrop');\n```\n\n1. ####请指出'$'和'$.fn'的区别？或者说出'\\$.fn'的用途。\n\n1. ####解释 chaining。\n\n```javascript\n// 链式调用，如果对象的方法不需要一个明确意义的返回值，那么可以返回自身。\n$('XXX')\n    .css('width', '100px')\n    .show()\n    .click(function() {});\n```\n\n1. ####你知道那些针对 jQuery 的优化方法。\n   （1）将一个 jQuery 对象保存起来，如果多次使用的话。\n\n1. jQuery 中 prop 和 attr 方法的异同？\n","slug":"jQuery-Interview-Questions","published":1,"date":"2013-05-16T16:00:00.000Z","updated":"2018-12-07T03:03:03.754Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9c000bw8wkltbtsbpt","content":"<ol>\n<li>####解释什么是 Deferred，以及优点是什么。<br>Deferred，意为延迟执行，是 jQuery 的回调函数解决方案，对所有的异步操作提供统一和更加方便的编程接口。使用 Deferred 实现的\\$.ajax 有以下几种有点。（1）链式调用（2）指定多个回调（3）为多个操作指定回调</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.ajax(<span class=\"string\">'test.html'</span>)</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Done.'</span>)&#125;)</span><br><span class=\"line\">  .fail(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Fail.'</span>)&#125;)</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'OK.'</span>));</span><br><span class=\"line\">$.when($.ajax(<span class=\"string\">'test1.html'</span>), $.ajax(<span class=\"string\">'test2.html'</span>))</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Done.'</span>)&#125;)</span><br><span class=\"line\">  .fail(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Fail.'</span>)&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>####你如何给一个事件处理函数命名空间，为什么要这样做？</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主要用于jQuery插件，当需要取消某插件的效果时，可以通过unbind('.namespace')一次性删除该插件绑定的所有事件，而不会影响到其他插件或者用户手动绑定的事件。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> $btn = $(<span class=\"string\">'XXX'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 比如我们写了一个实现拖拽的插件，该插件监听了mousedown，mousemove和mouseup事件。</span></span><br><span class=\"line\">$btn.bind(<span class=\"string\">'mousedown.dragdrop'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\">$btn.bind(<span class=\"string\">'mousemove.dragdrop'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\">$btn.bind(<span class=\"string\">'mouseup.dragdrop'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 当某个节点不支持拖拽时，取消拖拽相关的事件监听，就可以使用如下方法，一次性删除。</span></span><br><span class=\"line\">$btn.unbind(<span class=\"string\">'.dragdrop'</span>);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####请指出’$’和’$.fn’的区别？或者说出’\\$.fn’的用途。</p>\n</li>\n<li><p>####解释 chaining。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 链式调用，如果对象的方法不需要一个明确意义的返回值，那么可以返回自身。</span></span><br><span class=\"line\">$(<span class=\"string\">'XXX'</span>)</span><br><span class=\"line\">    .css(<span class=\"string\">'width'</span>, <span class=\"string\">'100px'</span>)</span><br><span class=\"line\">    .show()</span><br><span class=\"line\">    .click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####你知道那些针对 jQuery 的优化方法。<br>（1）将一个 jQuery 对象保存起来，如果多次使用的话。</p>\n</li>\n<li><p>jQuery 中 prop 和 attr 方法的异同？</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>####解释什么是 Deferred，以及优点是什么。<br>Deferred，意为延迟执行，是 jQuery 的回调函数解决方案，对所有的异步操作提供统一和更加方便的编程接口。使用 Deferred 实现的\\$.ajax 有以下几种有点。（1）链式调用（2）指定多个回调（3）为多个操作指定回调</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.ajax(<span class=\"string\">'test.html'</span>)</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Done.'</span>)&#125;)</span><br><span class=\"line\">  .fail(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Fail.'</span>)&#125;)</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'OK.'</span>));</span><br><span class=\"line\">$.when($.ajax(<span class=\"string\">'test1.html'</span>), $.ajax(<span class=\"string\">'test2.html'</span>))</span><br><span class=\"line\">  .done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Done.'</span>)&#125;)</span><br><span class=\"line\">  .fail(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Fail.'</span>)&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li>####你如何给一个事件处理函数命名空间，为什么要这样做？</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主要用于jQuery插件，当需要取消某插件的效果时，可以通过unbind('.namespace')一次性删除该插件绑定的所有事件，而不会影响到其他插件或者用户手动绑定的事件。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> $btn = $(<span class=\"string\">'XXX'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 比如我们写了一个实现拖拽的插件，该插件监听了mousedown，mousemove和mouseup事件。</span></span><br><span class=\"line\">$btn.bind(<span class=\"string\">'mousedown.dragdrop'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\">$btn.bind(<span class=\"string\">'mousemove.dragdrop'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\">$btn.bind(<span class=\"string\">'mouseup.dragdrop'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 当某个节点不支持拖拽时，取消拖拽相关的事件监听，就可以使用如下方法，一次性删除。</span></span><br><span class=\"line\">$btn.unbind(<span class=\"string\">'.dragdrop'</span>);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####请指出’$’和’$.fn’的区别？或者说出’\\$.fn’的用途。</p>\n</li>\n<li><p>####解释 chaining。</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 链式调用，如果对象的方法不需要一个明确意义的返回值，那么可以返回自身。</span></span><br><span class=\"line\">$(<span class=\"string\">'XXX'</span>)</span><br><span class=\"line\">    .css(<span class=\"string\">'width'</span>, <span class=\"string\">'100px'</span>)</span><br><span class=\"line\">    .show()</span><br><span class=\"line\">    .click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>####你知道那些针对 jQuery 的优化方法。<br>（1）将一个 jQuery 对象保存起来，如果多次使用的话。</p>\n</li>\n<li><p>jQuery 中 prop 和 attr 方法的异同？</p>\n</li>\n</ol>\n"},{"title":"【翻译】使用SVG","_content":"\n[原文地址：css-tricks.com](http://css-tricks.com/using-svg/)\n\nSVG 是一种矢量图片格式。字面意为可伸缩矢量图形（Scalable Vector Graphics）。也就是你通过 Adobe Illustrator 做出来的东西。在网页中可以很简单地使用 SVG，但是有些东西是你应该了解的。\n\n### 为什么要使用 SVG？\n\n1. 压缩量好，文件小\n2. 高保真伸缩到任意尺寸（除了尺寸很小的情况下会失真）\n3. 适合视网膜屏（retina）显示\n4. Design control like interactivity and filters\n\n###Getting some SVG to work with\n下图是在 Adobe Illustrator 中设计的一只鹬鸵站在一个椭圆上。\n![kiwi.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/kiwi.png)\nNotice the artboard is cropped up right agains the edges of the design. Canvas matters in SVG just like it would in PNG or JPG.\n\n在 Adobe Illusatrator 可以将图形直接保存为 SVG 文件。  \n![save-as-svg.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/save-as-svg.png)\n保存时，你会看到另一个关于 SVG 选项的对话框。关于这个对话框，我了解的不多。这里有一个[SVG 说明书](http://www.w3.org/TR/SVGMobile/)。SVG1.1 可以正常工作。\n![svg-options.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-options.png)\n最有趣的是你可以按下 OK 保存文件，也可以按下“SVG Code...”通过 TextEdit（在 Mac 上）打开 SVG 代码。  \n![svg-code.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-code.png)\n\n### 当做 img 使用 SVG\n\n如果刚才我将 SVG 保存到一个文件中，那么我现在可以将它用在一个 img 标签中。\n\n```html\n<img src=\"kiwi.svg\" alt=\"Kiwi standing on oval\" />\n```\n\n在 Illustrator 中，绘图板大小是 612x502px。\n![artboard.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/artboard.png)\n以下是该图片在网页中显示尺寸。你可以选择 img 节点并修改其 width 或者 height 来改变其大小，就跟 PNG 或 JPG 图片一样。[这儿](http://codepen.io/chriscoyier/pen/evcBu)有一个例子。  \n![kiwi.svg](http://s.cdpn.io/3/kiwi.svg)\n\n### 浏览器支持情况\n\n这样使用 SVG 要注意[它的浏览器支持情况](http://caniuse.com/#feat=svg-img)总体来讲，除了 IE8 及以下，Android2.3 及以下都支持的很好。\n\n如果你想使用 SVG，但是又要支持这些不支持 SVG 的浏览器，你有一些选择，在[包含](http://css-tricks.com/workshop-notes-webstock-13/)了一些我使用过的一些技术。\n\n一个方法是通过 Modernizr 测试是否支持冰替换 img 的 src 属性。\n\n```js\nif (!Modernizr.svg) {\n    $('.logo img').attr('src', 'images/logo.png');\n}\n```\n\nDavid Bushell 提出了一个[更简单的方法](http://dbushell.com/2013/02/04/a-primer-to-front-end-svg-hacking/)。如果可以在标签中使用 javascript。\n\n```html\n<img src=\"image.svg\" onerror=\"this.onerror=null; this.src='image.png'\" />\n```\n\n[SVGeezy](http://benhowdle.im/svgeezy/)也很有用，在以下文章中我们会讲到更多的 fallback 技术。\n\n### 作为 background-image 使用 SVG\n\n跟将 SVG 作为 img 使用一样简单，也可以将它作为 backgorund-image。\n\n```html\n<a href=\"/\" class=\"logo\"> Kiwi Corp </a>\n```\n\n```css\n.logo {\n    display: block;\n    text-indent: -9999px;\n    width: 100px;\n    height: 82px;\n    background: url(kiwi.svg);\n    background-size: 100px 82px;\n}\n```\n\n[未完]\n","source":"_posts/2013-05-18-Using SVG.md","raw":"---\ntitle: 【翻译】使用SVG\n---\n\n[原文地址：css-tricks.com](http://css-tricks.com/using-svg/)\n\nSVG 是一种矢量图片格式。字面意为可伸缩矢量图形（Scalable Vector Graphics）。也就是你通过 Adobe Illustrator 做出来的东西。在网页中可以很简单地使用 SVG，但是有些东西是你应该了解的。\n\n### 为什么要使用 SVG？\n\n1. 压缩量好，文件小\n2. 高保真伸缩到任意尺寸（除了尺寸很小的情况下会失真）\n3. 适合视网膜屏（retina）显示\n4. Design control like interactivity and filters\n\n###Getting some SVG to work with\n下图是在 Adobe Illustrator 中设计的一只鹬鸵站在一个椭圆上。\n![kiwi.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/kiwi.png)\nNotice the artboard is cropped up right agains the edges of the design. Canvas matters in SVG just like it would in PNG or JPG.\n\n在 Adobe Illusatrator 可以将图形直接保存为 SVG 文件。  \n![save-as-svg.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/save-as-svg.png)\n保存时，你会看到另一个关于 SVG 选项的对话框。关于这个对话框，我了解的不多。这里有一个[SVG 说明书](http://www.w3.org/TR/SVGMobile/)。SVG1.1 可以正常工作。\n![svg-options.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-options.png)\n最有趣的是你可以按下 OK 保存文件，也可以按下“SVG Code...”通过 TextEdit（在 Mac 上）打开 SVG 代码。  \n![svg-code.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-code.png)\n\n### 当做 img 使用 SVG\n\n如果刚才我将 SVG 保存到一个文件中，那么我现在可以将它用在一个 img 标签中。\n\n```html\n<img src=\"kiwi.svg\" alt=\"Kiwi standing on oval\" />\n```\n\n在 Illustrator 中，绘图板大小是 612x502px。\n![artboard.png](http://cdn.css-tricks.com/wp-content/uploads/2013/03/artboard.png)\n以下是该图片在网页中显示尺寸。你可以选择 img 节点并修改其 width 或者 height 来改变其大小，就跟 PNG 或 JPG 图片一样。[这儿](http://codepen.io/chriscoyier/pen/evcBu)有一个例子。  \n![kiwi.svg](http://s.cdpn.io/3/kiwi.svg)\n\n### 浏览器支持情况\n\n这样使用 SVG 要注意[它的浏览器支持情况](http://caniuse.com/#feat=svg-img)总体来讲，除了 IE8 及以下，Android2.3 及以下都支持的很好。\n\n如果你想使用 SVG，但是又要支持这些不支持 SVG 的浏览器，你有一些选择，在[包含](http://css-tricks.com/workshop-notes-webstock-13/)了一些我使用过的一些技术。\n\n一个方法是通过 Modernizr 测试是否支持冰替换 img 的 src 属性。\n\n```js\nif (!Modernizr.svg) {\n    $('.logo img').attr('src', 'images/logo.png');\n}\n```\n\nDavid Bushell 提出了一个[更简单的方法](http://dbushell.com/2013/02/04/a-primer-to-front-end-svg-hacking/)。如果可以在标签中使用 javascript。\n\n```html\n<img src=\"image.svg\" onerror=\"this.onerror=null; this.src='image.png'\" />\n```\n\n[SVGeezy](http://benhowdle.im/svgeezy/)也很有用，在以下文章中我们会讲到更多的 fallback 技术。\n\n### 作为 background-image 使用 SVG\n\n跟将 SVG 作为 img 使用一样简单，也可以将它作为 backgorund-image。\n\n```html\n<a href=\"/\" class=\"logo\"> Kiwi Corp </a>\n```\n\n```css\n.logo {\n    display: block;\n    text-indent: -9999px;\n    width: 100px;\n    height: 82px;\n    background: url(kiwi.svg);\n    background-size: 100px 82px;\n}\n```\n\n[未完]\n","slug":"Using SVG","published":1,"date":"2013-05-17T16:00:00.000Z","updated":"2018-12-07T03:02:58.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9e000cw8wkndis437n","content":"<p><a href=\"http://css-tricks.com/using-svg/\" target=\"_blank\" rel=\"noopener\">原文地址：css-tricks.com</a></p>\n<p>SVG 是一种矢量图片格式。字面意为可伸缩矢量图形（Scalable Vector Graphics）。也就是你通过 Adobe Illustrator 做出来的东西。在网页中可以很简单地使用 SVG，但是有些东西是你应该了解的。</p>\n<h3 id=\"为什么要使用-SVG？\"><a href=\"#为什么要使用-SVG？\" class=\"headerlink\" title=\"为什么要使用 SVG？\"></a>为什么要使用 SVG？</h3><ol>\n<li>压缩量好，文件小</li>\n<li>高保真伸缩到任意尺寸（除了尺寸很小的情况下会失真）</li>\n<li>适合视网膜屏（retina）显示</li>\n<li>Design control like interactivity and filters</li>\n</ol>\n<p>###Getting some SVG to work with<br>下图是在 Adobe Illustrator 中设计的一只鹬鸵站在一个椭圆上。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/kiwi.png\" alt=\"kiwi.png\"><br>Notice the artboard is cropped up right agains the edges of the design. Canvas matters in SVG just like it would in PNG or JPG.</p>\n<p>在 Adobe Illusatrator 可以将图形直接保存为 SVG 文件。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/save-as-svg.png\" alt=\"save-as-svg.png\"><br>保存时，你会看到另一个关于 SVG 选项的对话框。关于这个对话框，我了解的不多。这里有一个<a href=\"http://www.w3.org/TR/SVGMobile/\" target=\"_blank\" rel=\"noopener\">SVG 说明书</a>。SVG1.1 可以正常工作。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-options.png\" alt=\"svg-options.png\"><br>最有趣的是你可以按下 OK 保存文件，也可以按下“SVG Code…”通过 TextEdit（在 Mac 上）打开 SVG 代码。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-code.png\" alt=\"svg-code.png\"></p>\n<h3 id=\"当做-img-使用-SVG\"><a href=\"#当做-img-使用-SVG\" class=\"headerlink\" title=\"当做 img 使用 SVG\"></a>当做 img 使用 SVG</h3><p>如果刚才我将 SVG 保存到一个文件中，那么我现在可以将它用在一个 img 标签中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"kiwi.svg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Kiwi standing on oval\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在 Illustrator 中，绘图板大小是 612x502px。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/artboard.png\" alt=\"artboard.png\"><br>以下是该图片在网页中显示尺寸。你可以选择 img 节点并修改其 width 或者 height 来改变其大小，就跟 PNG 或 JPG 图片一样。<a href=\"http://codepen.io/chriscoyier/pen/evcBu\" target=\"_blank\" rel=\"noopener\">这儿</a>有一个例子。<br><img src=\"http://s.cdpn.io/3/kiwi.svg\" alt=\"kiwi.svg\"></p>\n<h3 id=\"浏览器支持情况\"><a href=\"#浏览器支持情况\" class=\"headerlink\" title=\"浏览器支持情况\"></a>浏览器支持情况</h3><p>这样使用 SVG 要注意<a href=\"http://caniuse.com/#feat=svg-img\" target=\"_blank\" rel=\"noopener\">它的浏览器支持情况</a>总体来讲，除了 IE8 及以下，Android2.3 及以下都支持的很好。</p>\n<p>如果你想使用 SVG，但是又要支持这些不支持 SVG 的浏览器，你有一些选择，在<a href=\"http://css-tricks.com/workshop-notes-webstock-13/\" target=\"_blank\" rel=\"noopener\">包含</a>了一些我使用过的一些技术。</p>\n<p>一个方法是通过 Modernizr 测试是否支持冰替换 img 的 src 属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!Modernizr.svg) &#123;</span><br><span class=\"line\">    $(<span class=\"string\">'.logo img'</span>).attr(<span class=\"string\">'src'</span>, <span class=\"string\">'images/logo.png'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>David Bushell 提出了一个<a href=\"http://dbushell.com/2013/02/04/a-primer-to-front-end-svg-hacking/\" target=\"_blank\" rel=\"noopener\">更简单的方法</a>。如果可以在标签中使用 javascript。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"image.svg\"</span> <span class=\"attr\">onerror</span>=<span class=\"string\">\"this.onerror=null; this.src='image.png'\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"http://benhowdle.im/svgeezy/\" target=\"_blank\" rel=\"noopener\">SVGeezy</a>也很有用，在以下文章中我们会讲到更多的 fallback 技术。</p>\n<h3 id=\"作为-background-image-使用-SVG\"><a href=\"#作为-background-image-使用-SVG\" class=\"headerlink\" title=\"作为 background-image 使用 SVG\"></a>作为 background-image 使用 SVG</h3><p>跟将 SVG 作为 img 使用一样简单，也可以将它作为 backgorund-image。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"logo\"</span>&gt;</span> Kiwi Corp <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.logo</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">text-indent</span>: -<span class=\"number\">9999px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">82px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(kiwi.svg);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100px</span> <span class=\"number\">82px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>[未完]</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://css-tricks.com/using-svg/\" target=\"_blank\" rel=\"noopener\">原文地址：css-tricks.com</a></p>\n<p>SVG 是一种矢量图片格式。字面意为可伸缩矢量图形（Scalable Vector Graphics）。也就是你通过 Adobe Illustrator 做出来的东西。在网页中可以很简单地使用 SVG，但是有些东西是你应该了解的。</p>\n<h3 id=\"为什么要使用-SVG？\"><a href=\"#为什么要使用-SVG？\" class=\"headerlink\" title=\"为什么要使用 SVG？\"></a>为什么要使用 SVG？</h3><ol>\n<li>压缩量好，文件小</li>\n<li>高保真伸缩到任意尺寸（除了尺寸很小的情况下会失真）</li>\n<li>适合视网膜屏（retina）显示</li>\n<li>Design control like interactivity and filters</li>\n</ol>\n<p>###Getting some SVG to work with<br>下图是在 Adobe Illustrator 中设计的一只鹬鸵站在一个椭圆上。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/kiwi.png\" alt=\"kiwi.png\"><br>Notice the artboard is cropped up right agains the edges of the design. Canvas matters in SVG just like it would in PNG or JPG.</p>\n<p>在 Adobe Illusatrator 可以将图形直接保存为 SVG 文件。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/save-as-svg.png\" alt=\"save-as-svg.png\"><br>保存时，你会看到另一个关于 SVG 选项的对话框。关于这个对话框，我了解的不多。这里有一个<a href=\"http://www.w3.org/TR/SVGMobile/\" target=\"_blank\" rel=\"noopener\">SVG 说明书</a>。SVG1.1 可以正常工作。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-options.png\" alt=\"svg-options.png\"><br>最有趣的是你可以按下 OK 保存文件，也可以按下“SVG Code…”通过 TextEdit（在 Mac 上）打开 SVG 代码。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/svg-code.png\" alt=\"svg-code.png\"></p>\n<h3 id=\"当做-img-使用-SVG\"><a href=\"#当做-img-使用-SVG\" class=\"headerlink\" title=\"当做 img 使用 SVG\"></a>当做 img 使用 SVG</h3><p>如果刚才我将 SVG 保存到一个文件中，那么我现在可以将它用在一个 img 标签中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"kiwi.svg\"</span> <span class=\"attr\">alt</span>=<span class=\"string\">\"Kiwi standing on oval\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在 Illustrator 中，绘图板大小是 612x502px。<br><img src=\"http://cdn.css-tricks.com/wp-content/uploads/2013/03/artboard.png\" alt=\"artboard.png\"><br>以下是该图片在网页中显示尺寸。你可以选择 img 节点并修改其 width 或者 height 来改变其大小，就跟 PNG 或 JPG 图片一样。<a href=\"http://codepen.io/chriscoyier/pen/evcBu\" target=\"_blank\" rel=\"noopener\">这儿</a>有一个例子。<br><img src=\"http://s.cdpn.io/3/kiwi.svg\" alt=\"kiwi.svg\"></p>\n<h3 id=\"浏览器支持情况\"><a href=\"#浏览器支持情况\" class=\"headerlink\" title=\"浏览器支持情况\"></a>浏览器支持情况</h3><p>这样使用 SVG 要注意<a href=\"http://caniuse.com/#feat=svg-img\" target=\"_blank\" rel=\"noopener\">它的浏览器支持情况</a>总体来讲，除了 IE8 及以下，Android2.3 及以下都支持的很好。</p>\n<p>如果你想使用 SVG，但是又要支持这些不支持 SVG 的浏览器，你有一些选择，在<a href=\"http://css-tricks.com/workshop-notes-webstock-13/\" target=\"_blank\" rel=\"noopener\">包含</a>了一些我使用过的一些技术。</p>\n<p>一个方法是通过 Modernizr 测试是否支持冰替换 img 的 src 属性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!Modernizr.svg) &#123;</span><br><span class=\"line\">    $(<span class=\"string\">'.logo img'</span>).attr(<span class=\"string\">'src'</span>, <span class=\"string\">'images/logo.png'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>David Bushell 提出了一个<a href=\"http://dbushell.com/2013/02/04/a-primer-to-front-end-svg-hacking/\" target=\"_blank\" rel=\"noopener\">更简单的方法</a>。如果可以在标签中使用 javascript。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"image.svg\"</span> <span class=\"attr\">onerror</span>=<span class=\"string\">\"this.onerror=null; this.src='image.png'\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"http://benhowdle.im/svgeezy/\" target=\"_blank\" rel=\"noopener\">SVGeezy</a>也很有用，在以下文章中我们会讲到更多的 fallback 技术。</p>\n<h3 id=\"作为-background-image-使用-SVG\"><a href=\"#作为-background-image-使用-SVG\" class=\"headerlink\" title=\"作为 background-image 使用 SVG\"></a>作为 background-image 使用 SVG</h3><p>跟将 SVG 作为 img 使用一样简单，也可以将它作为 backgorund-image。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"logo\"</span>&gt;</span> Kiwi Corp <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.logo</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: block;</span><br><span class=\"line\">    <span class=\"attribute\">text-indent</span>: -<span class=\"number\">9999px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">82px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"built_in\">url</span>(kiwi.svg);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100px</span> <span class=\"number\">82px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>[未完]</p>\n"},{"title":"在DOM操作中，如何减少 reflow 或 repaint","_content":"\n在这篇博客中，我们列举一些可以减少 reflow 或者 repaint 的方法。下面先讲述一下这两个概念。  \n**reflow**，翻译为重排，意为重新布局。当一个元素的形状位置发生改变时，浏览器会对该元素以及子元素（也可能包括同级元素）进行布局和重绘。称之为重排。  \n**repaint**，翻译为重绘。当一个元素的颜色等发生改变时，浏览器会对该元素进行重绘。  \n为了减少重排和重绘，可以从以下几个方面着手。\n\n## 批量增删节点\n\n### 通过`elem.innerHTML`批量删除和添加子节点。\n\n### 通过`elem.insertAdjacentHTML`批量添加子节点。\n\n### 通过创建一个 fragment 来批量添加子节点。\n\n```javascript\nvar fragment = document.createDocumentFragment();\nfor (var i = 0; i < 10; i++) {\n    var div = document.createElement('div');\n    fragment.addChild(div);\n}\nelem.appendChild(fragment);\n```\n\n### 通过创建一个 range 来批量删除一组连续节点。\n\n```javascript\nfunction removeChildren(parent, start, end) {\n    var range = document.createRange();\n    var children = parent.children;\n    range.setStartBefore(children[start]);\n    range.setEndAfter(children[end]);\n    children = null;\n    range.deleteContents();\n}\n```\n\n## 批量修改节点和样式\n\n### 通过修改 class 属性代替多次修改 style 属性\n\n不好的做法：\n\n```javascript\nelem.style.width = '200px';\nelem.style.height = '200px';\n```\n\n较好的做法：\n\n```css\n.another-style {\n    width: 200px;\n    height: 200px;\n}\n```\n\n```javascript\nelem.className = 'another-style';\n```\n\n### 将节点隐藏或者删除后，批量修改，然后再显示或者添加到 DOM 树中。不管修改了多少次，只重新布局两次。\n\n### 先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。\n\n### 尽量缩小修改的影响\n\n### 让对经常变化的节点脱离文档流，比如使用 absolute 或者 fixed 的 position。这样，当该节点重排时不会影响其以后的兄弟节点。\n\n### 少使用 table 布局，很小的改动会导致整个 table 的重新布局。\n\n## 访问 DOM 节点的某些属性\n\n比如 offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop/Left/Width/Height, clientTop/Left/Width/Height, getComputedStyle()等等，参考[When does DOM access slow down rendering?](http://www.yiotabytes.com/2011/04/when-does-dom-access-slow-down.html)。文章中也提到浏览器越来越聪明，会尽量避免这些不太必要的重排重绘。我暂时还不知道怎么验证是否发生了重排重绘。\n\n留个问题，CSS3 Transition 动画能不能减少重排呢？重绘肯定是少不了的。\n","source":"_posts/2013-05-25-Reduce-reflow-repaint.md","raw":"---\ntitle: 在DOM操作中，如何减少 reflow 或 repaint\n---\n\n在这篇博客中，我们列举一些可以减少 reflow 或者 repaint 的方法。下面先讲述一下这两个概念。  \n**reflow**，翻译为重排，意为重新布局。当一个元素的形状位置发生改变时，浏览器会对该元素以及子元素（也可能包括同级元素）进行布局和重绘。称之为重排。  \n**repaint**，翻译为重绘。当一个元素的颜色等发生改变时，浏览器会对该元素进行重绘。  \n为了减少重排和重绘，可以从以下几个方面着手。\n\n## 批量增删节点\n\n### 通过`elem.innerHTML`批量删除和添加子节点。\n\n### 通过`elem.insertAdjacentHTML`批量添加子节点。\n\n### 通过创建一个 fragment 来批量添加子节点。\n\n```javascript\nvar fragment = document.createDocumentFragment();\nfor (var i = 0; i < 10; i++) {\n    var div = document.createElement('div');\n    fragment.addChild(div);\n}\nelem.appendChild(fragment);\n```\n\n### 通过创建一个 range 来批量删除一组连续节点。\n\n```javascript\nfunction removeChildren(parent, start, end) {\n    var range = document.createRange();\n    var children = parent.children;\n    range.setStartBefore(children[start]);\n    range.setEndAfter(children[end]);\n    children = null;\n    range.deleteContents();\n}\n```\n\n## 批量修改节点和样式\n\n### 通过修改 class 属性代替多次修改 style 属性\n\n不好的做法：\n\n```javascript\nelem.style.width = '200px';\nelem.style.height = '200px';\n```\n\n较好的做法：\n\n```css\n.another-style {\n    width: 200px;\n    height: 200px;\n}\n```\n\n```javascript\nelem.className = 'another-style';\n```\n\n### 将节点隐藏或者删除后，批量修改，然后再显示或者添加到 DOM 树中。不管修改了多少次，只重新布局两次。\n\n### 先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。\n\n### 尽量缩小修改的影响\n\n### 让对经常变化的节点脱离文档流，比如使用 absolute 或者 fixed 的 position。这样，当该节点重排时不会影响其以后的兄弟节点。\n\n### 少使用 table 布局，很小的改动会导致整个 table 的重新布局。\n\n## 访问 DOM 节点的某些属性\n\n比如 offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop/Left/Width/Height, clientTop/Left/Width/Height, getComputedStyle()等等，参考[When does DOM access slow down rendering?](http://www.yiotabytes.com/2011/04/when-does-dom-access-slow-down.html)。文章中也提到浏览器越来越聪明，会尽量避免这些不太必要的重排重绘。我暂时还不知道怎么验证是否发生了重排重绘。\n\n留个问题，CSS3 Transition 动画能不能减少重排呢？重绘肯定是少不了的。\n","slug":"Reduce-reflow-repaint","published":1,"date":"2013-05-24T16:00:00.000Z","updated":"2018-12-07T03:07:49.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9e000dw8wkr8pp7hk5","content":"<p>在这篇博客中，我们列举一些可以减少 reflow 或者 repaint 的方法。下面先讲述一下这两个概念。<br><strong>reflow</strong>，翻译为重排，意为重新布局。当一个元素的形状位置发生改变时，浏览器会对该元素以及子元素（也可能包括同级元素）进行布局和重绘。称之为重排。<br><strong>repaint</strong>，翻译为重绘。当一个元素的颜色等发生改变时，浏览器会对该元素进行重绘。<br>为了减少重排和重绘，可以从以下几个方面着手。</p>\n<h2 id=\"批量增删节点\"><a href=\"#批量增删节点\" class=\"headerlink\" title=\"批量增删节点\"></a>批量增删节点</h2><h3 id=\"通过elem-innerHTML批量删除和添加子节点。\"><a href=\"#通过elem-innerHTML批量删除和添加子节点。\" class=\"headerlink\" title=\"通过elem.innerHTML批量删除和添加子节点。\"></a>通过<code>elem.innerHTML</code>批量删除和添加子节点。</h3><h3 id=\"通过elem-insertAdjacentHTML批量添加子节点。\"><a href=\"#通过elem-insertAdjacentHTML批量添加子节点。\" class=\"headerlink\" title=\"通过elem.insertAdjacentHTML批量添加子节点。\"></a>通过<code>elem.insertAdjacentHTML</code>批量添加子节点。</h3><h3 id=\"通过创建一个-fragment-来批量添加子节点。\"><a href=\"#通过创建一个-fragment-来批量添加子节点。\" class=\"headerlink\" title=\"通过创建一个 fragment 来批量添加子节点。\"></a>通过创建一个 fragment 来批量添加子节点。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">    fragment.addChild(div);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">elem.appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过创建一个-range-来批量删除一组连续节点。\"><a href=\"#通过创建一个-range-来批量删除一组连续节点。\" class=\"headerlink\" title=\"通过创建一个 range 来批量删除一组连续节点。\"></a>通过创建一个 range 来批量删除一组连续节点。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeChildren</span>(<span class=\"params\">parent, start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> range = <span class=\"built_in\">document</span>.createRange();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> children = parent.children;</span><br><span class=\"line\">    range.setStartBefore(children[start]);</span><br><span class=\"line\">    range.setEndAfter(children[end]);</span><br><span class=\"line\">    children = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    range.deleteContents();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"批量修改节点和样式\"><a href=\"#批量修改节点和样式\" class=\"headerlink\" title=\"批量修改节点和样式\"></a>批量修改节点和样式</h2><h3 id=\"通过修改-class-属性代替多次修改-style-属性\"><a href=\"#通过修改-class-属性代替多次修改-style-属性\" class=\"headerlink\" title=\"通过修改 class 属性代替多次修改 style 属性\"></a>通过修改 class 属性代替多次修改 style 属性</h3><p>不好的做法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">elem.style.width = <span class=\"string\">'200px'</span>;</span><br><span class=\"line\">elem.style.height = <span class=\"string\">'200px'</span>;</span><br></pre></td></tr></table></figure>\n<p>较好的做法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.another-style</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">elem.className = <span class=\"string\">'another-style'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"将节点隐藏或者删除后，批量修改，然后再显示或者添加到-DOM-树中。不管修改了多少次，只重新布局两次。\"><a href=\"#将节点隐藏或者删除后，批量修改，然后再显示或者添加到-DOM-树中。不管修改了多少次，只重新布局两次。\" class=\"headerlink\" title=\"将节点隐藏或者删除后，批量修改，然后再显示或者添加到 DOM 树中。不管修改了多少次，只重新布局两次。\"></a>将节点隐藏或者删除后，批量修改，然后再显示或者添加到 DOM 树中。不管修改了多少次，只重新布局两次。</h3><h3 id=\"先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。\"><a href=\"#先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。\" class=\"headerlink\" title=\"先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。\"></a>先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。</h3><h3 id=\"尽量缩小修改的影响\"><a href=\"#尽量缩小修改的影响\" class=\"headerlink\" title=\"尽量缩小修改的影响\"></a>尽量缩小修改的影响</h3><h3 id=\"让对经常变化的节点脱离文档流，比如使用-absolute-或者-fixed-的-position。这样，当该节点重排时不会影响其以后的兄弟节点。\"><a href=\"#让对经常变化的节点脱离文档流，比如使用-absolute-或者-fixed-的-position。这样，当该节点重排时不会影响其以后的兄弟节点。\" class=\"headerlink\" title=\"让对经常变化的节点脱离文档流，比如使用 absolute 或者 fixed 的 position。这样，当该节点重排时不会影响其以后的兄弟节点。\"></a>让对经常变化的节点脱离文档流，比如使用 absolute 或者 fixed 的 position。这样，当该节点重排时不会影响其以后的兄弟节点。</h3><h3 id=\"少使用-table-布局，很小的改动会导致整个-table-的重新布局。\"><a href=\"#少使用-table-布局，很小的改动会导致整个-table-的重新布局。\" class=\"headerlink\" title=\"少使用 table 布局，很小的改动会导致整个 table 的重新布局。\"></a>少使用 table 布局，很小的改动会导致整个 table 的重新布局。</h3><h2 id=\"访问-DOM-节点的某些属性\"><a href=\"#访问-DOM-节点的某些属性\" class=\"headerlink\" title=\"访问 DOM 节点的某些属性\"></a>访问 DOM 节点的某些属性</h2><p>比如 offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop/Left/Width/Height, clientTop/Left/Width/Height, getComputedStyle()等等，参考<a href=\"http://www.yiotabytes.com/2011/04/when-does-dom-access-slow-down.html\" target=\"_blank\" rel=\"noopener\">When does DOM access slow down rendering?</a>。文章中也提到浏览器越来越聪明，会尽量避免这些不太必要的重排重绘。我暂时还不知道怎么验证是否发生了重排重绘。</p>\n<p>留个问题，CSS3 Transition 动画能不能减少重排呢？重绘肯定是少不了的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在这篇博客中，我们列举一些可以减少 reflow 或者 repaint 的方法。下面先讲述一下这两个概念。<br><strong>reflow</strong>，翻译为重排，意为重新布局。当一个元素的形状位置发生改变时，浏览器会对该元素以及子元素（也可能包括同级元素）进行布局和重绘。称之为重排。<br><strong>repaint</strong>，翻译为重绘。当一个元素的颜色等发生改变时，浏览器会对该元素进行重绘。<br>为了减少重排和重绘，可以从以下几个方面着手。</p>\n<h2 id=\"批量增删节点\"><a href=\"#批量增删节点\" class=\"headerlink\" title=\"批量增删节点\"></a>批量增删节点</h2><h3 id=\"通过elem-innerHTML批量删除和添加子节点。\"><a href=\"#通过elem-innerHTML批量删除和添加子节点。\" class=\"headerlink\" title=\"通过elem.innerHTML批量删除和添加子节点。\"></a>通过<code>elem.innerHTML</code>批量删除和添加子节点。</h3><h3 id=\"通过elem-insertAdjacentHTML批量添加子节点。\"><a href=\"#通过elem-insertAdjacentHTML批量添加子节点。\" class=\"headerlink\" title=\"通过elem.insertAdjacentHTML批量添加子节点。\"></a>通过<code>elem.insertAdjacentHTML</code>批量添加子节点。</h3><h3 id=\"通过创建一个-fragment-来批量添加子节点。\"><a href=\"#通过创建一个-fragment-来批量添加子节点。\" class=\"headerlink\" title=\"通过创建一个 fragment 来批量添加子节点。\"></a>通过创建一个 fragment 来批量添加子节点。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'div'</span>);</span><br><span class=\"line\">    fragment.addChild(div);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">elem.appendChild(fragment);</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过创建一个-range-来批量删除一组连续节点。\"><a href=\"#通过创建一个-range-来批量删除一组连续节点。\" class=\"headerlink\" title=\"通过创建一个 range 来批量删除一组连续节点。\"></a>通过创建一个 range 来批量删除一组连续节点。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">removeChildren</span>(<span class=\"params\">parent, start, end</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> range = <span class=\"built_in\">document</span>.createRange();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> children = parent.children;</span><br><span class=\"line\">    range.setStartBefore(children[start]);</span><br><span class=\"line\">    range.setEndAfter(children[end]);</span><br><span class=\"line\">    children = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    range.deleteContents();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"批量修改节点和样式\"><a href=\"#批量修改节点和样式\" class=\"headerlink\" title=\"批量修改节点和样式\"></a>批量修改节点和样式</h2><h3 id=\"通过修改-class-属性代替多次修改-style-属性\"><a href=\"#通过修改-class-属性代替多次修改-style-属性\" class=\"headerlink\" title=\"通过修改 class 属性代替多次修改 style 属性\"></a>通过修改 class 属性代替多次修改 style 属性</h3><p>不好的做法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">elem.style.width = <span class=\"string\">'200px'</span>;</span><br><span class=\"line\">elem.style.height = <span class=\"string\">'200px'</span>;</span><br></pre></td></tr></table></figure>\n<p>较好的做法：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.another-style</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">elem.className = <span class=\"string\">'another-style'</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"将节点隐藏或者删除后，批量修改，然后再显示或者添加到-DOM-树中。不管修改了多少次，只重新布局两次。\"><a href=\"#将节点隐藏或者删除后，批量修改，然后再显示或者添加到-DOM-树中。不管修改了多少次，只重新布局两次。\" class=\"headerlink\" title=\"将节点隐藏或者删除后，批量修改，然后再显示或者添加到 DOM 树中。不管修改了多少次，只重新布局两次。\"></a>将节点隐藏或者删除后，批量修改，然后再显示或者添加到 DOM 树中。不管修改了多少次，只重新布局两次。</h3><h3 id=\"先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。\"><a href=\"#先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。\" class=\"headerlink\" title=\"先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。\"></a>先克隆节点，然后对克隆出来的节点做相应修改，然后再将原节点替换下来。</h3><h3 id=\"尽量缩小修改的影响\"><a href=\"#尽量缩小修改的影响\" class=\"headerlink\" title=\"尽量缩小修改的影响\"></a>尽量缩小修改的影响</h3><h3 id=\"让对经常变化的节点脱离文档流，比如使用-absolute-或者-fixed-的-position。这样，当该节点重排时不会影响其以后的兄弟节点。\"><a href=\"#让对经常变化的节点脱离文档流，比如使用-absolute-或者-fixed-的-position。这样，当该节点重排时不会影响其以后的兄弟节点。\" class=\"headerlink\" title=\"让对经常变化的节点脱离文档流，比如使用 absolute 或者 fixed 的 position。这样，当该节点重排时不会影响其以后的兄弟节点。\"></a>让对经常变化的节点脱离文档流，比如使用 absolute 或者 fixed 的 position。这样，当该节点重排时不会影响其以后的兄弟节点。</h3><h3 id=\"少使用-table-布局，很小的改动会导致整个-table-的重新布局。\"><a href=\"#少使用-table-布局，很小的改动会导致整个-table-的重新布局。\" class=\"headerlink\" title=\"少使用 table 布局，很小的改动会导致整个 table 的重新布局。\"></a>少使用 table 布局，很小的改动会导致整个 table 的重新布局。</h3><h2 id=\"访问-DOM-节点的某些属性\"><a href=\"#访问-DOM-节点的某些属性\" class=\"headerlink\" title=\"访问 DOM 节点的某些属性\"></a>访问 DOM 节点的某些属性</h2><p>比如 offsetTop, offsetLeft, offsetWidth, offsetHeight, scrollTop/Left/Width/Height, clientTop/Left/Width/Height, getComputedStyle()等等，参考<a href=\"http://www.yiotabytes.com/2011/04/when-does-dom-access-slow-down.html\" target=\"_blank\" rel=\"noopener\">When does DOM access slow down rendering?</a>。文章中也提到浏览器越来越聪明，会尽量避免这些不太必要的重排重绘。我暂时还不知道怎么验证是否发生了重排重绘。</p>\n<p>留个问题，CSS3 Transition 动画能不能减少重排呢？重绘肯定是少不了的。</p>\n"},{"title":"通过 body 的 error 事件捕获页面中所有图片的 error 事件","_content":"\n在 BDP 项目中，根据用户输入的关键字搜索视频并显示出来，后端返回的每条记录中有一个数组字段`image_urls`表示该视频的缩略图地址，它共有三种类型，分别是 small, medium 和 large。\n\n```json\n{\n    \"image_urls\": {\n        \"small\": \"http://...\",\n        \"medium\": \"http://...\",\n        \"large\": \"http://...\"\n    }\n}\n```\n\n需求是：在显示该条记录时，如果有 small，就显示 small，没有 small 但是有 medium，就显示 medium，如果没有 small 和 medium 但是有 large，就显示 large。如果三者都没有，那么显示一个默认的图片。实现起来非常简单。如下：\n\n```js\nvar default_icon = '/images/default_icon.png';\nitem.icon = image_urls.small || image_urls.medium || image_urls.large || default_icon;\n```\n\n这个时候已经隐隐觉得不妥，因为给该缩略图的准备的位置只有 84\\*84px。也就是说\n\n```css\n.icon {\n    max-width: 84px;\n    max-height: 84px;\n}\n```\n\n如果某条记录只有 large 缩略图，并且尺寸远远大于 84\\*84px，那么非常浪费带宽，对于性能很差的蓝光机浏览器来说，浏览器渲染若干张那么大的图片，使得性能更加低下。通知需求方以后，他们回复是这些记录有可能是从第三方服务获取，后端不可能准备合适尺寸的缩略图，但是他们又想尽可能显示缩略图，所以只能这样。\n\n还有另外一个问题：当一条记录有 small 和 medium 缩略图，但是 small 缩略图地址是无效地址，此时并不会显示 medium 缩略图。跟需求方沟通这种情况能否接受，但是需求方没有妥协，他们希望越完善越好。希望后端不要返回无效的地址，因为这样第一做起来比较复杂，第二这样可能无故增加很多无效的 404 请求。但是后端的回复仍然是有些记录来自第三方服务，后端不会判断缩略图地址是否有效。所以这时候的需求就变成：\n在显示某条记录时，如果有 small 地址有效，那么显示 small，如果 small 地址无效，但是 medium 地址有效，那么显示 medium，如果 small 和 medium 地址都无效，但是 large 地址有效，那么显示 large，如果三者都无效，那么显示默认图片。\n\n由于 img 的 error 事件并不会冒泡，只能分别处理，要在所有的 img 元素上都监听 error 事件真是令人头大。所幸我们使用基于字符串的模板引擎，onerror 方法只需写在模板中即可。实现如下。\n\n```html\n<!-- use doT as template engine -->\n<img\n    src=\"{{=item._src}}\"\n    images=\"{{=item._images}}\"\n    imageIndex=\"1\"\n    onerror=\"var images=this.getAttribute('images').split('|');var index=parseInt(this.getAttribute('imageIndex'),10);if(index<images.length){this.src=images[index];this.setAttribute('imageIndex', index+1)}\"\n/>\n```\n\n```js\nvar images = [];\nvar urls = item.image_urls;\nif (urls) {\n    if (urls.small) images.push(urls.small);\n    if (urls.medium) images.push(urls.medium);\n    if (urls.thumbnail) images.push(urls.thumbnail);\n}\nimages.push(default_thumb);\nitem._images = images.join('|');\nitem._src = images[0];\n```\n\n就像我们想象中的一样，解决了问题。但是在《Javascript 权威指南（第六版）》中 17.2.2 节中提到，以上的做法有着坏味道，第一点，将 html 视图和 js 控制逻辑混和在一起；第二点，当指定一个字符串作为事件处理程序时，浏览器会做以下事情：\n\n```js\nfunction(event) {\n  with(document) {\n    with(this.form || {}) {\n      with(this) {\n        /* your code here */\n      }\n    }\n  }\n}\n```\n\n这样通过`onXxx=\"\"`属性绑定事件处理程序的方法是每一个热爱代码热爱前端的人所不能忍受的。\n\n后来持续地在网上寻找更好的解决方案，终于老天开眼，找到下面这篇文章[Error events don’t bubble from images and how to work around that](http://m.cg/post/30934181934/error-events-dont-bubble-from-images-and-how-to-work)，文章中指出在 W3C 的 DOM Level 2 规范中指定[error 事件应该冒泡](http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-htmlevents)，但是只有 Opera 实现了这点。应该是由于其他的浏览器的反对，最后在 DOM Level 3 规范中[取消的 error 事件的冒泡](http://www.w3.org/TR/DOM-Level-3-Events/#event-type-error)。作者还指出一种解决办法就是：使用 body 元素的捕获处理程序。\n\n```js\ndocument.body.addEventListener('error', handleResourceError, true);\n```\n\n顺便提及一下，作者最后提出`<body onerror=\"handleResourceError()\">`相当于在 window 上注册了事件并可以监听到脚本（运行时）错误。这个论点在 Chrome27 **没有** 得到支持。\n\n所以最后的比较完美的解决方案是：\n\n```html\n<img src=\"{{=item._src}}\" images=\"{{=item._images}}\" imageIndex=\"1\" />\n```\n\n```js\n// 部分代码同上，略去\ndocument.body.addEventListener(\n    'error',\n    function(e) {\n        var target = e.target;\n        if (!target || target.tagName !== 'IMG') return;\n        var images = target.getAttribute('images').split('|');\n        var index = parseInt(target.getAttribute('imageIndex'), 10);\n        if (index < images.length) {\n            target.src = images[index];\n            target.setAttribute('imageIndex', index + 1);\n        }\n    },\n    true\n);\n```\n\n在《Javascript 权威指南（第六版）》中 17.3.6 节中提到：事件传播的捕获阶段就像反向的冒泡阶段，一次调用 window，document，body...直至父节点之上的捕获处理程序，在目标对象绑定的捕获事件处理程序不会被调用。事件捕获提供了在事件还没有传播到目标节点之前查看他们的机会，可以用于调试，或者过滤事件。比如用于拖放，拖放的处理通常不是鼠标点击的目标元素。\n","source":"_posts/2013-06-06-Events-in-Capture-Phase.md","raw":"---\ntitle: 通过 body 的 error 事件捕获页面中所有图片的 error 事件\n---\n\n在 BDP 项目中，根据用户输入的关键字搜索视频并显示出来，后端返回的每条记录中有一个数组字段`image_urls`表示该视频的缩略图地址，它共有三种类型，分别是 small, medium 和 large。\n\n```json\n{\n    \"image_urls\": {\n        \"small\": \"http://...\",\n        \"medium\": \"http://...\",\n        \"large\": \"http://...\"\n    }\n}\n```\n\n需求是：在显示该条记录时，如果有 small，就显示 small，没有 small 但是有 medium，就显示 medium，如果没有 small 和 medium 但是有 large，就显示 large。如果三者都没有，那么显示一个默认的图片。实现起来非常简单。如下：\n\n```js\nvar default_icon = '/images/default_icon.png';\nitem.icon = image_urls.small || image_urls.medium || image_urls.large || default_icon;\n```\n\n这个时候已经隐隐觉得不妥，因为给该缩略图的准备的位置只有 84\\*84px。也就是说\n\n```css\n.icon {\n    max-width: 84px;\n    max-height: 84px;\n}\n```\n\n如果某条记录只有 large 缩略图，并且尺寸远远大于 84\\*84px，那么非常浪费带宽，对于性能很差的蓝光机浏览器来说，浏览器渲染若干张那么大的图片，使得性能更加低下。通知需求方以后，他们回复是这些记录有可能是从第三方服务获取，后端不可能准备合适尺寸的缩略图，但是他们又想尽可能显示缩略图，所以只能这样。\n\n还有另外一个问题：当一条记录有 small 和 medium 缩略图，但是 small 缩略图地址是无效地址，此时并不会显示 medium 缩略图。跟需求方沟通这种情况能否接受，但是需求方没有妥协，他们希望越完善越好。希望后端不要返回无效的地址，因为这样第一做起来比较复杂，第二这样可能无故增加很多无效的 404 请求。但是后端的回复仍然是有些记录来自第三方服务，后端不会判断缩略图地址是否有效。所以这时候的需求就变成：\n在显示某条记录时，如果有 small 地址有效，那么显示 small，如果 small 地址无效，但是 medium 地址有效，那么显示 medium，如果 small 和 medium 地址都无效，但是 large 地址有效，那么显示 large，如果三者都无效，那么显示默认图片。\n\n由于 img 的 error 事件并不会冒泡，只能分别处理，要在所有的 img 元素上都监听 error 事件真是令人头大。所幸我们使用基于字符串的模板引擎，onerror 方法只需写在模板中即可。实现如下。\n\n```html\n<!-- use doT as template engine -->\n<img\n    src=\"{{=item._src}}\"\n    images=\"{{=item._images}}\"\n    imageIndex=\"1\"\n    onerror=\"var images=this.getAttribute('images').split('|');var index=parseInt(this.getAttribute('imageIndex'),10);if(index<images.length){this.src=images[index];this.setAttribute('imageIndex', index+1)}\"\n/>\n```\n\n```js\nvar images = [];\nvar urls = item.image_urls;\nif (urls) {\n    if (urls.small) images.push(urls.small);\n    if (urls.medium) images.push(urls.medium);\n    if (urls.thumbnail) images.push(urls.thumbnail);\n}\nimages.push(default_thumb);\nitem._images = images.join('|');\nitem._src = images[0];\n```\n\n就像我们想象中的一样，解决了问题。但是在《Javascript 权威指南（第六版）》中 17.2.2 节中提到，以上的做法有着坏味道，第一点，将 html 视图和 js 控制逻辑混和在一起；第二点，当指定一个字符串作为事件处理程序时，浏览器会做以下事情：\n\n```js\nfunction(event) {\n  with(document) {\n    with(this.form || {}) {\n      with(this) {\n        /* your code here */\n      }\n    }\n  }\n}\n```\n\n这样通过`onXxx=\"\"`属性绑定事件处理程序的方法是每一个热爱代码热爱前端的人所不能忍受的。\n\n后来持续地在网上寻找更好的解决方案，终于老天开眼，找到下面这篇文章[Error events don’t bubble from images and how to work around that](http://m.cg/post/30934181934/error-events-dont-bubble-from-images-and-how-to-work)，文章中指出在 W3C 的 DOM Level 2 规范中指定[error 事件应该冒泡](http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-htmlevents)，但是只有 Opera 实现了这点。应该是由于其他的浏览器的反对，最后在 DOM Level 3 规范中[取消的 error 事件的冒泡](http://www.w3.org/TR/DOM-Level-3-Events/#event-type-error)。作者还指出一种解决办法就是：使用 body 元素的捕获处理程序。\n\n```js\ndocument.body.addEventListener('error', handleResourceError, true);\n```\n\n顺便提及一下，作者最后提出`<body onerror=\"handleResourceError()\">`相当于在 window 上注册了事件并可以监听到脚本（运行时）错误。这个论点在 Chrome27 **没有** 得到支持。\n\n所以最后的比较完美的解决方案是：\n\n```html\n<img src=\"{{=item._src}}\" images=\"{{=item._images}}\" imageIndex=\"1\" />\n```\n\n```js\n// 部分代码同上，略去\ndocument.body.addEventListener(\n    'error',\n    function(e) {\n        var target = e.target;\n        if (!target || target.tagName !== 'IMG') return;\n        var images = target.getAttribute('images').split('|');\n        var index = parseInt(target.getAttribute('imageIndex'), 10);\n        if (index < images.length) {\n            target.src = images[index];\n            target.setAttribute('imageIndex', index + 1);\n        }\n    },\n    true\n);\n```\n\n在《Javascript 权威指南（第六版）》中 17.3.6 节中提到：事件传播的捕获阶段就像反向的冒泡阶段，一次调用 window，document，body...直至父节点之上的捕获处理程序，在目标对象绑定的捕获事件处理程序不会被调用。事件捕获提供了在事件还没有传播到目标节点之前查看他们的机会，可以用于调试，或者过滤事件。比如用于拖放，拖放的处理通常不是鼠标点击的目标元素。\n","slug":"Events-in-Capture-Phase","published":1,"date":"2013-06-05T16:00:00.000Z","updated":"2018-12-07T03:01:43.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9g000ew8wkhoaayisz","content":"<p>在 BDP 项目中，根据用户输入的关键字搜索视频并显示出来，后端返回的每条记录中有一个数组字段<code>image_urls</code>表示该视频的缩略图地址，它共有三种类型，分别是 small, medium 和 large。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"image_urls\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"small\"</span>: <span class=\"string\">\"http://...\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"medium\"</span>: <span class=\"string\">\"http://...\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"large\"</span>: <span class=\"string\">\"http://...\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需求是：在显示该条记录时，如果有 small，就显示 small，没有 small 但是有 medium，就显示 medium，如果没有 small 和 medium 但是有 large，就显示 large。如果三者都没有，那么显示一个默认的图片。实现起来非常简单。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> default_icon = <span class=\"string\">'/images/default_icon.png'</span>;</span><br><span class=\"line\">item.icon = image_urls.small || image_urls.medium || image_urls.large || default_icon;</span><br></pre></td></tr></table></figure>\n<p>这个时候已经隐隐觉得不妥，因为给该缩略图的准备的位置只有 84*84px。也就是说</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.icon</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: <span class=\"number\">84px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">max-height</span>: <span class=\"number\">84px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果某条记录只有 large 缩略图，并且尺寸远远大于 84*84px，那么非常浪费带宽，对于性能很差的蓝光机浏览器来说，浏览器渲染若干张那么大的图片，使得性能更加低下。通知需求方以后，他们回复是这些记录有可能是从第三方服务获取，后端不可能准备合适尺寸的缩略图，但是他们又想尽可能显示缩略图，所以只能这样。</p>\n<p>还有另外一个问题：当一条记录有 small 和 medium 缩略图，但是 small 缩略图地址是无效地址，此时并不会显示 medium 缩略图。跟需求方沟通这种情况能否接受，但是需求方没有妥协，他们希望越完善越好。希望后端不要返回无效的地址，因为这样第一做起来比较复杂，第二这样可能无故增加很多无效的 404 请求。但是后端的回复仍然是有些记录来自第三方服务，后端不会判断缩略图地址是否有效。所以这时候的需求就变成：<br>在显示某条记录时，如果有 small 地址有效，那么显示 small，如果 small 地址无效，但是 medium 地址有效，那么显示 medium，如果 small 和 medium 地址都无效，但是 large 地址有效，那么显示 large，如果三者都无效，那么显示默认图片。</p>\n<p>由于 img 的 error 事件并不会冒泡，只能分别处理，要在所有的 img 元素上都监听 error 事件真是令人头大。所幸我们使用基于字符串的模板引擎，onerror 方法只需写在模板中即可。实现如下。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- use doT as template engine --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;&#123;=item._src&#125;&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">images</span>=<span class=\"string\">\"&#123;&#123;=item._images&#125;&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">imageIndex</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">onerror</span>=<span class=\"string\">\"var images=this.getAttribute('images').split('|');var index=parseInt(this.getAttribute('imageIndex'),10);if(index&lt;images.length)&#123;this.src=images[index];this.setAttribute('imageIndex', index+1)&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> images = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> urls = item.image_urls;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (urls) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.small) images.push(urls.small);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.medium) images.push(urls.medium);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.thumbnail) images.push(urls.thumbnail);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">images.push(default_thumb);</span><br><span class=\"line\">item._images = images.join(<span class=\"string\">'|'</span>);</span><br><span class=\"line\">item._src = images[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>就像我们想象中的一样，解决了问题。但是在《Javascript 权威指南（第六版）》中 17.2.2 节中提到，以上的做法有着坏味道，第一点，将 html 视图和 js 控制逻辑混和在一起；第二点，当指定一个字符串作为事件处理程序时，浏览器会做以下事情：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">with</span>(<span class=\"built_in\">document</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">with</span>(<span class=\"keyword\">this</span>.form || &#123;&#125;) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">with</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* your code here */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样通过<code>onXxx=&quot;&quot;</code>属性绑定事件处理程序的方法是每一个热爱代码热爱前端的人所不能忍受的。</p>\n<p>后来持续地在网上寻找更好的解决方案，终于老天开眼，找到下面这篇文章<a href=\"http://m.cg/post/30934181934/error-events-dont-bubble-from-images-and-how-to-work\" target=\"_blank\" rel=\"noopener\">Error events don’t bubble from images and how to work around that</a>，文章中指出在 W3C 的 DOM Level 2 规范中指定<a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-htmlevents\" target=\"_blank\" rel=\"noopener\">error 事件应该冒泡</a>，但是只有 Opera 实现了这点。应该是由于其他的浏览器的反对，最后在 DOM Level 3 规范中<a href=\"http://www.w3.org/TR/DOM-Level-3-Events/#event-type-error\" target=\"_blank\" rel=\"noopener\">取消的 error 事件的冒泡</a>。作者还指出一种解决办法就是：使用 body 元素的捕获处理程序。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(<span class=\"string\">'error'</span>, handleResourceError, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>顺便提及一下，作者最后提出<code>&lt;body onerror=&quot;handleResourceError()&quot;&gt;</code>相当于在 window 上注册了事件并可以监听到脚本（运行时）错误。这个论点在 Chrome27 <strong>没有</strong> 得到支持。</p>\n<p>所以最后的比较完美的解决方案是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;&#123;=item._src&#125;&#125;\"</span> <span class=\"attr\">images</span>=<span class=\"string\">\"&#123;&#123;=item._images&#125;&#125;\"</span> <span class=\"attr\">imageIndex</span>=<span class=\"string\">\"1\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 部分代码同上，略去</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(</span><br><span class=\"line\">    <span class=\"string\">'error'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> target = e.target;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!target || target.tagName !== <span class=\"string\">'IMG'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> images = target.getAttribute(<span class=\"string\">'images'</span>).split(<span class=\"string\">'|'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"built_in\">parseInt</span>(target.getAttribute(<span class=\"string\">'imageIndex'</span>), <span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; images.length) &#123;</span><br><span class=\"line\">            target.src = images[index];</span><br><span class=\"line\">            target.setAttribute(<span class=\"string\">'imageIndex'</span>, index + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>在《Javascript 权威指南（第六版）》中 17.3.6 节中提到：事件传播的捕获阶段就像反向的冒泡阶段，一次调用 window，document，body…直至父节点之上的捕获处理程序，在目标对象绑定的捕获事件处理程序不会被调用。事件捕获提供了在事件还没有传播到目标节点之前查看他们的机会，可以用于调试，或者过滤事件。比如用于拖放，拖放的处理通常不是鼠标点击的目标元素。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 BDP 项目中，根据用户输入的关键字搜索视频并显示出来，后端返回的每条记录中有一个数组字段<code>image_urls</code>表示该视频的缩略图地址，它共有三种类型，分别是 small, medium 和 large。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"image_urls\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"small\"</span>: <span class=\"string\">\"http://...\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"medium\"</span>: <span class=\"string\">\"http://...\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"large\"</span>: <span class=\"string\">\"http://...\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需求是：在显示该条记录时，如果有 small，就显示 small，没有 small 但是有 medium，就显示 medium，如果没有 small 和 medium 但是有 large，就显示 large。如果三者都没有，那么显示一个默认的图片。实现起来非常简单。如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> default_icon = <span class=\"string\">'/images/default_icon.png'</span>;</span><br><span class=\"line\">item.icon = image_urls.small || image_urls.medium || image_urls.large || default_icon;</span><br></pre></td></tr></table></figure>\n<p>这个时候已经隐隐觉得不妥，因为给该缩略图的准备的位置只有 84*84px。也就是说</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.icon</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">max-width</span>: <span class=\"number\">84px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">max-height</span>: <span class=\"number\">84px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果某条记录只有 large 缩略图，并且尺寸远远大于 84*84px，那么非常浪费带宽，对于性能很差的蓝光机浏览器来说，浏览器渲染若干张那么大的图片，使得性能更加低下。通知需求方以后，他们回复是这些记录有可能是从第三方服务获取，后端不可能准备合适尺寸的缩略图，但是他们又想尽可能显示缩略图，所以只能这样。</p>\n<p>还有另外一个问题：当一条记录有 small 和 medium 缩略图，但是 small 缩略图地址是无效地址，此时并不会显示 medium 缩略图。跟需求方沟通这种情况能否接受，但是需求方没有妥协，他们希望越完善越好。希望后端不要返回无效的地址，因为这样第一做起来比较复杂，第二这样可能无故增加很多无效的 404 请求。但是后端的回复仍然是有些记录来自第三方服务，后端不会判断缩略图地址是否有效。所以这时候的需求就变成：<br>在显示某条记录时，如果有 small 地址有效，那么显示 small，如果 small 地址无效，但是 medium 地址有效，那么显示 medium，如果 small 和 medium 地址都无效，但是 large 地址有效，那么显示 large，如果三者都无效，那么显示默认图片。</p>\n<p>由于 img 的 error 事件并不会冒泡，只能分别处理，要在所有的 img 元素上都监听 error 事件真是令人头大。所幸我们使用基于字符串的模板引擎，onerror 方法只需写在模板中即可。实现如下。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- use doT as template engine --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;&#123;=item._src&#125;&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">images</span>=<span class=\"string\">\"&#123;&#123;=item._images&#125;&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">imageIndex</span>=<span class=\"string\">\"1\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">onerror</span>=<span class=\"string\">\"var images=this.getAttribute('images').split('|');var index=parseInt(this.getAttribute('imageIndex'),10);if(index&lt;images.length)&#123;this.src=images[index];this.setAttribute('imageIndex', index+1)&#125;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> images = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> urls = item.image_urls;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (urls) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.small) images.push(urls.small);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.medium) images.push(urls.medium);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (urls.thumbnail) images.push(urls.thumbnail);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">images.push(default_thumb);</span><br><span class=\"line\">item._images = images.join(<span class=\"string\">'|'</span>);</span><br><span class=\"line\">item._src = images[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>就像我们想象中的一样，解决了问题。但是在《Javascript 权威指南（第六版）》中 17.2.2 节中提到，以上的做法有着坏味道，第一点，将 html 视图和 js 控制逻辑混和在一起；第二点，当指定一个字符串作为事件处理程序时，浏览器会做以下事情：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">with</span>(<span class=\"built_in\">document</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">with</span>(<span class=\"keyword\">this</span>.form || &#123;&#125;) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">with</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* your code here */</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样通过<code>onXxx=&quot;&quot;</code>属性绑定事件处理程序的方法是每一个热爱代码热爱前端的人所不能忍受的。</p>\n<p>后来持续地在网上寻找更好的解决方案，终于老天开眼，找到下面这篇文章<a href=\"http://m.cg/post/30934181934/error-events-dont-bubble-from-images-and-how-to-work\" target=\"_blank\" rel=\"noopener\">Error events don’t bubble from images and how to work around that</a>，文章中指出在 W3C 的 DOM Level 2 规范中指定<a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-eventgroupings-htmlevents\" target=\"_blank\" rel=\"noopener\">error 事件应该冒泡</a>，但是只有 Opera 实现了这点。应该是由于其他的浏览器的反对，最后在 DOM Level 3 规范中<a href=\"http://www.w3.org/TR/DOM-Level-3-Events/#event-type-error\" target=\"_blank\" rel=\"noopener\">取消的 error 事件的冒泡</a>。作者还指出一种解决办法就是：使用 body 元素的捕获处理程序。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(<span class=\"string\">'error'</span>, handleResourceError, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>顺便提及一下，作者最后提出<code>&lt;body onerror=&quot;handleResourceError()&quot;&gt;</code>相当于在 window 上注册了事件并可以监听到脚本（运行时）错误。这个论点在 Chrome27 <strong>没有</strong> 得到支持。</p>\n<p>所以最后的比较完美的解决方案是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"&#123;&#123;=item._src&#125;&#125;\"</span> <span class=\"attr\">images</span>=<span class=\"string\">\"&#123;&#123;=item._images&#125;&#125;\"</span> <span class=\"attr\">imageIndex</span>=<span class=\"string\">\"1\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 部分代码同上，略去</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.addEventListener(</span><br><span class=\"line\">    <span class=\"string\">'error'</span>,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> target = e.target;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!target || target.tagName !== <span class=\"string\">'IMG'</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> images = target.getAttribute(<span class=\"string\">'images'</span>).split(<span class=\"string\">'|'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index = <span class=\"built_in\">parseInt</span>(target.getAttribute(<span class=\"string\">'imageIndex'</span>), <span class=\"number\">10</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; images.length) &#123;</span><br><span class=\"line\">            target.src = images[index];</span><br><span class=\"line\">            target.setAttribute(<span class=\"string\">'imageIndex'</span>, index + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"literal\">true</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>在《Javascript 权威指南（第六版）》中 17.3.6 节中提到：事件传播的捕获阶段就像反向的冒泡阶段，一次调用 window，document，body…直至父节点之上的捕获处理程序，在目标对象绑定的捕获事件处理程序不会被调用。事件捕获提供了在事件还没有传播到目标节点之前查看他们的机会，可以用于调试，或者过滤事件。比如用于拖放，拖放的处理通常不是鼠标点击的目标元素。</p>\n"},{"title":"强迫注册和注册强迫症","_content":"\n关于用户体验，我们经常听到这样的言论，除非到了非注册不可的时候，才让用户注册账号。过早地强迫用户注册，只会吓走用户。以今天看到的一个站点[孢子社区](http://baoz.me/)为例，首页是一张背景图片，一张 LOGO 图标，一个登陆按钮和一个注册按钮，可谓非常简洁。“孢子”这个名字对我来说比较亲切，我挺喜欢玩《植物大战僵尸》，里面有个孢子射手。背景图片也很亲切，是一群光着身子的小孩子欢笑跳跃，对我也说，也非常亲切，我很想知道这个网站是干什么的，但是孢子社区的首页并没有告诉我，而是在门口安排了两个保安（登录按钮和注册按钮），要检查我的身份证，刚才提及的亲切感顿时灰飞烟灭。  \n![孢子首页截屏](../../../../images/baoz.me-home.png)  \n![孢子注册页面截屏](../../../../images/baoz.me-register.png)\n\n当我意识是他们强迫我注册，才让我不想进去看看里面有什么东西的，并且我又临时决定写这样一篇博客时，我决定去注册一下，去看看里面有什么东西。注册页面也挺简单：要填写一个邮箱，一个昵称，和一个密码。注意这里并没有要我再填写一次密码，这是最近比较流行的注册方式。顺便看看内容，还好。其中一个图片令人捧腹，所谓[百鸟朝凤](http://f.baoz.cn/f/9793b729aab2d6416d566b788db562a5)，图片有色。\n\n使用一小段时间之后，发现都不是非注册不可。我不发帖不留言。所以该网站就因为首页的注册按钮丢失了我这个潜在的用户。\n\n本公司是一家家电产业的公司，生产基于 Android 系统的手机，相机，电视等，为了丰富他们的使用价值，希望吸引开发者多多开发其上的应用。但是考虑到如下因素，以电视机为例，为了开发电视机上的应用，不是每个个人开发者都可以去买一台电视机，也不是每家公司都有足够电视机供员工调试开发使用。所以本公司就想开发一个模拟应用，称之为应用 D，它能够模拟电视机开放出来的接口。我的建议很简单，用户打开应用 D 以后，就看到一堆可以申请的设备，包括电视机，相机等，一键申请设备之后，就会显示在用户设备列表中，用户就可以使用他们。当用户关掉应用 D，所有的设备都消失，当应用再次打开应用 D 时，需要重新申请才可以继续使用。当然如果感觉这样比较麻烦，那么可以在应用 D 本地数据中保留用户已经申请的设备，使得用户再次打开应用 D 时，可以看到以前申请的各种设备。但公司领导还是希望用户打开应用 D 之后，首先注册账号，以便把申请的设备保存到服务器端，然后本公司可以跟踪用户喜欢申请那些设备，以及使用时间长短等等。我也提出，这些问题也可以通过记录用户的操作，比如点击申请等来跟踪，但是注册不是必须的。还有很重要的一点，如果你要用户注册账号，你就要保证用户账号安全。近几年来，已经发生了不少大公司用户信息被盗取的案例。不幸的是本公司也在其列。\n\n面对每天要登录的各种应用各种网站，我总是在想，苹果拥有那么多终端，那么多的用户账号，为什么不提供一种功能，类似 Open ID，不管是网页还是本地 APP，开发者只需要一个添加一句话，甚至只要在 APP 的配置中给予权限，用户就可以使用 Apple ID 一键该网站或者 APP。这是一种多么令人向往的美好。\n\n关于 Open ID，国内用的比较多的，当属新浪微博，腾讯 QQ，校内网等等。令人郁闷的是很多网站在我使用 Open ID 首次登录以后，还让我填写昵称和邮箱，他妈的这和我重新注册账号有什么区别？？？使用新浪微博账号登录以后，还很有能会在我不知情的情况下，替我发条微博，趁机给自己的产品做个广告。让我的隐私暴露的体无完肤啊！！！你们能有点节操吗？\n\n顺便吐槽一下[海丁网](headin.cn)，每次报名参加一次讲座的时候，都要填写邮箱，手机号码，职位和公司名称。我从来没有见过这么 SB 的网站。  \n![海丁网报名页面截屏](../../../../images/headin.cn.png)\n\n标题中还有一个词叫做注册强迫症，就是我看到一个新的网站，就想使用我的常用 ID 把它注册了。我有轻微的强迫注册症，但是这不妨碍我讨厌被强迫注册。我有三个常用 ID，第一个是被逼的没办法只能注册时，或者对网站内容或者网站所有者不屑时使用的 ID，再或者像上一段中提及的那些没有节操的网站，即便当时填写了一些个人信息，你可以想象，有多大的可信度，有多大的数据挖掘价值。第二个是全世界唯一的 UUID，用于常用 ID 已经被注册的情况。第三个是我真实姓名，用于我很喜欢的一些网站。有时候最初觉得某个网站不好，所以没有使用真实姓名注册，而后来越来越觉得好时，我还会使用真实姓名注册下来。我也会因为没有使用我的真实姓名注册到 gmail 邮箱而遗憾。所以从我的个人习惯来看，强迫用户注册真不是好主意。\n\n真是希望网站开发者或者老板能够认识到这一点，你有好用的产品，有有价值的内容，还怕没有用户？\n","source":"_posts/2013-06-07-essay.md","raw":"---\ntitle: 强迫注册和注册强迫症\n---\n\n关于用户体验，我们经常听到这样的言论，除非到了非注册不可的时候，才让用户注册账号。过早地强迫用户注册，只会吓走用户。以今天看到的一个站点[孢子社区](http://baoz.me/)为例，首页是一张背景图片，一张 LOGO 图标，一个登陆按钮和一个注册按钮，可谓非常简洁。“孢子”这个名字对我来说比较亲切，我挺喜欢玩《植物大战僵尸》，里面有个孢子射手。背景图片也很亲切，是一群光着身子的小孩子欢笑跳跃，对我也说，也非常亲切，我很想知道这个网站是干什么的，但是孢子社区的首页并没有告诉我，而是在门口安排了两个保安（登录按钮和注册按钮），要检查我的身份证，刚才提及的亲切感顿时灰飞烟灭。  \n![孢子首页截屏](../../../../images/baoz.me-home.png)  \n![孢子注册页面截屏](../../../../images/baoz.me-register.png)\n\n当我意识是他们强迫我注册，才让我不想进去看看里面有什么东西的，并且我又临时决定写这样一篇博客时，我决定去注册一下，去看看里面有什么东西。注册页面也挺简单：要填写一个邮箱，一个昵称，和一个密码。注意这里并没有要我再填写一次密码，这是最近比较流行的注册方式。顺便看看内容，还好。其中一个图片令人捧腹，所谓[百鸟朝凤](http://f.baoz.cn/f/9793b729aab2d6416d566b788db562a5)，图片有色。\n\n使用一小段时间之后，发现都不是非注册不可。我不发帖不留言。所以该网站就因为首页的注册按钮丢失了我这个潜在的用户。\n\n本公司是一家家电产业的公司，生产基于 Android 系统的手机，相机，电视等，为了丰富他们的使用价值，希望吸引开发者多多开发其上的应用。但是考虑到如下因素，以电视机为例，为了开发电视机上的应用，不是每个个人开发者都可以去买一台电视机，也不是每家公司都有足够电视机供员工调试开发使用。所以本公司就想开发一个模拟应用，称之为应用 D，它能够模拟电视机开放出来的接口。我的建议很简单，用户打开应用 D 以后，就看到一堆可以申请的设备，包括电视机，相机等，一键申请设备之后，就会显示在用户设备列表中，用户就可以使用他们。当用户关掉应用 D，所有的设备都消失，当应用再次打开应用 D 时，需要重新申请才可以继续使用。当然如果感觉这样比较麻烦，那么可以在应用 D 本地数据中保留用户已经申请的设备，使得用户再次打开应用 D 时，可以看到以前申请的各种设备。但公司领导还是希望用户打开应用 D 之后，首先注册账号，以便把申请的设备保存到服务器端，然后本公司可以跟踪用户喜欢申请那些设备，以及使用时间长短等等。我也提出，这些问题也可以通过记录用户的操作，比如点击申请等来跟踪，但是注册不是必须的。还有很重要的一点，如果你要用户注册账号，你就要保证用户账号安全。近几年来，已经发生了不少大公司用户信息被盗取的案例。不幸的是本公司也在其列。\n\n面对每天要登录的各种应用各种网站，我总是在想，苹果拥有那么多终端，那么多的用户账号，为什么不提供一种功能，类似 Open ID，不管是网页还是本地 APP，开发者只需要一个添加一句话，甚至只要在 APP 的配置中给予权限，用户就可以使用 Apple ID 一键该网站或者 APP。这是一种多么令人向往的美好。\n\n关于 Open ID，国内用的比较多的，当属新浪微博，腾讯 QQ，校内网等等。令人郁闷的是很多网站在我使用 Open ID 首次登录以后，还让我填写昵称和邮箱，他妈的这和我重新注册账号有什么区别？？？使用新浪微博账号登录以后，还很有能会在我不知情的情况下，替我发条微博，趁机给自己的产品做个广告。让我的隐私暴露的体无完肤啊！！！你们能有点节操吗？\n\n顺便吐槽一下[海丁网](headin.cn)，每次报名参加一次讲座的时候，都要填写邮箱，手机号码，职位和公司名称。我从来没有见过这么 SB 的网站。  \n![海丁网报名页面截屏](../../../../images/headin.cn.png)\n\n标题中还有一个词叫做注册强迫症，就是我看到一个新的网站，就想使用我的常用 ID 把它注册了。我有轻微的强迫注册症，但是这不妨碍我讨厌被强迫注册。我有三个常用 ID，第一个是被逼的没办法只能注册时，或者对网站内容或者网站所有者不屑时使用的 ID，再或者像上一段中提及的那些没有节操的网站，即便当时填写了一些个人信息，你可以想象，有多大的可信度，有多大的数据挖掘价值。第二个是全世界唯一的 UUID，用于常用 ID 已经被注册的情况。第三个是我真实姓名，用于我很喜欢的一些网站。有时候最初觉得某个网站不好，所以没有使用真实姓名注册，而后来越来越觉得好时，我还会使用真实姓名注册下来。我也会因为没有使用我的真实姓名注册到 gmail 邮箱而遗憾。所以从我的个人习惯来看，强迫用户注册真不是好主意。\n\n真是希望网站开发者或者老板能够认识到这一点，你有好用的产品，有有价值的内容，还怕没有用户？\n","slug":"essay","published":1,"date":"2013-06-06T16:00:00.000Z","updated":"2018-12-07T03:01:29.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9h000fw8wk8mgrepug","content":"<p>关于用户体验，我们经常听到这样的言论，除非到了非注册不可的时候，才让用户注册账号。过早地强迫用户注册，只会吓走用户。以今天看到的一个站点<a href=\"http://baoz.me/\" target=\"_blank\" rel=\"noopener\">孢子社区</a>为例，首页是一张背景图片，一张 LOGO 图标，一个登陆按钮和一个注册按钮，可谓非常简洁。“孢子”这个名字对我来说比较亲切，我挺喜欢玩《植物大战僵尸》，里面有个孢子射手。背景图片也很亲切，是一群光着身子的小孩子欢笑跳跃，对我也说，也非常亲切，我很想知道这个网站是干什么的，但是孢子社区的首页并没有告诉我，而是在门口安排了两个保安（登录按钮和注册按钮），要检查我的身份证，刚才提及的亲切感顿时灰飞烟灭。<br><img src=\"../../../../images/baoz.me-home.png\" alt=\"孢子首页截屏\"><br><img src=\"../../../../images/baoz.me-register.png\" alt=\"孢子注册页面截屏\"></p>\n<p>当我意识是他们强迫我注册，才让我不想进去看看里面有什么东西的，并且我又临时决定写这样一篇博客时，我决定去注册一下，去看看里面有什么东西。注册页面也挺简单：要填写一个邮箱，一个昵称，和一个密码。注意这里并没有要我再填写一次密码，这是最近比较流行的注册方式。顺便看看内容，还好。其中一个图片令人捧腹，所谓<a href=\"http://f.baoz.cn/f/9793b729aab2d6416d566b788db562a5\" target=\"_blank\" rel=\"noopener\">百鸟朝凤</a>，图片有色。</p>\n<p>使用一小段时间之后，发现都不是非注册不可。我不发帖不留言。所以该网站就因为首页的注册按钮丢失了我这个潜在的用户。</p>\n<p>本公司是一家家电产业的公司，生产基于 Android 系统的手机，相机，电视等，为了丰富他们的使用价值，希望吸引开发者多多开发其上的应用。但是考虑到如下因素，以电视机为例，为了开发电视机上的应用，不是每个个人开发者都可以去买一台电视机，也不是每家公司都有足够电视机供员工调试开发使用。所以本公司就想开发一个模拟应用，称之为应用 D，它能够模拟电视机开放出来的接口。我的建议很简单，用户打开应用 D 以后，就看到一堆可以申请的设备，包括电视机，相机等，一键申请设备之后，就会显示在用户设备列表中，用户就可以使用他们。当用户关掉应用 D，所有的设备都消失，当应用再次打开应用 D 时，需要重新申请才可以继续使用。当然如果感觉这样比较麻烦，那么可以在应用 D 本地数据中保留用户已经申请的设备，使得用户再次打开应用 D 时，可以看到以前申请的各种设备。但公司领导还是希望用户打开应用 D 之后，首先注册账号，以便把申请的设备保存到服务器端，然后本公司可以跟踪用户喜欢申请那些设备，以及使用时间长短等等。我也提出，这些问题也可以通过记录用户的操作，比如点击申请等来跟踪，但是注册不是必须的。还有很重要的一点，如果你要用户注册账号，你就要保证用户账号安全。近几年来，已经发生了不少大公司用户信息被盗取的案例。不幸的是本公司也在其列。</p>\n<p>面对每天要登录的各种应用各种网站，我总是在想，苹果拥有那么多终端，那么多的用户账号，为什么不提供一种功能，类似 Open ID，不管是网页还是本地 APP，开发者只需要一个添加一句话，甚至只要在 APP 的配置中给予权限，用户就可以使用 Apple ID 一键该网站或者 APP。这是一种多么令人向往的美好。</p>\n<p>关于 Open ID，国内用的比较多的，当属新浪微博，腾讯 QQ，校内网等等。令人郁闷的是很多网站在我使用 Open ID 首次登录以后，还让我填写昵称和邮箱，他妈的这和我重新注册账号有什么区别？？？使用新浪微博账号登录以后，还很有能会在我不知情的情况下，替我发条微博，趁机给自己的产品做个广告。让我的隐私暴露的体无完肤啊！！！你们能有点节操吗？</p>\n<p>顺便吐槽一下<a href=\"headin.cn\">海丁网</a>，每次报名参加一次讲座的时候，都要填写邮箱，手机号码，职位和公司名称。我从来没有见过这么 SB 的网站。<br><img src=\"../../../../images/headin.cn.png\" alt=\"海丁网报名页面截屏\"></p>\n<p>标题中还有一个词叫做注册强迫症，就是我看到一个新的网站，就想使用我的常用 ID 把它注册了。我有轻微的强迫注册症，但是这不妨碍我讨厌被强迫注册。我有三个常用 ID，第一个是被逼的没办法只能注册时，或者对网站内容或者网站所有者不屑时使用的 ID，再或者像上一段中提及的那些没有节操的网站，即便当时填写了一些个人信息，你可以想象，有多大的可信度，有多大的数据挖掘价值。第二个是全世界唯一的 UUID，用于常用 ID 已经被注册的情况。第三个是我真实姓名，用于我很喜欢的一些网站。有时候最初觉得某个网站不好，所以没有使用真实姓名注册，而后来越来越觉得好时，我还会使用真实姓名注册下来。我也会因为没有使用我的真实姓名注册到 gmail 邮箱而遗憾。所以从我的个人习惯来看，强迫用户注册真不是好主意。</p>\n<p>真是希望网站开发者或者老板能够认识到这一点，你有好用的产品，有有价值的内容，还怕没有用户？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关于用户体验，我们经常听到这样的言论，除非到了非注册不可的时候，才让用户注册账号。过早地强迫用户注册，只会吓走用户。以今天看到的一个站点<a href=\"http://baoz.me/\" target=\"_blank\" rel=\"noopener\">孢子社区</a>为例，首页是一张背景图片，一张 LOGO 图标，一个登陆按钮和一个注册按钮，可谓非常简洁。“孢子”这个名字对我来说比较亲切，我挺喜欢玩《植物大战僵尸》，里面有个孢子射手。背景图片也很亲切，是一群光着身子的小孩子欢笑跳跃，对我也说，也非常亲切，我很想知道这个网站是干什么的，但是孢子社区的首页并没有告诉我，而是在门口安排了两个保安（登录按钮和注册按钮），要检查我的身份证，刚才提及的亲切感顿时灰飞烟灭。<br><img src=\"../../../../images/baoz.me-home.png\" alt=\"孢子首页截屏\"><br><img src=\"../../../../images/baoz.me-register.png\" alt=\"孢子注册页面截屏\"></p>\n<p>当我意识是他们强迫我注册，才让我不想进去看看里面有什么东西的，并且我又临时决定写这样一篇博客时，我决定去注册一下，去看看里面有什么东西。注册页面也挺简单：要填写一个邮箱，一个昵称，和一个密码。注意这里并没有要我再填写一次密码，这是最近比较流行的注册方式。顺便看看内容，还好。其中一个图片令人捧腹，所谓<a href=\"http://f.baoz.cn/f/9793b729aab2d6416d566b788db562a5\" target=\"_blank\" rel=\"noopener\">百鸟朝凤</a>，图片有色。</p>\n<p>使用一小段时间之后，发现都不是非注册不可。我不发帖不留言。所以该网站就因为首页的注册按钮丢失了我这个潜在的用户。</p>\n<p>本公司是一家家电产业的公司，生产基于 Android 系统的手机，相机，电视等，为了丰富他们的使用价值，希望吸引开发者多多开发其上的应用。但是考虑到如下因素，以电视机为例，为了开发电视机上的应用，不是每个个人开发者都可以去买一台电视机，也不是每家公司都有足够电视机供员工调试开发使用。所以本公司就想开发一个模拟应用，称之为应用 D，它能够模拟电视机开放出来的接口。我的建议很简单，用户打开应用 D 以后，就看到一堆可以申请的设备，包括电视机，相机等，一键申请设备之后，就会显示在用户设备列表中，用户就可以使用他们。当用户关掉应用 D，所有的设备都消失，当应用再次打开应用 D 时，需要重新申请才可以继续使用。当然如果感觉这样比较麻烦，那么可以在应用 D 本地数据中保留用户已经申请的设备，使得用户再次打开应用 D 时，可以看到以前申请的各种设备。但公司领导还是希望用户打开应用 D 之后，首先注册账号，以便把申请的设备保存到服务器端，然后本公司可以跟踪用户喜欢申请那些设备，以及使用时间长短等等。我也提出，这些问题也可以通过记录用户的操作，比如点击申请等来跟踪，但是注册不是必须的。还有很重要的一点，如果你要用户注册账号，你就要保证用户账号安全。近几年来，已经发生了不少大公司用户信息被盗取的案例。不幸的是本公司也在其列。</p>\n<p>面对每天要登录的各种应用各种网站，我总是在想，苹果拥有那么多终端，那么多的用户账号，为什么不提供一种功能，类似 Open ID，不管是网页还是本地 APP，开发者只需要一个添加一句话，甚至只要在 APP 的配置中给予权限，用户就可以使用 Apple ID 一键该网站或者 APP。这是一种多么令人向往的美好。</p>\n<p>关于 Open ID，国内用的比较多的，当属新浪微博，腾讯 QQ，校内网等等。令人郁闷的是很多网站在我使用 Open ID 首次登录以后，还让我填写昵称和邮箱，他妈的这和我重新注册账号有什么区别？？？使用新浪微博账号登录以后，还很有能会在我不知情的情况下，替我发条微博，趁机给自己的产品做个广告。让我的隐私暴露的体无完肤啊！！！你们能有点节操吗？</p>\n<p>顺便吐槽一下<a href=\"headin.cn\">海丁网</a>，每次报名参加一次讲座的时候，都要填写邮箱，手机号码，职位和公司名称。我从来没有见过这么 SB 的网站。<br><img src=\"../../../../images/headin.cn.png\" alt=\"海丁网报名页面截屏\"></p>\n<p>标题中还有一个词叫做注册强迫症，就是我看到一个新的网站，就想使用我的常用 ID 把它注册了。我有轻微的强迫注册症，但是这不妨碍我讨厌被强迫注册。我有三个常用 ID，第一个是被逼的没办法只能注册时，或者对网站内容或者网站所有者不屑时使用的 ID，再或者像上一段中提及的那些没有节操的网站，即便当时填写了一些个人信息，你可以想象，有多大的可信度，有多大的数据挖掘价值。第二个是全世界唯一的 UUID，用于常用 ID 已经被注册的情况。第三个是我真实姓名，用于我很喜欢的一些网站。有时候最初觉得某个网站不好，所以没有使用真实姓名注册，而后来越来越觉得好时，我还会使用真实姓名注册下来。我也会因为没有使用我的真实姓名注册到 gmail 邮箱而遗憾。所以从我的个人习惯来看，强迫用户注册真不是好主意。</p>\n<p>真是希望网站开发者或者老板能够认识到这一点，你有好用的产品，有有价值的内容，还怕没有用户？</p>\n"},{"title":"YouTube 开放 API 中返回数据不一致","_content":"\n在[YouTube 的开放 API](https://developers.google.com/youtube/2.0/reference?hl=en)中，totalResults 字段只是近似值，而不是准确值。比如返回的 totalResults 为 48，但是只返回 46 条记录。所以应用中不能依赖该字段来确定总共有多少页，然后允许用户直接跳到最后一页。因为最后一页很有可能就不存在。\n\n为什么会出现这种情况呢？我们从以下几个概念开始说起。\n\n## CAP 理论\n\nCAP 理论由 Eric Brewer 教授提出：在设计和部署分布式应用时，存在以下三个核心的系统需求：一致性（Consistency），可用性（Availability）和分区容错性（Partition Tolerance）， **针对特定数据，最多只能同时满足两个**。  \n**一致性**：又称为原子性或者事务性。表示一组操作是不可分割的，要么全部完成，不会出现部分完成的情况。  \n**可用性**：是指系统能够很好的为用户服务，不会出现操作失败或者访问超时等用户体验不好的情况。可以通过数据冗余，负载均衡等手段实现。  \n**分区容错性**：一个良好的分布式系统，在其中一个或者几个节点宕掉的情况下仍然能够工作。\n\n从这里可以大胆的猜测，YouTube 系统应该舍弃了一致性，保证了可用性和分区容错性。\n\n身为前端开发人员，还是更加看重这样的决策对前端的影响。\n\n1）就是不能使用传统的分页方式，可以采用无限滚动列表，或者只有“上一页”和“下一页”两个按钮的分页方式。在 BDP 项目中，我们使用无限列表的方式，当然是用这种方式的更大原因，电视机上没有鼠标操作，只有遥控器的上下左右键，而左右键被用切换页面，所以只能使用上下键来选择记录了。\n\n2）前端需要良好的容错机制。首先会假设 totalResults 字段是准确的，并显示给用户看。随着用户的操作，持续地发送请求获取更多记录，直到 ① 当前已经获取的记录数大于等于 totalResults，或者 ② 请求出错，就将 totalResults 修正为当前已经获取的记录的个数，并且比较圆润地处理错误，使得用户操作正常，就像没有出错一样。用户希望提前看到 totalResults，并不一定要看到一个准确的结果，多数时候他们需要的是个预期，大概多少条记录，我要滚动页面多长时间才能浏览一遍。\n","source":"_posts/2013-06-09-TotalResults-filed-in-Youtube-Open-API.md","raw":"---\ntitle: YouTube 开放 API 中返回数据不一致\n---\n\n在[YouTube 的开放 API](https://developers.google.com/youtube/2.0/reference?hl=en)中，totalResults 字段只是近似值，而不是准确值。比如返回的 totalResults 为 48，但是只返回 46 条记录。所以应用中不能依赖该字段来确定总共有多少页，然后允许用户直接跳到最后一页。因为最后一页很有可能就不存在。\n\n为什么会出现这种情况呢？我们从以下几个概念开始说起。\n\n## CAP 理论\n\nCAP 理论由 Eric Brewer 教授提出：在设计和部署分布式应用时，存在以下三个核心的系统需求：一致性（Consistency），可用性（Availability）和分区容错性（Partition Tolerance）， **针对特定数据，最多只能同时满足两个**。  \n**一致性**：又称为原子性或者事务性。表示一组操作是不可分割的，要么全部完成，不会出现部分完成的情况。  \n**可用性**：是指系统能够很好的为用户服务，不会出现操作失败或者访问超时等用户体验不好的情况。可以通过数据冗余，负载均衡等手段实现。  \n**分区容错性**：一个良好的分布式系统，在其中一个或者几个节点宕掉的情况下仍然能够工作。\n\n从这里可以大胆的猜测，YouTube 系统应该舍弃了一致性，保证了可用性和分区容错性。\n\n身为前端开发人员，还是更加看重这样的决策对前端的影响。\n\n1）就是不能使用传统的分页方式，可以采用无限滚动列表，或者只有“上一页”和“下一页”两个按钮的分页方式。在 BDP 项目中，我们使用无限列表的方式，当然是用这种方式的更大原因，电视机上没有鼠标操作，只有遥控器的上下左右键，而左右键被用切换页面，所以只能使用上下键来选择记录了。\n\n2）前端需要良好的容错机制。首先会假设 totalResults 字段是准确的，并显示给用户看。随着用户的操作，持续地发送请求获取更多记录，直到 ① 当前已经获取的记录数大于等于 totalResults，或者 ② 请求出错，就将 totalResults 修正为当前已经获取的记录的个数，并且比较圆润地处理错误，使得用户操作正常，就像没有出错一样。用户希望提前看到 totalResults，并不一定要看到一个准确的结果，多数时候他们需要的是个预期，大概多少条记录，我要滚动页面多长时间才能浏览一遍。\n","slug":"TotalResults-filed-in-Youtube-Open-API","published":1,"date":"2013-06-08T16:00:00.000Z","updated":"2018-12-07T03:01:26.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9i000gw8wkm0qt1u67","content":"<p>在<a href=\"https://developers.google.com/youtube/2.0/reference?hl=en\" target=\"_blank\" rel=\"noopener\">YouTube 的开放 API</a>中，totalResults 字段只是近似值，而不是准确值。比如返回的 totalResults 为 48，但是只返回 46 条记录。所以应用中不能依赖该字段来确定总共有多少页，然后允许用户直接跳到最后一页。因为最后一页很有可能就不存在。</p>\n<p>为什么会出现这种情况呢？我们从以下几个概念开始说起。</p>\n<h2 id=\"CAP-理论\"><a href=\"#CAP-理论\" class=\"headerlink\" title=\"CAP 理论\"></a>CAP 理论</h2><p>CAP 理论由 Eric Brewer 教授提出：在设计和部署分布式应用时，存在以下三个核心的系统需求：一致性（Consistency），可用性（Availability）和分区容错性（Partition Tolerance）， <strong>针对特定数据，最多只能同时满足两个</strong>。<br><strong>一致性</strong>：又称为原子性或者事务性。表示一组操作是不可分割的，要么全部完成，不会出现部分完成的情况。<br><strong>可用性</strong>：是指系统能够很好的为用户服务，不会出现操作失败或者访问超时等用户体验不好的情况。可以通过数据冗余，负载均衡等手段实现。<br><strong>分区容错性</strong>：一个良好的分布式系统，在其中一个或者几个节点宕掉的情况下仍然能够工作。</p>\n<p>从这里可以大胆的猜测，YouTube 系统应该舍弃了一致性，保证了可用性和分区容错性。</p>\n<p>身为前端开发人员，还是更加看重这样的决策对前端的影响。</p>\n<p>1）就是不能使用传统的分页方式，可以采用无限滚动列表，或者只有“上一页”和“下一页”两个按钮的分页方式。在 BDP 项目中，我们使用无限列表的方式，当然是用这种方式的更大原因，电视机上没有鼠标操作，只有遥控器的上下左右键，而左右键被用切换页面，所以只能使用上下键来选择记录了。</p>\n<p>2）前端需要良好的容错机制。首先会假设 totalResults 字段是准确的，并显示给用户看。随着用户的操作，持续地发送请求获取更多记录，直到 ① 当前已经获取的记录数大于等于 totalResults，或者 ② 请求出错，就将 totalResults 修正为当前已经获取的记录的个数，并且比较圆润地处理错误，使得用户操作正常，就像没有出错一样。用户希望提前看到 totalResults，并不一定要看到一个准确的结果，多数时候他们需要的是个预期，大概多少条记录，我要滚动页面多长时间才能浏览一遍。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"https://developers.google.com/youtube/2.0/reference?hl=en\" target=\"_blank\" rel=\"noopener\">YouTube 的开放 API</a>中，totalResults 字段只是近似值，而不是准确值。比如返回的 totalResults 为 48，但是只返回 46 条记录。所以应用中不能依赖该字段来确定总共有多少页，然后允许用户直接跳到最后一页。因为最后一页很有可能就不存在。</p>\n<p>为什么会出现这种情况呢？我们从以下几个概念开始说起。</p>\n<h2 id=\"CAP-理论\"><a href=\"#CAP-理论\" class=\"headerlink\" title=\"CAP 理论\"></a>CAP 理论</h2><p>CAP 理论由 Eric Brewer 教授提出：在设计和部署分布式应用时，存在以下三个核心的系统需求：一致性（Consistency），可用性（Availability）和分区容错性（Partition Tolerance）， <strong>针对特定数据，最多只能同时满足两个</strong>。<br><strong>一致性</strong>：又称为原子性或者事务性。表示一组操作是不可分割的，要么全部完成，不会出现部分完成的情况。<br><strong>可用性</strong>：是指系统能够很好的为用户服务，不会出现操作失败或者访问超时等用户体验不好的情况。可以通过数据冗余，负载均衡等手段实现。<br><strong>分区容错性</strong>：一个良好的分布式系统，在其中一个或者几个节点宕掉的情况下仍然能够工作。</p>\n<p>从这里可以大胆的猜测，YouTube 系统应该舍弃了一致性，保证了可用性和分区容错性。</p>\n<p>身为前端开发人员，还是更加看重这样的决策对前端的影响。</p>\n<p>1）就是不能使用传统的分页方式，可以采用无限滚动列表，或者只有“上一页”和“下一页”两个按钮的分页方式。在 BDP 项目中，我们使用无限列表的方式，当然是用这种方式的更大原因，电视机上没有鼠标操作，只有遥控器的上下左右键，而左右键被用切换页面，所以只能使用上下键来选择记录了。</p>\n<p>2）前端需要良好的容错机制。首先会假设 totalResults 字段是准确的，并显示给用户看。随着用户的操作，持续地发送请求获取更多记录，直到 ① 当前已经获取的记录数大于等于 totalResults，或者 ② 请求出错，就将 totalResults 修正为当前已经获取的记录的个数，并且比较圆润地处理错误，使得用户操作正常，就像没有出错一样。用户希望提前看到 totalResults，并不一定要看到一个准确的结果，多数时候他们需要的是个预期，大概多少条记录，我要滚动页面多长时间才能浏览一遍。</p>\n"},{"title":"Javascript的坑","_content":"\n以下题目摘自[饮水思源](http://bbs.sjtu.edu.cn/bbscon?board=WebDevelop&file=M.1371046203.A)。\n\n## 语言基础篇\n\n### 0. this 的指代\n\n```js\nfunction getThis() {\n    return this;\n}\nconsole.log(getThis.call(1) === 1);\nconsole.log(getThis.call('test') === 'test');\nconsole.log(getThis.call() === undefined);\nconsole.log(getThis.call(null) === null);\nconsole.log(getThis.call(false) === false);\n```\n\n> > 在 ECMA5 严格模式中，this 都会 call 和 apply 的第一个实参，哪怕传入的实参是原始值甚至是 null 或者 undefined。在 ECMA3 和非严格模式中，传入的 null 和 undefined 会被替换成全局对象。  \n> > 如果 call 和 apply 的第一个实参是原始类型，那么会先包装成对象。\n> > 所以以上 **全部 false**\n\n### 1. bind & call\n\n```js\nfunction getThisAndArguments() {\n    return { this: this, arguments: arguments };\n}\nconsole.log(\n    getThisAndArguments\n        .bind(1, 2)\n        .bind(3, 4)\n        .call(5, 6)\n);\n```\n\n> > bind 和 call 以及 apply 一样，如果第一个实参是原始类型，会包装成对象做为 this 的值。bind 一旦绑定 this 之后就不可以再次绑定，所以 this 最终指向一个 Number 对象，其原始值 1.  \n> > arguments 最终指向一个类似[2,4,6]的 Arguments 对象。\n\n### 2. 解释一下 fn 是做什么用的，以及它的声明语句为啥这么长。\n\n```js\nvar fn = Function.prototype.call.bind(Array.prototype.forEach);\nfn(document.querySelectorAll('*'), function(a) {\n    console.log(a);\n});\n```\n\n> > 如果说只看代码声明还不知道 fn 是干什么的话，那么看了 fn 的调用就可以肯定它是干什么的。  \n> > **不完全准确**地说，bind 就是将一个函数作为一个对象的成员函数来执行。所以以上代码等价于以下代码：\n\n```js\n// 该行代码是废话，可以忽略\nArray.prototype.forEach.call = Function.prototype.call;\n//\nArray.prototype.forEach.call(document.querySelectorAll('*'), function(a) {\n    console.log(a);\n});\n```\n\n> > 看到上面的代码相比大家都明白了。\n\n### 3. Object & Function\n\n结果分别是？解释一下\n\n```js\nconsole.log(Object instanceof Function);\nconsole.log(Function instanceof Object);\n```\n\n> > 因为可以调用`new Object()`，所以 Object 肯定是函数。另外任何对象都是 Object 的实例，包括 Object 自身。  \n> > 以上答案经过 Chrome 验证是正确的。\n\n## 实战篇\n\n以下题目是比较常见的场景，所以可能已经存在很好的 JS 库，请尽量不要参考。\n\n### 4.\n\n我们有一个 Node.js 爬虫，和一堆需要它去爬的连接，爬完后用 log()记录内容，现在\n请你改写这例子，控制爬虫并发请求数<=10。如果你能写出一个类似 Python\nmultiprocessing.Pool 的可复用的东西，有加分噢。\n\n```js\nvar urlArr = [...];\nvar url = urlArr[0];\ncrawl(url, callback(err, response){\n    log(url, response);\n});\n```\n\n### 5. 多层嵌套的优化\n\n我们要用 Nodejs 查询若干次数据库，生成一个简单的博客页面，请你把如下例子尽可能改得优雅些。如果你能实现一个可复用的东西，有加分噢~\n\n```js\ndb.getArticles(function(err, articles) {\n    if (err) return handle(err);\n    db.getTags(function(err, tags) {\n        if (err) return handle(err);\n        db.getCategories(function(err, categories) {\n            if (err) return handle(err);\n            db.getComments(function(err, comments) {\n                if (err) return handle(err);\n                render('index', {\n                    articles: articles,\n                    tags: tags,\n                    categories: categories,\n                    comments: comments,\n                });\n            });\n        });\n    });\n});\n```\n\n### 6.\n\n由于历史的原因，我们有一个很傻的异步 API：\n\n```js\nwindow.getSomeInfo = function(info){\n  console.log(info); //info.url 是请求的url\n};\nvar url = 'http://www.baidu.com/;\nwindow.external.getSomeInfo(url); //异步执行，请求完成后会调用window.getSomeInfo()\n```\n\n如你所见，这个 API 没法支持两对及以上的 url->callback 组合。你能不能改写出一个稍微灵活点的 wrapper？\n","source":"_posts/2013-06-20-Javascript-Trick.md","raw":"---\ntitle: Javascript的坑\n---\n\n以下题目摘自[饮水思源](http://bbs.sjtu.edu.cn/bbscon?board=WebDevelop&file=M.1371046203.A)。\n\n## 语言基础篇\n\n### 0. this 的指代\n\n```js\nfunction getThis() {\n    return this;\n}\nconsole.log(getThis.call(1) === 1);\nconsole.log(getThis.call('test') === 'test');\nconsole.log(getThis.call() === undefined);\nconsole.log(getThis.call(null) === null);\nconsole.log(getThis.call(false) === false);\n```\n\n> > 在 ECMA5 严格模式中，this 都会 call 和 apply 的第一个实参，哪怕传入的实参是原始值甚至是 null 或者 undefined。在 ECMA3 和非严格模式中，传入的 null 和 undefined 会被替换成全局对象。  \n> > 如果 call 和 apply 的第一个实参是原始类型，那么会先包装成对象。\n> > 所以以上 **全部 false**\n\n### 1. bind & call\n\n```js\nfunction getThisAndArguments() {\n    return { this: this, arguments: arguments };\n}\nconsole.log(\n    getThisAndArguments\n        .bind(1, 2)\n        .bind(3, 4)\n        .call(5, 6)\n);\n```\n\n> > bind 和 call 以及 apply 一样，如果第一个实参是原始类型，会包装成对象做为 this 的值。bind 一旦绑定 this 之后就不可以再次绑定，所以 this 最终指向一个 Number 对象，其原始值 1.  \n> > arguments 最终指向一个类似[2,4,6]的 Arguments 对象。\n\n### 2. 解释一下 fn 是做什么用的，以及它的声明语句为啥这么长。\n\n```js\nvar fn = Function.prototype.call.bind(Array.prototype.forEach);\nfn(document.querySelectorAll('*'), function(a) {\n    console.log(a);\n});\n```\n\n> > 如果说只看代码声明还不知道 fn 是干什么的话，那么看了 fn 的调用就可以肯定它是干什么的。  \n> > **不完全准确**地说，bind 就是将一个函数作为一个对象的成员函数来执行。所以以上代码等价于以下代码：\n\n```js\n// 该行代码是废话，可以忽略\nArray.prototype.forEach.call = Function.prototype.call;\n//\nArray.prototype.forEach.call(document.querySelectorAll('*'), function(a) {\n    console.log(a);\n});\n```\n\n> > 看到上面的代码相比大家都明白了。\n\n### 3. Object & Function\n\n结果分别是？解释一下\n\n```js\nconsole.log(Object instanceof Function);\nconsole.log(Function instanceof Object);\n```\n\n> > 因为可以调用`new Object()`，所以 Object 肯定是函数。另外任何对象都是 Object 的实例，包括 Object 自身。  \n> > 以上答案经过 Chrome 验证是正确的。\n\n## 实战篇\n\n以下题目是比较常见的场景，所以可能已经存在很好的 JS 库，请尽量不要参考。\n\n### 4.\n\n我们有一个 Node.js 爬虫，和一堆需要它去爬的连接，爬完后用 log()记录内容，现在\n请你改写这例子，控制爬虫并发请求数<=10。如果你能写出一个类似 Python\nmultiprocessing.Pool 的可复用的东西，有加分噢。\n\n```js\nvar urlArr = [...];\nvar url = urlArr[0];\ncrawl(url, callback(err, response){\n    log(url, response);\n});\n```\n\n### 5. 多层嵌套的优化\n\n我们要用 Nodejs 查询若干次数据库，生成一个简单的博客页面，请你把如下例子尽可能改得优雅些。如果你能实现一个可复用的东西，有加分噢~\n\n```js\ndb.getArticles(function(err, articles) {\n    if (err) return handle(err);\n    db.getTags(function(err, tags) {\n        if (err) return handle(err);\n        db.getCategories(function(err, categories) {\n            if (err) return handle(err);\n            db.getComments(function(err, comments) {\n                if (err) return handle(err);\n                render('index', {\n                    articles: articles,\n                    tags: tags,\n                    categories: categories,\n                    comments: comments,\n                });\n            });\n        });\n    });\n});\n```\n\n### 6.\n\n由于历史的原因，我们有一个很傻的异步 API：\n\n```js\nwindow.getSomeInfo = function(info){\n  console.log(info); //info.url 是请求的url\n};\nvar url = 'http://www.baidu.com/;\nwindow.external.getSomeInfo(url); //异步执行，请求完成后会调用window.getSomeInfo()\n```\n\n如你所见，这个 API 没法支持两对及以上的 url->callback 组合。你能不能改写出一个稍微灵活点的 wrapper？\n","slug":"Javascript-Trick","published":1,"date":"2013-06-19T16:00:00.000Z","updated":"2018-12-07T03:00:43.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9i000hw8wk0ignl1z7","content":"<p>以下题目摘自<a href=\"http://bbs.sjtu.edu.cn/bbscon?board=WebDevelop&amp;file=M.1371046203.A\" target=\"_blank\" rel=\"noopener\">饮水思源</a>。</p>\n<h2 id=\"语言基础篇\"><a href=\"#语言基础篇\" class=\"headerlink\" title=\"语言基础篇\"></a>语言基础篇</h2><h3 id=\"0-this-的指代\"><a href=\"#0-this-的指代\" class=\"headerlink\" title=\"0. this 的指代\"></a>0. this 的指代</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getThis</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call(<span class=\"number\">1</span>) === <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call(<span class=\"string\">'test'</span>) === <span class=\"string\">'test'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call() === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call(<span class=\"literal\">null</span>) === <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call(<span class=\"literal\">false</span>) === <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>在 ECMA5 严格模式中，this 都会 call 和 apply 的第一个实参，哪怕传入的实参是原始值甚至是 null 或者 undefined。在 ECMA3 和非严格模式中，传入的 null 和 undefined 会被替换成全局对象。<br>如果 call 和 apply 的第一个实参是原始类型，那么会先包装成对象。<br>所以以上 <strong>全部 false</strong></p>\n</blockquote>\n</blockquote>\n<h3 id=\"1-bind-amp-call\"><a href=\"#1-bind-amp-call\" class=\"headerlink\" title=\"1. bind &amp; call\"></a>1. bind &amp; call</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getThisAndArguments</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">this</span>: <span class=\"keyword\">this</span>, <span class=\"attr\">arguments</span>: <span class=\"built_in\">arguments</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">    getThisAndArguments</span><br><span class=\"line\">        .bind(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">        .bind(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">        .call(<span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>bind 和 call 以及 apply 一样，如果第一个实参是原始类型，会包装成对象做为 this 的值。bind 一旦绑定 this 之后就不可以再次绑定，所以 this 最终指向一个 Number 对象，其原始值 1.<br>arguments 最终指向一个类似[2,4,6]的 Arguments 对象。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"2-解释一下-fn-是做什么用的，以及它的声明语句为啥这么长。\"><a href=\"#2-解释一下-fn-是做什么用的，以及它的声明语句为啥这么长。\" class=\"headerlink\" title=\"2. 解释一下 fn 是做什么用的，以及它的声明语句为啥这么长。\"></a>2. 解释一下 fn 是做什么用的，以及它的声明语句为啥这么长。</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"built_in\">Function</span>.prototype.call.bind(<span class=\"built_in\">Array</span>.prototype.forEach);</span><br><span class=\"line\">fn(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'*'</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>如果说只看代码声明还不知道 fn 是干什么的话，那么看了 fn 的调用就可以肯定它是干什么的。<br><strong>不完全准确</strong>地说，bind 就是将一个函数作为一个对象的成员函数来执行。所以以上代码等价于以下代码：</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 该行代码是废话，可以忽略</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.forEach.call = <span class=\"built_in\">Function</span>.prototype.call;</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.forEach.call(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'*'</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>看到上面的代码相比大家都明白了。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"3-Object-amp-Function\"><a href=\"#3-Object-amp-Function\" class=\"headerlink\" title=\"3. Object &amp; Function\"></a>3. Object &amp; Function</h3><p>结果分别是？解释一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>因为可以调用<code>new Object()</code>，所以 Object 肯定是函数。另外任何对象都是 Object 的实例，包括 Object 自身。<br>以上答案经过 Chrome 验证是正确的。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"实战篇\"><a href=\"#实战篇\" class=\"headerlink\" title=\"实战篇\"></a>实战篇</h2><p>以下题目是比较常见的场景，所以可能已经存在很好的 JS 库，请尽量不要参考。</p>\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h3><p>我们有一个 Node.js 爬虫，和一堆需要它去爬的连接，爬完后用 log()记录内容，现在<br>请你改写这例子，控制爬虫并发请求数&lt;=10。如果你能写出一个类似 Python<br>multiprocessing.Pool 的可复用的东西，有加分噢。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> urlArr = [...];</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = urlArr[<span class=\"number\">0</span>];</span><br><span class=\"line\">crawl(url, callback(err, response)&#123;</span><br><span class=\"line\">    log(url, response);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-多层嵌套的优化\"><a href=\"#5-多层嵌套的优化\" class=\"headerlink\" title=\"5. 多层嵌套的优化\"></a>5. 多层嵌套的优化</h3><p>我们要用 Nodejs 查询若干次数据库，生成一个简单的博客页面，请你把如下例子尽可能改得优雅些。如果你能实现一个可复用的东西，有加分噢~</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getArticles(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, articles</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handle(err);</span><br><span class=\"line\">    db.getTags(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, tags</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handle(err);</span><br><span class=\"line\">        db.getCategories(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, categories</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handle(err);</span><br><span class=\"line\">            db.getComments(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, comments</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handle(err);</span><br><span class=\"line\">                render(<span class=\"string\">'index'</span>, &#123;</span><br><span class=\"line\">                    articles: articles,</span><br><span class=\"line\">                    tags: tags,</span><br><span class=\"line\">                    categories: categories,</span><br><span class=\"line\">                    comments: comments,</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6.\"></a>6.</h3><p>由于历史的原因，我们有一个很傻的异步 API：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.getSomeInfo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">info</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(info); <span class=\"comment\">//info.url 是请求的url</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://www.baidu.com/;</span></span><br><span class=\"line\"><span class=\"string\">window.external.getSomeInfo(url); //异步执行，请求完成后会调用window.getSomeInfo()</span></span><br></pre></td></tr></table></figure>\n<p>如你所见，这个 API 没法支持两对及以上的 url-&gt;callback 组合。你能不能改写出一个稍微灵活点的 wrapper？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以下题目摘自<a href=\"http://bbs.sjtu.edu.cn/bbscon?board=WebDevelop&amp;file=M.1371046203.A\" target=\"_blank\" rel=\"noopener\">饮水思源</a>。</p>\n<h2 id=\"语言基础篇\"><a href=\"#语言基础篇\" class=\"headerlink\" title=\"语言基础篇\"></a>语言基础篇</h2><h3 id=\"0-this-的指代\"><a href=\"#0-this-的指代\" class=\"headerlink\" title=\"0. this 的指代\"></a>0. this 的指代</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getThis</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call(<span class=\"number\">1</span>) === <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call(<span class=\"string\">'test'</span>) === <span class=\"string\">'test'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call() === <span class=\"literal\">undefined</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call(<span class=\"literal\">null</span>) === <span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getThis.call(<span class=\"literal\">false</span>) === <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>在 ECMA5 严格模式中，this 都会 call 和 apply 的第一个实参，哪怕传入的实参是原始值甚至是 null 或者 undefined。在 ECMA3 和非严格模式中，传入的 null 和 undefined 会被替换成全局对象。<br>如果 call 和 apply 的第一个实参是原始类型，那么会先包装成对象。<br>所以以上 <strong>全部 false</strong></p>\n</blockquote>\n</blockquote>\n<h3 id=\"1-bind-amp-call\"><a href=\"#1-bind-amp-call\" class=\"headerlink\" title=\"1. bind &amp; call\"></a>1. bind &amp; call</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getThisAndArguments</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">this</span>: <span class=\"keyword\">this</span>, <span class=\"attr\">arguments</span>: <span class=\"built_in\">arguments</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(</span><br><span class=\"line\">    getThisAndArguments</span><br><span class=\"line\">        .bind(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">        .bind(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">        .call(<span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>bind 和 call 以及 apply 一样，如果第一个实参是原始类型，会包装成对象做为 this 的值。bind 一旦绑定 this 之后就不可以再次绑定，所以 this 最终指向一个 Number 对象，其原始值 1.<br>arguments 最终指向一个类似[2,4,6]的 Arguments 对象。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"2-解释一下-fn-是做什么用的，以及它的声明语句为啥这么长。\"><a href=\"#2-解释一下-fn-是做什么用的，以及它的声明语句为啥这么长。\" class=\"headerlink\" title=\"2. 解释一下 fn 是做什么用的，以及它的声明语句为啥这么长。\"></a>2. 解释一下 fn 是做什么用的，以及它的声明语句为啥这么长。</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"built_in\">Function</span>.prototype.call.bind(<span class=\"built_in\">Array</span>.prototype.forEach);</span><br><span class=\"line\">fn(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'*'</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>如果说只看代码声明还不知道 fn 是干什么的话，那么看了 fn 的调用就可以肯定它是干什么的。<br><strong>不完全准确</strong>地说，bind 就是将一个函数作为一个对象的成员函数来执行。所以以上代码等价于以下代码：</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 该行代码是废话，可以忽略</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.forEach.call = <span class=\"built_in\">Function</span>.prototype.call;</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.forEach.call(<span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'*'</span>), <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>看到上面的代码相比大家都明白了。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"3-Object-amp-Function\"><a href=\"#3-Object-amp-Function\" class=\"headerlink\" title=\"3. Object &amp; Function\"></a>3. Object &amp; Function</h3><p>结果分别是？解释一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Function</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>因为可以调用<code>new Object()</code>，所以 Object 肯定是函数。另外任何对象都是 Object 的实例，包括 Object 自身。<br>以上答案经过 Chrome 验证是正确的。</p>\n</blockquote>\n</blockquote>\n<h2 id=\"实战篇\"><a href=\"#实战篇\" class=\"headerlink\" title=\"实战篇\"></a>实战篇</h2><p>以下题目是比较常见的场景，所以可能已经存在很好的 JS 库，请尽量不要参考。</p>\n<h3 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h3><p>我们有一个 Node.js 爬虫，和一堆需要它去爬的连接，爬完后用 log()记录内容，现在<br>请你改写这例子，控制爬虫并发请求数&lt;=10。如果你能写出一个类似 Python<br>multiprocessing.Pool 的可复用的东西，有加分噢。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> urlArr = [...];</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = urlArr[<span class=\"number\">0</span>];</span><br><span class=\"line\">crawl(url, callback(err, response)&#123;</span><br><span class=\"line\">    log(url, response);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-多层嵌套的优化\"><a href=\"#5-多层嵌套的优化\" class=\"headerlink\" title=\"5. 多层嵌套的优化\"></a>5. 多层嵌套的优化</h3><p>我们要用 Nodejs 查询若干次数据库，生成一个简单的博客页面，请你把如下例子尽可能改得优雅些。如果你能实现一个可复用的东西，有加分噢~</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.getArticles(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, articles</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handle(err);</span><br><span class=\"line\">    db.getTags(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, tags</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handle(err);</span><br><span class=\"line\">        db.getCategories(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, categories</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handle(err);</span><br><span class=\"line\">            db.getComments(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, comments</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> handle(err);</span><br><span class=\"line\">                render(<span class=\"string\">'index'</span>, &#123;</span><br><span class=\"line\">                    articles: articles,</span><br><span class=\"line\">                    tags: tags,</span><br><span class=\"line\">                    categories: categories,</span><br><span class=\"line\">                    comments: comments,</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6.\"></a>6.</h3><p>由于历史的原因，我们有一个很傻的异步 API：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.getSomeInfo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">info</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(info); <span class=\"comment\">//info.url 是请求的url</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://www.baidu.com/;</span></span><br><span class=\"line\"><span class=\"string\">window.external.getSomeInfo(url); //异步执行，请求完成后会调用window.getSomeInfo()</span></span><br></pre></td></tr></table></figure>\n<p>如你所见，这个 API 没法支持两对及以上的 url-&gt;callback 组合。你能不能改写出一个稍微灵活点的 wrapper？</p>\n"},{"title":"一些有意思的交互设计","_content":"\n### 1. 网易邮箱\n\n**当用户在很短的时间内三次点击“收信”按钮之后，如果还没有收到新邮件，系统提示用户注意查看“垃圾邮件”。**  \n当用户做出这样的动作时，基本都是用户被其他系统提示给他发送了一封邮件，然后用户急于查看邮件内容。如果该邮箱启动了垃圾邮件过滤功能，那么在多次刷新无果的情况下，就有可能是被当做垃圾邮件处理了，所以给出用户一种提示。这是几年前我注意到的交互行为，但是现在消失了。不知道是网易对自己的垃圾邮件判断准确率得到了大幅提高，还是其他原因，就不得而知了。\n\n### 2. 隐藏的菜单\n\n在一些系统中，受到设备尺寸的限制或者是设计上的权衡，最后将菜单隐藏或者最小化处理。那么怎么才能告诉用户这里有菜单呢？有种做法在系统启动时，将执行**菜单从隐藏渐变到完全显示再渐变到隐藏**这样一个动画效果，以提示用户这里有个菜单，可以点击（或滑动）附近区域来显示菜单。  \n这样也有一个问题，每次启动系统或者页面刷新时都会执行这样的动画会对用户造成一定骚扰。首先就是动画执行要快，不要影响用户的正常操作，然后就是当用户第一次弹出菜单以后，我们就认为用户学会了如何弹出菜单，以后就不再显示该动画效果。  \n为什么会想到这样一个案例呢，是因为前几天午饭时，一个同事谈起他的新手机，底部 Back，Home，Settings 等菜单突然找不到了，重启机器也不会出现。然后上网搜索才知道是被不小心手指下滑隐藏了菜单，需要手指上滑来显示菜单。试想如果在用户重启以后会有上述的动画效果，或许能够提示用户。\n\n### 3. 鲸鱼岛的冬天\n\n（摘自程序员杂志 201209 P71）\n将游戏首页加上模糊处理，使它看起来像是玻璃上结了一层水雾。小朋友都会很自然的去擦，从而获得清晰的页面。据说很多小朋友都把整个页面擦干净才开始游戏。  \nABCKit 等知名应用的开发者 Karina Ibarra 在 Designing Apps For Kids 一文中提出了儿童应用的设计要点：简短的启动画面（儿童缺乏耐心）、首页的设计（低龄儿童难以被其吸引）、应用相关设置简单（防止儿童误操作）、从大处着眼（易于识别）、任务机制简单（易用性原则）以及随时的赞美和鼓励。  \n孩子如果想重启或者恢复一个游戏，故事或者活动时，他们不会按返回键来恢复游戏或者返回主页，大多数孩子会直接按下 iPad 或 iPhone 的 Home 键，先退出游戏，再重新开始游戏。\n","source":"_posts/2013-06-22-Some-Interesting-Interactive.md","raw":"---\ntitle: 一些有意思的交互设计\n---\n\n### 1. 网易邮箱\n\n**当用户在很短的时间内三次点击“收信”按钮之后，如果还没有收到新邮件，系统提示用户注意查看“垃圾邮件”。**  \n当用户做出这样的动作时，基本都是用户被其他系统提示给他发送了一封邮件，然后用户急于查看邮件内容。如果该邮箱启动了垃圾邮件过滤功能，那么在多次刷新无果的情况下，就有可能是被当做垃圾邮件处理了，所以给出用户一种提示。这是几年前我注意到的交互行为，但是现在消失了。不知道是网易对自己的垃圾邮件判断准确率得到了大幅提高，还是其他原因，就不得而知了。\n\n### 2. 隐藏的菜单\n\n在一些系统中，受到设备尺寸的限制或者是设计上的权衡，最后将菜单隐藏或者最小化处理。那么怎么才能告诉用户这里有菜单呢？有种做法在系统启动时，将执行**菜单从隐藏渐变到完全显示再渐变到隐藏**这样一个动画效果，以提示用户这里有个菜单，可以点击（或滑动）附近区域来显示菜单。  \n这样也有一个问题，每次启动系统或者页面刷新时都会执行这样的动画会对用户造成一定骚扰。首先就是动画执行要快，不要影响用户的正常操作，然后就是当用户第一次弹出菜单以后，我们就认为用户学会了如何弹出菜单，以后就不再显示该动画效果。  \n为什么会想到这样一个案例呢，是因为前几天午饭时，一个同事谈起他的新手机，底部 Back，Home，Settings 等菜单突然找不到了，重启机器也不会出现。然后上网搜索才知道是被不小心手指下滑隐藏了菜单，需要手指上滑来显示菜单。试想如果在用户重启以后会有上述的动画效果，或许能够提示用户。\n\n### 3. 鲸鱼岛的冬天\n\n（摘自程序员杂志 201209 P71）\n将游戏首页加上模糊处理，使它看起来像是玻璃上结了一层水雾。小朋友都会很自然的去擦，从而获得清晰的页面。据说很多小朋友都把整个页面擦干净才开始游戏。  \nABCKit 等知名应用的开发者 Karina Ibarra 在 Designing Apps For Kids 一文中提出了儿童应用的设计要点：简短的启动画面（儿童缺乏耐心）、首页的设计（低龄儿童难以被其吸引）、应用相关设置简单（防止儿童误操作）、从大处着眼（易于识别）、任务机制简单（易用性原则）以及随时的赞美和鼓励。  \n孩子如果想重启或者恢复一个游戏，故事或者活动时，他们不会按返回键来恢复游戏或者返回主页，大多数孩子会直接按下 iPad 或 iPhone 的 Home 键，先退出游戏，再重新开始游戏。\n","slug":"Some-Interesting-Interactive","published":1,"date":"2013-06-21T16:00:00.000Z","updated":"2018-12-07T03:00:39.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9j000iw8wkxb7zuf1b","content":"<h3 id=\"1-网易邮箱\"><a href=\"#1-网易邮箱\" class=\"headerlink\" title=\"1. 网易邮箱\"></a>1. 网易邮箱</h3><p><strong>当用户在很短的时间内三次点击“收信”按钮之后，如果还没有收到新邮件，系统提示用户注意查看“垃圾邮件”。</strong><br>当用户做出这样的动作时，基本都是用户被其他系统提示给他发送了一封邮件，然后用户急于查看邮件内容。如果该邮箱启动了垃圾邮件过滤功能，那么在多次刷新无果的情况下，就有可能是被当做垃圾邮件处理了，所以给出用户一种提示。这是几年前我注意到的交互行为，但是现在消失了。不知道是网易对自己的垃圾邮件判断准确率得到了大幅提高，还是其他原因，就不得而知了。</p>\n<h3 id=\"2-隐藏的菜单\"><a href=\"#2-隐藏的菜单\" class=\"headerlink\" title=\"2. 隐藏的菜单\"></a>2. 隐藏的菜单</h3><p>在一些系统中，受到设备尺寸的限制或者是设计上的权衡，最后将菜单隐藏或者最小化处理。那么怎么才能告诉用户这里有菜单呢？有种做法在系统启动时，将执行<strong>菜单从隐藏渐变到完全显示再渐变到隐藏</strong>这样一个动画效果，以提示用户这里有个菜单，可以点击（或滑动）附近区域来显示菜单。<br>这样也有一个问题，每次启动系统或者页面刷新时都会执行这样的动画会对用户造成一定骚扰。首先就是动画执行要快，不要影响用户的正常操作，然后就是当用户第一次弹出菜单以后，我们就认为用户学会了如何弹出菜单，以后就不再显示该动画效果。<br>为什么会想到这样一个案例呢，是因为前几天午饭时，一个同事谈起他的新手机，底部 Back，Home，Settings 等菜单突然找不到了，重启机器也不会出现。然后上网搜索才知道是被不小心手指下滑隐藏了菜单，需要手指上滑来显示菜单。试想如果在用户重启以后会有上述的动画效果，或许能够提示用户。</p>\n<h3 id=\"3-鲸鱼岛的冬天\"><a href=\"#3-鲸鱼岛的冬天\" class=\"headerlink\" title=\"3. 鲸鱼岛的冬天\"></a>3. 鲸鱼岛的冬天</h3><p>（摘自程序员杂志 201209 P71）<br>将游戏首页加上模糊处理，使它看起来像是玻璃上结了一层水雾。小朋友都会很自然的去擦，从而获得清晰的页面。据说很多小朋友都把整个页面擦干净才开始游戏。<br>ABCKit 等知名应用的开发者 Karina Ibarra 在 Designing Apps For Kids 一文中提出了儿童应用的设计要点：简短的启动画面（儿童缺乏耐心）、首页的设计（低龄儿童难以被其吸引）、应用相关设置简单（防止儿童误操作）、从大处着眼（易于识别）、任务机制简单（易用性原则）以及随时的赞美和鼓励。<br>孩子如果想重启或者恢复一个游戏，故事或者活动时，他们不会按返回键来恢复游戏或者返回主页，大多数孩子会直接按下 iPad 或 iPhone 的 Home 键，先退出游戏，再重新开始游戏。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-网易邮箱\"><a href=\"#1-网易邮箱\" class=\"headerlink\" title=\"1. 网易邮箱\"></a>1. 网易邮箱</h3><p><strong>当用户在很短的时间内三次点击“收信”按钮之后，如果还没有收到新邮件，系统提示用户注意查看“垃圾邮件”。</strong><br>当用户做出这样的动作时，基本都是用户被其他系统提示给他发送了一封邮件，然后用户急于查看邮件内容。如果该邮箱启动了垃圾邮件过滤功能，那么在多次刷新无果的情况下，就有可能是被当做垃圾邮件处理了，所以给出用户一种提示。这是几年前我注意到的交互行为，但是现在消失了。不知道是网易对自己的垃圾邮件判断准确率得到了大幅提高，还是其他原因，就不得而知了。</p>\n<h3 id=\"2-隐藏的菜单\"><a href=\"#2-隐藏的菜单\" class=\"headerlink\" title=\"2. 隐藏的菜单\"></a>2. 隐藏的菜单</h3><p>在一些系统中，受到设备尺寸的限制或者是设计上的权衡，最后将菜单隐藏或者最小化处理。那么怎么才能告诉用户这里有菜单呢？有种做法在系统启动时，将执行<strong>菜单从隐藏渐变到完全显示再渐变到隐藏</strong>这样一个动画效果，以提示用户这里有个菜单，可以点击（或滑动）附近区域来显示菜单。<br>这样也有一个问题，每次启动系统或者页面刷新时都会执行这样的动画会对用户造成一定骚扰。首先就是动画执行要快，不要影响用户的正常操作，然后就是当用户第一次弹出菜单以后，我们就认为用户学会了如何弹出菜单，以后就不再显示该动画效果。<br>为什么会想到这样一个案例呢，是因为前几天午饭时，一个同事谈起他的新手机，底部 Back，Home，Settings 等菜单突然找不到了，重启机器也不会出现。然后上网搜索才知道是被不小心手指下滑隐藏了菜单，需要手指上滑来显示菜单。试想如果在用户重启以后会有上述的动画效果，或许能够提示用户。</p>\n<h3 id=\"3-鲸鱼岛的冬天\"><a href=\"#3-鲸鱼岛的冬天\" class=\"headerlink\" title=\"3. 鲸鱼岛的冬天\"></a>3. 鲸鱼岛的冬天</h3><p>（摘自程序员杂志 201209 P71）<br>将游戏首页加上模糊处理，使它看起来像是玻璃上结了一层水雾。小朋友都会很自然的去擦，从而获得清晰的页面。据说很多小朋友都把整个页面擦干净才开始游戏。<br>ABCKit 等知名应用的开发者 Karina Ibarra 在 Designing Apps For Kids 一文中提出了儿童应用的设计要点：简短的启动画面（儿童缺乏耐心）、首页的设计（低龄儿童难以被其吸引）、应用相关设置简单（防止儿童误操作）、从大处着眼（易于识别）、任务机制简单（易用性原则）以及随时的赞美和鼓励。<br>孩子如果想重启或者恢复一个游戏，故事或者活动时，他们不会按返回键来恢复游戏或者返回主页，大多数孩子会直接按下 iPad 或 iPhone 的 Home 键，先退出游戏，再重新开始游戏。</p>\n"},{"title":"没有后端的应用","_content":"\n在 infoQ 上这篇文章[不用后端：noBackend 是什么？有什么好处？](http://www.infoq.com/cn/news/2013/06/wangtao-on-nobackend)，阿里的王涛对这种没有后端的架构做了介绍和探讨。以下是文章引言。\n\n> > 在近期举办的[前端趋势 2013](http://2013.front-trends.com/)大会上，Gregor Martynus 做了一场题为“[各位快看，不用后端！](https://speakerdeck.com/gr2m/look-ma-no-backend)”的报告，站在前端的视角谈应用开发，服务端组件只退化到实现浏览器尚不支持的特性，这种方式与传统开发方式截然相反，后者首先要关注应用服务端，然后再利用前端技巧来提升应用。他们还建了一个名为[noBackend 的网站](http://nobackend.org/)来深入传播这种理念。\n\n王涛认为：这种模式给了前端开发人员更大的挑战和机遇。这种模式也不是横空出世的，它是经历了后端为主，前后端分离的阶段之后的另一个发展方向。当前前后端分离的模式正在大规模使用中。\n\n诚然，在当前流行的前后端分离开发的模式中，也越来越体现出这种模式，前端越来越重，对于安全性，机密性不强的逻辑都慢慢地放到前端来做。在我第二家雇主做的那款网页游戏中也很有体现。前后端的人员比例已经在 1：1，很多公司会更高，前端开发不仅要处理 UI，还要处理越来越多的业务逻辑。很多时候前端逻辑和后端逻辑有很大的重复。前端用于快速响应用户行为，后端用于验证后保存到数据库。比如根据当前属性，能不能穿上某种装备。前端判断可以，那么就让用户穿上装备，并且通知后端。后端判断可以，就保存到数据库，如果不可以（可能是用户使用外挂修改了自身属性），就返回错误让前端取消刚才的行为。\n\n前面我们提到很多应用中，后端就相当于是个数据库，前端才是应用的主体，有着完整的业务逻辑。但是后端着不可替代的验证作用。检验用户数据格式，数值，用户有没有作弊，以及保存到数据库中。\n\n所以这种没有后端的模式比较适合于这样的情况：\n\n(1)用户于用户之间没有关系的应用。比如 TODO List 等。一个人数据一般不会共享给其他人，也不会对其他人有任何影响，此时我们完全可以完全相信前端传来的数据。后端就完全退化成数据库，仅仅有着数据存储的功能了。\n\n(2)应用所有的操作都是比较通用的，云服务已经提供了这样的接口，比如博客应用，对文章的增删改查，博主的个人页面。在 Gregor Martynus 的讲稿中还有信用卡付费等接口，相信越来越多的操作会集成到这些云服务中，会有越来越多的应用适合种没有后端的模式。\n\n对于不少应用中，可能不是所有的数据都能满足以上条件，那么也可以仅仅将这部分数据拆分出来，减少后端人力的投入。对于以上模式，个人也是充满期待。\n","source":"_posts/2013-06-30-No-Backend.md","raw":"---\ntitle: 没有后端的应用\n---\n\n在 infoQ 上这篇文章[不用后端：noBackend 是什么？有什么好处？](http://www.infoq.com/cn/news/2013/06/wangtao-on-nobackend)，阿里的王涛对这种没有后端的架构做了介绍和探讨。以下是文章引言。\n\n> > 在近期举办的[前端趋势 2013](http://2013.front-trends.com/)大会上，Gregor Martynus 做了一场题为“[各位快看，不用后端！](https://speakerdeck.com/gr2m/look-ma-no-backend)”的报告，站在前端的视角谈应用开发，服务端组件只退化到实现浏览器尚不支持的特性，这种方式与传统开发方式截然相反，后者首先要关注应用服务端，然后再利用前端技巧来提升应用。他们还建了一个名为[noBackend 的网站](http://nobackend.org/)来深入传播这种理念。\n\n王涛认为：这种模式给了前端开发人员更大的挑战和机遇。这种模式也不是横空出世的，它是经历了后端为主，前后端分离的阶段之后的另一个发展方向。当前前后端分离的模式正在大规模使用中。\n\n诚然，在当前流行的前后端分离开发的模式中，也越来越体现出这种模式，前端越来越重，对于安全性，机密性不强的逻辑都慢慢地放到前端来做。在我第二家雇主做的那款网页游戏中也很有体现。前后端的人员比例已经在 1：1，很多公司会更高，前端开发不仅要处理 UI，还要处理越来越多的业务逻辑。很多时候前端逻辑和后端逻辑有很大的重复。前端用于快速响应用户行为，后端用于验证后保存到数据库。比如根据当前属性，能不能穿上某种装备。前端判断可以，那么就让用户穿上装备，并且通知后端。后端判断可以，就保存到数据库，如果不可以（可能是用户使用外挂修改了自身属性），就返回错误让前端取消刚才的行为。\n\n前面我们提到很多应用中，后端就相当于是个数据库，前端才是应用的主体，有着完整的业务逻辑。但是后端着不可替代的验证作用。检验用户数据格式，数值，用户有没有作弊，以及保存到数据库中。\n\n所以这种没有后端的模式比较适合于这样的情况：\n\n(1)用户于用户之间没有关系的应用。比如 TODO List 等。一个人数据一般不会共享给其他人，也不会对其他人有任何影响，此时我们完全可以完全相信前端传来的数据。后端就完全退化成数据库，仅仅有着数据存储的功能了。\n\n(2)应用所有的操作都是比较通用的，云服务已经提供了这样的接口，比如博客应用，对文章的增删改查，博主的个人页面。在 Gregor Martynus 的讲稿中还有信用卡付费等接口，相信越来越多的操作会集成到这些云服务中，会有越来越多的应用适合种没有后端的模式。\n\n对于不少应用中，可能不是所有的数据都能满足以上条件，那么也可以仅仅将这部分数据拆分出来，减少后端人力的投入。对于以上模式，个人也是充满期待。\n","slug":"No-Backend","published":1,"date":"2013-06-29T16:00:00.000Z","updated":"2018-12-07T03:00:21.245Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9k000jw8wk49uvpaqs","content":"<p>在 infoQ 上这篇文章<a href=\"http://www.infoq.com/cn/news/2013/06/wangtao-on-nobackend\" target=\"_blank\" rel=\"noopener\">不用后端：noBackend 是什么？有什么好处？</a>，阿里的王涛对这种没有后端的架构做了介绍和探讨。以下是文章引言。</p>\n<blockquote>\n<blockquote>\n<p>在近期举办的<a href=\"http://2013.front-trends.com/\" target=\"_blank\" rel=\"noopener\">前端趋势 2013</a>大会上，Gregor Martynus 做了一场题为“<a href=\"https://speakerdeck.com/gr2m/look-ma-no-backend\" target=\"_blank\" rel=\"noopener\">各位快看，不用后端！</a>”的报告，站在前端的视角谈应用开发，服务端组件只退化到实现浏览器尚不支持的特性，这种方式与传统开发方式截然相反，后者首先要关注应用服务端，然后再利用前端技巧来提升应用。他们还建了一个名为<a href=\"http://nobackend.org/\" target=\"_blank\" rel=\"noopener\">noBackend 的网站</a>来深入传播这种理念。</p>\n</blockquote>\n</blockquote>\n<p>王涛认为：这种模式给了前端开发人员更大的挑战和机遇。这种模式也不是横空出世的，它是经历了后端为主，前后端分离的阶段之后的另一个发展方向。当前前后端分离的模式正在大规模使用中。</p>\n<p>诚然，在当前流行的前后端分离开发的模式中，也越来越体现出这种模式，前端越来越重，对于安全性，机密性不强的逻辑都慢慢地放到前端来做。在我第二家雇主做的那款网页游戏中也很有体现。前后端的人员比例已经在 1：1，很多公司会更高，前端开发不仅要处理 UI，还要处理越来越多的业务逻辑。很多时候前端逻辑和后端逻辑有很大的重复。前端用于快速响应用户行为，后端用于验证后保存到数据库。比如根据当前属性，能不能穿上某种装备。前端判断可以，那么就让用户穿上装备，并且通知后端。后端判断可以，就保存到数据库，如果不可以（可能是用户使用外挂修改了自身属性），就返回错误让前端取消刚才的行为。</p>\n<p>前面我们提到很多应用中，后端就相当于是个数据库，前端才是应用的主体，有着完整的业务逻辑。但是后端着不可替代的验证作用。检验用户数据格式，数值，用户有没有作弊，以及保存到数据库中。</p>\n<p>所以这种没有后端的模式比较适合于这样的情况：</p>\n<p>(1)用户于用户之间没有关系的应用。比如 TODO List 等。一个人数据一般不会共享给其他人，也不会对其他人有任何影响，此时我们完全可以完全相信前端传来的数据。后端就完全退化成数据库，仅仅有着数据存储的功能了。</p>\n<p>(2)应用所有的操作都是比较通用的，云服务已经提供了这样的接口，比如博客应用，对文章的增删改查，博主的个人页面。在 Gregor Martynus 的讲稿中还有信用卡付费等接口，相信越来越多的操作会集成到这些云服务中，会有越来越多的应用适合种没有后端的模式。</p>\n<p>对于不少应用中，可能不是所有的数据都能满足以上条件，那么也可以仅仅将这部分数据拆分出来，减少后端人力的投入。对于以上模式，个人也是充满期待。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 infoQ 上这篇文章<a href=\"http://www.infoq.com/cn/news/2013/06/wangtao-on-nobackend\" target=\"_blank\" rel=\"noopener\">不用后端：noBackend 是什么？有什么好处？</a>，阿里的王涛对这种没有后端的架构做了介绍和探讨。以下是文章引言。</p>\n<blockquote>\n<blockquote>\n<p>在近期举办的<a href=\"http://2013.front-trends.com/\" target=\"_blank\" rel=\"noopener\">前端趋势 2013</a>大会上，Gregor Martynus 做了一场题为“<a href=\"https://speakerdeck.com/gr2m/look-ma-no-backend\" target=\"_blank\" rel=\"noopener\">各位快看，不用后端！</a>”的报告，站在前端的视角谈应用开发，服务端组件只退化到实现浏览器尚不支持的特性，这种方式与传统开发方式截然相反，后者首先要关注应用服务端，然后再利用前端技巧来提升应用。他们还建了一个名为<a href=\"http://nobackend.org/\" target=\"_blank\" rel=\"noopener\">noBackend 的网站</a>来深入传播这种理念。</p>\n</blockquote>\n</blockquote>\n<p>王涛认为：这种模式给了前端开发人员更大的挑战和机遇。这种模式也不是横空出世的，它是经历了后端为主，前后端分离的阶段之后的另一个发展方向。当前前后端分离的模式正在大规模使用中。</p>\n<p>诚然，在当前流行的前后端分离开发的模式中，也越来越体现出这种模式，前端越来越重，对于安全性，机密性不强的逻辑都慢慢地放到前端来做。在我第二家雇主做的那款网页游戏中也很有体现。前后端的人员比例已经在 1：1，很多公司会更高，前端开发不仅要处理 UI，还要处理越来越多的业务逻辑。很多时候前端逻辑和后端逻辑有很大的重复。前端用于快速响应用户行为，后端用于验证后保存到数据库。比如根据当前属性，能不能穿上某种装备。前端判断可以，那么就让用户穿上装备，并且通知后端。后端判断可以，就保存到数据库，如果不可以（可能是用户使用外挂修改了自身属性），就返回错误让前端取消刚才的行为。</p>\n<p>前面我们提到很多应用中，后端就相当于是个数据库，前端才是应用的主体，有着完整的业务逻辑。但是后端着不可替代的验证作用。检验用户数据格式，数值，用户有没有作弊，以及保存到数据库中。</p>\n<p>所以这种没有后端的模式比较适合于这样的情况：</p>\n<p>(1)用户于用户之间没有关系的应用。比如 TODO List 等。一个人数据一般不会共享给其他人，也不会对其他人有任何影响，此时我们完全可以完全相信前端传来的数据。后端就完全退化成数据库，仅仅有着数据存储的功能了。</p>\n<p>(2)应用所有的操作都是比较通用的，云服务已经提供了这样的接口，比如博客应用，对文章的增删改查，博主的个人页面。在 Gregor Martynus 的讲稿中还有信用卡付费等接口，相信越来越多的操作会集成到这些云服务中，会有越来越多的应用适合种没有后端的模式。</p>\n<p>对于不少应用中，可能不是所有的数据都能满足以上条件，那么也可以仅仅将这部分数据拆分出来，减少后端人力的投入。对于以上模式，个人也是充满期待。</p>\n"},{"title":"API设计","_content":"\nhttp://www.infoq.com/cn/news/2013/09/mamund-on-api-design\n\n这里谈到的 API 是指应用程序中不同模块之间的接口。它一般包含函数名，若干形参和一个返回值。\n","source":"_posts/2013-07-19-API-Design.md","raw":"---\ntitle: API设计\n---\n\nhttp://www.infoq.com/cn/news/2013/09/mamund-on-api-design\n\n这里谈到的 API 是指应用程序中不同模块之间的接口。它一般包含函数名，若干形参和一个返回值。\n","slug":"API-Design","published":1,"date":"2013-07-18T16:00:00.000Z","updated":"2018-12-07T03:00:11.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9k000kw8wk1k15ie7u","content":"<p><a href=\"http://www.infoq.com/cn/news/2013/09/mamund-on-api-design\" target=\"_blank\" rel=\"noopener\">http://www.infoq.com/cn/news/2013/09/mamund-on-api-design</a></p>\n<p>这里谈到的 API 是指应用程序中不同模块之间的接口。它一般包含函数名，若干形参和一个返回值。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.infoq.com/cn/news/2013/09/mamund-on-api-design\" target=\"_blank\" rel=\"noopener\">http://www.infoq.com/cn/news/2013/09/mamund-on-api-design</a></p>\n<p>这里谈到的 API 是指应用程序中不同模块之间的接口。它一般包含函数名，若干形参和一个返回值。</p>\n"},{"title":"程序员困境","_content":"\n这两天有一篇叫做《程序员困境》（英文原文 [Programmer’s dilemma](https://medium.com/i-m-h-o/231d7499a75)，中文解读版本，[程序员困境：底层编码能力正逐步丧失](http://www.csdn.net/article/2013-08-19/2816613-Programmer%E2%80%99s-dilemma)）的文章很火，激起了程序员们的一系列讨论。\n\n作者讲了他最近经历，面试数十人，发现虽然他们的简历闪亮，但是底层编码能力很差。然后作者尝试分析其原因，提到了两个名词：  \n1）**专家陷阱**：过于深入研究某些既有代码，成为这一方面的专家，但是这些经验阻挡了他的视野，也限制了他把握大局的能力。当换了一个环境时，他就什么也不是了。  \n个人认为这个不算个很大的问题，人的精力有限，专精是有代价的，是要有所舍弃，来成全某一方面的专精的。\n2）**程序员困境**：我们通过给大公司写代码谋生，而大公司却意图摧毁我们谋生的能力。\n\n首先整体来讲，我个人不支持作者观点。 ###术业有专攻\n有人负责生产，就要有人负责消费。不能全部都去生产，也不能全部都去消费。\n\n程序员的工作就是让所有人失业，包括程序员自身。\n","source":"_posts/2013-08-19-Programmer-Dilemma.md","raw":"---\ntitle: 程序员困境\n---\n\n这两天有一篇叫做《程序员困境》（英文原文 [Programmer’s dilemma](https://medium.com/i-m-h-o/231d7499a75)，中文解读版本，[程序员困境：底层编码能力正逐步丧失](http://www.csdn.net/article/2013-08-19/2816613-Programmer%E2%80%99s-dilemma)）的文章很火，激起了程序员们的一系列讨论。\n\n作者讲了他最近经历，面试数十人，发现虽然他们的简历闪亮，但是底层编码能力很差。然后作者尝试分析其原因，提到了两个名词：  \n1）**专家陷阱**：过于深入研究某些既有代码，成为这一方面的专家，但是这些经验阻挡了他的视野，也限制了他把握大局的能力。当换了一个环境时，他就什么也不是了。  \n个人认为这个不算个很大的问题，人的精力有限，专精是有代价的，是要有所舍弃，来成全某一方面的专精的。\n2）**程序员困境**：我们通过给大公司写代码谋生，而大公司却意图摧毁我们谋生的能力。\n\n首先整体来讲，我个人不支持作者观点。 ###术业有专攻\n有人负责生产，就要有人负责消费。不能全部都去生产，也不能全部都去消费。\n\n程序员的工作就是让所有人失业，包括程序员自身。\n","slug":"Programmer-Dilemma","published":1,"date":"2013-08-18T16:00:00.000Z","updated":"2018-12-07T03:00:06.101Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9l000lw8wk0dah9ho0","content":"<p>这两天有一篇叫做《程序员困境》（英文原文 <a href=\"https://medium.com/i-m-h-o/231d7499a75\" target=\"_blank\" rel=\"noopener\">Programmer’s dilemma</a>，中文解读版本，<a href=\"http://www.csdn.net/article/2013-08-19/2816613-Programmer%E2%80%99s-dilemma\" target=\"_blank\" rel=\"noopener\">程序员困境：底层编码能力正逐步丧失</a>）的文章很火，激起了程序员们的一系列讨论。</p>\n<p>作者讲了他最近经历，面试数十人，发现虽然他们的简历闪亮，但是底层编码能力很差。然后作者尝试分析其原因，提到了两个名词：<br>1）<strong>专家陷阱</strong>：过于深入研究某些既有代码，成为这一方面的专家，但是这些经验阻挡了他的视野，也限制了他把握大局的能力。当换了一个环境时，他就什么也不是了。<br>个人认为这个不算个很大的问题，人的精力有限，专精是有代价的，是要有所舍弃，来成全某一方面的专精的。<br>2）<strong>程序员困境</strong>：我们通过给大公司写代码谋生，而大公司却意图摧毁我们谋生的能力。</p>\n<p>首先整体来讲，我个人不支持作者观点。 ###术业有专攻<br>有人负责生产，就要有人负责消费。不能全部都去生产，也不能全部都去消费。</p>\n<p>程序员的工作就是让所有人失业，包括程序员自身。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这两天有一篇叫做《程序员困境》（英文原文 <a href=\"https://medium.com/i-m-h-o/231d7499a75\" target=\"_blank\" rel=\"noopener\">Programmer’s dilemma</a>，中文解读版本，<a href=\"http://www.csdn.net/article/2013-08-19/2816613-Programmer%E2%80%99s-dilemma\" target=\"_blank\" rel=\"noopener\">程序员困境：底层编码能力正逐步丧失</a>）的文章很火，激起了程序员们的一系列讨论。</p>\n<p>作者讲了他最近经历，面试数十人，发现虽然他们的简历闪亮，但是底层编码能力很差。然后作者尝试分析其原因，提到了两个名词：<br>1）<strong>专家陷阱</strong>：过于深入研究某些既有代码，成为这一方面的专家，但是这些经验阻挡了他的视野，也限制了他把握大局的能力。当换了一个环境时，他就什么也不是了。<br>个人认为这个不算个很大的问题，人的精力有限，专精是有代价的，是要有所舍弃，来成全某一方面的专精的。<br>2）<strong>程序员困境</strong>：我们通过给大公司写代码谋生，而大公司却意图摧毁我们谋生的能力。</p>\n<p>首先整体来讲，我个人不支持作者观点。 ###术业有专攻<br>有人负责生产，就要有人负责消费。不能全部都去生产，也不能全部都去消费。</p>\n<p>程序员的工作就是让所有人失业，包括程序员自身。</p>\n"},{"title":"【Chrome Extension】如何获取Extension的版本号","_content":"\nChrome 中有两种扩展应用类型，一种是 Extension，它通过往页面中添加 script 脚本来达到其目的。另外一种是 Packaged Application，它是基于 Chrome 的本地应用。具体用法以后再总结。\n\n这两种扩展都是需要用户手动安装的，也是可以自动更新的。但是有些时候，我们还是需要去检查 Extension 的版本。下面我们就看看如何去做？\n\n首先，我们知道，在编写 Extension 时，我们都需要写一个`manifest.json`文件，它里面包含着关于这个 Extension 的信息。比如`name`，`description`，`version`等很多信息。那么我就可以通过获取该文件来获取本扩展的版本。\n\n那么如何获取`manifest.json`文件呢？\n\n首先我们知道 Extension 中可以通过`XMLHttpRequest`来获取资源文件，而`manifest.json`也可以看做是普通的一个资源文件，那么我们就可以通过`XMLHttpRequest`获取`manifest.json`。\n\n```javascript\n(function() {\n    var url = 'manifest.json';\n    var xhr = new XMLHttpRequest();\n    xhr.onload = function() {\n        var manifest = JSON.parse(xhr.response);\n        var version = manifest.version;\n        // do something here\n    };\n    xhr.open('GET', url, true);\n    xhr.send();\n})();\n```\n\n以上方法放在 Extension 的 content script 中，报如下错误：`GET http://[ip]:[port]/manifest.json 404 (Not Found)`。这个很容易理解，因为在 Extension 中，该脚本是通过 script 标签插入到 DOM 中执行的。那么我们如何来获取 manifest.json 的实际路径呢？答案是`chrome.extension.getURL`，这个 API 就是根据扩展中资源文件的相对路径来获取其绝对路径。而在 Packaged App 中则可以直接使用相对路径。所以在 Extension 中的做法是：\n\n```javascript\n(function() {\n    var url = chrome.extension.getURL('manifest.json');\n    var xhr = new XMLHttpRequest();\n    xhr.onload = function() {\n        var manifest = JSON.parse(xhr.response);\n        var version = manifest.version;\n        // do something here\n    };\n    xhr.open('GET', url, true);\n    xhr.send();\n})();\n```\n\n还要记住，我们需要在`manifest.json`中声明`manifest.json`是一种可以访问的资源。\n\n```json\n{\n    \"web_accessible_resources\": [\"manifest.json\"]\n}\n```\n\n否则我们会看到如下错误：\n\n```\nDenying load of chrome-extension://ongmmjdilaoifhglgibpinckpckeclch/manifest.json. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.\n```\n\n以上我们把`manifest.json`当做一个普通的资源文件来访问。那么`manifest.json`作为一种很关键很通用（所有 Extension 中都有该文件）的一个配置文件，那么有没有更简单的方法呢？答案是肯定的。在最新的 Chrome（v22+）中提供了`chrome.runtime.*`API，他们提供了获取 background 页面，manifest.json 文件，以及和其他 Extension 通信的各种 API。代码如下：\n\n```javascript\nvar manifest = chrome.runtime.getManifest();\nvar version = manifest.version;\n// do something here\n```\n\n很明显，直接使用`chrome.runtime.getManifest`来获取 Extension 的版本号，最为简单，代码少，还是同步的。\n\n总结：文章总结了获取 Extension 版本号（在`manifest.json`中）的两种方法，一种把`manifest.json`当做普通资源文件访问，一种直接使用`chrome.runtime.getManifest`访问，后者更为简单易用。\n","source":"_posts/2013-08-26-Get-Version-Info-in-Chrome-Extension.md","raw":"---\ntitle: 【Chrome Extension】如何获取Extension的版本号\n---\n\nChrome 中有两种扩展应用类型，一种是 Extension，它通过往页面中添加 script 脚本来达到其目的。另外一种是 Packaged Application，它是基于 Chrome 的本地应用。具体用法以后再总结。\n\n这两种扩展都是需要用户手动安装的，也是可以自动更新的。但是有些时候，我们还是需要去检查 Extension 的版本。下面我们就看看如何去做？\n\n首先，我们知道，在编写 Extension 时，我们都需要写一个`manifest.json`文件，它里面包含着关于这个 Extension 的信息。比如`name`，`description`，`version`等很多信息。那么我就可以通过获取该文件来获取本扩展的版本。\n\n那么如何获取`manifest.json`文件呢？\n\n首先我们知道 Extension 中可以通过`XMLHttpRequest`来获取资源文件，而`manifest.json`也可以看做是普通的一个资源文件，那么我们就可以通过`XMLHttpRequest`获取`manifest.json`。\n\n```javascript\n(function() {\n    var url = 'manifest.json';\n    var xhr = new XMLHttpRequest();\n    xhr.onload = function() {\n        var manifest = JSON.parse(xhr.response);\n        var version = manifest.version;\n        // do something here\n    };\n    xhr.open('GET', url, true);\n    xhr.send();\n})();\n```\n\n以上方法放在 Extension 的 content script 中，报如下错误：`GET http://[ip]:[port]/manifest.json 404 (Not Found)`。这个很容易理解，因为在 Extension 中，该脚本是通过 script 标签插入到 DOM 中执行的。那么我们如何来获取 manifest.json 的实际路径呢？答案是`chrome.extension.getURL`，这个 API 就是根据扩展中资源文件的相对路径来获取其绝对路径。而在 Packaged App 中则可以直接使用相对路径。所以在 Extension 中的做法是：\n\n```javascript\n(function() {\n    var url = chrome.extension.getURL('manifest.json');\n    var xhr = new XMLHttpRequest();\n    xhr.onload = function() {\n        var manifest = JSON.parse(xhr.response);\n        var version = manifest.version;\n        // do something here\n    };\n    xhr.open('GET', url, true);\n    xhr.send();\n})();\n```\n\n还要记住，我们需要在`manifest.json`中声明`manifest.json`是一种可以访问的资源。\n\n```json\n{\n    \"web_accessible_resources\": [\"manifest.json\"]\n}\n```\n\n否则我们会看到如下错误：\n\n```\nDenying load of chrome-extension://ongmmjdilaoifhglgibpinckpckeclch/manifest.json. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.\n```\n\n以上我们把`manifest.json`当做一个普通的资源文件来访问。那么`manifest.json`作为一种很关键很通用（所有 Extension 中都有该文件）的一个配置文件，那么有没有更简单的方法呢？答案是肯定的。在最新的 Chrome（v22+）中提供了`chrome.runtime.*`API，他们提供了获取 background 页面，manifest.json 文件，以及和其他 Extension 通信的各种 API。代码如下：\n\n```javascript\nvar manifest = chrome.runtime.getManifest();\nvar version = manifest.version;\n// do something here\n```\n\n很明显，直接使用`chrome.runtime.getManifest`来获取 Extension 的版本号，最为简单，代码少，还是同步的。\n\n总结：文章总结了获取 Extension 版本号（在`manifest.json`中）的两种方法，一种把`manifest.json`当做普通资源文件访问，一种直接使用`chrome.runtime.getManifest`访问，后者更为简单易用。\n","slug":"Get-Version-Info-in-Chrome-Extension","published":1,"date":"2013-08-25T16:00:00.000Z","updated":"2018-12-07T03:00:01.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9m000mw8wkpn27kibz","content":"<p>Chrome 中有两种扩展应用类型，一种是 Extension，它通过往页面中添加 script 脚本来达到其目的。另外一种是 Packaged Application，它是基于 Chrome 的本地应用。具体用法以后再总结。</p>\n<p>这两种扩展都是需要用户手动安装的，也是可以自动更新的。但是有些时候，我们还是需要去检查 Extension 的版本。下面我们就看看如何去做？</p>\n<p>首先，我们知道，在编写 Extension 时，我们都需要写一个<code>manifest.json</code>文件，它里面包含着关于这个 Extension 的信息。比如<code>name</code>，<code>description</code>，<code>version</code>等很多信息。那么我就可以通过获取该文件来获取本扩展的版本。</p>\n<p>那么如何获取<code>manifest.json</code>文件呢？</p>\n<p>首先我们知道 Extension 中可以通过<code>XMLHttpRequest</code>来获取资源文件，而<code>manifest.json</code>也可以看做是普通的一个资源文件，那么我们就可以通过<code>XMLHttpRequest</code>获取<code>manifest.json</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = <span class=\"string\">'manifest.json'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> manifest = <span class=\"built_in\">JSON</span>.parse(xhr.response);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> version = manifest.version;</span><br><span class=\"line\">        <span class=\"comment\">// do something here</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.open(<span class=\"string\">'GET'</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    xhr.send();</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>以上方法放在 Extension 的 content script 中，报如下错误：<code>GET http://[ip]:[port]/manifest.json 404 (Not Found)</code>。这个很容易理解，因为在 Extension 中，该脚本是通过 script 标签插入到 DOM 中执行的。那么我们如何来获取 manifest.json 的实际路径呢？答案是<code>chrome.extension.getURL</code>，这个 API 就是根据扩展中资源文件的相对路径来获取其绝对路径。而在 Packaged App 中则可以直接使用相对路径。所以在 Extension 中的做法是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = chrome.extension.getURL(<span class=\"string\">'manifest.json'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> manifest = <span class=\"built_in\">JSON</span>.parse(xhr.response);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> version = manifest.version;</span><br><span class=\"line\">        <span class=\"comment\">// do something here</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.open(<span class=\"string\">'GET'</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    xhr.send();</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>还要记住，我们需要在<code>manifest.json</code>中声明<code>manifest.json</code>是一种可以访问的资源。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"web_accessible_resources\"</span>: [<span class=\"string\">\"manifest.json\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>否则我们会看到如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Denying load of chrome-extension://ongmmjdilaoifhglgibpinckpckeclch/manifest.json. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.</span><br></pre></td></tr></table></figure>\n<p>以上我们把<code>manifest.json</code>当做一个普通的资源文件来访问。那么<code>manifest.json</code>作为一种很关键很通用（所有 Extension 中都有该文件）的一个配置文件，那么有没有更简单的方法呢？答案是肯定的。在最新的 Chrome（v22+）中提供了<code>chrome.runtime.*</code>API，他们提供了获取 background 页面，manifest.json 文件，以及和其他 Extension 通信的各种 API。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> manifest = chrome.runtime.getManifest();</span><br><span class=\"line\"><span class=\"keyword\">var</span> version = manifest.version;</span><br><span class=\"line\"><span class=\"comment\">// do something here</span></span><br></pre></td></tr></table></figure>\n<p>很明显，直接使用<code>chrome.runtime.getManifest</code>来获取 Extension 的版本号，最为简单，代码少，还是同步的。</p>\n<p>总结：文章总结了获取 Extension 版本号（在<code>manifest.json</code>中）的两种方法，一种把<code>manifest.json</code>当做普通资源文件访问，一种直接使用<code>chrome.runtime.getManifest</code>访问，后者更为简单易用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Chrome 中有两种扩展应用类型，一种是 Extension，它通过往页面中添加 script 脚本来达到其目的。另外一种是 Packaged Application，它是基于 Chrome 的本地应用。具体用法以后再总结。</p>\n<p>这两种扩展都是需要用户手动安装的，也是可以自动更新的。但是有些时候，我们还是需要去检查 Extension 的版本。下面我们就看看如何去做？</p>\n<p>首先，我们知道，在编写 Extension 时，我们都需要写一个<code>manifest.json</code>文件，它里面包含着关于这个 Extension 的信息。比如<code>name</code>，<code>description</code>，<code>version</code>等很多信息。那么我就可以通过获取该文件来获取本扩展的版本。</p>\n<p>那么如何获取<code>manifest.json</code>文件呢？</p>\n<p>首先我们知道 Extension 中可以通过<code>XMLHttpRequest</code>来获取资源文件，而<code>manifest.json</code>也可以看做是普通的一个资源文件，那么我们就可以通过<code>XMLHttpRequest</code>获取<code>manifest.json</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = <span class=\"string\">'manifest.json'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> manifest = <span class=\"built_in\">JSON</span>.parse(xhr.response);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> version = manifest.version;</span><br><span class=\"line\">        <span class=\"comment\">// do something here</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.open(<span class=\"string\">'GET'</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    xhr.send();</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>以上方法放在 Extension 的 content script 中，报如下错误：<code>GET http://[ip]:[port]/manifest.json 404 (Not Found)</code>。这个很容易理解，因为在 Extension 中，该脚本是通过 script 标签插入到 DOM 中执行的。那么我们如何来获取 manifest.json 的实际路径呢？答案是<code>chrome.extension.getURL</code>，这个 API 就是根据扩展中资源文件的相对路径来获取其绝对路径。而在 Packaged App 中则可以直接使用相对路径。所以在 Extension 中的做法是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = chrome.extension.getURL(<span class=\"string\">'manifest.json'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> manifest = <span class=\"built_in\">JSON</span>.parse(xhr.response);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> version = manifest.version;</span><br><span class=\"line\">        <span class=\"comment\">// do something here</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    xhr.open(<span class=\"string\">'GET'</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    xhr.send();</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>还要记住，我们需要在<code>manifest.json</code>中声明<code>manifest.json</code>是一种可以访问的资源。</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"web_accessible_resources\"</span>: [<span class=\"string\">\"manifest.json\"</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>否则我们会看到如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Denying load of chrome-extension://ongmmjdilaoifhglgibpinckpckeclch/manifest.json. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.</span><br></pre></td></tr></table></figure>\n<p>以上我们把<code>manifest.json</code>当做一个普通的资源文件来访问。那么<code>manifest.json</code>作为一种很关键很通用（所有 Extension 中都有该文件）的一个配置文件，那么有没有更简单的方法呢？答案是肯定的。在最新的 Chrome（v22+）中提供了<code>chrome.runtime.*</code>API，他们提供了获取 background 页面，manifest.json 文件，以及和其他 Extension 通信的各种 API。代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> manifest = chrome.runtime.getManifest();</span><br><span class=\"line\"><span class=\"keyword\">var</span> version = manifest.version;</span><br><span class=\"line\"><span class=\"comment\">// do something here</span></span><br></pre></td></tr></table></figure>\n<p>很明显，直接使用<code>chrome.runtime.getManifest</code>来获取 Extension 的版本号，最为简单，代码少，还是同步的。</p>\n<p>总结：文章总结了获取 Extension 版本号（在<code>manifest.json</code>中）的两种方法，一种把<code>manifest.json</code>当做普通资源文件访问，一种直接使用<code>chrome.runtime.getManifest</code>访问，后者更为简单易用。</p>\n"},{"_content":"# 跨域的几种方法\n","source":"_posts/2013-09-01-Ways-to-Cross-Domain.md","raw":"# 跨域的几种方法\n","slug":"Ways-to-Cross-Domain","published":1,"date":"2013-08-31T16:00:00.000Z","updated":"2018-12-07T02:59:58.097Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9n000nw8wkcpjeqb74","content":"<h1 id=\"跨域的几种方法\"><a href=\"#跨域的几种方法\" class=\"headerlink\" title=\"跨域的几种方法\"></a>跨域的几种方法</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"跨域的几种方法\"><a href=\"#跨域的几种方法\" class=\"headerlink\" title=\"跨域的几种方法\"></a>跨域的几种方法</h1>"},{"title":"使用页面跳转完成登录和认证","_content":"\n在上篇文章我们提到如何使用 WWW-Authenticate 实现登录和认证。这一次我们讲一下另一种实现方式。服务器端提供一个登录认证页面，浏览器端需要跳转到该页面，用户输入 PIN 码之后，发送请求，浏览器验证之后跳转当前页面来。以下是更详细的步骤。\n\n1. 浏览器端点击认证按钮，然后请求电视机（服务器端，下同）提供的一个认证页面。\n\n```\nGET http://192.168.1.199:7999/webauth/auth_default?app_name=Sample%20Web%20App&app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&auth_level=generic HTTP/1.1\n```\n\n该请求中包含一些重要的参数信息：  \napp_name 该应用的名称，显示给用户确认。  \napp_url 该应用的网址，显示给用户确认。  \nreturn_url 认证完成之后，通过该网址跳回本应用。  \nauth_level 认证等级，将会体现到该应用对电视机操控权限上。\n\n2. 电视机接收到认证页面请求，创建 PIN 码并显示在电视机上（如下图），返回该页面源码。  \n   ![电视机上显示PIN码](../../../../images/Redirect-1.png)\n\n```\nHTTP/1.1 200 OK\n<!DOCTYPE HTML>\n```\n\n3. 浏览器端显示该页面（如下图），用户输入 PIN 码并发送认证请求。  \n   ![浏览器上显示认证页面](../../../../images/Redirect-2.png)\n\n```\nPOST http://192.168.1.199:7999/webauth/auth_default_submit HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\npin_code=5184&response=allow&token=1378462608431&app_name=Sample+Web+App&app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&auth_level=generic\n```\n\n4. 电视机收到认证请求，判断 PIN 码是否正确，如果不正确，则再次回到第二步中的认证页面，并提示错误，如下图。  \n   ![PIN码输入错误](../../../../images/Redirect-error-case.png)  \n   如果正确，则跳转到 return_url 页面。\n\n```\nHTTP/1.1 302 Found\nLocation: http://192.168.1.199:3000/test/bravia.html?server=192.168.1.199&port=7999&device_id=3&x=1&y=2&result=authorized#zzz\nSet-Cookie: auth=9336226396260589431055355817107579663142096251022247731126844883; path=/; max-age=1209600; expires=Fri, 20 Sep 2013 10:49:56 GMT\n```\n","source":"_posts/2013-09-06-Using-Redirect-to-Login-and-Authentication.md","raw":"---\ntitle: 使用页面跳转完成登录和认证\n---\n\n在上篇文章我们提到如何使用 WWW-Authenticate 实现登录和认证。这一次我们讲一下另一种实现方式。服务器端提供一个登录认证页面，浏览器端需要跳转到该页面，用户输入 PIN 码之后，发送请求，浏览器验证之后跳转当前页面来。以下是更详细的步骤。\n\n1. 浏览器端点击认证按钮，然后请求电视机（服务器端，下同）提供的一个认证页面。\n\n```\nGET http://192.168.1.199:7999/webauth/auth_default?app_name=Sample%20Web%20App&app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&auth_level=generic HTTP/1.1\n```\n\n该请求中包含一些重要的参数信息：  \napp_name 该应用的名称，显示给用户确认。  \napp_url 该应用的网址，显示给用户确认。  \nreturn_url 认证完成之后，通过该网址跳回本应用。  \nauth_level 认证等级，将会体现到该应用对电视机操控权限上。\n\n2. 电视机接收到认证页面请求，创建 PIN 码并显示在电视机上（如下图），返回该页面源码。  \n   ![电视机上显示PIN码](../../../../images/Redirect-1.png)\n\n```\nHTTP/1.1 200 OK\n<!DOCTYPE HTML>\n```\n\n3. 浏览器端显示该页面（如下图），用户输入 PIN 码并发送认证请求。  \n   ![浏览器上显示认证页面](../../../../images/Redirect-2.png)\n\n```\nPOST http://192.168.1.199:7999/webauth/auth_default_submit HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\npin_code=5184&response=allow&token=1378462608431&app_name=Sample+Web+App&app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&auth_level=generic\n```\n\n4. 电视机收到认证请求，判断 PIN 码是否正确，如果不正确，则再次回到第二步中的认证页面，并提示错误，如下图。  \n   ![PIN码输入错误](../../../../images/Redirect-error-case.png)  \n   如果正确，则跳转到 return_url 页面。\n\n```\nHTTP/1.1 302 Found\nLocation: http://192.168.1.199:3000/test/bravia.html?server=192.168.1.199&port=7999&device_id=3&x=1&y=2&result=authorized#zzz\nSet-Cookie: auth=9336226396260589431055355817107579663142096251022247731126844883; path=/; max-age=1209600; expires=Fri, 20 Sep 2013 10:49:56 GMT\n```\n","slug":"Using-Redirect-to-Login-and-Authentication","published":1,"date":"2013-09-05T16:00:00.000Z","updated":"2018-12-07T02:59:54.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9n000ow8wk25cenfkq","content":"<p>在上篇文章我们提到如何使用 WWW-Authenticate 实现登录和认证。这一次我们讲一下另一种实现方式。服务器端提供一个登录认证页面，浏览器端需要跳转到该页面，用户输入 PIN 码之后，发送请求，浏览器验证之后跳转当前页面来。以下是更详细的步骤。</p>\n<ol>\n<li>浏览器端点击认证按钮，然后请求电视机（服务器端，下同）提供的一个认证页面。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET http://192.168.1.199:7999/webauth/auth_default?app_name=Sample%20Web%20App&amp;app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&amp;return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&amp;auth_level=generic HTTP/1.1</span><br></pre></td></tr></table></figure>\n<p>该请求中包含一些重要的参数信息：<br>app_name 该应用的名称，显示给用户确认。<br>app_url 该应用的网址，显示给用户确认。<br>return_url 认证完成之后，通过该网址跳回本应用。<br>auth_level 认证等级，将会体现到该应用对电视机操控权限上。</p>\n<ol start=\"2\">\n<li>电视机接收到认证页面请求，创建 PIN 码并显示在电视机上（如下图），返回该页面源码。<br><img src=\"../../../../images/Redirect-1.png\" alt=\"电视机上显示PIN码\"></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>浏览器端显示该页面（如下图），用户输入 PIN 码并发送认证请求。<br><img src=\"../../../../images/Redirect-2.png\" alt=\"浏览器上显示认证页面\"></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST http://192.168.1.199:7999/webauth/auth_default_submit HTTP/1.1</span><br><span class=\"line\">Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">pin_code=5184&amp;response=allow&amp;token=1378462608431&amp;app_name=Sample+Web+App&amp;app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&amp;return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&amp;auth_level=generic</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>电视机收到认证请求，判断 PIN 码是否正确，如果不正确，则再次回到第二步中的认证页面，并提示错误，如下图。<br><img src=\"../../../../images/Redirect-error-case.png\" alt=\"PIN码输入错误\"><br>如果正确，则跳转到 return_url 页面。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 302 Found</span><br><span class=\"line\">Location: http://192.168.1.199:3000/test/bravia.html?server=192.168.1.199&amp;port=7999&amp;device_id=3&amp;x=1&amp;y=2&amp;result=authorized#zzz</span><br><span class=\"line\">Set-Cookie: auth=9336226396260589431055355817107579663142096251022247731126844883; path=/; max-age=1209600; expires=Fri, 20 Sep 2013 10:49:56 GMT</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在上篇文章我们提到如何使用 WWW-Authenticate 实现登录和认证。这一次我们讲一下另一种实现方式。服务器端提供一个登录认证页面，浏览器端需要跳转到该页面，用户输入 PIN 码之后，发送请求，浏览器验证之后跳转当前页面来。以下是更详细的步骤。</p>\n<ol>\n<li>浏览器端点击认证按钮，然后请求电视机（服务器端，下同）提供的一个认证页面。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET http://192.168.1.199:7999/webauth/auth_default?app_name=Sample%20Web%20App&amp;app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&amp;return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&amp;auth_level=generic HTTP/1.1</span><br></pre></td></tr></table></figure>\n<p>该请求中包含一些重要的参数信息：<br>app_name 该应用的名称，显示给用户确认。<br>app_url 该应用的网址，显示给用户确认。<br>return_url 认证完成之后，通过该网址跳回本应用。<br>auth_level 认证等级，将会体现到该应用对电视机操控权限上。</p>\n<ol start=\"2\">\n<li>电视机接收到认证页面请求，创建 PIN 码并显示在电视机上（如下图），返回该页面源码。<br><img src=\"../../../../images/Redirect-1.png\" alt=\"电视机上显示PIN码\"></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">&lt;!DOCTYPE HTML&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>浏览器端显示该页面（如下图），用户输入 PIN 码并发送认证请求。<br><img src=\"../../../../images/Redirect-2.png\" alt=\"浏览器上显示认证页面\"></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST http://192.168.1.199:7999/webauth/auth_default_submit HTTP/1.1</span><br><span class=\"line\">Content-Type: application/x-www-form-urlencoded</span><br><span class=\"line\">pin_code=5184&amp;response=allow&amp;token=1378462608431&amp;app_name=Sample+Web+App&amp;app_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html&amp;return_url=http%3A%2F%2F192.168.1.199%3A3000%2Ftest%2Fbravia.html%3Fserver%3D192.168.1.199%26port%3D7999%26device_id%3D3%26x%3D1%26y%3D2%23zzz&amp;auth_level=generic</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>电视机收到认证请求，判断 PIN 码是否正确，如果不正确，则再次回到第二步中的认证页面，并提示错误，如下图。<br><img src=\"../../../../images/Redirect-error-case.png\" alt=\"PIN码输入错误\"><br>如果正确，则跳转到 return_url 页面。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 302 Found</span><br><span class=\"line\">Location: http://192.168.1.199:3000/test/bravia.html?server=192.168.1.199&amp;port=7999&amp;device_id=3&amp;x=1&amp;y=2&amp;result=authorized#zzz</span><br><span class=\"line\">Set-Cookie: auth=9336226396260589431055355817107579663142096251022247731126844883; path=/; max-age=1209600; expires=Fri, 20 Sep 2013 10:49:56 GMT</span><br></pre></td></tr></table></figure>\n"},{"title":"使用WWW-Authenticate实现登录认证","_content":"\n在当前的项目中，我们做了虚拟电视机设备，手机应用必须连接并通过认证才能控制电视机。认证步骤如下，首先由手机应用向电视机发送认证请求，电视机收到后会显示 PIN 码，用户在手机应用中输入 PIN 码，再发送请求验证即可。\n\n其中一种认证实现，我们采用了 WWW-Authenticate，这种在互联网初期比较常见的认证方式。优点是非常简单，标准化的，浏览器支持完善。缺点是用户名和密码是经 Base64 编码传输。大家都知道 Base64 就是个简单的障眼法，是那种防君子不防小人的做法。解密过程特别简单，与明文传输基本无异。\n\n下面就简单描述一下过程吧。\n\n1. 浏览器向电视机（服务器端，下同）发送请求。\n\n```\nPOST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1\n```\n\n2. 电视机没有收到认证信息，创建 PIN 码并显示在电视机上（如下图），返回 401 未认证错误。\n\n```\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: Basic realm=\"Private Page\"\n```\n\n![显示PIN码](../../../../images/WWW-Authentication-1.png)\n\n3. 浏览器收到 401 未认证错误，将会显示一个如下登录框。并显示出服务器端给的提示信息`Private Page`.  \n   ![浏览器显示登录框](../../../../images/WWW-Authentication-2.png)  \n   用户在密码一栏中输入 PIN 码之后点击登录，浏览器将会重新再发一次请求。这次请求跟上次请求唯一不同就是多了一个 header。\n\n```\nPOST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1\nAuthorization: Basic OjgyNzU=\n```\n\n我们在 Chrome 的控制台执行以下代码`atob('OjgyNzU=')`，可以看到结果是`:8275`，也就是`: + PIN`。也许你已经猜到了，Authorization 的值就是`Basic base64(<username>:<password>)`。\n\n4. 电视机收到带有 Authorization 头部的请求以后，调用类似`atob`的方法解码，得到 PIN 码判断是否正确，如果正确则验证成功，如果不正确则继续返回和第 2 步一样的响应。在这里，我们输入了正确的 PIN 码，所以服务器端返回了 200 状态吗。\n\n```\nHTTP/1.1 200 OK\nSet-Cookie: auth=0757981464307829417712055147089187584491446610025428754976019263; path=/; max-age=1209600; expires=Fri Sep 20 2013 17:09:39 GMT\n```\n\n以上这种方法的客户端并不一定要是浏览器，在手机原生应用中也可以做到，一般需要 HTTP 客户端库来辅助发送请求并解析响应。当然还需要自己做一个登录框。\n","source":"_posts/2013-09-06-Using-WWW-Authenticate-to-Login-Authentication.md","raw":"---\ntitle: 使用WWW-Authenticate实现登录认证\n---\n\n在当前的项目中，我们做了虚拟电视机设备，手机应用必须连接并通过认证才能控制电视机。认证步骤如下，首先由手机应用向电视机发送认证请求，电视机收到后会显示 PIN 码，用户在手机应用中输入 PIN 码，再发送请求验证即可。\n\n其中一种认证实现，我们采用了 WWW-Authenticate，这种在互联网初期比较常见的认证方式。优点是非常简单，标准化的，浏览器支持完善。缺点是用户名和密码是经 Base64 编码传输。大家都知道 Base64 就是个简单的障眼法，是那种防君子不防小人的做法。解密过程特别简单，与明文传输基本无异。\n\n下面就简单描述一下过程吧。\n\n1. 浏览器向电视机（服务器端，下同）发送请求。\n\n```\nPOST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1\n```\n\n2. 电视机没有收到认证信息，创建 PIN 码并显示在电视机上（如下图），返回 401 未认证错误。\n\n```\nHTTP/1.1 401 Unauthorized\nWWW-Authenticate: Basic realm=\"Private Page\"\n```\n\n![显示PIN码](../../../../images/WWW-Authentication-1.png)\n\n3. 浏览器收到 401 未认证错误，将会显示一个如下登录框。并显示出服务器端给的提示信息`Private Page`.  \n   ![浏览器显示登录框](../../../../images/WWW-Authentication-2.png)  \n   用户在密码一栏中输入 PIN 码之后点击登录，浏览器将会重新再发一次请求。这次请求跟上次请求唯一不同就是多了一个 header。\n\n```\nPOST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1\nAuthorization: Basic OjgyNzU=\n```\n\n我们在 Chrome 的控制台执行以下代码`atob('OjgyNzU=')`，可以看到结果是`:8275`，也就是`: + PIN`。也许你已经猜到了，Authorization 的值就是`Basic base64(<username>:<password>)`。\n\n4. 电视机收到带有 Authorization 头部的请求以后，调用类似`atob`的方法解码，得到 PIN 码判断是否正确，如果正确则验证成功，如果不正确则继续返回和第 2 步一样的响应。在这里，我们输入了正确的 PIN 码，所以服务器端返回了 200 状态吗。\n\n```\nHTTP/1.1 200 OK\nSet-Cookie: auth=0757981464307829417712055147089187584491446610025428754976019263; path=/; max-age=1209600; expires=Fri Sep 20 2013 17:09:39 GMT\n```\n\n以上这种方法的客户端并不一定要是浏览器，在手机原生应用中也可以做到，一般需要 HTTP 客户端库来辅助发送请求并解析响应。当然还需要自己做一个登录框。\n","slug":"Using-WWW-Authenticate-to-Login-Authentication","published":1,"date":"2013-09-05T16:00:00.000Z","updated":"2018-12-07T02:59:50.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9o000pw8wk0q2ov50x","content":"<p>在当前的项目中，我们做了虚拟电视机设备，手机应用必须连接并通过认证才能控制电视机。认证步骤如下，首先由手机应用向电视机发送认证请求，电视机收到后会显示 PIN 码，用户在手机应用中输入 PIN 码，再发送请求验证即可。</p>\n<p>其中一种认证实现，我们采用了 WWW-Authenticate，这种在互联网初期比较常见的认证方式。优点是非常简单，标准化的，浏览器支持完善。缺点是用户名和密码是经 Base64 编码传输。大家都知道 Base64 就是个简单的障眼法，是那种防君子不防小人的做法。解密过程特别简单，与明文传输基本无异。</p>\n<p>下面就简单描述一下过程吧。</p>\n<ol>\n<li>浏览器向电视机（服务器端，下同）发送请求。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>电视机没有收到认证信息，创建 PIN 码并显示在电视机上（如下图），返回 401 未认证错误。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 401 Unauthorized</span><br><span class=\"line\">WWW-Authenticate: Basic realm=&quot;Private Page&quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../images/WWW-Authentication-1.png\" alt=\"显示PIN码\"></p>\n<ol start=\"3\">\n<li>浏览器收到 401 未认证错误，将会显示一个如下登录框。并显示出服务器端给的提示信息<code>Private Page</code>.<br><img src=\"../../../../images/WWW-Authentication-2.png\" alt=\"浏览器显示登录框\"><br>用户在密码一栏中输入 PIN 码之后点击登录，浏览器将会重新再发一次请求。这次请求跟上次请求唯一不同就是多了一个 header。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1</span><br><span class=\"line\">Authorization: Basic OjgyNzU=</span><br></pre></td></tr></table></figure>\n<p>我们在 Chrome 的控制台执行以下代码<code>atob(&#39;OjgyNzU=&#39;)</code>，可以看到结果是<code>:8275</code>，也就是<code>: + PIN</code>。也许你已经猜到了，Authorization 的值就是<code>Basic base64(&lt;username&gt;:&lt;password&gt;)</code>。</p>\n<ol start=\"4\">\n<li>电视机收到带有 Authorization 头部的请求以后，调用类似<code>atob</code>的方法解码，得到 PIN 码判断是否正确，如果正确则验证成功，如果不正确则继续返回和第 2 步一样的响应。在这里，我们输入了正确的 PIN 码，所以服务器端返回了 200 状态吗。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Set-Cookie: auth=0757981464307829417712055147089187584491446610025428754976019263; path=/; max-age=1209600; expires=Fri Sep 20 2013 17:09:39 GMT</span><br></pre></td></tr></table></figure>\n<p>以上这种方法的客户端并不一定要是浏览器，在手机原生应用中也可以做到，一般需要 HTTP 客户端库来辅助发送请求并解析响应。当然还需要自己做一个登录框。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在当前的项目中，我们做了虚拟电视机设备，手机应用必须连接并通过认证才能控制电视机。认证步骤如下，首先由手机应用向电视机发送认证请求，电视机收到后会显示 PIN 码，用户在手机应用中输入 PIN 码，再发送请求验证即可。</p>\n<p>其中一种认证实现，我们采用了 WWW-Authenticate，这种在互联网初期比较常见的认证方式。优点是非常简单，标准化的，浏览器支持完善。缺点是用户名和密码是经 Base64 编码传输。大家都知道 Base64 就是个简单的障眼法，是那种防君子不防小人的做法。解密过程特别简单，与明文传输基本无异。</p>\n<p>下面就简单描述一下过程吧。</p>\n<ol>\n<li>浏览器向电视机（服务器端，下同）发送请求。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>电视机没有收到认证信息，创建 PIN 码并显示在电视机上（如下图），返回 401 未认证错误。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 401 Unauthorized</span><br><span class=\"line\">WWW-Authenticate: Basic realm=&quot;Private Page&quot;</span><br></pre></td></tr></table></figure>\n<p><img src=\"../../../../images/WWW-Authentication-1.png\" alt=\"显示PIN码\"></p>\n<ol start=\"3\">\n<li>浏览器收到 401 未认证错误，将会显示一个如下登录框。并显示出服务器端给的提示信息<code>Private Page</code>.<br><img src=\"../../../../images/WWW-Authentication-2.png\" alt=\"浏览器显示登录框\"><br>用户在密码一栏中输入 PIN 码之后点击登录，浏览器将会重新再发一次请求。这次请求跟上次请求唯一不同就是多了一个 header。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST http://192.168.1.199:7999/sony/3/accessControl HTTP/1.1</span><br><span class=\"line\">Authorization: Basic OjgyNzU=</span><br></pre></td></tr></table></figure>\n<p>我们在 Chrome 的控制台执行以下代码<code>atob(&#39;OjgyNzU=&#39;)</code>，可以看到结果是<code>:8275</code>，也就是<code>: + PIN</code>。也许你已经猜到了，Authorization 的值就是<code>Basic base64(&lt;username&gt;:&lt;password&gt;)</code>。</p>\n<ol start=\"4\">\n<li>电视机收到带有 Authorization 头部的请求以后，调用类似<code>atob</code>的方法解码，得到 PIN 码判断是否正确，如果正确则验证成功，如果不正确则继续返回和第 2 步一样的响应。在这里，我们输入了正确的 PIN 码，所以服务器端返回了 200 状态吗。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">Set-Cookie: auth=0757981464307829417712055147089187584491446610025428754976019263; path=/; max-age=1209600; expires=Fri Sep 20 2013 17:09:39 GMT</span><br></pre></td></tr></table></figure>\n<p>以上这种方法的客户端并不一定要是浏览器，在手机原生应用中也可以做到，一般需要 HTTP 客户端库来辅助发送请求并解析响应。当然还需要自己做一个登录框。</p>\n"},{"_content":"软件产品质量不能依靠测试来保证\n","source":"_posts/2013-09-11-Software-Product-Quality-Cannot-be-rely-on-Test.md","raw":"软件产品质量不能依靠测试来保证\n","slug":"Software-Product-Quality-Cannot-be-rely-on-Test","published":1,"date":"2013-09-10T16:00:00.000Z","updated":"2018-12-07T02:59:45.802Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9o000qw8wkm3up6173","content":"<p>软件产品质量不能依靠测试来保证</p>\n","site":{"data":{}},"excerpt":"","more":"<p>软件产品质量不能依靠测试来保证</p>\n"},{"title":"透过用户的要求理解用户的关切","_content":"\n先介绍一下项目背景：公司生产了一些电视机和照相机，同时公开了一些接口，允许开发者基于此开发一些第三方应用。有些开发者可能没有电视机和照相机真机，或者团队中真机不足，为了能够是他们顺利地进行开发，所以我们开发一款软件，让开发者可以申请虚拟设备。该软件中实现了 SSDP 协议让第三方应用发现虚拟设备。\n\n前些天，Tony 作为用户又作为项目的负责人提出一个要求：不能让一个账号同时在两个电脑（或者浏览器）上登录。这下可难倒了我们外包团队。他们的开发人员 W 找到我，说这个该怎么做呢？W 也提出一种方案，就是使用 WebSocket，对于不支持 WebSocket 的浏览器使用轮询来作为 fallback 方案。这个方案可以使用现有的 socket.io 库来轻松实现。\n\n首先讲一下，不让一个账号同时两处登录，这样做的站点一般有聊天室等，有了这样的限制以后，一个用户在某个浏览器上登录以后，再不退出的情况下直接关闭浏览器，用户就不能在其他浏览器上登录了，直到 Session 过期。Session 自动过期时间可长可短，一般是半个小时。用户体验非常不好，更好的策略是，后登录的把先登录的踢掉。\n\n以前我在 J2EE 企业级应用框架时实现了这样的功能，虽然实现了，但是还没有在任何一个项目中实际使用了。实现了，更多是为了功能的完备性。还有一点，在一个实现了完整的认证授权系统中，实现这样的功能是非常简单的。实现的方法如下：\n\n1. 首次成功登录以后，会再数据库的 Session 表中添加一条记录。字段一般包括 Session ID，用户 ID，Cookie，登录时间，最后操作时间（初始化为登录时间）。\n\n2. 以后用户没操作一次，都会修改 Session 表中的最后登录时间。这个在 J2EE 中一般通过 filter 实现。并且服务器端会定期执行一个任务，清除 Session 表中过期 Session。一个 Session 何时过期，一般判断条件是当前距离最后操作时间大于半个小时（可配置）。\n\n3. 当用户再次登录时，首先判断用户名和密码是否正确，如果正确，然后用户是否已经在别处登录，即 Session 表是否有该用户的未过期 Session，如果是，则给用户一个错误提示，否则才判定位登录成功。\n\n在我们当前的应用中，服务器端语言使用的 Node，框架是 Express。Session 管理我们可以使用的是 Express 自带的 Session 中间件。代码如下：\n\n```js\nvar express = require('express');\nvar app = new express();\napp.use(express.session());\n```\n\nExpress 的 Session 中间件没有 API 可以得到用户是否已经在别处登录。另外一个问题就是即便我们自己实现 Session 控制，那么也是不可取的，因为项目特殊性，用户在登录以后就加在几乎所有的资源，也只有在登录，申请设备和获取已申请设备清单时才会发送一个服务器端的请求。之后用户只需要按下启动按钮，之后虚拟设备就运行在 Web App 中了，第三方应用就可以通过 SSDP 协议发现设备并与该设备进行 HTTP 通信了。以后只有部分静态资源文件会从 Node Server 上获取之后，就没有其他的请求了。所以自从获取已申请设备清单以后，就没有会修改最后操作时间的请求了。\n\nW 给出的一个方案：使用 socket.io，保持与服务器端通信。可行倒是可行，但是我们要为了一个需求大动干戈吗？这个要划一个问号。然后我跟 W 说，我去跟 Tony 商量一下，看看他的目的是什么，再决定怎么做。\n\n在跟 Tony 的交流中，发现他有过这样的经历：开发阶段两个人使用了同一个账号同时登录，这两个浏览器中自然有着同样的设备列表，然后都启动了某个设备，这时候在局域网中就有了两个有着同样 UUID 的虚拟设备，他们 IP 不同，设别描述文件地址也不同，设备状态也不同。有些 SSDP 客户端会因此而崩溃掉。所以他想让一个账号不能同时在两处登录就能解决该问题了。\n\n我告诉 Tony，既然你是为了解决这样的问题，那么我们能否换个思路，让每个浏览器上的设备 UUID 都不相同，在生成 UUID 时，不仅加入设备 ID，还加入浏览器所在电脑的 IP，时间戳，随机值等。这样一来，团队成员可以共享一个账号，在同一个局域网中也可以独立使用，互不影响。然后 Tony 认同了这一做法。到此，这个需求就这么解决了，仅仅修改一下 UUID 的生成算法。\n\n在上面的案例中，可以发现，用户提出的要求可能只是他们所关切的问题的一个表象，或者是他们认为的这个问题的一个解决方案。我们不能仅仅局限于此，而要透过他们的要求去探索他们真正关切的问题。\n","source":"_posts/2013-09-16-Why-the-User-Need-this-Feature.md","raw":"---\ntitle: 透过用户的要求理解用户的关切\n---\n\n先介绍一下项目背景：公司生产了一些电视机和照相机，同时公开了一些接口，允许开发者基于此开发一些第三方应用。有些开发者可能没有电视机和照相机真机，或者团队中真机不足，为了能够是他们顺利地进行开发，所以我们开发一款软件，让开发者可以申请虚拟设备。该软件中实现了 SSDP 协议让第三方应用发现虚拟设备。\n\n前些天，Tony 作为用户又作为项目的负责人提出一个要求：不能让一个账号同时在两个电脑（或者浏览器）上登录。这下可难倒了我们外包团队。他们的开发人员 W 找到我，说这个该怎么做呢？W 也提出一种方案，就是使用 WebSocket，对于不支持 WebSocket 的浏览器使用轮询来作为 fallback 方案。这个方案可以使用现有的 socket.io 库来轻松实现。\n\n首先讲一下，不让一个账号同时两处登录，这样做的站点一般有聊天室等，有了这样的限制以后，一个用户在某个浏览器上登录以后，再不退出的情况下直接关闭浏览器，用户就不能在其他浏览器上登录了，直到 Session 过期。Session 自动过期时间可长可短，一般是半个小时。用户体验非常不好，更好的策略是，后登录的把先登录的踢掉。\n\n以前我在 J2EE 企业级应用框架时实现了这样的功能，虽然实现了，但是还没有在任何一个项目中实际使用了。实现了，更多是为了功能的完备性。还有一点，在一个实现了完整的认证授权系统中，实现这样的功能是非常简单的。实现的方法如下：\n\n1. 首次成功登录以后，会再数据库的 Session 表中添加一条记录。字段一般包括 Session ID，用户 ID，Cookie，登录时间，最后操作时间（初始化为登录时间）。\n\n2. 以后用户没操作一次，都会修改 Session 表中的最后登录时间。这个在 J2EE 中一般通过 filter 实现。并且服务器端会定期执行一个任务，清除 Session 表中过期 Session。一个 Session 何时过期，一般判断条件是当前距离最后操作时间大于半个小时（可配置）。\n\n3. 当用户再次登录时，首先判断用户名和密码是否正确，如果正确，然后用户是否已经在别处登录，即 Session 表是否有该用户的未过期 Session，如果是，则给用户一个错误提示，否则才判定位登录成功。\n\n在我们当前的应用中，服务器端语言使用的 Node，框架是 Express。Session 管理我们可以使用的是 Express 自带的 Session 中间件。代码如下：\n\n```js\nvar express = require('express');\nvar app = new express();\napp.use(express.session());\n```\n\nExpress 的 Session 中间件没有 API 可以得到用户是否已经在别处登录。另外一个问题就是即便我们自己实现 Session 控制，那么也是不可取的，因为项目特殊性，用户在登录以后就加在几乎所有的资源，也只有在登录，申请设备和获取已申请设备清单时才会发送一个服务器端的请求。之后用户只需要按下启动按钮，之后虚拟设备就运行在 Web App 中了，第三方应用就可以通过 SSDP 协议发现设备并与该设备进行 HTTP 通信了。以后只有部分静态资源文件会从 Node Server 上获取之后，就没有其他的请求了。所以自从获取已申请设备清单以后，就没有会修改最后操作时间的请求了。\n\nW 给出的一个方案：使用 socket.io，保持与服务器端通信。可行倒是可行，但是我们要为了一个需求大动干戈吗？这个要划一个问号。然后我跟 W 说，我去跟 Tony 商量一下，看看他的目的是什么，再决定怎么做。\n\n在跟 Tony 的交流中，发现他有过这样的经历：开发阶段两个人使用了同一个账号同时登录，这两个浏览器中自然有着同样的设备列表，然后都启动了某个设备，这时候在局域网中就有了两个有着同样 UUID 的虚拟设备，他们 IP 不同，设别描述文件地址也不同，设备状态也不同。有些 SSDP 客户端会因此而崩溃掉。所以他想让一个账号不能同时在两处登录就能解决该问题了。\n\n我告诉 Tony，既然你是为了解决这样的问题，那么我们能否换个思路，让每个浏览器上的设备 UUID 都不相同，在生成 UUID 时，不仅加入设备 ID，还加入浏览器所在电脑的 IP，时间戳，随机值等。这样一来，团队成员可以共享一个账号，在同一个局域网中也可以独立使用，互不影响。然后 Tony 认同了这一做法。到此，这个需求就这么解决了，仅仅修改一下 UUID 的生成算法。\n\n在上面的案例中，可以发现，用户提出的要求可能只是他们所关切的问题的一个表象，或者是他们认为的这个问题的一个解决方案。我们不能仅仅局限于此，而要透过他们的要求去探索他们真正关切的问题。\n","slug":"Why-the-User-Need-this-Feature","published":1,"date":"2013-09-15T16:00:00.000Z","updated":"2018-12-07T02:58:25.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9p000rw8wk4htvvyhf","content":"<p>先介绍一下项目背景：公司生产了一些电视机和照相机，同时公开了一些接口，允许开发者基于此开发一些第三方应用。有些开发者可能没有电视机和照相机真机，或者团队中真机不足，为了能够是他们顺利地进行开发，所以我们开发一款软件，让开发者可以申请虚拟设备。该软件中实现了 SSDP 协议让第三方应用发现虚拟设备。</p>\n<p>前些天，Tony 作为用户又作为项目的负责人提出一个要求：不能让一个账号同时在两个电脑（或者浏览器）上登录。这下可难倒了我们外包团队。他们的开发人员 W 找到我，说这个该怎么做呢？W 也提出一种方案，就是使用 WebSocket，对于不支持 WebSocket 的浏览器使用轮询来作为 fallback 方案。这个方案可以使用现有的 socket.io 库来轻松实现。</p>\n<p>首先讲一下，不让一个账号同时两处登录，这样做的站点一般有聊天室等，有了这样的限制以后，一个用户在某个浏览器上登录以后，再不退出的情况下直接关闭浏览器，用户就不能在其他浏览器上登录了，直到 Session 过期。Session 自动过期时间可长可短，一般是半个小时。用户体验非常不好，更好的策略是，后登录的把先登录的踢掉。</p>\n<p>以前我在 J2EE 企业级应用框架时实现了这样的功能，虽然实现了，但是还没有在任何一个项目中实际使用了。实现了，更多是为了功能的完备性。还有一点，在一个实现了完整的认证授权系统中，实现这样的功能是非常简单的。实现的方法如下：</p>\n<ol>\n<li><p>首次成功登录以后，会再数据库的 Session 表中添加一条记录。字段一般包括 Session ID，用户 ID，Cookie，登录时间，最后操作时间（初始化为登录时间）。</p>\n</li>\n<li><p>以后用户没操作一次，都会修改 Session 表中的最后登录时间。这个在 J2EE 中一般通过 filter 实现。并且服务器端会定期执行一个任务，清除 Session 表中过期 Session。一个 Session 何时过期，一般判断条件是当前距离最后操作时间大于半个小时（可配置）。</p>\n</li>\n<li><p>当用户再次登录时，首先判断用户名和密码是否正确，如果正确，然后用户是否已经在别处登录，即 Session 表是否有该用户的未过期 Session，如果是，则给用户一个错误提示，否则才判定位登录成功。</p>\n</li>\n</ol>\n<p>在我们当前的应用中，服务器端语言使用的 Node，框架是 Express。Session 管理我们可以使用的是 Express 自带的 Session 中间件。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> express();</span><br><span class=\"line\">app.use(express.session());</span><br></pre></td></tr></table></figure>\n<p>Express 的 Session 中间件没有 API 可以得到用户是否已经在别处登录。另外一个问题就是即便我们自己实现 Session 控制，那么也是不可取的，因为项目特殊性，用户在登录以后就加在几乎所有的资源，也只有在登录，申请设备和获取已申请设备清单时才会发送一个服务器端的请求。之后用户只需要按下启动按钮，之后虚拟设备就运行在 Web App 中了，第三方应用就可以通过 SSDP 协议发现设备并与该设备进行 HTTP 通信了。以后只有部分静态资源文件会从 Node Server 上获取之后，就没有其他的请求了。所以自从获取已申请设备清单以后，就没有会修改最后操作时间的请求了。</p>\n<p>W 给出的一个方案：使用 socket.io，保持与服务器端通信。可行倒是可行，但是我们要为了一个需求大动干戈吗？这个要划一个问号。然后我跟 W 说，我去跟 Tony 商量一下，看看他的目的是什么，再决定怎么做。</p>\n<p>在跟 Tony 的交流中，发现他有过这样的经历：开发阶段两个人使用了同一个账号同时登录，这两个浏览器中自然有着同样的设备列表，然后都启动了某个设备，这时候在局域网中就有了两个有着同样 UUID 的虚拟设备，他们 IP 不同，设别描述文件地址也不同，设备状态也不同。有些 SSDP 客户端会因此而崩溃掉。所以他想让一个账号不能同时在两处登录就能解决该问题了。</p>\n<p>我告诉 Tony，既然你是为了解决这样的问题，那么我们能否换个思路，让每个浏览器上的设备 UUID 都不相同，在生成 UUID 时，不仅加入设备 ID，还加入浏览器所在电脑的 IP，时间戳，随机值等。这样一来，团队成员可以共享一个账号，在同一个局域网中也可以独立使用，互不影响。然后 Tony 认同了这一做法。到此，这个需求就这么解决了，仅仅修改一下 UUID 的生成算法。</p>\n<p>在上面的案例中，可以发现，用户提出的要求可能只是他们所关切的问题的一个表象，或者是他们认为的这个问题的一个解决方案。我们不能仅仅局限于此，而要透过他们的要求去探索他们真正关切的问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>先介绍一下项目背景：公司生产了一些电视机和照相机，同时公开了一些接口，允许开发者基于此开发一些第三方应用。有些开发者可能没有电视机和照相机真机，或者团队中真机不足，为了能够是他们顺利地进行开发，所以我们开发一款软件，让开发者可以申请虚拟设备。该软件中实现了 SSDP 协议让第三方应用发现虚拟设备。</p>\n<p>前些天，Tony 作为用户又作为项目的负责人提出一个要求：不能让一个账号同时在两个电脑（或者浏览器）上登录。这下可难倒了我们外包团队。他们的开发人员 W 找到我，说这个该怎么做呢？W 也提出一种方案，就是使用 WebSocket，对于不支持 WebSocket 的浏览器使用轮询来作为 fallback 方案。这个方案可以使用现有的 socket.io 库来轻松实现。</p>\n<p>首先讲一下，不让一个账号同时两处登录，这样做的站点一般有聊天室等，有了这样的限制以后，一个用户在某个浏览器上登录以后，再不退出的情况下直接关闭浏览器，用户就不能在其他浏览器上登录了，直到 Session 过期。Session 自动过期时间可长可短，一般是半个小时。用户体验非常不好，更好的策略是，后登录的把先登录的踢掉。</p>\n<p>以前我在 J2EE 企业级应用框架时实现了这样的功能，虽然实现了，但是还没有在任何一个项目中实际使用了。实现了，更多是为了功能的完备性。还有一点，在一个实现了完整的认证授权系统中，实现这样的功能是非常简单的。实现的方法如下：</p>\n<ol>\n<li><p>首次成功登录以后，会再数据库的 Session 表中添加一条记录。字段一般包括 Session ID，用户 ID，Cookie，登录时间，最后操作时间（初始化为登录时间）。</p>\n</li>\n<li><p>以后用户没操作一次，都会修改 Session 表中的最后登录时间。这个在 J2EE 中一般通过 filter 实现。并且服务器端会定期执行一个任务，清除 Session 表中过期 Session。一个 Session 何时过期，一般判断条件是当前距离最后操作时间大于半个小时（可配置）。</p>\n</li>\n<li><p>当用户再次登录时，首先判断用户名和密码是否正确，如果正确，然后用户是否已经在别处登录，即 Session 表是否有该用户的未过期 Session，如果是，则给用户一个错误提示，否则才判定位登录成功。</p>\n</li>\n</ol>\n<p>在我们当前的应用中，服务器端语言使用的 Node，框架是 Express。Session 管理我们可以使用的是 Express 自带的 Session 中间件。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = <span class=\"keyword\">new</span> express();</span><br><span class=\"line\">app.use(express.session());</span><br></pre></td></tr></table></figure>\n<p>Express 的 Session 中间件没有 API 可以得到用户是否已经在别处登录。另外一个问题就是即便我们自己实现 Session 控制，那么也是不可取的，因为项目特殊性，用户在登录以后就加在几乎所有的资源，也只有在登录，申请设备和获取已申请设备清单时才会发送一个服务器端的请求。之后用户只需要按下启动按钮，之后虚拟设备就运行在 Web App 中了，第三方应用就可以通过 SSDP 协议发现设备并与该设备进行 HTTP 通信了。以后只有部分静态资源文件会从 Node Server 上获取之后，就没有其他的请求了。所以自从获取已申请设备清单以后，就没有会修改最后操作时间的请求了。</p>\n<p>W 给出的一个方案：使用 socket.io，保持与服务器端通信。可行倒是可行，但是我们要为了一个需求大动干戈吗？这个要划一个问号。然后我跟 W 说，我去跟 Tony 商量一下，看看他的目的是什么，再决定怎么做。</p>\n<p>在跟 Tony 的交流中，发现他有过这样的经历：开发阶段两个人使用了同一个账号同时登录，这两个浏览器中自然有着同样的设备列表，然后都启动了某个设备，这时候在局域网中就有了两个有着同样 UUID 的虚拟设备，他们 IP 不同，设别描述文件地址也不同，设备状态也不同。有些 SSDP 客户端会因此而崩溃掉。所以他想让一个账号不能同时在两处登录就能解决该问题了。</p>\n<p>我告诉 Tony，既然你是为了解决这样的问题，那么我们能否换个思路，让每个浏览器上的设备 UUID 都不相同，在生成 UUID 时，不仅加入设备 ID，还加入浏览器所在电脑的 IP，时间戳，随机值等。这样一来，团队成员可以共享一个账号，在同一个局域网中也可以独立使用，互不影响。然后 Tony 认同了这一做法。到此，这个需求就这么解决了，仅仅修改一下 UUID 的生成算法。</p>\n<p>在上面的案例中，可以发现，用户提出的要求可能只是他们所关切的问题的一个表象，或者是他们认为的这个问题的一个解决方案。我们不能仅仅局限于此，而要透过他们的要求去探索他们真正关切的问题。</p>\n"},{"title":"innerText vs textContent","_content":"\n为什么 innerText 会导致重排？我在我的上篇[关于重排的文章](http://kellegous.com/j/2013/01/26/layout-performance)末尾提出了这个问题。这里简单地总结一下，有些 DOM API 可能会因为不必要的重排，从而导致严重的性能问题。我将在这些文章中，着重提出这些年我发现的关于 Web 性能的古怪问题。\n\nAs with many other things in browsers, innerText’s behavior seemed to have happened due to overlapping (and, perhaps, under-defined) use cases. 当你要获取 DOM 节点中的文本时，你会遇到两个问题，节点中原始文本是什么？用户看到的文本是什么？虽然类似，但是显然有所不同。在浏览器中，可以通过 textContent 获得前者，通过 innerHTML 获得后者。\n\n我们用以下例子来解释他们的最重要的不同点，看看以下 HTML 节点的 innerText 和 textContent。\n\n```html\n<div id=\"t\">\n    <div>lions, tigers</div>\n    <div style=\"visibility:hidden\">and bears</div>\n</div>\n```\n\ninnerText: `lions, tigers`  \ntextContent: `lions,\\n tigersand bears`\n\n注意以下不同点：（1）.那些没有显示出来元素也不会出现在 innerText 中（2）innerText 中的换行符遵循布局中换行符的规则。理解 innerText 最好的方式就是，它大概就是你选择该节点的内容然后拷贝获得的文本。而 textContent 是各个子节点的文本内容组成的文本。\n\n## innerText 可能不是你想要的\n\ninnerText 最大的特点是需要从布局系统中获得一些信息然后决定文本是怎样显示给用户的，这就是为什么 innerText 成为一个让性能变糟的一个属性。很多库喜欢用`innerText`而不用`textContent`仅仅是因为 IE 中先有`innerText`。下面让我们演示选择`innerText`和`textContent`时对性能的影响。\n\n在基于 Webkit 的浏览器中，你可以看到很大的性能差异，大概`300ms`对`1ms`。在 IE9 中，你可以看到较好的性能以及较小的差异，这是因为\n\n## innerText 可能不是你想要的另一个原因\n\n虽然 innerText 被广泛使用，但它不是规范的属性。它能够存活下来是因为 IE 时代的广泛使用。\nOn a WebKit browser, you should see a significant performance difference (~300ms vs ~1ms). On IE9, you’ll see better performance and a much smaller difference. It is clear that IE avoids computing a full layout and probably uses a special code path that computes only what is needed for innerText (which really isn’t much). If you are using Firefox or Opera, you may be scatching your head. Keep reading.\n\nWhile one could certainly conceive of use cases for innerText, most callers just assume that innerText and textContent are identical. You will see the expression node.innerText || node.textContent still being used in a number of libraries. Unfortunately, that leaves the door open for some unexpected performance problems. It is much wiser to prefer textContent these days.\n\nAnother reason innerText is probably not what you want\nWhile it is still widely used, innerText is not standard. It is a bit of behavior that has lived on due to wide use during the Internet Explorer era. It’s heavy use back then is probably the reason IE seems to have a specialized code path. To this day, it is not present in Firefox (wise decision on their part) and its behavior still varies widely in the browsers that do support it. Opera, for instance, merely computes textContent when you try to access innerText. This is why it outperforms WebKit in the example I show. When I use the expression “browser landmine”, innerText is what I have in mind. To quote my good friend, Joel Webber, “it’s slower, but at least it doesn’t work as you would expect.”\n","source":"_posts/2013-09-17-innertext-vs-textcontent.md","raw":"---\ntitle: innerText vs textContent\n---\n\n为什么 innerText 会导致重排？我在我的上篇[关于重排的文章](http://kellegous.com/j/2013/01/26/layout-performance)末尾提出了这个问题。这里简单地总结一下，有些 DOM API 可能会因为不必要的重排，从而导致严重的性能问题。我将在这些文章中，着重提出这些年我发现的关于 Web 性能的古怪问题。\n\nAs with many other things in browsers, innerText’s behavior seemed to have happened due to overlapping (and, perhaps, under-defined) use cases. 当你要获取 DOM 节点中的文本时，你会遇到两个问题，节点中原始文本是什么？用户看到的文本是什么？虽然类似，但是显然有所不同。在浏览器中，可以通过 textContent 获得前者，通过 innerHTML 获得后者。\n\n我们用以下例子来解释他们的最重要的不同点，看看以下 HTML 节点的 innerText 和 textContent。\n\n```html\n<div id=\"t\">\n    <div>lions, tigers</div>\n    <div style=\"visibility:hidden\">and bears</div>\n</div>\n```\n\ninnerText: `lions, tigers`  \ntextContent: `lions,\\n tigersand bears`\n\n注意以下不同点：（1）.那些没有显示出来元素也不会出现在 innerText 中（2）innerText 中的换行符遵循布局中换行符的规则。理解 innerText 最好的方式就是，它大概就是你选择该节点的内容然后拷贝获得的文本。而 textContent 是各个子节点的文本内容组成的文本。\n\n## innerText 可能不是你想要的\n\ninnerText 最大的特点是需要从布局系统中获得一些信息然后决定文本是怎样显示给用户的，这就是为什么 innerText 成为一个让性能变糟的一个属性。很多库喜欢用`innerText`而不用`textContent`仅仅是因为 IE 中先有`innerText`。下面让我们演示选择`innerText`和`textContent`时对性能的影响。\n\n在基于 Webkit 的浏览器中，你可以看到很大的性能差异，大概`300ms`对`1ms`。在 IE9 中，你可以看到较好的性能以及较小的差异，这是因为\n\n## innerText 可能不是你想要的另一个原因\n\n虽然 innerText 被广泛使用，但它不是规范的属性。它能够存活下来是因为 IE 时代的广泛使用。\nOn a WebKit browser, you should see a significant performance difference (~300ms vs ~1ms). On IE9, you’ll see better performance and a much smaller difference. It is clear that IE avoids computing a full layout and probably uses a special code path that computes only what is needed for innerText (which really isn’t much). If you are using Firefox or Opera, you may be scatching your head. Keep reading.\n\nWhile one could certainly conceive of use cases for innerText, most callers just assume that innerText and textContent are identical. You will see the expression node.innerText || node.textContent still being used in a number of libraries. Unfortunately, that leaves the door open for some unexpected performance problems. It is much wiser to prefer textContent these days.\n\nAnother reason innerText is probably not what you want\nWhile it is still widely used, innerText is not standard. It is a bit of behavior that has lived on due to wide use during the Internet Explorer era. It’s heavy use back then is probably the reason IE seems to have a specialized code path. To this day, it is not present in Firefox (wise decision on their part) and its behavior still varies widely in the browsers that do support it. Opera, for instance, merely computes textContent when you try to access innerText. This is why it outperforms WebKit in the example I show. When I use the expression “browser landmine”, innerText is what I have in mind. To quote my good friend, Joel Webber, “it’s slower, but at least it doesn’t work as you would expect.”\n","slug":"innertext-vs-textcontent","published":1,"date":"2013-09-16T16:00:00.000Z","updated":"2018-12-07T02:58:01.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9q000sw8wkwxx0ugnm","content":"<p>为什么 innerText 会导致重排？我在我的上篇<a href=\"http://kellegous.com/j/2013/01/26/layout-performance\" target=\"_blank\" rel=\"noopener\">关于重排的文章</a>末尾提出了这个问题。这里简单地总结一下，有些 DOM API 可能会因为不必要的重排，从而导致严重的性能问题。我将在这些文章中，着重提出这些年我发现的关于 Web 性能的古怪问题。</p>\n<p>As with many other things in browsers, innerText’s behavior seemed to have happened due to overlapping (and, perhaps, under-defined) use cases. 当你要获取 DOM 节点中的文本时，你会遇到两个问题，节点中原始文本是什么？用户看到的文本是什么？虽然类似，但是显然有所不同。在浏览器中，可以通过 textContent 获得前者，通过 innerHTML 获得后者。</p>\n<p>我们用以下例子来解释他们的最重要的不同点，看看以下 HTML 节点的 innerText 和 textContent。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"t\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>lions, tigers<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"visibility:hidden\"</span>&gt;</span>and bears<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>innerText: <code>lions, tigers</code><br>textContent: <code>lions,\\n tigersand bears</code></p>\n<p>注意以下不同点：（1）.那些没有显示出来元素也不会出现在 innerText 中（2）innerText 中的换行符遵循布局中换行符的规则。理解 innerText 最好的方式就是，它大概就是你选择该节点的内容然后拷贝获得的文本。而 textContent 是各个子节点的文本内容组成的文本。</p>\n<h2 id=\"innerText-可能不是你想要的\"><a href=\"#innerText-可能不是你想要的\" class=\"headerlink\" title=\"innerText 可能不是你想要的\"></a>innerText 可能不是你想要的</h2><p>innerText 最大的特点是需要从布局系统中获得一些信息然后决定文本是怎样显示给用户的，这就是为什么 innerText 成为一个让性能变糟的一个属性。很多库喜欢用<code>innerText</code>而不用<code>textContent</code>仅仅是因为 IE 中先有<code>innerText</code>。下面让我们演示选择<code>innerText</code>和<code>textContent</code>时对性能的影响。</p>\n<p>在基于 Webkit 的浏览器中，你可以看到很大的性能差异，大概<code>300ms</code>对<code>1ms</code>。在 IE9 中，你可以看到较好的性能以及较小的差异，这是因为</p>\n<h2 id=\"innerText-可能不是你想要的另一个原因\"><a href=\"#innerText-可能不是你想要的另一个原因\" class=\"headerlink\" title=\"innerText 可能不是你想要的另一个原因\"></a>innerText 可能不是你想要的另一个原因</h2><p>虽然 innerText 被广泛使用，但它不是规范的属性。它能够存活下来是因为 IE 时代的广泛使用。<br>On a WebKit browser, you should see a significant performance difference (~300ms vs ~1ms). On IE9, you’ll see better performance and a much smaller difference. It is clear that IE avoids computing a full layout and probably uses a special code path that computes only what is needed for innerText (which really isn’t much). If you are using Firefox or Opera, you may be scatching your head. Keep reading.</p>\n<p>While one could certainly conceive of use cases for innerText, most callers just assume that innerText and textContent are identical. You will see the expression node.innerText || node.textContent still being used in a number of libraries. Unfortunately, that leaves the door open for some unexpected performance problems. It is much wiser to prefer textContent these days.</p>\n<p>Another reason innerText is probably not what you want<br>While it is still widely used, innerText is not standard. It is a bit of behavior that has lived on due to wide use during the Internet Explorer era. It’s heavy use back then is probably the reason IE seems to have a specialized code path. To this day, it is not present in Firefox (wise decision on their part) and its behavior still varies widely in the browsers that do support it. Opera, for instance, merely computes textContent when you try to access innerText. This is why it outperforms WebKit in the example I show. When I use the expression “browser landmine”, innerText is what I have in mind. To quote my good friend, Joel Webber, “it’s slower, but at least it doesn’t work as you would expect.”</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为什么 innerText 会导致重排？我在我的上篇<a href=\"http://kellegous.com/j/2013/01/26/layout-performance\" target=\"_blank\" rel=\"noopener\">关于重排的文章</a>末尾提出了这个问题。这里简单地总结一下，有些 DOM API 可能会因为不必要的重排，从而导致严重的性能问题。我将在这些文章中，着重提出这些年我发现的关于 Web 性能的古怪问题。</p>\n<p>As with many other things in browsers, innerText’s behavior seemed to have happened due to overlapping (and, perhaps, under-defined) use cases. 当你要获取 DOM 节点中的文本时，你会遇到两个问题，节点中原始文本是什么？用户看到的文本是什么？虽然类似，但是显然有所不同。在浏览器中，可以通过 textContent 获得前者，通过 innerHTML 获得后者。</p>\n<p>我们用以下例子来解释他们的最重要的不同点，看看以下 HTML 节点的 innerText 和 textContent。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"t\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>lions, tigers<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"visibility:hidden\"</span>&gt;</span>and bears<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>innerText: <code>lions, tigers</code><br>textContent: <code>lions,\\n tigersand bears</code></p>\n<p>注意以下不同点：（1）.那些没有显示出来元素也不会出现在 innerText 中（2）innerText 中的换行符遵循布局中换行符的规则。理解 innerText 最好的方式就是，它大概就是你选择该节点的内容然后拷贝获得的文本。而 textContent 是各个子节点的文本内容组成的文本。</p>\n<h2 id=\"innerText-可能不是你想要的\"><a href=\"#innerText-可能不是你想要的\" class=\"headerlink\" title=\"innerText 可能不是你想要的\"></a>innerText 可能不是你想要的</h2><p>innerText 最大的特点是需要从布局系统中获得一些信息然后决定文本是怎样显示给用户的，这就是为什么 innerText 成为一个让性能变糟的一个属性。很多库喜欢用<code>innerText</code>而不用<code>textContent</code>仅仅是因为 IE 中先有<code>innerText</code>。下面让我们演示选择<code>innerText</code>和<code>textContent</code>时对性能的影响。</p>\n<p>在基于 Webkit 的浏览器中，你可以看到很大的性能差异，大概<code>300ms</code>对<code>1ms</code>。在 IE9 中，你可以看到较好的性能以及较小的差异，这是因为</p>\n<h2 id=\"innerText-可能不是你想要的另一个原因\"><a href=\"#innerText-可能不是你想要的另一个原因\" class=\"headerlink\" title=\"innerText 可能不是你想要的另一个原因\"></a>innerText 可能不是你想要的另一个原因</h2><p>虽然 innerText 被广泛使用，但它不是规范的属性。它能够存活下来是因为 IE 时代的广泛使用。<br>On a WebKit browser, you should see a significant performance difference (~300ms vs ~1ms). On IE9, you’ll see better performance and a much smaller difference. It is clear that IE avoids computing a full layout and probably uses a special code path that computes only what is needed for innerText (which really isn’t much). If you are using Firefox or Opera, you may be scatching your head. Keep reading.</p>\n<p>While one could certainly conceive of use cases for innerText, most callers just assume that innerText and textContent are identical. You will see the expression node.innerText || node.textContent still being used in a number of libraries. Unfortunately, that leaves the door open for some unexpected performance problems. It is much wiser to prefer textContent these days.</p>\n<p>Another reason innerText is probably not what you want<br>While it is still widely used, innerText is not standard. It is a bit of behavior that has lived on due to wide use during the Internet Explorer era. It’s heavy use back then is probably the reason IE seems to have a specialized code path. To this day, it is not present in Firefox (wise decision on their part) and its behavior still varies widely in the browsers that do support it. Opera, for instance, merely computes textContent when you try to access innerText. This is why it outperforms WebKit in the example I show. When I use the expression “browser landmine”, innerText is what I have in mind. To quote my good friend, Joel Webber, “it’s slower, but at least it doesn’t work as you would expect.”</p>\n"},{"_content":"# 浏览器缓存模型\n","source":"_posts/2013-09-23-Browser-Cache.md","raw":"# 浏览器缓存模型\n","slug":"Browser-Cache","published":1,"date":"2013-09-22T16:00:00.000Z","updated":"2018-12-07T02:57:11.187Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9q000tw8wkonxo0sz6","content":"<h1 id=\"浏览器缓存模型\"><a href=\"#浏览器缓存模型\" class=\"headerlink\" title=\"浏览器缓存模型\"></a>浏览器缓存模型</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"浏览器缓存模型\"><a href=\"#浏览器缓存模型\" class=\"headerlink\" title=\"浏览器缓存模型\"></a>浏览器缓存模型</h1>"},{"title":"HTML5应用缓存与百度地图服务","_content":"\n本文假设你基本了解 HTML5 应用缓存。\n\n前几天，一个同事联系到我，说他们项目想使用 HTML5 的应用缓存，但是遇到了脚本执行错误问题，但是如果去掉 manifest 配置，即不使用应用缓存，则一切正常运行。我让他将项目代码简化一下，剥离业务相关部分，然后打包发给我。\n\n在浏览器中打开该页面以后，发现如下两个错误：\n\n```\nUncaught ReferenceError: BMap is not defined index.html:18\nGET http://api.map.baidu.com/getscript?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2&services=&t=20130916115231\n```\n\n以上两个错误很明显是脚本加载失败造成的。\n\n通过代码可以看到，项目中使用了百度地图，使用方法是引入一个`script`标签.\n\n```html\n<script src=\"http://api.map.baidu.com/api?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2\"></script>\n```\n\n以上`script`标签从服务器端获取的代码是：\n\n```js\n(function() {\n    window.BMap_loadScriptTime = new Date().getTime();\n    document.write(\n        '<script type=\"text/javascript\" src=\"http://api.map.baidu.com/getscript?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2&services=&t=20130916115231\"></script>'\n    );\n})();\n```\n\n我们可以看到它使用了`document.write`方法，插入另一个`script`标签。然而在`manifest`文件中，却没有说明该脚本应该如何处理。\n\n```\nCACHE MANIFEST\nNETWORK:\nhttp://api.map.baidu.com/api?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2\n```\n\n这时候浏览器尝试从应用缓存中寻找`http://api.map.baidu.com/getscript?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2&services=&t=20130916115231`却没有找到，所以脚本加载失败。因为这个脚本网址不是公开 API 的一部分，今天是这个 URL，明天也许就是另一个 URL 了，所以我们不能写在`manifest`文件里面。再者地图相关资源肯定不适合应用缓存，一是我们不能枚举需要调用的脚本，图片和其他资源，从而罗列在`CACHE:`配置中，二是应用缓存在每个域下只有 25M 的配额，甚至更少。那么对于这种不固定的网址或者不可枚举的网址该怎么处理呢？\n\n这时候我们有两种做法，第一种比较简单，在`manifest`文件中 NETWORK 一栏中使用`*`这个通配符，表示如果某个 URL 没有显式定义出来，则从互联网上获取该资源。于是`manifest`文件就变成：\n\n```\nNETWORK:\n*\n```\n\n另外一种做法就是将这些不固定的网址（在这里，是百度地图服务）封装在一个固定地址的页面中，不使用应用缓存，并且通过 iframe 元素引入。  \n比如：\n\n```\nNETWORK:\nmap.html\n```\n\n其中 map.html 负责渲染地图，并且不使用应用缓存。\n\n现在问题看似解决了，但是我们的目的是使用应用缓存，那么当百度地图服务不可用（没有网络或者百度地图服务宕掉）时，打开页面是怎样的呢？我关闭了网络连接后，刷新页面，看到是一个块空白，以及如下错误：\n\n```\nApplication Cache Error event: Manifest fetch failed (-1) http://192.168.0.100/github/map/map.manifest map.html:1\nUncaught ReferenceError: BMap is not defined map.html:18\nGET http://api.map.baidu.com/api?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2\n```\n\n直接给用户一个空白的地图似乎不是那么友好，更好的一种做法就是在使用一张静态的百度地图的截图代替，或者通过文字告诉用户，地图加载失败。\n\n这时候有两种做法，一种做法是判断 BMap 是否定义，如果已定义则认为百度地图服务可用，否则认为不可用，此时可以提示用户地图服务不可用。这种做法很简单，这就不多说了。另一种做法更加适合上面使用 iframe 的情形，使用用应用缓存中的 FALLBACK 配置项。在 FALLBACK 配置中，每一行包括两个 URL，用空格分隔。第一个 URL 是正常情况下的资源地址，第二个 URL 是后备资源地址，当前者不可用时，由后者顶上。\n\n使用 FALLBACK 时，我们可以定义一个 nomap.html 作为百度地图 API 的后备处理方案。代码如下：\n\n```\nFALLBACK:\nmap.html nomap.html\n```\n\n> **FALLBACK 有个坑，就是 FALLBACK 中配置中第一个 URL 不能出现在 NETWORK 中，否则 FALLBACK 配置可能失效。**\n\n## 总结：\n\n1. 可以使用`NETWORK`中统配符`*`来告诉浏览器，对于那些未显式指定的资源总是从网络上获取。\n2. 对于`iframe`让应用的一部分使用应用缓存，另一部分不使用。\n3. 配合`FALLBACK`，可以让网络不可用时或者服务不可用时，界面更加友好。\n","source":"_posts/2013-09-23-HTML5-Application-Cache-and-Baidu-Map-Service.md","raw":"---\ntitle: HTML5应用缓存与百度地图服务\n---\n\n本文假设你基本了解 HTML5 应用缓存。\n\n前几天，一个同事联系到我，说他们项目想使用 HTML5 的应用缓存，但是遇到了脚本执行错误问题，但是如果去掉 manifest 配置，即不使用应用缓存，则一切正常运行。我让他将项目代码简化一下，剥离业务相关部分，然后打包发给我。\n\n在浏览器中打开该页面以后，发现如下两个错误：\n\n```\nUncaught ReferenceError: BMap is not defined index.html:18\nGET http://api.map.baidu.com/getscript?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2&services=&t=20130916115231\n```\n\n以上两个错误很明显是脚本加载失败造成的。\n\n通过代码可以看到，项目中使用了百度地图，使用方法是引入一个`script`标签.\n\n```html\n<script src=\"http://api.map.baidu.com/api?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2\"></script>\n```\n\n以上`script`标签从服务器端获取的代码是：\n\n```js\n(function() {\n    window.BMap_loadScriptTime = new Date().getTime();\n    document.write(\n        '<script type=\"text/javascript\" src=\"http://api.map.baidu.com/getscript?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2&services=&t=20130916115231\"></script>'\n    );\n})();\n```\n\n我们可以看到它使用了`document.write`方法，插入另一个`script`标签。然而在`manifest`文件中，却没有说明该脚本应该如何处理。\n\n```\nCACHE MANIFEST\nNETWORK:\nhttp://api.map.baidu.com/api?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2\n```\n\n这时候浏览器尝试从应用缓存中寻找`http://api.map.baidu.com/getscript?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2&services=&t=20130916115231`却没有找到，所以脚本加载失败。因为这个脚本网址不是公开 API 的一部分，今天是这个 URL，明天也许就是另一个 URL 了，所以我们不能写在`manifest`文件里面。再者地图相关资源肯定不适合应用缓存，一是我们不能枚举需要调用的脚本，图片和其他资源，从而罗列在`CACHE:`配置中，二是应用缓存在每个域下只有 25M 的配额，甚至更少。那么对于这种不固定的网址或者不可枚举的网址该怎么处理呢？\n\n这时候我们有两种做法，第一种比较简单，在`manifest`文件中 NETWORK 一栏中使用`*`这个通配符，表示如果某个 URL 没有显式定义出来，则从互联网上获取该资源。于是`manifest`文件就变成：\n\n```\nNETWORK:\n*\n```\n\n另外一种做法就是将这些不固定的网址（在这里，是百度地图服务）封装在一个固定地址的页面中，不使用应用缓存，并且通过 iframe 元素引入。  \n比如：\n\n```\nNETWORK:\nmap.html\n```\n\n其中 map.html 负责渲染地图，并且不使用应用缓存。\n\n现在问题看似解决了，但是我们的目的是使用应用缓存，那么当百度地图服务不可用（没有网络或者百度地图服务宕掉）时，打开页面是怎样的呢？我关闭了网络连接后，刷新页面，看到是一个块空白，以及如下错误：\n\n```\nApplication Cache Error event: Manifest fetch failed (-1) http://192.168.0.100/github/map/map.manifest map.html:1\nUncaught ReferenceError: BMap is not defined map.html:18\nGET http://api.map.baidu.com/api?v=1.5&ak=24fddd5bf8d6cbe100c40dfa9aed10d2\n```\n\n直接给用户一个空白的地图似乎不是那么友好，更好的一种做法就是在使用一张静态的百度地图的截图代替，或者通过文字告诉用户，地图加载失败。\n\n这时候有两种做法，一种做法是判断 BMap 是否定义，如果已定义则认为百度地图服务可用，否则认为不可用，此时可以提示用户地图服务不可用。这种做法很简单，这就不多说了。另一种做法更加适合上面使用 iframe 的情形，使用用应用缓存中的 FALLBACK 配置项。在 FALLBACK 配置中，每一行包括两个 URL，用空格分隔。第一个 URL 是正常情况下的资源地址，第二个 URL 是后备资源地址，当前者不可用时，由后者顶上。\n\n使用 FALLBACK 时，我们可以定义一个 nomap.html 作为百度地图 API 的后备处理方案。代码如下：\n\n```\nFALLBACK:\nmap.html nomap.html\n```\n\n> **FALLBACK 有个坑，就是 FALLBACK 中配置中第一个 URL 不能出现在 NETWORK 中，否则 FALLBACK 配置可能失效。**\n\n## 总结：\n\n1. 可以使用`NETWORK`中统配符`*`来告诉浏览器，对于那些未显式指定的资源总是从网络上获取。\n2. 对于`iframe`让应用的一部分使用应用缓存，另一部分不使用。\n3. 配合`FALLBACK`，可以让网络不可用时或者服务不可用时，界面更加友好。\n","slug":"HTML5-Application-Cache-and-Baidu-Map-Service","published":1,"date":"2013-09-22T16:00:00.000Z","updated":"2018-12-07T02:57:07.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9r000uw8wk7plvpdpb","content":"<p>本文假设你基本了解 HTML5 应用缓存。</p>\n<p>前几天，一个同事联系到我，说他们项目想使用 HTML5 的应用缓存，但是遇到了脚本执行错误问题，但是如果去掉 manifest 配置，即不使用应用缓存，则一切正常运行。我让他将项目代码简化一下，剥离业务相关部分，然后打包发给我。</p>\n<p>在浏览器中打开该页面以后，发现如下两个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught ReferenceError: BMap is not defined index.html:18</span><br><span class=\"line\">GET http://api.map.baidu.com/getscript?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2&amp;services=&amp;t=20130916115231</span><br></pre></td></tr></table></figure>\n<p>以上两个错误很明显是脚本加载失败造成的。</p>\n<p>通过代码可以看到，项目中使用了百度地图，使用方法是引入一个<code>script</code>标签.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://api.map.baidu.com/api?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以上<code>script</code>标签从服务器端获取的代码是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.BMap_loadScriptTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(</span><br><span class=\"line\">        <span class=\"string\">'&lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/getscript?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2&amp;services=&amp;t=20130916115231\"&gt;&lt;/script&gt;'</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>我们可以看到它使用了<code>document.write</code>方法，插入另一个<code>script</code>标签。然而在<code>manifest</code>文件中，却没有说明该脚本应该如何处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">http://api.map.baidu.com/api?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2</span><br></pre></td></tr></table></figure>\n<p>这时候浏览器尝试从应用缓存中寻找<code>http://api.map.baidu.com/getscript?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2&amp;services=&amp;t=20130916115231</code>却没有找到，所以脚本加载失败。因为这个脚本网址不是公开 API 的一部分，今天是这个 URL，明天也许就是另一个 URL 了，所以我们不能写在<code>manifest</code>文件里面。再者地图相关资源肯定不适合应用缓存，一是我们不能枚举需要调用的脚本，图片和其他资源，从而罗列在<code>CACHE:</code>配置中，二是应用缓存在每个域下只有 25M 的配额，甚至更少。那么对于这种不固定的网址或者不可枚举的网址该怎么处理呢？</p>\n<p>这时候我们有两种做法，第一种比较简单，在<code>manifest</code>文件中 NETWORK 一栏中使用<code>*</code>这个通配符，表示如果某个 URL 没有显式定义出来，则从互联网上获取该资源。于是<code>manifest</code>文件就变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">NETWORK:</span><br><span class=\"line\">*</span><br></pre></td></tr></table></figure>\n<p>另外一种做法就是将这些不固定的网址（在这里，是百度地图服务）封装在一个固定地址的页面中，不使用应用缓存，并且通过 iframe 元素引入。<br>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">NETWORK:</span><br><span class=\"line\">map.html</span><br></pre></td></tr></table></figure>\n<p>其中 map.html 负责渲染地图，并且不使用应用缓存。</p>\n<p>现在问题看似解决了，但是我们的目的是使用应用缓存，那么当百度地图服务不可用（没有网络或者百度地图服务宕掉）时，打开页面是怎样的呢？我关闭了网络连接后，刷新页面，看到是一个块空白，以及如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Application Cache Error event: Manifest fetch failed (-1) http://192.168.0.100/github/map/map.manifest map.html:1</span><br><span class=\"line\">Uncaught ReferenceError: BMap is not defined map.html:18</span><br><span class=\"line\">GET http://api.map.baidu.com/api?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2</span><br></pre></td></tr></table></figure>\n<p>直接给用户一个空白的地图似乎不是那么友好，更好的一种做法就是在使用一张静态的百度地图的截图代替，或者通过文字告诉用户，地图加载失败。</p>\n<p>这时候有两种做法，一种做法是判断 BMap 是否定义，如果已定义则认为百度地图服务可用，否则认为不可用，此时可以提示用户地图服务不可用。这种做法很简单，这就不多说了。另一种做法更加适合上面使用 iframe 的情形，使用用应用缓存中的 FALLBACK 配置项。在 FALLBACK 配置中，每一行包括两个 URL，用空格分隔。第一个 URL 是正常情况下的资源地址，第二个 URL 是后备资源地址，当前者不可用时，由后者顶上。</p>\n<p>使用 FALLBACK 时，我们可以定义一个 nomap.html 作为百度地图 API 的后备处理方案。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">FALLBACK:</span><br><span class=\"line\">map.html nomap.html</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>FALLBACK 有个坑，就是 FALLBACK 中配置中第一个 URL 不能出现在 NETWORK 中，否则 FALLBACK 配置可能失效。</strong></p>\n</blockquote>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li>可以使用<code>NETWORK</code>中统配符<code>*</code>来告诉浏览器，对于那些未显式指定的资源总是从网络上获取。</li>\n<li>对于<code>iframe</code>让应用的一部分使用应用缓存，另一部分不使用。</li>\n<li>配合<code>FALLBACK</code>，可以让网络不可用时或者服务不可用时，界面更加友好。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>本文假设你基本了解 HTML5 应用缓存。</p>\n<p>前几天，一个同事联系到我，说他们项目想使用 HTML5 的应用缓存，但是遇到了脚本执行错误问题，但是如果去掉 manifest 配置，即不使用应用缓存，则一切正常运行。我让他将项目代码简化一下，剥离业务相关部分，然后打包发给我。</p>\n<p>在浏览器中打开该页面以后，发现如下两个错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Uncaught ReferenceError: BMap is not defined index.html:18</span><br><span class=\"line\">GET http://api.map.baidu.com/getscript?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2&amp;services=&amp;t=20130916115231</span><br></pre></td></tr></table></figure>\n<p>以上两个错误很明显是脚本加载失败造成的。</p>\n<p>通过代码可以看到，项目中使用了百度地图，使用方法是引入一个<code>script</code>标签.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://api.map.baidu.com/api?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>以上<code>script</code>标签从服务器端获取的代码是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.BMap_loadScriptTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.write(</span><br><span class=\"line\">        <span class=\"string\">'&lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/getscript?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2&amp;services=&amp;t=20130916115231\"&gt;&lt;/script&gt;'</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>我们可以看到它使用了<code>document.write</code>方法，插入另一个<code>script</code>标签。然而在<code>manifest</code>文件中，却没有说明该脚本应该如何处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">http://api.map.baidu.com/api?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2</span><br></pre></td></tr></table></figure>\n<p>这时候浏览器尝试从应用缓存中寻找<code>http://api.map.baidu.com/getscript?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2&amp;services=&amp;t=20130916115231</code>却没有找到，所以脚本加载失败。因为这个脚本网址不是公开 API 的一部分，今天是这个 URL，明天也许就是另一个 URL 了，所以我们不能写在<code>manifest</code>文件里面。再者地图相关资源肯定不适合应用缓存，一是我们不能枚举需要调用的脚本，图片和其他资源，从而罗列在<code>CACHE:</code>配置中，二是应用缓存在每个域下只有 25M 的配额，甚至更少。那么对于这种不固定的网址或者不可枚举的网址该怎么处理呢？</p>\n<p>这时候我们有两种做法，第一种比较简单，在<code>manifest</code>文件中 NETWORK 一栏中使用<code>*</code>这个通配符，表示如果某个 URL 没有显式定义出来，则从互联网上获取该资源。于是<code>manifest</code>文件就变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">NETWORK:</span><br><span class=\"line\">*</span><br></pre></td></tr></table></figure>\n<p>另外一种做法就是将这些不固定的网址（在这里，是百度地图服务）封装在一个固定地址的页面中，不使用应用缓存，并且通过 iframe 元素引入。<br>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">NETWORK:</span><br><span class=\"line\">map.html</span><br></pre></td></tr></table></figure>\n<p>其中 map.html 负责渲染地图，并且不使用应用缓存。</p>\n<p>现在问题看似解决了，但是我们的目的是使用应用缓存，那么当百度地图服务不可用（没有网络或者百度地图服务宕掉）时，打开页面是怎样的呢？我关闭了网络连接后，刷新页面，看到是一个块空白，以及如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Application Cache Error event: Manifest fetch failed (-1) http://192.168.0.100/github/map/map.manifest map.html:1</span><br><span class=\"line\">Uncaught ReferenceError: BMap is not defined map.html:18</span><br><span class=\"line\">GET http://api.map.baidu.com/api?v=1.5&amp;ak=24fddd5bf8d6cbe100c40dfa9aed10d2</span><br></pre></td></tr></table></figure>\n<p>直接给用户一个空白的地图似乎不是那么友好，更好的一种做法就是在使用一张静态的百度地图的截图代替，或者通过文字告诉用户，地图加载失败。</p>\n<p>这时候有两种做法，一种做法是判断 BMap 是否定义，如果已定义则认为百度地图服务可用，否则认为不可用，此时可以提示用户地图服务不可用。这种做法很简单，这就不多说了。另一种做法更加适合上面使用 iframe 的情形，使用用应用缓存中的 FALLBACK 配置项。在 FALLBACK 配置中，每一行包括两个 URL，用空格分隔。第一个 URL 是正常情况下的资源地址，第二个 URL 是后备资源地址，当前者不可用时，由后者顶上。</p>\n<p>使用 FALLBACK 时，我们可以定义一个 nomap.html 作为百度地图 API 的后备处理方案。代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">FALLBACK:</span><br><span class=\"line\">map.html nomap.html</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>FALLBACK 有个坑，就是 FALLBACK 中配置中第一个 URL 不能出现在 NETWORK 中，否则 FALLBACK 配置可能失效。</strong></p>\n</blockquote>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li>可以使用<code>NETWORK</code>中统配符<code>*</code>来告诉浏览器，对于那些未显式指定的资源总是从网络上获取。</li>\n<li>对于<code>iframe</code>让应用的一部分使用应用缓存，另一部分不使用。</li>\n<li>配合<code>FALLBACK</code>，可以让网络不可用时或者服务不可用时，界面更加友好。</li>\n</ol>\n"},{"title":"HTML5应用缓存基础知识","_content":"\n下面简单的介绍一下应用缓存的基本知识：\n\n## 1. 应用缓存的作用\n\n让浏览器内 WebApp 像本地应用一样，多数或者全部资源都保存在本地，在没有网络，或者服务器宕掉的情况下，仍然能够使用大多数或者全部功能。有三个特点：离线浏览，更快的速度，以及减轻服务器负担。\n\n## 2. 使用了应用缓存的页面的加载流程\n\n当浏览器访问一个包含了应用缓存的页面时，\n\n1. 如果应用缓存已经存在，那么直接使用应用缓存，并且仅仅加载`manifest`文件，判断该文件是否和缓存中的`manifest`文件是否相同，如果相同，则什么也不做，如果有任何一点不同，则重新加载`manifest`文件中列出的一系列缓存文件，并且在此过程中，会触发一些列的事件，可以通过监听这些时间，来重新加载该页面，以使用网站的最新版本。，\n2. 否则浏览器加载文档，然后获取`manifest`文件列出的 CACHE 和 FALLBACK 文件，生成第一版的应用缓存。\n\n## 3. 使用方法：\n\n### 1. 创建`manifest`文件\n\n以下是`manifest`文件的模板\n\n```\nCACHE MANIFEST\n# version 1\nCACHE:\npath/to/cached/file/a.html\npath/to/cached/file/b.js\nNETWORK:\npath/to/network/request/a\npath/to/network/folder/b\nFALLBACK:\npath/to/network/request/c path/to/fallback/file/c\npath/to/network/folder/d path/to/fallback/file/d\n```\n\n`manifest`文件对路径，文件名和后缀名没有限制。但是一般推荐放在项目根目录下面，因为在`manifest`文件里面定义的相对路径是相对于`manifest`文件的，而不是引用该`manifest`文件的 html 页面。后缀名虽然没有限制，但是该文件的 MIME 类型必须是`text/cache-manifest`，因此假如后缀名是`manifest`，那么必须做如下配置：\nApache： 在相应的`.htaccess`文件中增加 `AddType text/cache-manifest .manifest`  \nNginx： 在`mime.types`文件中加上`text/cache-manifest manifest`;\n\n第一行必须是`CACHE MANIFEST`；  \n第二行建议是注释，标明当前`manifest`文件版本。注释以`#`开始。为什么要有这样一个注释呢，这是因为浏览器在判断是否需要更新应用缓存时，是根据当前获得的`manifest`文件内容和缓存中的`manifest`文件内容有没有不同，如有不同，才会更新应用缓存。有时候我们仅仅更改某个文件的内容，但是`manifest`文件却不需要更改，但是如果不更改，那么浏览器就不会去获取新的资源文件。所以一个最佳实践就是一旦有文件修改，总是去更新`manifest`文件中的版本号。  \n在以后的若干行中，可以是\n1）空白行  \n2）注释行  \n3）段落标题 可以是`CACHE:`，`NETWORK:`或`FALLBACK:`，可以出现零次或多次。  \n4）段落数据  \nCACHE 段落以`CACHE:`段落标题（可省略）开始，每行都是一个 URL，表示该资源要被缓存起来。不允许使用通配符`*`。  \nNETWORK 段落以`NETWORK:`段落标题开始，每行都是一个 URL，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取。  \nFALLBACK 段落以`FALLBACK:`段落标题开始，每行都包含两个 URL，第一个 URL 是资源地址，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取，第二个 URL 是后备资源地址，该资源会放入应用缓存中。如果前者获取失败，则从应用缓存获取后备资源替代。\n\n### 2. 引入`manifest`文件\n\n```html\n<html manifest=\"example.manifest\">\n    ...\n</html>\n```\n\n### 3. 前面已经提到，需要给`manifest`文件设置正确的 MIME 类型\n\n## 注意事项\n\n### 1. 自动缓存包含`manifest`文件的 HTML 页面\n\n这一点是有必要的，因为如果不缓存该页面，该页面必须通过网络加载，这样就不能达到离线应用的目的。如果你只想缓存这些资源，减少网络资源请求，并不想做成离线应用，那么你可以在页面中增加一个隐藏的 iframe，并且该 iframe 正确地引用了`manifest`文件。\n\n### 2. 一旦`manifest`文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次\n\n这是应用缓存的一个巨大缺陷，不过可以结合 localStorage 实现一个更加灵活的缓存系统，即实现了离线应用，又避免的资源的全量更新。\n\n## 参考\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache)\n","source":"_posts/2013-09-25-HTML5-Application-Cache-Basic.md","raw":"---\ntitle: HTML5应用缓存基础知识\n---\n\n下面简单的介绍一下应用缓存的基本知识：\n\n## 1. 应用缓存的作用\n\n让浏览器内 WebApp 像本地应用一样，多数或者全部资源都保存在本地，在没有网络，或者服务器宕掉的情况下，仍然能够使用大多数或者全部功能。有三个特点：离线浏览，更快的速度，以及减轻服务器负担。\n\n## 2. 使用了应用缓存的页面的加载流程\n\n当浏览器访问一个包含了应用缓存的页面时，\n\n1. 如果应用缓存已经存在，那么直接使用应用缓存，并且仅仅加载`manifest`文件，判断该文件是否和缓存中的`manifest`文件是否相同，如果相同，则什么也不做，如果有任何一点不同，则重新加载`manifest`文件中列出的一系列缓存文件，并且在此过程中，会触发一些列的事件，可以通过监听这些时间，来重新加载该页面，以使用网站的最新版本。，\n2. 否则浏览器加载文档，然后获取`manifest`文件列出的 CACHE 和 FALLBACK 文件，生成第一版的应用缓存。\n\n## 3. 使用方法：\n\n### 1. 创建`manifest`文件\n\n以下是`manifest`文件的模板\n\n```\nCACHE MANIFEST\n# version 1\nCACHE:\npath/to/cached/file/a.html\npath/to/cached/file/b.js\nNETWORK:\npath/to/network/request/a\npath/to/network/folder/b\nFALLBACK:\npath/to/network/request/c path/to/fallback/file/c\npath/to/network/folder/d path/to/fallback/file/d\n```\n\n`manifest`文件对路径，文件名和后缀名没有限制。但是一般推荐放在项目根目录下面，因为在`manifest`文件里面定义的相对路径是相对于`manifest`文件的，而不是引用该`manifest`文件的 html 页面。后缀名虽然没有限制，但是该文件的 MIME 类型必须是`text/cache-manifest`，因此假如后缀名是`manifest`，那么必须做如下配置：\nApache： 在相应的`.htaccess`文件中增加 `AddType text/cache-manifest .manifest`  \nNginx： 在`mime.types`文件中加上`text/cache-manifest manifest`;\n\n第一行必须是`CACHE MANIFEST`；  \n第二行建议是注释，标明当前`manifest`文件版本。注释以`#`开始。为什么要有这样一个注释呢，这是因为浏览器在判断是否需要更新应用缓存时，是根据当前获得的`manifest`文件内容和缓存中的`manifest`文件内容有没有不同，如有不同，才会更新应用缓存。有时候我们仅仅更改某个文件的内容，但是`manifest`文件却不需要更改，但是如果不更改，那么浏览器就不会去获取新的资源文件。所以一个最佳实践就是一旦有文件修改，总是去更新`manifest`文件中的版本号。  \n在以后的若干行中，可以是\n1）空白行  \n2）注释行  \n3）段落标题 可以是`CACHE:`，`NETWORK:`或`FALLBACK:`，可以出现零次或多次。  \n4）段落数据  \nCACHE 段落以`CACHE:`段落标题（可省略）开始，每行都是一个 URL，表示该资源要被缓存起来。不允许使用通配符`*`。  \nNETWORK 段落以`NETWORK:`段落标题开始，每行都是一个 URL，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取。  \nFALLBACK 段落以`FALLBACK:`段落标题开始，每行都包含两个 URL，第一个 URL 是资源地址，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取，第二个 URL 是后备资源地址，该资源会放入应用缓存中。如果前者获取失败，则从应用缓存获取后备资源替代。\n\n### 2. 引入`manifest`文件\n\n```html\n<html manifest=\"example.manifest\">\n    ...\n</html>\n```\n\n### 3. 前面已经提到，需要给`manifest`文件设置正确的 MIME 类型\n\n## 注意事项\n\n### 1. 自动缓存包含`manifest`文件的 HTML 页面\n\n这一点是有必要的，因为如果不缓存该页面，该页面必须通过网络加载，这样就不能达到离线应用的目的。如果你只想缓存这些资源，减少网络资源请求，并不想做成离线应用，那么你可以在页面中增加一个隐藏的 iframe，并且该 iframe 正确地引用了`manifest`文件。\n\n### 2. 一旦`manifest`文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次\n\n这是应用缓存的一个巨大缺陷，不过可以结合 localStorage 实现一个更加灵活的缓存系统，即实现了离线应用，又避免的资源的全量更新。\n\n## 参考\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache)\n","slug":"HTML5-Application-Cache-Basic","published":1,"date":"2013-09-24T16:00:00.000Z","updated":"2018-12-07T02:56:53.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9s000vw8wkj7pg3dl9","content":"<p>下面简单的介绍一下应用缓存的基本知识：</p>\n<h2 id=\"1-应用缓存的作用\"><a href=\"#1-应用缓存的作用\" class=\"headerlink\" title=\"1. 应用缓存的作用\"></a>1. 应用缓存的作用</h2><p>让浏览器内 WebApp 像本地应用一样，多数或者全部资源都保存在本地，在没有网络，或者服务器宕掉的情况下，仍然能够使用大多数或者全部功能。有三个特点：离线浏览，更快的速度，以及减轻服务器负担。</p>\n<h2 id=\"2-使用了应用缓存的页面的加载流程\"><a href=\"#2-使用了应用缓存的页面的加载流程\" class=\"headerlink\" title=\"2. 使用了应用缓存的页面的加载流程\"></a>2. 使用了应用缓存的页面的加载流程</h2><p>当浏览器访问一个包含了应用缓存的页面时，</p>\n<ol>\n<li>如果应用缓存已经存在，那么直接使用应用缓存，并且仅仅加载<code>manifest</code>文件，判断该文件是否和缓存中的<code>manifest</code>文件是否相同，如果相同，则什么也不做，如果有任何一点不同，则重新加载<code>manifest</code>文件中列出的一系列缓存文件，并且在此过程中，会触发一些列的事件，可以通过监听这些时间，来重新加载该页面，以使用网站的最新版本。，</li>\n<li>否则浏览器加载文档，然后获取<code>manifest</code>文件列出的 CACHE 和 FALLBACK 文件，生成第一版的应用缓存。</li>\n</ol>\n<h2 id=\"3-使用方法：\"><a href=\"#3-使用方法：\" class=\"headerlink\" title=\"3. 使用方法：\"></a>3. 使用方法：</h2><h3 id=\"1-创建manifest文件\"><a href=\"#1-创建manifest文件\" class=\"headerlink\" title=\"1. 创建manifest文件\"></a>1. 创建<code>manifest</code>文件</h3><p>以下是<code>manifest</code>文件的模板</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"># version 1</span><br><span class=\"line\">CACHE:</span><br><span class=\"line\">path/to/cached/file/a.html</span><br><span class=\"line\">path/to/cached/file/b.js</span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">path/to/network/request/a</span><br><span class=\"line\">path/to/network/folder/b</span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\">path/to/network/request/c path/to/fallback/file/c</span><br><span class=\"line\">path/to/network/folder/d path/to/fallback/file/d</span><br></pre></td></tr></table></figure>\n<p><code>manifest</code>文件对路径，文件名和后缀名没有限制。但是一般推荐放在项目根目录下面，因为在<code>manifest</code>文件里面定义的相对路径是相对于<code>manifest</code>文件的，而不是引用该<code>manifest</code>文件的 html 页面。后缀名虽然没有限制，但是该文件的 MIME 类型必须是<code>text/cache-manifest</code>，因此假如后缀名是<code>manifest</code>，那么必须做如下配置：<br>Apache： 在相应的<code>.htaccess</code>文件中增加 <code>AddType text/cache-manifest .manifest</code><br>Nginx： 在<code>mime.types</code>文件中加上<code>text/cache-manifest manifest</code>;</p>\n<p>第一行必须是<code>CACHE MANIFEST</code>；<br>第二行建议是注释，标明当前<code>manifest</code>文件版本。注释以<code>#</code>开始。为什么要有这样一个注释呢，这是因为浏览器在判断是否需要更新应用缓存时，是根据当前获得的<code>manifest</code>文件内容和缓存中的<code>manifest</code>文件内容有没有不同，如有不同，才会更新应用缓存。有时候我们仅仅更改某个文件的内容，但是<code>manifest</code>文件却不需要更改，但是如果不更改，那么浏览器就不会去获取新的资源文件。所以一个最佳实践就是一旦有文件修改，总是去更新<code>manifest</code>文件中的版本号。<br>在以后的若干行中，可以是<br>1）空白行<br>2）注释行<br>3）段落标题 可以是<code>CACHE:</code>，<code>NETWORK:</code>或<code>FALLBACK:</code>，可以出现零次或多次。<br>4）段落数据<br>CACHE 段落以<code>CACHE:</code>段落标题（可省略）开始，每行都是一个 URL，表示该资源要被缓存起来。不允许使用通配符<code>*</code>。<br>NETWORK 段落以<code>NETWORK:</code>段落标题开始，每行都是一个 URL，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取。<br>FALLBACK 段落以<code>FALLBACK:</code>段落标题开始，每行都包含两个 URL，第一个 URL 是资源地址，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取，第二个 URL 是后备资源地址，该资源会放入应用缓存中。如果前者获取失败，则从应用缓存获取后备资源替代。</p>\n<h3 id=\"2-引入manifest文件\"><a href=\"#2-引入manifest文件\" class=\"headerlink\" title=\"2. 引入manifest文件\"></a>2. 引入<code>manifest</code>文件</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"example.manifest\"</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-前面已经提到，需要给manifest文件设置正确的-MIME-类型\"><a href=\"#3-前面已经提到，需要给manifest文件设置正确的-MIME-类型\" class=\"headerlink\" title=\"3. 前面已经提到，需要给manifest文件设置正确的 MIME 类型\"></a>3. 前面已经提到，需要给<code>manifest</code>文件设置正确的 MIME 类型</h3><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"1-自动缓存包含manifest文件的-HTML-页面\"><a href=\"#1-自动缓存包含manifest文件的-HTML-页面\" class=\"headerlink\" title=\"1. 自动缓存包含manifest文件的 HTML 页面\"></a>1. 自动缓存包含<code>manifest</code>文件的 HTML 页面</h3><p>这一点是有必要的，因为如果不缓存该页面，该页面必须通过网络加载，这样就不能达到离线应用的目的。如果你只想缓存这些资源，减少网络资源请求，并不想做成离线应用，那么你可以在页面中增加一个隐藏的 iframe，并且该 iframe 正确地引用了<code>manifest</code>文件。</p>\n<h3 id=\"2-一旦manifest文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次\"><a href=\"#2-一旦manifest文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次\" class=\"headerlink\" title=\"2. 一旦manifest文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次\"></a>2. 一旦<code>manifest</code>文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次</h3><p>这是应用缓存的一个巨大缺陷，不过可以结合 localStorage 实现一个更加灵活的缓存系统，即实现了离线应用，又避免的资源的全量更新。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>下面简单的介绍一下应用缓存的基本知识：</p>\n<h2 id=\"1-应用缓存的作用\"><a href=\"#1-应用缓存的作用\" class=\"headerlink\" title=\"1. 应用缓存的作用\"></a>1. 应用缓存的作用</h2><p>让浏览器内 WebApp 像本地应用一样，多数或者全部资源都保存在本地，在没有网络，或者服务器宕掉的情况下，仍然能够使用大多数或者全部功能。有三个特点：离线浏览，更快的速度，以及减轻服务器负担。</p>\n<h2 id=\"2-使用了应用缓存的页面的加载流程\"><a href=\"#2-使用了应用缓存的页面的加载流程\" class=\"headerlink\" title=\"2. 使用了应用缓存的页面的加载流程\"></a>2. 使用了应用缓存的页面的加载流程</h2><p>当浏览器访问一个包含了应用缓存的页面时，</p>\n<ol>\n<li>如果应用缓存已经存在，那么直接使用应用缓存，并且仅仅加载<code>manifest</code>文件，判断该文件是否和缓存中的<code>manifest</code>文件是否相同，如果相同，则什么也不做，如果有任何一点不同，则重新加载<code>manifest</code>文件中列出的一系列缓存文件，并且在此过程中，会触发一些列的事件，可以通过监听这些时间，来重新加载该页面，以使用网站的最新版本。，</li>\n<li>否则浏览器加载文档，然后获取<code>manifest</code>文件列出的 CACHE 和 FALLBACK 文件，生成第一版的应用缓存。</li>\n</ol>\n<h2 id=\"3-使用方法：\"><a href=\"#3-使用方法：\" class=\"headerlink\" title=\"3. 使用方法：\"></a>3. 使用方法：</h2><h3 id=\"1-创建manifest文件\"><a href=\"#1-创建manifest文件\" class=\"headerlink\" title=\"1. 创建manifest文件\"></a>1. 创建<code>manifest</code>文件</h3><p>以下是<code>manifest</code>文件的模板</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">CACHE MANIFEST</span><br><span class=\"line\"># version 1</span><br><span class=\"line\">CACHE:</span><br><span class=\"line\">path/to/cached/file/a.html</span><br><span class=\"line\">path/to/cached/file/b.js</span><br><span class=\"line\">NETWORK:</span><br><span class=\"line\">path/to/network/request/a</span><br><span class=\"line\">path/to/network/folder/b</span><br><span class=\"line\">FALLBACK:</span><br><span class=\"line\">path/to/network/request/c path/to/fallback/file/c</span><br><span class=\"line\">path/to/network/folder/d path/to/fallback/file/d</span><br></pre></td></tr></table></figure>\n<p><code>manifest</code>文件对路径，文件名和后缀名没有限制。但是一般推荐放在项目根目录下面，因为在<code>manifest</code>文件里面定义的相对路径是相对于<code>manifest</code>文件的，而不是引用该<code>manifest</code>文件的 html 页面。后缀名虽然没有限制，但是该文件的 MIME 类型必须是<code>text/cache-manifest</code>，因此假如后缀名是<code>manifest</code>，那么必须做如下配置：<br>Apache： 在相应的<code>.htaccess</code>文件中增加 <code>AddType text/cache-manifest .manifest</code><br>Nginx： 在<code>mime.types</code>文件中加上<code>text/cache-manifest manifest</code>;</p>\n<p>第一行必须是<code>CACHE MANIFEST</code>；<br>第二行建议是注释，标明当前<code>manifest</code>文件版本。注释以<code>#</code>开始。为什么要有这样一个注释呢，这是因为浏览器在判断是否需要更新应用缓存时，是根据当前获得的<code>manifest</code>文件内容和缓存中的<code>manifest</code>文件内容有没有不同，如有不同，才会更新应用缓存。有时候我们仅仅更改某个文件的内容，但是<code>manifest</code>文件却不需要更改，但是如果不更改，那么浏览器就不会去获取新的资源文件。所以一个最佳实践就是一旦有文件修改，总是去更新<code>manifest</code>文件中的版本号。<br>在以后的若干行中，可以是<br>1）空白行<br>2）注释行<br>3）段落标题 可以是<code>CACHE:</code>，<code>NETWORK:</code>或<code>FALLBACK:</code>，可以出现零次或多次。<br>4）段落数据<br>CACHE 段落以<code>CACHE:</code>段落标题（可省略）开始，每行都是一个 URL，表示该资源要被缓存起来。不允许使用通配符<code>*</code>。<br>NETWORK 段落以<code>NETWORK:</code>段落标题开始，每行都是一个 URL，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取。<br>FALLBACK 段落以<code>FALLBACK:</code>段落标题开始，每行都包含两个 URL，第一个 URL 是资源地址，代表一条资源或者该资源目录下的一组子资源，表示这些资源总是从互联网获取，第二个 URL 是后备资源地址，该资源会放入应用缓存中。如果前者获取失败，则从应用缓存获取后备资源替代。</p>\n<h3 id=\"2-引入manifest文件\"><a href=\"#2-引入manifest文件\" class=\"headerlink\" title=\"2. 引入manifest文件\"></a>2. 引入<code>manifest</code>文件</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">manifest</span>=<span class=\"string\">\"example.manifest\"</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-前面已经提到，需要给manifest文件设置正确的-MIME-类型\"><a href=\"#3-前面已经提到，需要给manifest文件设置正确的-MIME-类型\" class=\"headerlink\" title=\"3. 前面已经提到，需要给manifest文件设置正确的 MIME 类型\"></a>3. 前面已经提到，需要给<code>manifest</code>文件设置正确的 MIME 类型</h3><h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><h3 id=\"1-自动缓存包含manifest文件的-HTML-页面\"><a href=\"#1-自动缓存包含manifest文件的-HTML-页面\" class=\"headerlink\" title=\"1. 自动缓存包含manifest文件的 HTML 页面\"></a>1. 自动缓存包含<code>manifest</code>文件的 HTML 页面</h3><p>这一点是有必要的，因为如果不缓存该页面，该页面必须通过网络加载，这样就不能达到离线应用的目的。如果你只想缓存这些资源，减少网络资源请求，并不想做成离线应用，那么你可以在页面中增加一个隐藏的 iframe，并且该 iframe 正确地引用了<code>manifest</code>文件。</p>\n<h3 id=\"2-一旦manifest文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次\"><a href=\"#2-一旦manifest文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次\" class=\"headerlink\" title=\"2. 一旦manifest文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次\"></a>2. 一旦<code>manifest</code>文件文件内容有变化，那么所有的缓存文件都必须被重新加载一次</h3><p>这是应用缓存的一个巨大缺陷，不过可以结合 localStorage 实现一个更加灵活的缓存系统，即实现了离线应用，又避免的资源的全量更新。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/HTML/Using_the_application_cache\" target=\"_blank\" rel=\"noopener\">MDN</a></p>\n"},{"title":"【翻译】图片优化工具","_content":"\n[原文地址](http://addyosmani.com/blog/image-optimization-tools/)\n\nAs we saw a few weeks ago, the weight of an average web page is now almost 1.5MB (median ~1MB), with > 50% of this being images. It’s a harsh reminder that many of our pages on the web are still quite fat, a big concern for slower mobile data connections.zipjszip\n\nBigQuery calculated medians for a HTTP Archive run\nBigQuery calculated medians for a HTTP Archive run thanks to Ilya Grigorik\nThere have been plenty of well documented cases of page weight being heavy, with the Oakley site Brad Frost mentioned in April clocking in at ~ 25MB worth of images alone. Insanity. Just think of this on mobile: slower data, CPU, GPU..and it’s just ONE page.\n\nImages are a non-trivial problem to solve because they occasionally need to be high-res, but at the same time small enough to not kill your users mobile data cap. My hope is that srcset will help us improve this long-term. Thankfully Blink, WebKit and soon FF will have it.\n\nThe page cost of using images on the web is however not a new problem but we’re at least moving beyond blaming scripts as the main culprit. As a reminder, here’s a quote from Adam Sontag who suggested “One less JPG” as a solution to our bickering about framework sizes back in 2012:\n\nTools\n\nWhere possible, it’s best to try automating image optimization so that it’s a first-class citizen in your build chain. To help, I thought I’d share some of the tools I use for this.\n\nAs a general rule run lossy optimizers first, then lossless. Most developers forget that optimizers optimize a particular file rather than the image. This means that it doesn’t make sense to optimize an image file and then resize/crop or convert it as any changes to the file will completely undo lossless optimizations and make lossy ones a lot less effective.\n\nGrunt tasks\n\nGrunt is a fantastic task runner I use daily and there are a number of reliable tasks that can assist with image weight reduction:\n\nRecompressing JPG/PNG/GIF to save on bytes:\nOptiPNG/jpegtran/gifsicle: grunt-contrib-imagemin\nImageOptim-CLI companion: grunt-imageoptim\nConvert to WebP: grunt-webp\nSpriting to reduce HTTP requests:\ngrunt-spritefiles\ngrunt-montage\nPrescaling (normalization) to avoid excessive image resize/decode work:\ngrunt-imageNormalize\ngrunt-image-resize\nResponsive image generation/handling:\nGenerate multi-resolution images: grunt-responsive-images\nClowncar technique: grunt-clowncar\nInline images as data URIs (careful as costly on mobile):\ngrunt-image-embed\nOf course, not everyone uses Grunt so let’s take a look at some individual tools you can use regardless of your tooling choices.\n\nIndividual tools\n\nSome of the image compressions tools I recommend checking out include:\n\nPNG:\npngcrush\noptipng\nadvpng\nFor Windows, see pngout and pngwolf.\nzopfli-png and Pngnq S9 by Kornel\nPNG Quantizer\npngquant ~ recommended\npngnq\nJPG:\njpegmini\njpegcrush\njpegoptim\njpgtran\nGIF:\ngifsicle\nThe Yeoman team have a Node.js wrapper called node-gifsicle that makes this available as a local dependency on OS X, Linux and Windows in case you’re interested.We have wrappers for optipng, jpegtran, pngquant too.\n\nSVG\nSVGO which has a Grunt task called grunt-svgmin\nSVGCleaner\nYou may also find that removing EXIF data and unneeded color profile information from images also leads to some gains.\n\nList of tools? Argh. What should I use?\n\nImage compression expert Kornel Lesiński was kind enough to reach out with some recommendations for what to use based on research and usage of them. If opting for your own tooling chain:\n\nFor JPEG:\n\nJPEGMini – lossy (30-50% reduction)\nJPEGMini sets the quality of your JPEG to the lowest setting the human eyes can tolerate. It’s quite good at doing this. If you’re unable to use it, consider manually adjusting the quality as low as possible. Be careful though as you shouldn’t just save all JPEGs at “80%”. The quality setting is only a weak approximation and quality that you actually achieve can vary from image to image.\n\nJPEGMini doesn’t really have an open-source/CLI equivalent (ImageOptim-CLI scripts it though) but the closest equivalent is adept-jpg-compressor.\n\njpegcrush (same as jpegrescan) is lossless (5-10% reduction), beating jpegoptim in 99% of cases. jpegcrush is a Perl script utilizing jpegtran, so there’s little need to use jpegtran separately.\nFor PNG:\n\nThere are 3 steps involved in PNG compression: first lossy conversion (50-70% reduction), then search for optimal filters (5-10%), and then optimal gzip (5-30%).\n\npngquant2 provides a competitive filesize and quality compression option for PNG. Windows users can use Tinypng.org which is pngquant2+optipng (and Kraken.io is the same thing again). Note that most “stable” Linux distributions ship pngquant 1.0. This is quite old and offers significantly poorer quality encodes. pngquant is worth using from version 1.6 up.\npngnq-s9, pngnq and Photoshop export (if you don’t have alpha) are also decent options worth trying (they’re okay). I would suggest staying away from RIOT, PHP-libgd and if at all possible ImageMagick and IrfanView as they aren’t great at PNG8 and don’t fully support alpha either.\n\ncryopng is also worth checking out and (if you have time) pngwolf, which was mentioned earlier. Alternatively Optipng or pngcrush.\nadvpng probably has the best speed/compression ratio and I believe that’s what punypng and Kraken.io use too. If you have time, then Zopflipng is also worth considering. It’s quite slow, but beats everything else 95% of the time. PNGOUT is a close second (and pretty slow too).\nOnline tools\n\nThere are also a number of free online tools you can use for optimization including some of those mentioned already: Kraken.io, punypng, smush.it, tinypng and jpegmini. Also check out Spriteme for combining background images into CSS sprites.\n\nDesktop tools\n\nIf you’re primarily a designer or don’t have a build process setup, please consider at least running your images through tools like ImageOptim or ImageAlpha as they will shave bytes off your images and keep your pages a little more lean.\n\nYou might also find this write-up on image compression for web developers by Colt McAnlis of interest.\n\nmod_pagespeed\n\nFor those looking for a more automated server-side solution to image optimization, mod_pagespeed is an Apache module created by some of my colleagues at Google to speed up pages to reduce latency and bandwidth. A list of image optimization techniques it supports is available and includes inlining and recompression.\n\nOthers?\n\nIf there are other tools or Grunt tasks you’ve found helpful for image optimization, please feel free to share them. I know that both I and others are always interested in benchmarking new alternatives.\n\nWrapping up\n\nMobile users are the biggest victims of image bloat on web pages. They take ages to load on slow connections and when used without any optimization can make for a costly user experience.\n\nRespect your user’s time, try to keep your pages lean and with some luck we’ll make the web just a little bit faster.\n","source":"_posts/2013-09-27-Tools-for-Image-Optimization.md","raw":"---\ntitle: 【翻译】图片优化工具\n---\n\n[原文地址](http://addyosmani.com/blog/image-optimization-tools/)\n\nAs we saw a few weeks ago, the weight of an average web page is now almost 1.5MB (median ~1MB), with > 50% of this being images. It’s a harsh reminder that many of our pages on the web are still quite fat, a big concern for slower mobile data connections.zipjszip\n\nBigQuery calculated medians for a HTTP Archive run\nBigQuery calculated medians for a HTTP Archive run thanks to Ilya Grigorik\nThere have been plenty of well documented cases of page weight being heavy, with the Oakley site Brad Frost mentioned in April clocking in at ~ 25MB worth of images alone. Insanity. Just think of this on mobile: slower data, CPU, GPU..and it’s just ONE page.\n\nImages are a non-trivial problem to solve because they occasionally need to be high-res, but at the same time small enough to not kill your users mobile data cap. My hope is that srcset will help us improve this long-term. Thankfully Blink, WebKit and soon FF will have it.\n\nThe page cost of using images on the web is however not a new problem but we’re at least moving beyond blaming scripts as the main culprit. As a reminder, here’s a quote from Adam Sontag who suggested “One less JPG” as a solution to our bickering about framework sizes back in 2012:\n\nTools\n\nWhere possible, it’s best to try automating image optimization so that it’s a first-class citizen in your build chain. To help, I thought I’d share some of the tools I use for this.\n\nAs a general rule run lossy optimizers first, then lossless. Most developers forget that optimizers optimize a particular file rather than the image. This means that it doesn’t make sense to optimize an image file and then resize/crop or convert it as any changes to the file will completely undo lossless optimizations and make lossy ones a lot less effective.\n\nGrunt tasks\n\nGrunt is a fantastic task runner I use daily and there are a number of reliable tasks that can assist with image weight reduction:\n\nRecompressing JPG/PNG/GIF to save on bytes:\nOptiPNG/jpegtran/gifsicle: grunt-contrib-imagemin\nImageOptim-CLI companion: grunt-imageoptim\nConvert to WebP: grunt-webp\nSpriting to reduce HTTP requests:\ngrunt-spritefiles\ngrunt-montage\nPrescaling (normalization) to avoid excessive image resize/decode work:\ngrunt-imageNormalize\ngrunt-image-resize\nResponsive image generation/handling:\nGenerate multi-resolution images: grunt-responsive-images\nClowncar technique: grunt-clowncar\nInline images as data URIs (careful as costly on mobile):\ngrunt-image-embed\nOf course, not everyone uses Grunt so let’s take a look at some individual tools you can use regardless of your tooling choices.\n\nIndividual tools\n\nSome of the image compressions tools I recommend checking out include:\n\nPNG:\npngcrush\noptipng\nadvpng\nFor Windows, see pngout and pngwolf.\nzopfli-png and Pngnq S9 by Kornel\nPNG Quantizer\npngquant ~ recommended\npngnq\nJPG:\njpegmini\njpegcrush\njpegoptim\njpgtran\nGIF:\ngifsicle\nThe Yeoman team have a Node.js wrapper called node-gifsicle that makes this available as a local dependency on OS X, Linux and Windows in case you’re interested.We have wrappers for optipng, jpegtran, pngquant too.\n\nSVG\nSVGO which has a Grunt task called grunt-svgmin\nSVGCleaner\nYou may also find that removing EXIF data and unneeded color profile information from images also leads to some gains.\n\nList of tools? Argh. What should I use?\n\nImage compression expert Kornel Lesiński was kind enough to reach out with some recommendations for what to use based on research and usage of them. If opting for your own tooling chain:\n\nFor JPEG:\n\nJPEGMini – lossy (30-50% reduction)\nJPEGMini sets the quality of your JPEG to the lowest setting the human eyes can tolerate. It’s quite good at doing this. If you’re unable to use it, consider manually adjusting the quality as low as possible. Be careful though as you shouldn’t just save all JPEGs at “80%”. The quality setting is only a weak approximation and quality that you actually achieve can vary from image to image.\n\nJPEGMini doesn’t really have an open-source/CLI equivalent (ImageOptim-CLI scripts it though) but the closest equivalent is adept-jpg-compressor.\n\njpegcrush (same as jpegrescan) is lossless (5-10% reduction), beating jpegoptim in 99% of cases. jpegcrush is a Perl script utilizing jpegtran, so there’s little need to use jpegtran separately.\nFor PNG:\n\nThere are 3 steps involved in PNG compression: first lossy conversion (50-70% reduction), then search for optimal filters (5-10%), and then optimal gzip (5-30%).\n\npngquant2 provides a competitive filesize and quality compression option for PNG. Windows users can use Tinypng.org which is pngquant2+optipng (and Kraken.io is the same thing again). Note that most “stable” Linux distributions ship pngquant 1.0. This is quite old and offers significantly poorer quality encodes. pngquant is worth using from version 1.6 up.\npngnq-s9, pngnq and Photoshop export (if you don’t have alpha) are also decent options worth trying (they’re okay). I would suggest staying away from RIOT, PHP-libgd and if at all possible ImageMagick and IrfanView as they aren’t great at PNG8 and don’t fully support alpha either.\n\ncryopng is also worth checking out and (if you have time) pngwolf, which was mentioned earlier. Alternatively Optipng or pngcrush.\nadvpng probably has the best speed/compression ratio and I believe that’s what punypng and Kraken.io use too. If you have time, then Zopflipng is also worth considering. It’s quite slow, but beats everything else 95% of the time. PNGOUT is a close second (and pretty slow too).\nOnline tools\n\nThere are also a number of free online tools you can use for optimization including some of those mentioned already: Kraken.io, punypng, smush.it, tinypng and jpegmini. Also check out Spriteme for combining background images into CSS sprites.\n\nDesktop tools\n\nIf you’re primarily a designer or don’t have a build process setup, please consider at least running your images through tools like ImageOptim or ImageAlpha as they will shave bytes off your images and keep your pages a little more lean.\n\nYou might also find this write-up on image compression for web developers by Colt McAnlis of interest.\n\nmod_pagespeed\n\nFor those looking for a more automated server-side solution to image optimization, mod_pagespeed is an Apache module created by some of my colleagues at Google to speed up pages to reduce latency and bandwidth. A list of image optimization techniques it supports is available and includes inlining and recompression.\n\nOthers?\n\nIf there are other tools or Grunt tasks you’ve found helpful for image optimization, please feel free to share them. I know that both I and others are always interested in benchmarking new alternatives.\n\nWrapping up\n\nMobile users are the biggest victims of image bloat on web pages. They take ages to load on slow connections and when used without any optimization can make for a costly user experience.\n\nRespect your user’s time, try to keep your pages lean and with some luck we’ll make the web just a little bit faster.\n","slug":"Tools-for-Image-Optimization","published":1,"date":"2013-09-26T16:00:00.000Z","updated":"2018-12-07T02:56:38.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9t000ww8wk1lwm3l02","content":"<p><a href=\"http://addyosmani.com/blog/image-optimization-tools/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>As we saw a few weeks ago, the weight of an average web page is now almost 1.5MB (median ~1MB), with &gt; 50% of this being images. It’s a harsh reminder that many of our pages on the web are still quite fat, a big concern for slower mobile data connections.zipjszip</p>\n<p>BigQuery calculated medians for a HTTP Archive run<br>BigQuery calculated medians for a HTTP Archive run thanks to Ilya Grigorik<br>There have been plenty of well documented cases of page weight being heavy, with the Oakley site Brad Frost mentioned in April clocking in at ~ 25MB worth of images alone. Insanity. Just think of this on mobile: slower data, CPU, GPU..and it’s just ONE page.</p>\n<p>Images are a non-trivial problem to solve because they occasionally need to be high-res, but at the same time small enough to not kill your users mobile data cap. My hope is that srcset will help us improve this long-term. Thankfully Blink, WebKit and soon FF will have it.</p>\n<p>The page cost of using images on the web is however not a new problem but we’re at least moving beyond blaming scripts as the main culprit. As a reminder, here’s a quote from Adam Sontag who suggested “One less JPG” as a solution to our bickering about framework sizes back in 2012:</p>\n<p>Tools</p>\n<p>Where possible, it’s best to try automating image optimization so that it’s a first-class citizen in your build chain. To help, I thought I’d share some of the tools I use for this.</p>\n<p>As a general rule run lossy optimizers first, then lossless. Most developers forget that optimizers optimize a particular file rather than the image. This means that it doesn’t make sense to optimize an image file and then resize/crop or convert it as any changes to the file will completely undo lossless optimizations and make lossy ones a lot less effective.</p>\n<p>Grunt tasks</p>\n<p>Grunt is a fantastic task runner I use daily and there are a number of reliable tasks that can assist with image weight reduction:</p>\n<p>Recompressing JPG/PNG/GIF to save on bytes:<br>OptiPNG/jpegtran/gifsicle: grunt-contrib-imagemin<br>ImageOptim-CLI companion: grunt-imageoptim<br>Convert to WebP: grunt-webp<br>Spriting to reduce HTTP requests:<br>grunt-spritefiles<br>grunt-montage<br>Prescaling (normalization) to avoid excessive image resize/decode work:<br>grunt-imageNormalize<br>grunt-image-resize<br>Responsive image generation/handling:<br>Generate multi-resolution images: grunt-responsive-images<br>Clowncar technique: grunt-clowncar<br>Inline images as data URIs (careful as costly on mobile):<br>grunt-image-embed<br>Of course, not everyone uses Grunt so let’s take a look at some individual tools you can use regardless of your tooling choices.</p>\n<p>Individual tools</p>\n<p>Some of the image compressions tools I recommend checking out include:</p>\n<p>PNG:<br>pngcrush<br>optipng<br>advpng<br>For Windows, see pngout and pngwolf.<br>zopfli-png and Pngnq S9 by Kornel<br>PNG Quantizer<br>pngquant ~ recommended<br>pngnq<br>JPG:<br>jpegmini<br>jpegcrush<br>jpegoptim<br>jpgtran<br>GIF:<br>gifsicle<br>The Yeoman team have a Node.js wrapper called node-gifsicle that makes this available as a local dependency on OS X, Linux and Windows in case you’re interested.We have wrappers for optipng, jpegtran, pngquant too.</p>\n<p>SVG<br>SVGO which has a Grunt task called grunt-svgmin<br>SVGCleaner<br>You may also find that removing EXIF data and unneeded color profile information from images also leads to some gains.</p>\n<p>List of tools? Argh. What should I use?</p>\n<p>Image compression expert Kornel Lesiński was kind enough to reach out with some recommendations for what to use based on research and usage of them. If opting for your own tooling chain:</p>\n<p>For JPEG:</p>\n<p>JPEGMini – lossy (30-50% reduction)<br>JPEGMini sets the quality of your JPEG to the lowest setting the human eyes can tolerate. It’s quite good at doing this. If you’re unable to use it, consider manually adjusting the quality as low as possible. Be careful though as you shouldn’t just save all JPEGs at “80%”. The quality setting is only a weak approximation and quality that you actually achieve can vary from image to image.</p>\n<p>JPEGMini doesn’t really have an open-source/CLI equivalent (ImageOptim-CLI scripts it though) but the closest equivalent is adept-jpg-compressor.</p>\n<p>jpegcrush (same as jpegrescan) is lossless (5-10% reduction), beating jpegoptim in 99% of cases. jpegcrush is a Perl script utilizing jpegtran, so there’s little need to use jpegtran separately.<br>For PNG:</p>\n<p>There are 3 steps involved in PNG compression: first lossy conversion (50-70% reduction), then search for optimal filters (5-10%), and then optimal gzip (5-30%).</p>\n<p>pngquant2 provides a competitive filesize and quality compression option for PNG. Windows users can use Tinypng.org which is pngquant2+optipng (and Kraken.io is the same thing again). Note that most “stable” Linux distributions ship pngquant 1.0. This is quite old and offers significantly poorer quality encodes. pngquant is worth using from version 1.6 up.<br>pngnq-s9, pngnq and Photoshop export (if you don’t have alpha) are also decent options worth trying (they’re okay). I would suggest staying away from RIOT, PHP-libgd and if at all possible ImageMagick and IrfanView as they aren’t great at PNG8 and don’t fully support alpha either.</p>\n<p>cryopng is also worth checking out and (if you have time) pngwolf, which was mentioned earlier. Alternatively Optipng or pngcrush.<br>advpng probably has the best speed/compression ratio and I believe that’s what punypng and Kraken.io use too. If you have time, then Zopflipng is also worth considering. It’s quite slow, but beats everything else 95% of the time. PNGOUT is a close second (and pretty slow too).<br>Online tools</p>\n<p>There are also a number of free online tools you can use for optimization including some of those mentioned already: Kraken.io, punypng, smush.it, tinypng and jpegmini. Also check out Spriteme for combining background images into CSS sprites.</p>\n<p>Desktop tools</p>\n<p>If you’re primarily a designer or don’t have a build process setup, please consider at least running your images through tools like ImageOptim or ImageAlpha as they will shave bytes off your images and keep your pages a little more lean.</p>\n<p>You might also find this write-up on image compression for web developers by Colt McAnlis of interest.</p>\n<p>mod_pagespeed</p>\n<p>For those looking for a more automated server-side solution to image optimization, mod_pagespeed is an Apache module created by some of my colleagues at Google to speed up pages to reduce latency and bandwidth. A list of image optimization techniques it supports is available and includes inlining and recompression.</p>\n<p>Others?</p>\n<p>If there are other tools or Grunt tasks you’ve found helpful for image optimization, please feel free to share them. I know that both I and others are always interested in benchmarking new alternatives.</p>\n<p>Wrapping up</p>\n<p>Mobile users are the biggest victims of image bloat on web pages. They take ages to load on slow connections and when used without any optimization can make for a costly user experience.</p>\n<p>Respect your user’s time, try to keep your pages lean and with some luck we’ll make the web just a little bit faster.</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://addyosmani.com/blog/image-optimization-tools/\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>As we saw a few weeks ago, the weight of an average web page is now almost 1.5MB (median ~1MB), with &gt; 50% of this being images. It’s a harsh reminder that many of our pages on the web are still quite fat, a big concern for slower mobile data connections.zipjszip</p>\n<p>BigQuery calculated medians for a HTTP Archive run<br>BigQuery calculated medians for a HTTP Archive run thanks to Ilya Grigorik<br>There have been plenty of well documented cases of page weight being heavy, with the Oakley site Brad Frost mentioned in April clocking in at ~ 25MB worth of images alone. Insanity. Just think of this on mobile: slower data, CPU, GPU..and it’s just ONE page.</p>\n<p>Images are a non-trivial problem to solve because they occasionally need to be high-res, but at the same time small enough to not kill your users mobile data cap. My hope is that srcset will help us improve this long-term. Thankfully Blink, WebKit and soon FF will have it.</p>\n<p>The page cost of using images on the web is however not a new problem but we’re at least moving beyond blaming scripts as the main culprit. As a reminder, here’s a quote from Adam Sontag who suggested “One less JPG” as a solution to our bickering about framework sizes back in 2012:</p>\n<p>Tools</p>\n<p>Where possible, it’s best to try automating image optimization so that it’s a first-class citizen in your build chain. To help, I thought I’d share some of the tools I use for this.</p>\n<p>As a general rule run lossy optimizers first, then lossless. Most developers forget that optimizers optimize a particular file rather than the image. This means that it doesn’t make sense to optimize an image file and then resize/crop or convert it as any changes to the file will completely undo lossless optimizations and make lossy ones a lot less effective.</p>\n<p>Grunt tasks</p>\n<p>Grunt is a fantastic task runner I use daily and there are a number of reliable tasks that can assist with image weight reduction:</p>\n<p>Recompressing JPG/PNG/GIF to save on bytes:<br>OptiPNG/jpegtran/gifsicle: grunt-contrib-imagemin<br>ImageOptim-CLI companion: grunt-imageoptim<br>Convert to WebP: grunt-webp<br>Spriting to reduce HTTP requests:<br>grunt-spritefiles<br>grunt-montage<br>Prescaling (normalization) to avoid excessive image resize/decode work:<br>grunt-imageNormalize<br>grunt-image-resize<br>Responsive image generation/handling:<br>Generate multi-resolution images: grunt-responsive-images<br>Clowncar technique: grunt-clowncar<br>Inline images as data URIs (careful as costly on mobile):<br>grunt-image-embed<br>Of course, not everyone uses Grunt so let’s take a look at some individual tools you can use regardless of your tooling choices.</p>\n<p>Individual tools</p>\n<p>Some of the image compressions tools I recommend checking out include:</p>\n<p>PNG:<br>pngcrush<br>optipng<br>advpng<br>For Windows, see pngout and pngwolf.<br>zopfli-png and Pngnq S9 by Kornel<br>PNG Quantizer<br>pngquant ~ recommended<br>pngnq<br>JPG:<br>jpegmini<br>jpegcrush<br>jpegoptim<br>jpgtran<br>GIF:<br>gifsicle<br>The Yeoman team have a Node.js wrapper called node-gifsicle that makes this available as a local dependency on OS X, Linux and Windows in case you’re interested.We have wrappers for optipng, jpegtran, pngquant too.</p>\n<p>SVG<br>SVGO which has a Grunt task called grunt-svgmin<br>SVGCleaner<br>You may also find that removing EXIF data and unneeded color profile information from images also leads to some gains.</p>\n<p>List of tools? Argh. What should I use?</p>\n<p>Image compression expert Kornel Lesiński was kind enough to reach out with some recommendations for what to use based on research and usage of them. If opting for your own tooling chain:</p>\n<p>For JPEG:</p>\n<p>JPEGMini – lossy (30-50% reduction)<br>JPEGMini sets the quality of your JPEG to the lowest setting the human eyes can tolerate. It’s quite good at doing this. If you’re unable to use it, consider manually adjusting the quality as low as possible. Be careful though as you shouldn’t just save all JPEGs at “80%”. The quality setting is only a weak approximation and quality that you actually achieve can vary from image to image.</p>\n<p>JPEGMini doesn’t really have an open-source/CLI equivalent (ImageOptim-CLI scripts it though) but the closest equivalent is adept-jpg-compressor.</p>\n<p>jpegcrush (same as jpegrescan) is lossless (5-10% reduction), beating jpegoptim in 99% of cases. jpegcrush is a Perl script utilizing jpegtran, so there’s little need to use jpegtran separately.<br>For PNG:</p>\n<p>There are 3 steps involved in PNG compression: first lossy conversion (50-70% reduction), then search for optimal filters (5-10%), and then optimal gzip (5-30%).</p>\n<p>pngquant2 provides a competitive filesize and quality compression option for PNG. Windows users can use Tinypng.org which is pngquant2+optipng (and Kraken.io is the same thing again). Note that most “stable” Linux distributions ship pngquant 1.0. This is quite old and offers significantly poorer quality encodes. pngquant is worth using from version 1.6 up.<br>pngnq-s9, pngnq and Photoshop export (if you don’t have alpha) are also decent options worth trying (they’re okay). I would suggest staying away from RIOT, PHP-libgd and if at all possible ImageMagick and IrfanView as they aren’t great at PNG8 and don’t fully support alpha either.</p>\n<p>cryopng is also worth checking out and (if you have time) pngwolf, which was mentioned earlier. Alternatively Optipng or pngcrush.<br>advpng probably has the best speed/compression ratio and I believe that’s what punypng and Kraken.io use too. If you have time, then Zopflipng is also worth considering. It’s quite slow, but beats everything else 95% of the time. PNGOUT is a close second (and pretty slow too).<br>Online tools</p>\n<p>There are also a number of free online tools you can use for optimization including some of those mentioned already: Kraken.io, punypng, smush.it, tinypng and jpegmini. Also check out Spriteme for combining background images into CSS sprites.</p>\n<p>Desktop tools</p>\n<p>If you’re primarily a designer or don’t have a build process setup, please consider at least running your images through tools like ImageOptim or ImageAlpha as they will shave bytes off your images and keep your pages a little more lean.</p>\n<p>You might also find this write-up on image compression for web developers by Colt McAnlis of interest.</p>\n<p>mod_pagespeed</p>\n<p>For those looking for a more automated server-side solution to image optimization, mod_pagespeed is an Apache module created by some of my colleagues at Google to speed up pages to reduce latency and bandwidth. A list of image optimization techniques it supports is available and includes inlining and recompression.</p>\n<p>Others?</p>\n<p>If there are other tools or Grunt tasks you’ve found helpful for image optimization, please feel free to share them. I know that both I and others are always interested in benchmarking new alternatives.</p>\n<p>Wrapping up</p>\n<p>Mobile users are the biggest victims of image bloat on web pages. They take ages to load on slow connections and when used without any optimization can make for a costly user experience.</p>\n<p>Respect your user’s time, try to keep your pages lean and with some luck we’ll make the web just a little bit faster.</p>\n"},{"title":"【翻译】优秀的用户界面设计（二）","_content":"\n译者注：几个月之前翻译了[Good UI](http://www.goodui.org/)前 20 个最佳实践[【翻译】优秀的用户界面设计](./blog/2013-06-28-Good-UI.md)。最近又看到有了更多的最佳实践。现在翻译出来，与您分享。\n\n1. 渐变而不是立即变化\n\nTry Transitions instead of showing changes instantly. Interface elements often appear, hide, move, shift, and resize as users do their thing. As elements respond to our interactions, it sometimes is a little easier to comprehend what just happened when we sprinkle in the element of time. A built in intentional delay in the form of an animation or transition, respects cognition and gives people the required time to understand a change in size or position. Keep in mind of course that as we start increasing the duration of such transitions beyond 0.5 seconds, there will be situations where people might start feeling the pain. For those who just wish to get things done quickly, too long of a delay of course can be a burden.\n","source":"_posts/2013-11-23-Good-UI-2.md","raw":"---\ntitle: 【翻译】优秀的用户界面设计（二）\n---\n\n译者注：几个月之前翻译了[Good UI](http://www.goodui.org/)前 20 个最佳实践[【翻译】优秀的用户界面设计](./blog/2013-06-28-Good-UI.md)。最近又看到有了更多的最佳实践。现在翻译出来，与您分享。\n\n1. 渐变而不是立即变化\n\nTry Transitions instead of showing changes instantly. Interface elements often appear, hide, move, shift, and resize as users do their thing. As elements respond to our interactions, it sometimes is a little easier to comprehend what just happened when we sprinkle in the element of time. A built in intentional delay in the form of an animation or transition, respects cognition and gives people the required time to understand a change in size or position. Keep in mind of course that as we start increasing the duration of such transitions beyond 0.5 seconds, there will be situations where people might start feeling the pain. For those who just wish to get things done quickly, too long of a delay of course can be a burden.\n","slug":"Good-UI-2","published":1,"date":"2013-11-22T16:00:00.000Z","updated":"2018-12-07T02:54:50.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9t000xw8wk2zjuotw6","content":"<p>译者注：几个月之前翻译了<a href=\"http://www.goodui.org/\" target=\"_blank\" rel=\"noopener\">Good UI</a>前 20 个最佳实践<a href=\"./blog/2013-06-28-Good-UI.md\">【翻译】优秀的用户界面设计</a>。最近又看到有了更多的最佳实践。现在翻译出来，与您分享。</p>\n<ol>\n<li>渐变而不是立即变化</li>\n</ol>\n<p>Try Transitions instead of showing changes instantly. Interface elements often appear, hide, move, shift, and resize as users do their thing. As elements respond to our interactions, it sometimes is a little easier to comprehend what just happened when we sprinkle in the element of time. A built in intentional delay in the form of an animation or transition, respects cognition and gives people the required time to understand a change in size or position. Keep in mind of course that as we start increasing the duration of such transitions beyond 0.5 seconds, there will be situations where people might start feeling the pain. For those who just wish to get things done quickly, too long of a delay of course can be a burden.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：几个月之前翻译了<a href=\"http://www.goodui.org/\" target=\"_blank\" rel=\"noopener\">Good UI</a>前 20 个最佳实践<a href=\"./blog/2013-06-28-Good-UI.md\">【翻译】优秀的用户界面设计</a>。最近又看到有了更多的最佳实践。现在翻译出来，与您分享。</p>\n<ol>\n<li>渐变而不是立即变化</li>\n</ol>\n<p>Try Transitions instead of showing changes instantly. Interface elements often appear, hide, move, shift, and resize as users do their thing. As elements respond to our interactions, it sometimes is a little easier to comprehend what just happened when we sprinkle in the element of time. A built in intentional delay in the form of an animation or transition, respects cognition and gives people the required time to understand a change in size or position. Keep in mind of course that as we start increasing the duration of such transitions beyond 0.5 seconds, there will be situations where people might start feeling the pain. For those who just wish to get things done quickly, too long of a delay of course can be a burden.</p>\n"},{"title":"【翻译】使用 Chrome 开发者工具调试 Canvas","_content":"\n## 简介\n\n使用过 Canvas 元素的人都知道 Canvas 很难调试。使用 Canvas 通常要调用一长串难以跟踪的 API。\n\n```js\nfunction draw() {\n    context.clearRect(0, 0, 258, 258);\n    context.fillStyle = '#EEEEEE';\n    context.beginPath();\n    context.arc(129, 129, 127, 0, 6.28, true);\n    context.closePath();\n    context.fill();\n}\n```\n\n有时候你希望记录发送给 Canvas 上下文的指令，并且逐条执行指令。幸运的是在 Chrome 开发者工具里有一个新的 Canvas 审查特性可以帮你做到这一点。\n\n在这篇文章里，我会给你演示怎样使用这个特性来调试你的 Canvas 行为。它支持 2D 和 WebGL 上下文，所以无论你在使用哪个，都可以使用它直接获取调试信息。\n\n## 准备开始\n\n在 Chrome 地址栏打开`about:flags`页面，并选中“启用开发者工具实验”（英文：Enable Developer Tools experiments，以上是 Chrome 中文版翻译）。  \n![Figure 1 - Enabling Developer Tools Experiments in about:flags](http://www.html5rocks.com/static/demos/canvas-inspection/images/enable-canvas-inspection.png)\n\n接下来，打开开发者工具并点击右下角的齿轮图标，在新打开配置页面中可以找到**实验（Experiments）**一栏，然后在该栏中启用**Canvas inspection（Canvas 审查）**。  \n![Figure 2 - Enabling Canvas inspection in DevTools’ experiments](http://www.html5rocks.com/static/demos/canvas-inspection/images/experiments.png)\n\n为了让这些修改生效，你必须关闭然后再打开开发者工具。当开发者工具再次打开时，找到 Profiles 一栏，你可以看到 Canvas Profile 选项，它是禁用状态，如果某个页面有你想要调试的 Canvas，你可以按下 Enable 按钮然后页面会重新载入，准备记录 Canvas 调用。  \n![Figure 3 - Switching on the Canvas Profiler](http://www.html5rocks.com/static/demos/canvas-inspection/images/canvas-profiler.png)\n\n然后你需要决定你是记录单帧（Single Frame），还是看起来很像开发者工具中时间轴的连续多帧（Consecutive Frames）。\n\n||一帧表示页面中的一次事件循环，涉及到执行 JavaScript 代码，事件处理，更新 DOM，修改样式，布局和重绘。为了让动画更加平滑，你要让每帧耗时小于 1/60 秒，即 16.6 毫秒。\n\n单帧仅仅记录本帧结束前所有的 API 调用，多帧则记录你手动停止之前的所有 API 调用。选择哪一种取决于你如何使用 canvas 元素。对于一个持续的动画，选择单帧更好，而那些用于响应用户事件的短暂动画，就应该使用多帧。\n\n![Figure 4 - Choosing how many frames to capture](http://www.html5rocks.com/static/demos/canvas-inspection/images/frames.png)\n\n这样我们就做完了所有的准备工作可以记录帧了。\n\n## 记录帧\n\n按下 Start 按钮，像平常一样与应用交互，你可以看到它已经在记录了。如果你要记录多帧，那你还需要回到开发者工具按下 Stop 按钮来结束记录。\n\n现在你可以看到左侧有一个 profile 列表中有了一个新的 profile，里面记录了所有 canvas 元素上下文的调用。点击 profile 就可以看到如下界面：\n\n![Figure 5 - A canvas profile in DevTools](http://www.html5rocks.com/static/demos/canvas-inspection/images/profile.png)\n\n你可以看到一组已经记录下来的帧，并且一步一步地浏览它们。一旦你点击了其中一个，你就可以看到该帧结束时 Canvas 的屏幕截图。如果有多个 Canvas 元素，你可以通过屏幕截图下面的菜单选择显示哪个 Canvas。\n\n![Figure 6 - Choosing your canvas context](http://www.html5rocks.com/static/demos/canvas-inspection/images/expanded-menu.png)\n\n在帧里你可以看到多个绘画调用组（Draw Call Group），每个绘画调用组包含一个绘画调用，并且是该组的最后一个调用。那什么是绘画调用呢？对于一个 2D 上下文来讲，它包括 clearRect(), drawImage(), fill(), stroke(), putImageData()和其他文字渲染方法；对于一个 WebGL 上下文来讲，它包括 clear(), drawArrays()和 drawElements()。本质上讲，任何会修改当前绘画缓存内容的调用都是绘画调用（如果你不熟悉图形编程，你可以认为缓存就是一个我们正在操作的像素位图）。\n\n你可以在帧，绘画调用组和调用这三个级别依次查看该列表。无论哪一种，你都可以看到那时的上下文，这意味着你可以迅速发现和修正 Bug。\n\n![Figure 7 - navigation buttons for convenient list hopping](http://www.html5rocks.com/static/demos/canvas-inspection/images/replaytime.png)\n\n## 找出属性变化\n\n另一个有用特性就是可以找出两次调用之间属性和变量发生了什么变化。\n\n（译者注：在 Chrome29 上没有找到该按钮，但是 canary Chrome31 上可以找到）点击右侧按钮![](http://www.html5rocks.com/static/demos/canvas-inspection/images/sidebar.png)会打开一个新的面板，随着一步一步地查看 API 调用，你可以看到属性的变化，当鼠标放在任何 Buffer 和数组上时，你可以看到他们的内容。\n\n![](http://www.html5rocks.com/static/demos/canvas-inspection/images/diff.gif)\n\n## 注意了！\n\n现在你已经知道了怎样在 Chrome 开发者工具中调试 Canvas。如果你对这个工具有任何回馈，请[提交一个 bug](http://crbug.com/new)或者写信给[Chrome 开发者工具工作组](https://groups.google.com/forum/#!forum/google-chrome-developer-tools)，告诉我们，你发现了 bug 或者在调试过程中你想看到哪些信息，因为只有开发者的回馈才能让它更好。\n","source":"_posts/2013-09-20-Canvas-Inspection-using-Chrome-DevTools.md","raw":"---\ntitle: 【翻译】使用 Chrome 开发者工具调试 Canvas\n---\n\n## 简介\n\n使用过 Canvas 元素的人都知道 Canvas 很难调试。使用 Canvas 通常要调用一长串难以跟踪的 API。\n\n```js\nfunction draw() {\n    context.clearRect(0, 0, 258, 258);\n    context.fillStyle = '#EEEEEE';\n    context.beginPath();\n    context.arc(129, 129, 127, 0, 6.28, true);\n    context.closePath();\n    context.fill();\n}\n```\n\n有时候你希望记录发送给 Canvas 上下文的指令，并且逐条执行指令。幸运的是在 Chrome 开发者工具里有一个新的 Canvas 审查特性可以帮你做到这一点。\n\n在这篇文章里，我会给你演示怎样使用这个特性来调试你的 Canvas 行为。它支持 2D 和 WebGL 上下文，所以无论你在使用哪个，都可以使用它直接获取调试信息。\n\n## 准备开始\n\n在 Chrome 地址栏打开`about:flags`页面，并选中“启用开发者工具实验”（英文：Enable Developer Tools experiments，以上是 Chrome 中文版翻译）。  \n![Figure 1 - Enabling Developer Tools Experiments in about:flags](http://www.html5rocks.com/static/demos/canvas-inspection/images/enable-canvas-inspection.png)\n\n接下来，打开开发者工具并点击右下角的齿轮图标，在新打开配置页面中可以找到**实验（Experiments）**一栏，然后在该栏中启用**Canvas inspection（Canvas 审查）**。  \n![Figure 2 - Enabling Canvas inspection in DevTools’ experiments](http://www.html5rocks.com/static/demos/canvas-inspection/images/experiments.png)\n\n为了让这些修改生效，你必须关闭然后再打开开发者工具。当开发者工具再次打开时，找到 Profiles 一栏，你可以看到 Canvas Profile 选项，它是禁用状态，如果某个页面有你想要调试的 Canvas，你可以按下 Enable 按钮然后页面会重新载入，准备记录 Canvas 调用。  \n![Figure 3 - Switching on the Canvas Profiler](http://www.html5rocks.com/static/demos/canvas-inspection/images/canvas-profiler.png)\n\n然后你需要决定你是记录单帧（Single Frame），还是看起来很像开发者工具中时间轴的连续多帧（Consecutive Frames）。\n\n||一帧表示页面中的一次事件循环，涉及到执行 JavaScript 代码，事件处理，更新 DOM，修改样式，布局和重绘。为了让动画更加平滑，你要让每帧耗时小于 1/60 秒，即 16.6 毫秒。\n\n单帧仅仅记录本帧结束前所有的 API 调用，多帧则记录你手动停止之前的所有 API 调用。选择哪一种取决于你如何使用 canvas 元素。对于一个持续的动画，选择单帧更好，而那些用于响应用户事件的短暂动画，就应该使用多帧。\n\n![Figure 4 - Choosing how many frames to capture](http://www.html5rocks.com/static/demos/canvas-inspection/images/frames.png)\n\n这样我们就做完了所有的准备工作可以记录帧了。\n\n## 记录帧\n\n按下 Start 按钮，像平常一样与应用交互，你可以看到它已经在记录了。如果你要记录多帧，那你还需要回到开发者工具按下 Stop 按钮来结束记录。\n\n现在你可以看到左侧有一个 profile 列表中有了一个新的 profile，里面记录了所有 canvas 元素上下文的调用。点击 profile 就可以看到如下界面：\n\n![Figure 5 - A canvas profile in DevTools](http://www.html5rocks.com/static/demos/canvas-inspection/images/profile.png)\n\n你可以看到一组已经记录下来的帧，并且一步一步地浏览它们。一旦你点击了其中一个，你就可以看到该帧结束时 Canvas 的屏幕截图。如果有多个 Canvas 元素，你可以通过屏幕截图下面的菜单选择显示哪个 Canvas。\n\n![Figure 6 - Choosing your canvas context](http://www.html5rocks.com/static/demos/canvas-inspection/images/expanded-menu.png)\n\n在帧里你可以看到多个绘画调用组（Draw Call Group），每个绘画调用组包含一个绘画调用，并且是该组的最后一个调用。那什么是绘画调用呢？对于一个 2D 上下文来讲，它包括 clearRect(), drawImage(), fill(), stroke(), putImageData()和其他文字渲染方法；对于一个 WebGL 上下文来讲，它包括 clear(), drawArrays()和 drawElements()。本质上讲，任何会修改当前绘画缓存内容的调用都是绘画调用（如果你不熟悉图形编程，你可以认为缓存就是一个我们正在操作的像素位图）。\n\n你可以在帧，绘画调用组和调用这三个级别依次查看该列表。无论哪一种，你都可以看到那时的上下文，这意味着你可以迅速发现和修正 Bug。\n\n![Figure 7 - navigation buttons for convenient list hopping](http://www.html5rocks.com/static/demos/canvas-inspection/images/replaytime.png)\n\n## 找出属性变化\n\n另一个有用特性就是可以找出两次调用之间属性和变量发生了什么变化。\n\n（译者注：在 Chrome29 上没有找到该按钮，但是 canary Chrome31 上可以找到）点击右侧按钮![](http://www.html5rocks.com/static/demos/canvas-inspection/images/sidebar.png)会打开一个新的面板，随着一步一步地查看 API 调用，你可以看到属性的变化，当鼠标放在任何 Buffer 和数组上时，你可以看到他们的内容。\n\n![](http://www.html5rocks.com/static/demos/canvas-inspection/images/diff.gif)\n\n## 注意了！\n\n现在你已经知道了怎样在 Chrome 开发者工具中调试 Canvas。如果你对这个工具有任何回馈，请[提交一个 bug](http://crbug.com/new)或者写信给[Chrome 开发者工具工作组](https://groups.google.com/forum/#!forum/google-chrome-developer-tools)，告诉我们，你发现了 bug 或者在调试过程中你想看到哪些信息，因为只有开发者的回馈才能让它更好。\n","slug":"Canvas-Inspection-using-Chrome-DevTools","published":1,"date":"2013-09-19T16:00:00.000Z","updated":"2018-12-07T02:57:47.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9u000yw8wkojpwk4ni","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>使用过 Canvas 元素的人都知道 Canvas 很难调试。使用 Canvas 通常要调用一长串难以跟踪的 API。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    context.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">258</span>, <span class=\"number\">258</span>);</span><br><span class=\"line\">    context.fillStyle = <span class=\"string\">'#EEEEEE'</span>;</span><br><span class=\"line\">    context.beginPath();</span><br><span class=\"line\">    context.arc(<span class=\"number\">129</span>, <span class=\"number\">129</span>, <span class=\"number\">127</span>, <span class=\"number\">0</span>, <span class=\"number\">6.28</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    context.closePath();</span><br><span class=\"line\">    context.fill();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有时候你希望记录发送给 Canvas 上下文的指令，并且逐条执行指令。幸运的是在 Chrome 开发者工具里有一个新的 Canvas 审查特性可以帮你做到这一点。</p>\n<p>在这篇文章里，我会给你演示怎样使用这个特性来调试你的 Canvas 行为。它支持 2D 和 WebGL 上下文，所以无论你在使用哪个，都可以使用它直接获取调试信息。</p>\n<h2 id=\"准备开始\"><a href=\"#准备开始\" class=\"headerlink\" title=\"准备开始\"></a>准备开始</h2><p>在 Chrome 地址栏打开<code>about:flags</code>页面，并选中“启用开发者工具实验”（英文：Enable Developer Tools experiments，以上是 Chrome 中文版翻译）。<br><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/enable-canvas-inspection.png\" alt=\"Figure 1 - Enabling Developer Tools Experiments in about:flags\"></p>\n<p>接下来，打开开发者工具并点击右下角的齿轮图标，在新打开配置页面中可以找到<strong>实验（Experiments）</strong>一栏，然后在该栏中启用<strong>Canvas inspection（Canvas 审查）</strong>。<br><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/experiments.png\" alt=\"Figure 2 - Enabling Canvas inspection in DevTools’ experiments\"></p>\n<p>为了让这些修改生效，你必须关闭然后再打开开发者工具。当开发者工具再次打开时，找到 Profiles 一栏，你可以看到 Canvas Profile 选项，它是禁用状态，如果某个页面有你想要调试的 Canvas，你可以按下 Enable 按钮然后页面会重新载入，准备记录 Canvas 调用。<br><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/canvas-profiler.png\" alt=\"Figure 3 - Switching on the Canvas Profiler\"></p>\n<p>然后你需要决定你是记录单帧（Single Frame），还是看起来很像开发者工具中时间轴的连续多帧（Consecutive Frames）。</p>\n<p>||一帧表示页面中的一次事件循环，涉及到执行 JavaScript 代码，事件处理，更新 DOM，修改样式，布局和重绘。为了让动画更加平滑，你要让每帧耗时小于 1/60 秒，即 16.6 毫秒。</p>\n<p>单帧仅仅记录本帧结束前所有的 API 调用，多帧则记录你手动停止之前的所有 API 调用。选择哪一种取决于你如何使用 canvas 元素。对于一个持续的动画，选择单帧更好，而那些用于响应用户事件的短暂动画，就应该使用多帧。</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/frames.png\" alt=\"Figure 4 - Choosing how many frames to capture\"></p>\n<p>这样我们就做完了所有的准备工作可以记录帧了。</p>\n<h2 id=\"记录帧\"><a href=\"#记录帧\" class=\"headerlink\" title=\"记录帧\"></a>记录帧</h2><p>按下 Start 按钮，像平常一样与应用交互，你可以看到它已经在记录了。如果你要记录多帧，那你还需要回到开发者工具按下 Stop 按钮来结束记录。</p>\n<p>现在你可以看到左侧有一个 profile 列表中有了一个新的 profile，里面记录了所有 canvas 元素上下文的调用。点击 profile 就可以看到如下界面：</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/profile.png\" alt=\"Figure 5 - A canvas profile in DevTools\"></p>\n<p>你可以看到一组已经记录下来的帧，并且一步一步地浏览它们。一旦你点击了其中一个，你就可以看到该帧结束时 Canvas 的屏幕截图。如果有多个 Canvas 元素，你可以通过屏幕截图下面的菜单选择显示哪个 Canvas。</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/expanded-menu.png\" alt=\"Figure 6 - Choosing your canvas context\"></p>\n<p>在帧里你可以看到多个绘画调用组（Draw Call Group），每个绘画调用组包含一个绘画调用，并且是该组的最后一个调用。那什么是绘画调用呢？对于一个 2D 上下文来讲，它包括 clearRect(), drawImage(), fill(), stroke(), putImageData()和其他文字渲染方法；对于一个 WebGL 上下文来讲，它包括 clear(), drawArrays()和 drawElements()。本质上讲，任何会修改当前绘画缓存内容的调用都是绘画调用（如果你不熟悉图形编程，你可以认为缓存就是一个我们正在操作的像素位图）。</p>\n<p>你可以在帧，绘画调用组和调用这三个级别依次查看该列表。无论哪一种，你都可以看到那时的上下文，这意味着你可以迅速发现和修正 Bug。</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/replaytime.png\" alt=\"Figure 7 - navigation buttons for convenient list hopping\"></p>\n<h2 id=\"找出属性变化\"><a href=\"#找出属性变化\" class=\"headerlink\" title=\"找出属性变化\"></a>找出属性变化</h2><p>另一个有用特性就是可以找出两次调用之间属性和变量发生了什么变化。</p>\n<p>（译者注：在 Chrome29 上没有找到该按钮，但是 canary Chrome31 上可以找到）点击右侧按钮<img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/sidebar.png\" alt=\"\">会打开一个新的面板，随着一步一步地查看 API 调用，你可以看到属性的变化，当鼠标放在任何 Buffer 和数组上时，你可以看到他们的内容。</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/diff.gif\" alt=\"\"></p>\n<h2 id=\"注意了！\"><a href=\"#注意了！\" class=\"headerlink\" title=\"注意了！\"></a>注意了！</h2><p>现在你已经知道了怎样在 Chrome 开发者工具中调试 Canvas。如果你对这个工具有任何回馈，请<a href=\"http://crbug.com/new\" target=\"_blank\" rel=\"noopener\">提交一个 bug</a>或者写信给<a href=\"https://groups.google.com/forum/#!forum/google-chrome-developer-tools\" target=\"_blank\" rel=\"noopener\">Chrome 开发者工具工作组</a>，告诉我们，你发现了 bug 或者在调试过程中你想看到哪些信息，因为只有开发者的回馈才能让它更好。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>使用过 Canvas 元素的人都知道 Canvas 很难调试。使用 Canvas 通常要调用一长串难以跟踪的 API。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    context.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">258</span>, <span class=\"number\">258</span>);</span><br><span class=\"line\">    context.fillStyle = <span class=\"string\">'#EEEEEE'</span>;</span><br><span class=\"line\">    context.beginPath();</span><br><span class=\"line\">    context.arc(<span class=\"number\">129</span>, <span class=\"number\">129</span>, <span class=\"number\">127</span>, <span class=\"number\">0</span>, <span class=\"number\">6.28</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    context.closePath();</span><br><span class=\"line\">    context.fill();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有时候你希望记录发送给 Canvas 上下文的指令，并且逐条执行指令。幸运的是在 Chrome 开发者工具里有一个新的 Canvas 审查特性可以帮你做到这一点。</p>\n<p>在这篇文章里，我会给你演示怎样使用这个特性来调试你的 Canvas 行为。它支持 2D 和 WebGL 上下文，所以无论你在使用哪个，都可以使用它直接获取调试信息。</p>\n<h2 id=\"准备开始\"><a href=\"#准备开始\" class=\"headerlink\" title=\"准备开始\"></a>准备开始</h2><p>在 Chrome 地址栏打开<code>about:flags</code>页面，并选中“启用开发者工具实验”（英文：Enable Developer Tools experiments，以上是 Chrome 中文版翻译）。<br><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/enable-canvas-inspection.png\" alt=\"Figure 1 - Enabling Developer Tools Experiments in about:flags\"></p>\n<p>接下来，打开开发者工具并点击右下角的齿轮图标，在新打开配置页面中可以找到<strong>实验（Experiments）</strong>一栏，然后在该栏中启用<strong>Canvas inspection（Canvas 审查）</strong>。<br><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/experiments.png\" alt=\"Figure 2 - Enabling Canvas inspection in DevTools’ experiments\"></p>\n<p>为了让这些修改生效，你必须关闭然后再打开开发者工具。当开发者工具再次打开时，找到 Profiles 一栏，你可以看到 Canvas Profile 选项，它是禁用状态，如果某个页面有你想要调试的 Canvas，你可以按下 Enable 按钮然后页面会重新载入，准备记录 Canvas 调用。<br><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/canvas-profiler.png\" alt=\"Figure 3 - Switching on the Canvas Profiler\"></p>\n<p>然后你需要决定你是记录单帧（Single Frame），还是看起来很像开发者工具中时间轴的连续多帧（Consecutive Frames）。</p>\n<p>||一帧表示页面中的一次事件循环，涉及到执行 JavaScript 代码，事件处理，更新 DOM，修改样式，布局和重绘。为了让动画更加平滑，你要让每帧耗时小于 1/60 秒，即 16.6 毫秒。</p>\n<p>单帧仅仅记录本帧结束前所有的 API 调用，多帧则记录你手动停止之前的所有 API 调用。选择哪一种取决于你如何使用 canvas 元素。对于一个持续的动画，选择单帧更好，而那些用于响应用户事件的短暂动画，就应该使用多帧。</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/frames.png\" alt=\"Figure 4 - Choosing how many frames to capture\"></p>\n<p>这样我们就做完了所有的准备工作可以记录帧了。</p>\n<h2 id=\"记录帧\"><a href=\"#记录帧\" class=\"headerlink\" title=\"记录帧\"></a>记录帧</h2><p>按下 Start 按钮，像平常一样与应用交互，你可以看到它已经在记录了。如果你要记录多帧，那你还需要回到开发者工具按下 Stop 按钮来结束记录。</p>\n<p>现在你可以看到左侧有一个 profile 列表中有了一个新的 profile，里面记录了所有 canvas 元素上下文的调用。点击 profile 就可以看到如下界面：</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/profile.png\" alt=\"Figure 5 - A canvas profile in DevTools\"></p>\n<p>你可以看到一组已经记录下来的帧，并且一步一步地浏览它们。一旦你点击了其中一个，你就可以看到该帧结束时 Canvas 的屏幕截图。如果有多个 Canvas 元素，你可以通过屏幕截图下面的菜单选择显示哪个 Canvas。</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/expanded-menu.png\" alt=\"Figure 6 - Choosing your canvas context\"></p>\n<p>在帧里你可以看到多个绘画调用组（Draw Call Group），每个绘画调用组包含一个绘画调用，并且是该组的最后一个调用。那什么是绘画调用呢？对于一个 2D 上下文来讲，它包括 clearRect(), drawImage(), fill(), stroke(), putImageData()和其他文字渲染方法；对于一个 WebGL 上下文来讲，它包括 clear(), drawArrays()和 drawElements()。本质上讲，任何会修改当前绘画缓存内容的调用都是绘画调用（如果你不熟悉图形编程，你可以认为缓存就是一个我们正在操作的像素位图）。</p>\n<p>你可以在帧，绘画调用组和调用这三个级别依次查看该列表。无论哪一种，你都可以看到那时的上下文，这意味着你可以迅速发现和修正 Bug。</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/replaytime.png\" alt=\"Figure 7 - navigation buttons for convenient list hopping\"></p>\n<h2 id=\"找出属性变化\"><a href=\"#找出属性变化\" class=\"headerlink\" title=\"找出属性变化\"></a>找出属性变化</h2><p>另一个有用特性就是可以找出两次调用之间属性和变量发生了什么变化。</p>\n<p>（译者注：在 Chrome29 上没有找到该按钮，但是 canary Chrome31 上可以找到）点击右侧按钮<img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/sidebar.png\" alt=\"\">会打开一个新的面板，随着一步一步地查看 API 调用，你可以看到属性的变化，当鼠标放在任何 Buffer 和数组上时，你可以看到他们的内容。</p>\n<p><img src=\"http://www.html5rocks.com/static/demos/canvas-inspection/images/diff.gif\" alt=\"\"></p>\n<h2 id=\"注意了！\"><a href=\"#注意了！\" class=\"headerlink\" title=\"注意了！\"></a>注意了！</h2><p>现在你已经知道了怎样在 Chrome 开发者工具中调试 Canvas。如果你对这个工具有任何回馈，请<a href=\"http://crbug.com/new\" target=\"_blank\" rel=\"noopener\">提交一个 bug</a>或者写信给<a href=\"https://groups.google.com/forum/#!forum/google-chrome-developer-tools\" target=\"_blank\" rel=\"noopener\">Chrome 开发者工具工作组</a>，告诉我们，你发现了 bug 或者在调试过程中你想看到哪些信息，因为只有开发者的回馈才能让它更好。</p>\n"},{"title":"npm install时连接超时的解决办法","_content":"\n今天在电脑上安装 node-inspector，用于在浏览器中调试 node。但是却遇到了如下连接超时错误。\n\n```\nsudo npm install -g node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm ERR! Error: connect ETIMEDOUT\nnpm ERR!     at errnoException (net.js:863:11)\n...\n```\n\n想到可能是伟大的长城在作怪，所以首先想到的是加上代理，这里使用的是 Goagent。因为下载过程中使用的 https 协议，所以设置的应该是 https-proxy。设置方法如下：\n\n```\nnpm config set https-proxy http://127.0.0.1:8087\n```\n\n依然失败，报错如下：\n\n```\nsudo npm install -g node-inspector\nGET https://registry.npmjs.org/node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm ERR! Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE\nnpm ERR!     at SecurePair.<anonymous> (tls.js:1271:32)\n```\n\n根据以上错误，猜测应该是代理出现问题，网站证书无法验证。既然 https 协议走不通，那么是否可以使用 http 协议呢？有些网站都同时支持这两种协议，比如 cdn.staticfile.org，cdnjs.com 等 CDN 服务。向谷哥寻求帮忙才找到了答案，可以使用如下命令设置：\n\n```\nnpm config set registry \"http://registry.npmjs.org/\"\n```\n\n还是失败，报错如下：\n\n```\nsudo npm install -g node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector\nnpm ERR! Error: connect ETIMEDOUT\nnpm ERR!     at errnoException (net.js:863:11)\n```\n\n长城真是密不透风啊！为 http 设置代理：\n\n```\nnpm config set proxy http://127.0.0.1:8087\n```\n\n然后终于看到亲切的`200`字眼。\n\n```\nsudo npm install -g node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector\nnpm http 200 http://registry.npmjs.org/node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgz\nnpm http 200 http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgz\nnpm http GET http://registry.npmjs.org/strong-data-uri\nnpm http GET http://registry.npmjs.org/async\n```\n\n以上就是今天遇到的通过`npm install`安装 node 包时遇到的问题以及解决过程。在遇到这些问题之前，还不知道`npm config`命令。所以在这里简单复习一下。\n在控制台中输入`npm config`：得到如下结果：\n\n```\nnpm config\nnpm ERR! Usage:\nnpm ERR! npm config set <key> <value>\nnpm ERR! npm config get [<key>]\nnpm ERR! npm config delete <key>\nnpm ERR! npm config list\nnpm ERR! npm config edit\nnpm ERR! npm set <key> <value>\nnpm ERR! npm get [<key>]\nnpm ERR! not ok code 0\n```\n\n`npm config`命令的使用方法都列出来了。如果想看到完全的信息，还是使用`npm help config`命令吧。这个命令会通过`vim`打开一个`npm config`命令的说明书，非常详尽，包括所有命令，各种类型的配置的优先级（比如命令行参数`--proxy http://server:port`优先级最高，文章中我们使用的方法是修改用户配置，优先级与命令行参数相比较低。）以及所有的配置选项（比如文章中我们修改了 proxy，https-proxy 和 registry.）。说明书篇幅很长，不再赘述。\n","source":"_posts/2013-10-11-Connect-Timeout-When-Npm-Install.md","raw":"---\ntitle: npm install时连接超时的解决办法\n---\n\n今天在电脑上安装 node-inspector，用于在浏览器中调试 node。但是却遇到了如下连接超时错误。\n\n```\nsudo npm install -g node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm ERR! Error: connect ETIMEDOUT\nnpm ERR!     at errnoException (net.js:863:11)\n...\n```\n\n想到可能是伟大的长城在作怪，所以首先想到的是加上代理，这里使用的是 Goagent。因为下载过程中使用的 https 协议，所以设置的应该是 https-proxy。设置方法如下：\n\n```\nnpm config set https-proxy http://127.0.0.1:8087\n```\n\n依然失败，报错如下：\n\n```\nsudo npm install -g node-inspector\nGET https://registry.npmjs.org/node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm http GET https://registry.npmjs.org/node-inspector\nnpm ERR! Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE\nnpm ERR!     at SecurePair.<anonymous> (tls.js:1271:32)\n```\n\n根据以上错误，猜测应该是代理出现问题，网站证书无法验证。既然 https 协议走不通，那么是否可以使用 http 协议呢？有些网站都同时支持这两种协议，比如 cdn.staticfile.org，cdnjs.com 等 CDN 服务。向谷哥寻求帮忙才找到了答案，可以使用如下命令设置：\n\n```\nnpm config set registry \"http://registry.npmjs.org/\"\n```\n\n还是失败，报错如下：\n\n```\nsudo npm install -g node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector\nnpm ERR! Error: connect ETIMEDOUT\nnpm ERR!     at errnoException (net.js:863:11)\n```\n\n长城真是密不透风啊！为 http 设置代理：\n\n```\nnpm config set proxy http://127.0.0.1:8087\n```\n\n然后终于看到亲切的`200`字眼。\n\n```\nsudo npm install -g node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector\nnpm http 200 http://registry.npmjs.org/node-inspector\nnpm http GET http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgz\nnpm http 200 http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgz\nnpm http GET http://registry.npmjs.org/strong-data-uri\nnpm http GET http://registry.npmjs.org/async\n```\n\n以上就是今天遇到的通过`npm install`安装 node 包时遇到的问题以及解决过程。在遇到这些问题之前，还不知道`npm config`命令。所以在这里简单复习一下。\n在控制台中输入`npm config`：得到如下结果：\n\n```\nnpm config\nnpm ERR! Usage:\nnpm ERR! npm config set <key> <value>\nnpm ERR! npm config get [<key>]\nnpm ERR! npm config delete <key>\nnpm ERR! npm config list\nnpm ERR! npm config edit\nnpm ERR! npm set <key> <value>\nnpm ERR! npm get [<key>]\nnpm ERR! not ok code 0\n```\n\n`npm config`命令的使用方法都列出来了。如果想看到完全的信息，还是使用`npm help config`命令吧。这个命令会通过`vim`打开一个`npm config`命令的说明书，非常详尽，包括所有命令，各种类型的配置的优先级（比如命令行参数`--proxy http://server:port`优先级最高，文章中我们使用的方法是修改用户配置，优先级与命令行参数相比较低。）以及所有的配置选项（比如文章中我们修改了 proxy，https-proxy 和 registry.）。说明书篇幅很长，不再赘述。\n","slug":"Connect-Timeout-When-Npm-Install","published":1,"date":"2013-10-10T16:00:00.000Z","updated":"2018-12-07T02:54:54.956Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9u000zw8wk8z6rnqgc","content":"<p>今天在电脑上安装 node-inspector，用于在浏览器中调试 node。但是却遇到了如下连接超时错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm ERR! Error: connect ETIMEDOUT</span><br><span class=\"line\">npm ERR!     at errnoException (net.js:863:11)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>想到可能是伟大的长城在作怪，所以首先想到的是加上代理，这里使用的是 Goagent。因为下载过程中使用的 https 协议，所以设置的应该是 https-proxy。设置方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set https-proxy http://127.0.0.1:8087</span><br></pre></td></tr></table></figure>\n<p>依然失败，报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g node-inspector</span><br><span class=\"line\">GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm ERR! Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE</span><br><span class=\"line\">npm ERR!     at SecurePair.&lt;anonymous&gt; (tls.js:1271:32)</span><br></pre></td></tr></table></figure>\n<p>根据以上错误，猜测应该是代理出现问题，网站证书无法验证。既然 https 协议走不通，那么是否可以使用 http 协议呢？有些网站都同时支持这两种协议，比如 cdn.staticfile.org，cdnjs.com 等 CDN 服务。向谷哥寻求帮忙才找到了答案，可以使用如下命令设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry &quot;http://registry.npmjs.org/&quot;</span><br></pre></td></tr></table></figure>\n<p>还是失败，报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm ERR! Error: connect ETIMEDOUT</span><br><span class=\"line\">npm ERR!     at errnoException (net.js:863:11)</span><br></pre></td></tr></table></figure>\n<p>长城真是密不透风啊！为 http 设置代理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set proxy http://127.0.0.1:8087</span><br></pre></td></tr></table></figure>\n<p>然后终于看到亲切的<code>200</code>字眼。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http 200 http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgz</span><br><span class=\"line\">npm http 200 http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgz</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/strong-data-uri</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/async</span><br></pre></td></tr></table></figure>\n<p>以上就是今天遇到的通过<code>npm install</code>安装 node 包时遇到的问题以及解决过程。在遇到这些问题之前，还不知道<code>npm config</code>命令。所以在这里简单复习一下。<br>在控制台中输入<code>npm config</code>：得到如下结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config</span><br><span class=\"line\">npm ERR! Usage:</span><br><span class=\"line\">npm ERR! npm config set &lt;key&gt; &lt;value&gt;</span><br><span class=\"line\">npm ERR! npm config get [&lt;key&gt;]</span><br><span class=\"line\">npm ERR! npm config delete &lt;key&gt;</span><br><span class=\"line\">npm ERR! npm config list</span><br><span class=\"line\">npm ERR! npm config edit</span><br><span class=\"line\">npm ERR! npm set &lt;key&gt; &lt;value&gt;</span><br><span class=\"line\">npm ERR! npm get [&lt;key&gt;]</span><br><span class=\"line\">npm ERR! not ok code 0</span><br></pre></td></tr></table></figure>\n<p><code>npm config</code>命令的使用方法都列出来了。如果想看到完全的信息，还是使用<code>npm help config</code>命令吧。这个命令会通过<code>vim</code>打开一个<code>npm config</code>命令的说明书，非常详尽，包括所有命令，各种类型的配置的优先级（比如命令行参数<code>--proxy http://server:port</code>优先级最高，文章中我们使用的方法是修改用户配置，优先级与命令行参数相比较低。）以及所有的配置选项（比如文章中我们修改了 proxy，https-proxy 和 registry.）。说明书篇幅很长，不再赘述。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天在电脑上安装 node-inspector，用于在浏览器中调试 node。但是却遇到了如下连接超时错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm ERR! Error: connect ETIMEDOUT</span><br><span class=\"line\">npm ERR!     at errnoException (net.js:863:11)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>想到可能是伟大的长城在作怪，所以首先想到的是加上代理，这里使用的是 Goagent。因为下载过程中使用的 https 协议，所以设置的应该是 https-proxy。设置方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set https-proxy http://127.0.0.1:8087</span><br></pre></td></tr></table></figure>\n<p>依然失败，报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g node-inspector</span><br><span class=\"line\">GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET https://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm ERR! Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE</span><br><span class=\"line\">npm ERR!     at SecurePair.&lt;anonymous&gt; (tls.js:1271:32)</span><br></pre></td></tr></table></figure>\n<p>根据以上错误，猜测应该是代理出现问题，网站证书无法验证。既然 https 协议走不通，那么是否可以使用 http 协议呢？有些网站都同时支持这两种协议，比如 cdn.staticfile.org，cdnjs.com 等 CDN 服务。向谷哥寻求帮忙才找到了答案，可以使用如下命令设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set registry &quot;http://registry.npmjs.org/&quot;</span><br></pre></td></tr></table></figure>\n<p>还是失败，报错如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm ERR! Error: connect ETIMEDOUT</span><br><span class=\"line\">npm ERR!     at errnoException (net.js:863:11)</span><br></pre></td></tr></table></figure>\n<p>长城真是密不透风啊！为 http 设置代理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config set proxy http://127.0.0.1:8087</span><br></pre></td></tr></table></figure>\n<p>然后终于看到亲切的<code>200</code>字眼。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http 200 http://registry.npmjs.org/node-inspector</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgz</span><br><span class=\"line\">npm http 200 http://registry.npmjs.org/node-inspector/-/node-inspector-0.5.0.tgz</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/strong-data-uri</span><br><span class=\"line\">npm http GET http://registry.npmjs.org/async</span><br></pre></td></tr></table></figure>\n<p>以上就是今天遇到的通过<code>npm install</code>安装 node 包时遇到的问题以及解决过程。在遇到这些问题之前，还不知道<code>npm config</code>命令。所以在这里简单复习一下。<br>在控制台中输入<code>npm config</code>：得到如下结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm config</span><br><span class=\"line\">npm ERR! Usage:</span><br><span class=\"line\">npm ERR! npm config set &lt;key&gt; &lt;value&gt;</span><br><span class=\"line\">npm ERR! npm config get [&lt;key&gt;]</span><br><span class=\"line\">npm ERR! npm config delete &lt;key&gt;</span><br><span class=\"line\">npm ERR! npm config list</span><br><span class=\"line\">npm ERR! npm config edit</span><br><span class=\"line\">npm ERR! npm set &lt;key&gt; &lt;value&gt;</span><br><span class=\"line\">npm ERR! npm get [&lt;key&gt;]</span><br><span class=\"line\">npm ERR! not ok code 0</span><br></pre></td></tr></table></figure>\n<p><code>npm config</code>命令的使用方法都列出来了。如果想看到完全的信息，还是使用<code>npm help config</code>命令吧。这个命令会通过<code>vim</code>打开一个<code>npm config</code>命令的说明书，非常详尽，包括所有命令，各种类型的配置的优先级（比如命令行参数<code>--proxy http://server:port</code>优先级最高，文章中我们使用的方法是修改用户配置，优先级与命令行参数相比较低。）以及所有的配置选项（比如文章中我们修改了 proxy，https-proxy 和 registry.）。说明书篇幅很长，不再赘述。</p>\n"},{"title":"IE6，7，8(Q)中同一元素重复定义的style属性会被合并","_content":"\n这个问题发生了有段时间了，现在把他记下来，一般人不会这么做，也不会遇到这种问题。但是你还是不能阻止有人不小心这么做了。出了问题就要解决，谁让咱是开发呢？\n\n某次项目发布前，测试同事报出 Bug：产品编辑页面原本有的产品分组输入框不见了。\n\n翻出我们的 VM 文件，代码中 #if 等是 velocity 语法。代码如下：\n\n```html\n<div\n    id=\"productTeamSelect\"\n    class=\"ui-form-item\"\n    #if(!$webProductPolicy.canDisplayGroupName)style=\"display:none;\"\n    #end\n></div>\n```\n\n既然是该 Div 不显示看了吗？那么我只需要打印下`$webProductPolicy.canDisplayGroupName`的值即可，该字段表示用户是否可以进行产品分组。如果其值是`false`，那么该用户不可以进行产品分组，就不显示。否则显示分组。通过打印发现其值为`false`，表示该用户不可以进行产品分组。那么不显示就是正常的。查看 Javascript 代码也发现：控制产品分组元素是否显示只出现在两个地方，但是都在 Click 事件回调中，并不会在加载页面之后就执行。所以不显示就是因为后端传来的值`$webProductPolicy.canDisplayGroupName`为`false`导致，交给后端同事处理。\n\n很快后端同事给出了回复，他们没有修改任何有关于此的代码，并且提出线上`$webProductPolicy.canDisplayGroupName`的值也同样为`false`，但是线上却显示了产品分组元素，该产品已经下架，不能分组，也符合业务需求，所以后端认为当前线上显示了分组是错误的，而现在却是意外地改正了。\n\n此时已经证明前端和后端都没有错误，而是当前线上代码有问题。线上代码是这样的：\n\n```html\n<div\n    id=\"productTeamSelect\"\n    class=\"productTeamSelect\"\n    style=\"float:left;\"\n    #if(!$webProductPolicy.canDisplayGroupName)style=\"display:none;\"\n    #end\n></div>\n```\n\n生成的页面源代码是：\n\n```html\n<div id=\"productTeamSelect\" class=\"productTeamSelect\" style=\"float:left;\" style=\"display:none;\"></div>\n```\n\n没有什么不对啊？`display`属性被设置为`none`，本不该显示的啊？为什么显示了呢？\n\n只好通过`window.getComputedStyle`方法获取`display`属性值，看看浏览器是解析这段 HTML 的。实验发现`display`属性值竟然是`block`。奇怪了，为什么第二个 style 没有生效，难道是因为最近刚刚修改的 document type 造成的。然后我编写了两个测试页面，他们都有一个 DIV 元素，且都有两个 style 属性。唯一不同的是 document type，分别是 HTML5 的 document type：`<!DOCTYPE html>`，和旧的 document type 声明\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n```\n\n测试发现，结果一致，后定义的 style 都没有生效。这个有点出乎我的意料，虽然之前没有看到规范中如何定义，但是潜意识中认为应该是两个 style 会整合在一起，并且在后定义覆盖先定义的。难道我的认识有误？\n\n谷歌了一下，发现一篇文章：[IE6 IE7 IE8(Q) 中同一元素重复定义的 style 属性会被合并](http://www.w3help.org/zh-cn/causes/HY8002)，文章介绍了 IE6-8 的这个 Bug，并且指出“不要依赖 IE 的容错机制，避免重复定义 HTML 元素属性”。这个知识点比较冷，并且一般人都不会这么写，也不会遇到这个问题。现在回头看时才注意到通过 Firefox 产看源代码时`style=\"display:none;\"`是被红色标注的。Firefox 意在提示我们第二个 style 属性没有生效，可惜这个重要信息被忽略了。\n\n下架产品在 IE6，7 下不能分组，而在 IE8 和其他浏览器中却可以进行分组，为什么该代码的作者没有发现该问题呢，就不得而知了。难道该代码是很多年前的，那时候还没有 IE8+，Firefox 还不够流行，chrome 还没有诞生？\n\n锁定根本原因就好办了，要么是继续保持网站内部逻辑，下架产品不能分组，即产品分组输入框不可见，修复线上故障。要么是取消以前的网站内部逻辑，下架产品也可以进行分组，这样后端输出的`$webProductPolicy.canDisplayGroupName`值改成`true`即可，最终效果保持和线上一致。最终由 PD 拍板决定采用后一个方法，修改网站内部逻辑，保持对最终用户的逻辑不变，下架产品也能进行分组。\n\n以上 Bug 是解决了，但是我们应该吸取教训，经常梳理业务逻辑，经常审核代码。\n","source":"_posts/2014-05-06-IE678-muti-style-attribute.md","raw":"---\ntitle: IE6，7，8(Q)中同一元素重复定义的style属性会被合并\n---\n\n这个问题发生了有段时间了，现在把他记下来，一般人不会这么做，也不会遇到这种问题。但是你还是不能阻止有人不小心这么做了。出了问题就要解决，谁让咱是开发呢？\n\n某次项目发布前，测试同事报出 Bug：产品编辑页面原本有的产品分组输入框不见了。\n\n翻出我们的 VM 文件，代码中 #if 等是 velocity 语法。代码如下：\n\n```html\n<div\n    id=\"productTeamSelect\"\n    class=\"ui-form-item\"\n    #if(!$webProductPolicy.canDisplayGroupName)style=\"display:none;\"\n    #end\n></div>\n```\n\n既然是该 Div 不显示看了吗？那么我只需要打印下`$webProductPolicy.canDisplayGroupName`的值即可，该字段表示用户是否可以进行产品分组。如果其值是`false`，那么该用户不可以进行产品分组，就不显示。否则显示分组。通过打印发现其值为`false`，表示该用户不可以进行产品分组。那么不显示就是正常的。查看 Javascript 代码也发现：控制产品分组元素是否显示只出现在两个地方，但是都在 Click 事件回调中，并不会在加载页面之后就执行。所以不显示就是因为后端传来的值`$webProductPolicy.canDisplayGroupName`为`false`导致，交给后端同事处理。\n\n很快后端同事给出了回复，他们没有修改任何有关于此的代码，并且提出线上`$webProductPolicy.canDisplayGroupName`的值也同样为`false`，但是线上却显示了产品分组元素，该产品已经下架，不能分组，也符合业务需求，所以后端认为当前线上显示了分组是错误的，而现在却是意外地改正了。\n\n此时已经证明前端和后端都没有错误，而是当前线上代码有问题。线上代码是这样的：\n\n```html\n<div\n    id=\"productTeamSelect\"\n    class=\"productTeamSelect\"\n    style=\"float:left;\"\n    #if(!$webProductPolicy.canDisplayGroupName)style=\"display:none;\"\n    #end\n></div>\n```\n\n生成的页面源代码是：\n\n```html\n<div id=\"productTeamSelect\" class=\"productTeamSelect\" style=\"float:left;\" style=\"display:none;\"></div>\n```\n\n没有什么不对啊？`display`属性被设置为`none`，本不该显示的啊？为什么显示了呢？\n\n只好通过`window.getComputedStyle`方法获取`display`属性值，看看浏览器是解析这段 HTML 的。实验发现`display`属性值竟然是`block`。奇怪了，为什么第二个 style 没有生效，难道是因为最近刚刚修改的 document type 造成的。然后我编写了两个测试页面，他们都有一个 DIV 元素，且都有两个 style 属性。唯一不同的是 document type，分别是 HTML5 的 document type：`<!DOCTYPE html>`，和旧的 document type 声明\n\n```html\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n```\n\n测试发现，结果一致，后定义的 style 都没有生效。这个有点出乎我的意料，虽然之前没有看到规范中如何定义，但是潜意识中认为应该是两个 style 会整合在一起，并且在后定义覆盖先定义的。难道我的认识有误？\n\n谷歌了一下，发现一篇文章：[IE6 IE7 IE8(Q) 中同一元素重复定义的 style 属性会被合并](http://www.w3help.org/zh-cn/causes/HY8002)，文章介绍了 IE6-8 的这个 Bug，并且指出“不要依赖 IE 的容错机制，避免重复定义 HTML 元素属性”。这个知识点比较冷，并且一般人都不会这么写，也不会遇到这个问题。现在回头看时才注意到通过 Firefox 产看源代码时`style=\"display:none;\"`是被红色标注的。Firefox 意在提示我们第二个 style 属性没有生效，可惜这个重要信息被忽略了。\n\n下架产品在 IE6，7 下不能分组，而在 IE8 和其他浏览器中却可以进行分组，为什么该代码的作者没有发现该问题呢，就不得而知了。难道该代码是很多年前的，那时候还没有 IE8+，Firefox 还不够流行，chrome 还没有诞生？\n\n锁定根本原因就好办了，要么是继续保持网站内部逻辑，下架产品不能分组，即产品分组输入框不可见，修复线上故障。要么是取消以前的网站内部逻辑，下架产品也可以进行分组，这样后端输出的`$webProductPolicy.canDisplayGroupName`值改成`true`即可，最终效果保持和线上一致。最终由 PD 拍板决定采用后一个方法，修改网站内部逻辑，保持对最终用户的逻辑不变，下架产品也能进行分组。\n\n以上 Bug 是解决了，但是我们应该吸取教训，经常梳理业务逻辑，经常审核代码。\n","slug":"IE678-muti-style-attribute","published":1,"date":"2014-05-05T16:00:00.000Z","updated":"2018-12-07T02:53:14.652Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9w0010w8wk1hjbps1m","content":"<p>这个问题发生了有段时间了，现在把他记下来，一般人不会这么做，也不会遇到这种问题。但是你还是不能阻止有人不小心这么做了。出了问题就要解决，谁让咱是开发呢？</p>\n<p>某次项目发布前，测试同事报出 Bug：产品编辑页面原本有的产品分组输入框不见了。</p>\n<p>翻出我们的 VM 文件，代码中 #if 等是 velocity 语法。代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">id</span>=<span class=\"string\">\"productTeamSelect\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"ui-form-item\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    #<span class=\"attr\">if</span>(!$<span class=\"attr\">webProductPolicy.canDisplayGroupName</span>)<span class=\"attr\">style</span>=<span class=\"string\">\"display:none;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    #<span class=\"attr\">end</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>既然是该 Div 不显示看了吗？那么我只需要打印下<code>$webProductPolicy.canDisplayGroupName</code>的值即可，该字段表示用户是否可以进行产品分组。如果其值是<code>false</code>，那么该用户不可以进行产品分组，就不显示。否则显示分组。通过打印发现其值为<code>false</code>，表示该用户不可以进行产品分组。那么不显示就是正常的。查看 Javascript 代码也发现：控制产品分组元素是否显示只出现在两个地方，但是都在 Click 事件回调中，并不会在加载页面之后就执行。所以不显示就是因为后端传来的值<code>$webProductPolicy.canDisplayGroupName</code>为<code>false</code>导致，交给后端同事处理。</p>\n<p>很快后端同事给出了回复，他们没有修改任何有关于此的代码，并且提出线上<code>$webProductPolicy.canDisplayGroupName</code>的值也同样为<code>false</code>，但是线上却显示了产品分组元素，该产品已经下架，不能分组，也符合业务需求，所以后端认为当前线上显示了分组是错误的，而现在却是意外地改正了。</p>\n<p>此时已经证明前端和后端都没有错误，而是当前线上代码有问题。线上代码是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">id</span>=<span class=\"string\">\"productTeamSelect\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"productTeamSelect\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"float:left;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    #<span class=\"attr\">if</span>(!$<span class=\"attr\">webProductPolicy.canDisplayGroupName</span>)<span class=\"attr\">style</span>=<span class=\"string\">\"display:none;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    #<span class=\"attr\">end</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>生成的页面源代码是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"productTeamSelect\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"productTeamSelect\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"float:left;\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display:none;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>没有什么不对啊？<code>display</code>属性被设置为<code>none</code>，本不该显示的啊？为什么显示了呢？</p>\n<p>只好通过<code>window.getComputedStyle</code>方法获取<code>display</code>属性值，看看浏览器是解析这段 HTML 的。实验发现<code>display</code>属性值竟然是<code>block</code>。奇怪了，为什么第二个 style 没有生效，难道是因为最近刚刚修改的 document type 造成的。然后我编写了两个测试页面，他们都有一个 DIV 元素，且都有两个 style 属性。唯一不同的是 document type，分别是 HTML5 的 document type：<code>&lt;!DOCTYPE html&gt;</code>，和旧的 document type 声明</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>测试发现，结果一致，后定义的 style 都没有生效。这个有点出乎我的意料，虽然之前没有看到规范中如何定义，但是潜意识中认为应该是两个 style 会整合在一起，并且在后定义覆盖先定义的。难道我的认识有误？</p>\n<p>谷歌了一下，发现一篇文章：<a href=\"http://www.w3help.org/zh-cn/causes/HY8002\" target=\"_blank\" rel=\"noopener\">IE6 IE7 IE8(Q) 中同一元素重复定义的 style 属性会被合并</a>，文章介绍了 IE6-8 的这个 Bug，并且指出“不要依赖 IE 的容错机制，避免重复定义 HTML 元素属性”。这个知识点比较冷，并且一般人都不会这么写，也不会遇到这个问题。现在回头看时才注意到通过 Firefox 产看源代码时<code>style=&quot;display:none;&quot;</code>是被红色标注的。Firefox 意在提示我们第二个 style 属性没有生效，可惜这个重要信息被忽略了。</p>\n<p>下架产品在 IE6，7 下不能分组，而在 IE8 和其他浏览器中却可以进行分组，为什么该代码的作者没有发现该问题呢，就不得而知了。难道该代码是很多年前的，那时候还没有 IE8+，Firefox 还不够流行，chrome 还没有诞生？</p>\n<p>锁定根本原因就好办了，要么是继续保持网站内部逻辑，下架产品不能分组，即产品分组输入框不可见，修复线上故障。要么是取消以前的网站内部逻辑，下架产品也可以进行分组，这样后端输出的<code>$webProductPolicy.canDisplayGroupName</code>值改成<code>true</code>即可，最终效果保持和线上一致。最终由 PD 拍板决定采用后一个方法，修改网站内部逻辑，保持对最终用户的逻辑不变，下架产品也能进行分组。</p>\n<p>以上 Bug 是解决了，但是我们应该吸取教训，经常梳理业务逻辑，经常审核代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这个问题发生了有段时间了，现在把他记下来，一般人不会这么做，也不会遇到这种问题。但是你还是不能阻止有人不小心这么做了。出了问题就要解决，谁让咱是开发呢？</p>\n<p>某次项目发布前，测试同事报出 Bug：产品编辑页面原本有的产品分组输入框不见了。</p>\n<p>翻出我们的 VM 文件，代码中 #if 等是 velocity 语法。代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">id</span>=<span class=\"string\">\"productTeamSelect\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"ui-form-item\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    #<span class=\"attr\">if</span>(!$<span class=\"attr\">webProductPolicy.canDisplayGroupName</span>)<span class=\"attr\">style</span>=<span class=\"string\">\"display:none;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    #<span class=\"attr\">end</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>既然是该 Div 不显示看了吗？那么我只需要打印下<code>$webProductPolicy.canDisplayGroupName</code>的值即可，该字段表示用户是否可以进行产品分组。如果其值是<code>false</code>，那么该用户不可以进行产品分组，就不显示。否则显示分组。通过打印发现其值为<code>false</code>，表示该用户不可以进行产品分组。那么不显示就是正常的。查看 Javascript 代码也发现：控制产品分组元素是否显示只出现在两个地方，但是都在 Click 事件回调中，并不会在加载页面之后就执行。所以不显示就是因为后端传来的值<code>$webProductPolicy.canDisplayGroupName</code>为<code>false</code>导致，交给后端同事处理。</p>\n<p>很快后端同事给出了回复，他们没有修改任何有关于此的代码，并且提出线上<code>$webProductPolicy.canDisplayGroupName</code>的值也同样为<code>false</code>，但是线上却显示了产品分组元素，该产品已经下架，不能分组，也符合业务需求，所以后端认为当前线上显示了分组是错误的，而现在却是意外地改正了。</p>\n<p>此时已经证明前端和后端都没有错误，而是当前线上代码有问题。线上代码是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">id</span>=<span class=\"string\">\"productTeamSelect\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">\"productTeamSelect\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">style</span>=<span class=\"string\">\"float:left;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    #<span class=\"attr\">if</span>(!$<span class=\"attr\">webProductPolicy.canDisplayGroupName</span>)<span class=\"attr\">style</span>=<span class=\"string\">\"display:none;\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    #<span class=\"attr\">end</span></span></span><br><span class=\"line\"><span class=\"tag\">&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>生成的页面源代码是：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"productTeamSelect\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"productTeamSelect\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"float:left;\"</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display:none;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>没有什么不对啊？<code>display</code>属性被设置为<code>none</code>，本不该显示的啊？为什么显示了呢？</p>\n<p>只好通过<code>window.getComputedStyle</code>方法获取<code>display</code>属性值，看看浏览器是解析这段 HTML 的。实验发现<code>display</code>属性值竟然是<code>block</code>。奇怪了，为什么第二个 style 没有生效，难道是因为最近刚刚修改的 document type 造成的。然后我编写了两个测试页面，他们都有一个 DIV 元素，且都有两个 style 属性。唯一不同的是 document type，分别是 HTML5 的 document type：<code>&lt;!DOCTYPE html&gt;</code>，和旧的 document type 声明</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;</span></span><br></pre></td></tr></table></figure>\n<p>测试发现，结果一致，后定义的 style 都没有生效。这个有点出乎我的意料，虽然之前没有看到规范中如何定义，但是潜意识中认为应该是两个 style 会整合在一起，并且在后定义覆盖先定义的。难道我的认识有误？</p>\n<p>谷歌了一下，发现一篇文章：<a href=\"http://www.w3help.org/zh-cn/causes/HY8002\" target=\"_blank\" rel=\"noopener\">IE6 IE7 IE8(Q) 中同一元素重复定义的 style 属性会被合并</a>，文章介绍了 IE6-8 的这个 Bug，并且指出“不要依赖 IE 的容错机制，避免重复定义 HTML 元素属性”。这个知识点比较冷，并且一般人都不会这么写，也不会遇到这个问题。现在回头看时才注意到通过 Firefox 产看源代码时<code>style=&quot;display:none;&quot;</code>是被红色标注的。Firefox 意在提示我们第二个 style 属性没有生效，可惜这个重要信息被忽略了。</p>\n<p>下架产品在 IE6，7 下不能分组，而在 IE8 和其他浏览器中却可以进行分组，为什么该代码的作者没有发现该问题呢，就不得而知了。难道该代码是很多年前的，那时候还没有 IE8+，Firefox 还不够流行，chrome 还没有诞生？</p>\n<p>锁定根本原因就好办了，要么是继续保持网站内部逻辑，下架产品不能分组，即产品分组输入框不可见，修复线上故障。要么是取消以前的网站内部逻辑，下架产品也可以进行分组，这样后端输出的<code>$webProductPolicy.canDisplayGroupName</code>值改成<code>true</code>即可，最终效果保持和线上一致。最终由 PD 拍板决定采用后一个方法，修改网站内部逻辑，保持对最终用户的逻辑不变，下架产品也能进行分组。</p>\n<p>以上 Bug 是解决了，但是我们应该吸取教训，经常梳理业务逻辑，经常审核代码。</p>\n"},{"title":"网页性能优化","_content":"\n提到网页性能优化，一般分为两部分，加载性能优化和交互性能优化。\n\n## 1.加载性能优化\n\n当在浏览器中输入一个 URL 或者在其他页面点击一个链接时，浏览器要做以下工作：DNS 查询，建立 TCP 链接，发送请求，接受响应，渲染页面，执行 Load 监听事件，至此页面加载就完成了。下面我们按照这个步骤思考如何优化页面加载性能？\n\n### 1.DNS 查询\n\n#### 1.减少 DNS 查询\n\n#### 2.使用 DNS Prefetching（DNS 预获取）特性缩短 DNS 查询时间。\n\nDNS 查询一般占用带宽少，但是延迟可能很高，典型的一次 DNS 查询需要 20-120ms。而 DNS 预获取为了获得较低的延迟，牺牲 DNS 查询次数。\n参考：[Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Controlling_DNS_prefetching)\n参考：[DNS Prefetching Implications](http://www.pinkbike.com/news/DNS-Prefetching-implications.html)\n\n减少请求\n使用 Data URI，\n使用 CSS Sprites\nhttp://www.csdn.net/article/2013-09-13/2816925-CSS-Sprites-vs.-Data-URIs:-Which-is-Faster-on-Mobile?\n\n## 2.TCP 连接\n\n### 1.使用 keep-alive 保持持久连接\n\n### 2.交互性能优化\n","source":"_posts/2013-09-24-Web-Page-Optimization.md","raw":"---\ntitle: 网页性能优化\n---\n\n提到网页性能优化，一般分为两部分，加载性能优化和交互性能优化。\n\n## 1.加载性能优化\n\n当在浏览器中输入一个 URL 或者在其他页面点击一个链接时，浏览器要做以下工作：DNS 查询，建立 TCP 链接，发送请求，接受响应，渲染页面，执行 Load 监听事件，至此页面加载就完成了。下面我们按照这个步骤思考如何优化页面加载性能？\n\n### 1.DNS 查询\n\n#### 1.减少 DNS 查询\n\n#### 2.使用 DNS Prefetching（DNS 预获取）特性缩短 DNS 查询时间。\n\nDNS 查询一般占用带宽少，但是延迟可能很高，典型的一次 DNS 查询需要 20-120ms。而 DNS 预获取为了获得较低的延迟，牺牲 DNS 查询次数。\n参考：[Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Controlling_DNS_prefetching)\n参考：[DNS Prefetching Implications](http://www.pinkbike.com/news/DNS-Prefetching-implications.html)\n\n减少请求\n使用 Data URI，\n使用 CSS Sprites\nhttp://www.csdn.net/article/2013-09-13/2816925-CSS-Sprites-vs.-Data-URIs:-Which-is-Faster-on-Mobile?\n\n## 2.TCP 连接\n\n### 1.使用 keep-alive 保持持久连接\n\n### 2.交互性能优化\n","slug":"Web-Page-Optimization","published":1,"date":"2013-09-23T16:00:00.000Z","updated":"2018-12-07T02:57:03.886Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9w0011w8wk5pd6w82q","content":"<p>提到网页性能优化，一般分为两部分，加载性能优化和交互性能优化。</p>\n<h2 id=\"1-加载性能优化\"><a href=\"#1-加载性能优化\" class=\"headerlink\" title=\"1.加载性能优化\"></a>1.加载性能优化</h2><p>当在浏览器中输入一个 URL 或者在其他页面点击一个链接时，浏览器要做以下工作：DNS 查询，建立 TCP 链接，发送请求，接受响应，渲染页面，执行 Load 监听事件，至此页面加载就完成了。下面我们按照这个步骤思考如何优化页面加载性能？</p>\n<h3 id=\"1-DNS-查询\"><a href=\"#1-DNS-查询\" class=\"headerlink\" title=\"1.DNS 查询\"></a>1.DNS 查询</h3><h4 id=\"1-减少-DNS-查询\"><a href=\"#1-减少-DNS-查询\" class=\"headerlink\" title=\"1.减少 DNS 查询\"></a>1.减少 DNS 查询</h4><h4 id=\"2-使用-DNS-Prefetching（DNS-预获取）特性缩短-DNS-查询时间。\"><a href=\"#2-使用-DNS-Prefetching（DNS-预获取）特性缩短-DNS-查询时间。\" class=\"headerlink\" title=\"2.使用 DNS Prefetching（DNS 预获取）特性缩短 DNS 查询时间。\"></a>2.使用 DNS Prefetching（DNS 预获取）特性缩短 DNS 查询时间。</h4><p>DNS 查询一般占用带宽少，但是延迟可能很高，典型的一次 DNS 查询需要 20-120ms。而 DNS 预获取为了获得较低的延迟，牺牲 DNS 查询次数。<br>参考：<a href=\"https://developer.mozilla.org/en-US/docs/Controlling_DNS_prefetching\" target=\"_blank\" rel=\"noopener\">Mozilla Developer Network</a><br>参考：<a href=\"http://www.pinkbike.com/news/DNS-Prefetching-implications.html\" target=\"_blank\" rel=\"noopener\">DNS Prefetching Implications</a></p>\n<p>减少请求<br>使用 Data URI，<br>使用 CSS Sprites<br><a href=\"http://www.csdn.net/article/2013-09-13/2816925-CSS-Sprites-vs.-Data-URIs:-Which-is-Faster-on-Mobile\" target=\"_blank\" rel=\"noopener\">http://www.csdn.net/article/2013-09-13/2816925-CSS-Sprites-vs.-Data-URIs:-Which-is-Faster-on-Mobile</a>?</p>\n<h2 id=\"2-TCP-连接\"><a href=\"#2-TCP-连接\" class=\"headerlink\" title=\"2.TCP 连接\"></a>2.TCP 连接</h2><h3 id=\"1-使用-keep-alive-保持持久连接\"><a href=\"#1-使用-keep-alive-保持持久连接\" class=\"headerlink\" title=\"1.使用 keep-alive 保持持久连接\"></a>1.使用 keep-alive 保持持久连接</h3><h3 id=\"2-交互性能优化\"><a href=\"#2-交互性能优化\" class=\"headerlink\" title=\"2.交互性能优化\"></a>2.交互性能优化</h3>","site":{"data":{}},"excerpt":"","more":"<p>提到网页性能优化，一般分为两部分，加载性能优化和交互性能优化。</p>\n<h2 id=\"1-加载性能优化\"><a href=\"#1-加载性能优化\" class=\"headerlink\" title=\"1.加载性能优化\"></a>1.加载性能优化</h2><p>当在浏览器中输入一个 URL 或者在其他页面点击一个链接时，浏览器要做以下工作：DNS 查询，建立 TCP 链接，发送请求，接受响应，渲染页面，执行 Load 监听事件，至此页面加载就完成了。下面我们按照这个步骤思考如何优化页面加载性能？</p>\n<h3 id=\"1-DNS-查询\"><a href=\"#1-DNS-查询\" class=\"headerlink\" title=\"1.DNS 查询\"></a>1.DNS 查询</h3><h4 id=\"1-减少-DNS-查询\"><a href=\"#1-减少-DNS-查询\" class=\"headerlink\" title=\"1.减少 DNS 查询\"></a>1.减少 DNS 查询</h4><h4 id=\"2-使用-DNS-Prefetching（DNS-预获取）特性缩短-DNS-查询时间。\"><a href=\"#2-使用-DNS-Prefetching（DNS-预获取）特性缩短-DNS-查询时间。\" class=\"headerlink\" title=\"2.使用 DNS Prefetching（DNS 预获取）特性缩短 DNS 查询时间。\"></a>2.使用 DNS Prefetching（DNS 预获取）特性缩短 DNS 查询时间。</h4><p>DNS 查询一般占用带宽少，但是延迟可能很高，典型的一次 DNS 查询需要 20-120ms。而 DNS 预获取为了获得较低的延迟，牺牲 DNS 查询次数。<br>参考：<a href=\"https://developer.mozilla.org/en-US/docs/Controlling_DNS_prefetching\" target=\"_blank\" rel=\"noopener\">Mozilla Developer Network</a><br>参考：<a href=\"http://www.pinkbike.com/news/DNS-Prefetching-implications.html\" target=\"_blank\" rel=\"noopener\">DNS Prefetching Implications</a></p>\n<p>减少请求<br>使用 Data URI，<br>使用 CSS Sprites<br><a href=\"http://www.csdn.net/article/2013-09-13/2816925-CSS-Sprites-vs.-Data-URIs:-Which-is-Faster-on-Mobile\" target=\"_blank\" rel=\"noopener\">http://www.csdn.net/article/2013-09-13/2816925-CSS-Sprites-vs.-Data-URIs:-Which-is-Faster-on-Mobile</a>?</p>\n<h2 id=\"2-TCP-连接\"><a href=\"#2-TCP-连接\" class=\"headerlink\" title=\"2.TCP 连接\"></a>2.TCP 连接</h2><h3 id=\"1-使用-keep-alive-保持持久连接\"><a href=\"#1-使用-keep-alive-保持持久连接\" class=\"headerlink\" title=\"1.使用 keep-alive 保持持久连接\"></a>1.使用 keep-alive 保持持久连接</h3><h3 id=\"2-交互性能优化\"><a href=\"#2-交互性能优化\" class=\"headerlink\" title=\"2.交互性能优化\"></a>2.交互性能优化</h3>"},{"title":"网站使用条款的处理","_content":"\n网站使用条款，Terms Of Use，也有简称为网规（以下都简称网规）的。前段时间有个需求，就是在用户访问量很大的页面的一个页面添加网规，当时因为时间问题就直接放在动态页面中了，最近开始考虑优化该页面时，才开始考虑如何优化网规。\n\n我们知道网规有如下特点：**① 文本量大**，**② 非常稳定不易变**，并且可能**③ 出现在多个页面**，且有可能会网站下次改版时就使用链接，点击链接才能看到网规。还有一个很重要的特点，就是这东西**④ 很重要但是没人愿意看**。最为常见的网规出现在注册页面，敢问你是不是从来不看网规就直接划勾了？针对以上 ①② 两个特点，**网规适合使用浏览器缓存**，这样可以减少网络传输内容，提高页面加载性能。针对以上第 ③ 个特点，**网规适合使用独立完成**，多个宿主页面可以方便地通用 iframe 加载网规，并且宿主页面和网规样式上互不影响。针对第 ④ 个特点，**网规适合延时加载**，等到必须要用户看的时候才显示出来，要么以链接的形式出现，感兴趣的用户点击查看；或者放在页面靠近底部的地方，让网规占用首屏实在是浪费。\n\n根据以上对网规的特点分析得知，处理网规最好的办法是：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。那么怎么处理呢？如果放在静态资源项目（该项目包含 js，css，image 等静态资源）或应用（后端）中，都需要有个发布过程，并且网规页面也会引用静态资源项目中的某些基础样式文件，如果放在静态资源项目中，不好处理被引用样式文件的版本。后来想到公司内部有个 CMS 系统叫做 TMS，它可以创建独立 php 页面。\n\n将网规放进 TMS 系统以后，发现了一个并不奇怪但出于预料的问题，该系统对一些词汇做了限制，比如“性虐待”，后来通过`<script>document.write('性' + '虐' + '待')；</script>`或者使用 php 语法`<?php echo '性'.'虐'.'待'; ?>`两中方法解决。还有一个预料之内的问题，就是如何设置浏览器缓存，最开始以为 TMS 系统应该对此有一套处理方法的，但是后来通过想 TMS 负责人咨询才发现没有，需要手动写 php 代码。好吧，那么我就写 php 代码吧。\n\n```php\n<?php\n  $etag = 'v1';\n  if ($_SERVER['HTTP_IF_NONE_MATCH'] == $etag){\n    header('Etag:'.$etag, true, 304);\n    exit;\n  }else{\n    header('Etag:'.$etag);\n  }\n?>\n```\n\n在以上代码中，我们使用 Etag/If-None-Match 这对响应头/请求头来做缓存处理，在文档没有变化的情况下，设置 HTTP Code 304，告诉浏览器使用缓存，而不用每次都给用户发一次网规文档。一旦网规文档有任何修改，都必须修改`$etag`变量的值，否则客户浏览器仍然使用缓存看不到最新网规。不过呢，虽然减少了响应内容，但是每次还是需要一个完整的 HTTP 请求和响应（虽然该响应只有 header，没有 body）。所以啊，我们还需要一个很常用的响应头`Cache-Control: max-age=86400`来告诉浏览器我给你的文档很新很稳定，在以后的这一天内你都不用再来找我了。`Cache-Control`是 HTTP1.1 规范中的，为了兼容性，可以使用`Expires`响应头作为 fallback 方案。由于`Expires`响应头使用的绝对时间，用来告诉浏览器我给你的文档有效期是某某时候，在那时之前你都不用来找我了。所以如果用户设备日期时间有较大偏差的话，`Expires`可能会失效。`Cache-Control`响应头使用相对时间，就不会这个问题，这也是为什么在 HTTP1.1 中增加了`Cache-Control`响应头的原因之一。废话不多说，上代码。\n\n```php\n<?php\n  $etag = 'v1';\n  $maxAge = 3600 * 24; // 86400s, 1 day\n  if ($_SERVER['HTTP_IF_NONE_MATCH'] == $etag){\n    header('Etag:'.$etag, true, 304);\n    exit;\n  }else{\n    header('Etag:'.$etag);\n    header('Cache-Control: max-age=' . $maxAge);\n    header('Expires: ' .gmdate('D, d M Y H:i:s', time()+$maxAge). ' GMT');\n  }\n?>\n```\n\n最后一点，如果可能，延迟加载网规文档。这点很简单，就不多讲了。\n\n至此，我们就完成了针对网规的优化：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。\n","source":"_posts/2014-05-05-terms-of-use.md","raw":"---\ntitle: 网站使用条款的处理\n---\n\n网站使用条款，Terms Of Use，也有简称为网规（以下都简称网规）的。前段时间有个需求，就是在用户访问量很大的页面的一个页面添加网规，当时因为时间问题就直接放在动态页面中了，最近开始考虑优化该页面时，才开始考虑如何优化网规。\n\n我们知道网规有如下特点：**① 文本量大**，**② 非常稳定不易变**，并且可能**③ 出现在多个页面**，且有可能会网站下次改版时就使用链接，点击链接才能看到网规。还有一个很重要的特点，就是这东西**④ 很重要但是没人愿意看**。最为常见的网规出现在注册页面，敢问你是不是从来不看网规就直接划勾了？针对以上 ①② 两个特点，**网规适合使用浏览器缓存**，这样可以减少网络传输内容，提高页面加载性能。针对以上第 ③ 个特点，**网规适合使用独立完成**，多个宿主页面可以方便地通用 iframe 加载网规，并且宿主页面和网规样式上互不影响。针对第 ④ 个特点，**网规适合延时加载**，等到必须要用户看的时候才显示出来，要么以链接的形式出现，感兴趣的用户点击查看；或者放在页面靠近底部的地方，让网规占用首屏实在是浪费。\n\n根据以上对网规的特点分析得知，处理网规最好的办法是：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。那么怎么处理呢？如果放在静态资源项目（该项目包含 js，css，image 等静态资源）或应用（后端）中，都需要有个发布过程，并且网规页面也会引用静态资源项目中的某些基础样式文件，如果放在静态资源项目中，不好处理被引用样式文件的版本。后来想到公司内部有个 CMS 系统叫做 TMS，它可以创建独立 php 页面。\n\n将网规放进 TMS 系统以后，发现了一个并不奇怪但出于预料的问题，该系统对一些词汇做了限制，比如“性虐待”，后来通过`<script>document.write('性' + '虐' + '待')；</script>`或者使用 php 语法`<?php echo '性'.'虐'.'待'; ?>`两中方法解决。还有一个预料之内的问题，就是如何设置浏览器缓存，最开始以为 TMS 系统应该对此有一套处理方法的，但是后来通过想 TMS 负责人咨询才发现没有，需要手动写 php 代码。好吧，那么我就写 php 代码吧。\n\n```php\n<?php\n  $etag = 'v1';\n  if ($_SERVER['HTTP_IF_NONE_MATCH'] == $etag){\n    header('Etag:'.$etag, true, 304);\n    exit;\n  }else{\n    header('Etag:'.$etag);\n  }\n?>\n```\n\n在以上代码中，我们使用 Etag/If-None-Match 这对响应头/请求头来做缓存处理，在文档没有变化的情况下，设置 HTTP Code 304，告诉浏览器使用缓存，而不用每次都给用户发一次网规文档。一旦网规文档有任何修改，都必须修改`$etag`变量的值，否则客户浏览器仍然使用缓存看不到最新网规。不过呢，虽然减少了响应内容，但是每次还是需要一个完整的 HTTP 请求和响应（虽然该响应只有 header，没有 body）。所以啊，我们还需要一个很常用的响应头`Cache-Control: max-age=86400`来告诉浏览器我给你的文档很新很稳定，在以后的这一天内你都不用再来找我了。`Cache-Control`是 HTTP1.1 规范中的，为了兼容性，可以使用`Expires`响应头作为 fallback 方案。由于`Expires`响应头使用的绝对时间，用来告诉浏览器我给你的文档有效期是某某时候，在那时之前你都不用来找我了。所以如果用户设备日期时间有较大偏差的话，`Expires`可能会失效。`Cache-Control`响应头使用相对时间，就不会这个问题，这也是为什么在 HTTP1.1 中增加了`Cache-Control`响应头的原因之一。废话不多说，上代码。\n\n```php\n<?php\n  $etag = 'v1';\n  $maxAge = 3600 * 24; // 86400s, 1 day\n  if ($_SERVER['HTTP_IF_NONE_MATCH'] == $etag){\n    header('Etag:'.$etag, true, 304);\n    exit;\n  }else{\n    header('Etag:'.$etag);\n    header('Cache-Control: max-age=' . $maxAge);\n    header('Expires: ' .gmdate('D, d M Y H:i:s', time()+$maxAge). ' GMT');\n  }\n?>\n```\n\n最后一点，如果可能，延迟加载网规文档。这点很简单，就不多讲了。\n\n至此，我们就完成了针对网规的优化：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。\n","slug":"terms-of-use","published":1,"date":"2014-05-04T16:00:00.000Z","updated":"2018-12-07T02:53:39.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9x0012w8wk5ji8qc9h","content":"<p>网站使用条款，Terms Of Use，也有简称为网规（以下都简称网规）的。前段时间有个需求，就是在用户访问量很大的页面的一个页面添加网规，当时因为时间问题就直接放在动态页面中了，最近开始考虑优化该页面时，才开始考虑如何优化网规。</p>\n<p>我们知道网规有如下特点：<strong>① 文本量大</strong>，<strong>② 非常稳定不易变</strong>，并且可能<strong>③ 出现在多个页面</strong>，且有可能会网站下次改版时就使用链接，点击链接才能看到网规。还有一个很重要的特点，就是这东西<strong>④ 很重要但是没人愿意看</strong>。最为常见的网规出现在注册页面，敢问你是不是从来不看网规就直接划勾了？针对以上 ①② 两个特点，<strong>网规适合使用浏览器缓存</strong>，这样可以减少网络传输内容，提高页面加载性能。针对以上第 ③ 个特点，<strong>网规适合使用独立完成</strong>，多个宿主页面可以方便地通用 iframe 加载网规，并且宿主页面和网规样式上互不影响。针对第 ④ 个特点，<strong>网规适合延时加载</strong>，等到必须要用户看的时候才显示出来，要么以链接的形式出现，感兴趣的用户点击查看；或者放在页面靠近底部的地方，让网规占用首屏实在是浪费。</p>\n<p>根据以上对网规的特点分析得知，处理网规最好的办法是：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。那么怎么处理呢？如果放在静态资源项目（该项目包含 js，css，image 等静态资源）或应用（后端）中，都需要有个发布过程，并且网规页面也会引用静态资源项目中的某些基础样式文件，如果放在静态资源项目中，不好处理被引用样式文件的版本。后来想到公司内部有个 CMS 系统叫做 TMS，它可以创建独立 php 页面。</p>\n<p>将网规放进 TMS 系统以后，发现了一个并不奇怪但出于预料的问题，该系统对一些词汇做了限制，比如“性虐待”，后来通过<code>&lt;script&gt;document.write(&#39;性&#39; + &#39;虐&#39; + &#39;待&#39;)；&lt;/script&gt;</code>或者使用 php 语法<code>&lt;?php echo &#39;性&#39;.&#39;虐&#39;.&#39;待&#39;; ?&gt;</code>两中方法解决。还有一个预料之内的问题，就是如何设置浏览器缓存，最开始以为 TMS 系统应该对此有一套处理方法的，但是后来通过想 TMS 负责人咨询才发现没有，需要手动写 php 代码。好吧，那么我就写 php 代码吧。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">  $etag = <span class=\"string\">'v1'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ($_SERVER[<span class=\"string\">'HTTP_IF_NONE_MATCH'</span>] == $etag)&#123;</span><br><span class=\"line\">    header(<span class=\"string\">'Etag:'</span>.$etag, <span class=\"keyword\">true</span>, <span class=\"number\">304</span>);</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    header(<span class=\"string\">'Etag:'</span>.$etag);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在以上代码中，我们使用 Etag/If-None-Match 这对响应头/请求头来做缓存处理，在文档没有变化的情况下，设置 HTTP Code 304，告诉浏览器使用缓存，而不用每次都给用户发一次网规文档。一旦网规文档有任何修改，都必须修改<code>$etag</code>变量的值，否则客户浏览器仍然使用缓存看不到最新网规。不过呢，虽然减少了响应内容，但是每次还是需要一个完整的 HTTP 请求和响应（虽然该响应只有 header，没有 body）。所以啊，我们还需要一个很常用的响应头<code>Cache-Control: max-age=86400</code>来告诉浏览器我给你的文档很新很稳定，在以后的这一天内你都不用再来找我了。<code>Cache-Control</code>是 HTTP1.1 规范中的，为了兼容性，可以使用<code>Expires</code>响应头作为 fallback 方案。由于<code>Expires</code>响应头使用的绝对时间，用来告诉浏览器我给你的文档有效期是某某时候，在那时之前你都不用来找我了。所以如果用户设备日期时间有较大偏差的话，<code>Expires</code>可能会失效。<code>Cache-Control</code>响应头使用相对时间，就不会这个问题，这也是为什么在 HTTP1.1 中增加了<code>Cache-Control</code>响应头的原因之一。废话不多说，上代码。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">  $etag = <span class=\"string\">'v1'</span>;</span><br><span class=\"line\">  $maxAge = <span class=\"number\">3600</span> * <span class=\"number\">24</span>; <span class=\"comment\">// 86400s, 1 day</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ($_SERVER[<span class=\"string\">'HTTP_IF_NONE_MATCH'</span>] == $etag)&#123;</span><br><span class=\"line\">    header(<span class=\"string\">'Etag:'</span>.$etag, <span class=\"keyword\">true</span>, <span class=\"number\">304</span>);</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    header(<span class=\"string\">'Etag:'</span>.$etag);</span><br><span class=\"line\">    header(<span class=\"string\">'Cache-Control: max-age='</span> . $maxAge);</span><br><span class=\"line\">    header(<span class=\"string\">'Expires: '</span> .gmdate(<span class=\"string\">'D, d M Y H:i:s'</span>, time()+$maxAge). <span class=\"string\">' GMT'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>最后一点，如果可能，延迟加载网规文档。这点很简单，就不多讲了。</p>\n<p>至此，我们就完成了针对网规的优化：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>网站使用条款，Terms Of Use，也有简称为网规（以下都简称网规）的。前段时间有个需求，就是在用户访问量很大的页面的一个页面添加网规，当时因为时间问题就直接放在动态页面中了，最近开始考虑优化该页面时，才开始考虑如何优化网规。</p>\n<p>我们知道网规有如下特点：<strong>① 文本量大</strong>，<strong>② 非常稳定不易变</strong>，并且可能<strong>③ 出现在多个页面</strong>，且有可能会网站下次改版时就使用链接，点击链接才能看到网规。还有一个很重要的特点，就是这东西<strong>④ 很重要但是没人愿意看</strong>。最为常见的网规出现在注册页面，敢问你是不是从来不看网规就直接划勾了？针对以上 ①② 两个特点，<strong>网规适合使用浏览器缓存</strong>，这样可以减少网络传输内容，提高页面加载性能。针对以上第 ③ 个特点，<strong>网规适合使用独立完成</strong>，多个宿主页面可以方便地通用 iframe 加载网规，并且宿主页面和网规样式上互不影响。针对第 ④ 个特点，<strong>网规适合延时加载</strong>，等到必须要用户看的时候才显示出来，要么以链接的形式出现，感兴趣的用户点击查看；或者放在页面靠近底部的地方，让网规占用首屏实在是浪费。</p>\n<p>根据以上对网规的特点分析得知，处理网规最好的办法是：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。那么怎么处理呢？如果放在静态资源项目（该项目包含 js，css，image 等静态资源）或应用（后端）中，都需要有个发布过程，并且网规页面也会引用静态资源项目中的某些基础样式文件，如果放在静态资源项目中，不好处理被引用样式文件的版本。后来想到公司内部有个 CMS 系统叫做 TMS，它可以创建独立 php 页面。</p>\n<p>将网规放进 TMS 系统以后，发现了一个并不奇怪但出于预料的问题，该系统对一些词汇做了限制，比如“性虐待”，后来通过<code>&lt;script&gt;document.write(&#39;性&#39; + &#39;虐&#39; + &#39;待&#39;)；&lt;/script&gt;</code>或者使用 php 语法<code>&lt;?php echo &#39;性&#39;.&#39;虐&#39;.&#39;待&#39;; ?&gt;</code>两中方法解决。还有一个预料之内的问题，就是如何设置浏览器缓存，最开始以为 TMS 系统应该对此有一套处理方法的，但是后来通过想 TMS 负责人咨询才发现没有，需要手动写 php 代码。好吧，那么我就写 php 代码吧。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">  $etag = <span class=\"string\">'v1'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ($_SERVER[<span class=\"string\">'HTTP_IF_NONE_MATCH'</span>] == $etag)&#123;</span><br><span class=\"line\">    header(<span class=\"string\">'Etag:'</span>.$etag, <span class=\"keyword\">true</span>, <span class=\"number\">304</span>);</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    header(<span class=\"string\">'Etag:'</span>.$etag);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在以上代码中，我们使用 Etag/If-None-Match 这对响应头/请求头来做缓存处理，在文档没有变化的情况下，设置 HTTP Code 304，告诉浏览器使用缓存，而不用每次都给用户发一次网规文档。一旦网规文档有任何修改，都必须修改<code>$etag</code>变量的值，否则客户浏览器仍然使用缓存看不到最新网规。不过呢，虽然减少了响应内容，但是每次还是需要一个完整的 HTTP 请求和响应（虽然该响应只有 header，没有 body）。所以啊，我们还需要一个很常用的响应头<code>Cache-Control: max-age=86400</code>来告诉浏览器我给你的文档很新很稳定，在以后的这一天内你都不用再来找我了。<code>Cache-Control</code>是 HTTP1.1 规范中的，为了兼容性，可以使用<code>Expires</code>响应头作为 fallback 方案。由于<code>Expires</code>响应头使用的绝对时间，用来告诉浏览器我给你的文档有效期是某某时候，在那时之前你都不用来找我了。所以如果用户设备日期时间有较大偏差的话，<code>Expires</code>可能会失效。<code>Cache-Control</code>响应头使用相对时间，就不会这个问题，这也是为什么在 HTTP1.1 中增加了<code>Cache-Control</code>响应头的原因之一。废话不多说，上代码。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">  $etag = <span class=\"string\">'v1'</span>;</span><br><span class=\"line\">  $maxAge = <span class=\"number\">3600</span> * <span class=\"number\">24</span>; <span class=\"comment\">// 86400s, 1 day</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ($_SERVER[<span class=\"string\">'HTTP_IF_NONE_MATCH'</span>] == $etag)&#123;</span><br><span class=\"line\">    header(<span class=\"string\">'Etag:'</span>.$etag, <span class=\"keyword\">true</span>, <span class=\"number\">304</span>);</span><br><span class=\"line\">    <span class=\"keyword\">exit</span>;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    header(<span class=\"string\">'Etag:'</span>.$etag);</span><br><span class=\"line\">    header(<span class=\"string\">'Cache-Control: max-age='</span> . $maxAge);</span><br><span class=\"line\">    header(<span class=\"string\">'Expires: '</span> .gmdate(<span class=\"string\">'D, d M Y H:i:s'</span>, time()+$maxAge). <span class=\"string\">' GMT'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n<p>最后一点，如果可能，延迟加载网规文档。这点很简单，就不多讲了。</p>\n<p>至此，我们就完成了针对网规的优化：为网规创建一个独立页面，设置好浏览器缓存，如果可能延迟加载。</p>\n"},{"title":"如何计算首屏加载时间？","_content":"\n在网站开发中，首屏是我们最需要关注的指标之一，它基本代表着用户眼中的网站加载时间。但是如何衡量它呢？\n\n在我们公司有这样的一种做法，将以下代码放入需要首屏最后一个元素后面\n\n```html\n<script type=\"text/javascript\">\n    /* <![CDATA[ */\n    PAGE_TIMING.firstScreenImage = new Image();\n    PAGE_TIMING.firstScreenImage.onload = function() {\n        PAGE_TIMING.firstScreen = new Date().getTime();\n    };\n    PAGE_TIMING.firstScreenImage.src = 'http://sample.com/wimg/monitor/first-screen.png';\n    /* ]]> */\n</script>\n```\n\n其中`first-screen.png`是用了缓存。我们将`PAGE_TIMING.firstScreen`作为首屏加载时间，这样也只是一个近似时间。不知道各位看官你们是如何处理的呢？\n","source":"_posts/2014-05-07-first-screen.md","raw":"---\ntitle: 如何计算首屏加载时间？\n---\n\n在网站开发中，首屏是我们最需要关注的指标之一，它基本代表着用户眼中的网站加载时间。但是如何衡量它呢？\n\n在我们公司有这样的一种做法，将以下代码放入需要首屏最后一个元素后面\n\n```html\n<script type=\"text/javascript\">\n    /* <![CDATA[ */\n    PAGE_TIMING.firstScreenImage = new Image();\n    PAGE_TIMING.firstScreenImage.onload = function() {\n        PAGE_TIMING.firstScreen = new Date().getTime();\n    };\n    PAGE_TIMING.firstScreenImage.src = 'http://sample.com/wimg/monitor/first-screen.png';\n    /* ]]> */\n</script>\n```\n\n其中`first-screen.png`是用了缓存。我们将`PAGE_TIMING.firstScreen`作为首屏加载时间，这样也只是一个近似时间。不知道各位看官你们是如何处理的呢？\n","slug":"first-screen","published":1,"date":"2014-05-06T16:00:00.000Z","updated":"2018-12-07T02:52:52.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9x0013w8wkk4nnppaq","content":"<p>在网站开发中，首屏是我们最需要关注的指标之一，它基本代表着用户眼中的网站加载时间。但是如何衡量它呢？</p>\n<p>在我们公司有这样的一种做法，将以下代码放入需要首屏最后一个元素后面</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">/* &lt;![CDATA[ */</span></span></span><br><span class=\"line\"><span class=\"javascript\">    PAGE_TIMING.firstScreenImage = <span class=\"keyword\">new</span> Image();</span></span><br><span class=\"line\"><span class=\"javascript\">    PAGE_TIMING.firstScreenImage.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        PAGE_TIMING.firstScreen = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">    PAGE_TIMING.firstScreenImage.src = <span class=\"string\">'http://sample.com/wimg/monitor/first-screen.png'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">/* ]]&gt; */</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其中<code>first-screen.png</code>是用了缓存。我们将<code>PAGE_TIMING.firstScreen</code>作为首屏加载时间，这样也只是一个近似时间。不知道各位看官你们是如何处理的呢？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在网站开发中，首屏是我们最需要关注的指标之一，它基本代表着用户眼中的网站加载时间。但是如何衡量它呢？</p>\n<p>在我们公司有这样的一种做法，将以下代码放入需要首屏最后一个元素后面</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">/* &lt;![CDATA[ */</span></span></span><br><span class=\"line\"><span class=\"javascript\">    PAGE_TIMING.firstScreenImage = <span class=\"keyword\">new</span> Image();</span></span><br><span class=\"line\"><span class=\"javascript\">    PAGE_TIMING.firstScreenImage.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        PAGE_TIMING.firstScreen = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\">    PAGE_TIMING.firstScreenImage.src = <span class=\"string\">'http://sample.com/wimg/monitor/first-screen.png'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"comment\">/* ]]&gt; */</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>其中<code>first-screen.png</code>是用了缓存。我们将<code>PAGE_TIMING.firstScreen</code>作为首屏加载时间，这样也只是一个近似时间。不知道各位看官你们是如何处理的呢？</p>\n"},{"title":"focus VS scrollIntoView","_content":"\n将今天遇到的小故障记录一下吧。  \n\n业务相关的东西就不多说了，","source":"_posts/2014-05-08-scrollIntoView.md","raw":"---\ntitle: focus VS scrollIntoView\n---\n\n将今天遇到的小故障记录一下吧。  \n\n业务相关的东西就不多说了，","slug":"scrollIntoView","published":1,"date":"2014-05-07T16:00:00.000Z","updated":"2018-12-06T11:21:06.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9y0014w8wkqjggvhf7","content":"<p>将今天遇到的小故障记录一下吧。  </p>\n<p>业务相关的东西就不多说了，</p>\n","site":{"data":{}},"excerpt":"","more":"<p>将今天遇到的小故障记录一下吧。  </p>\n<p>业务相关的东西就不多说了，</p>\n"},{"title":"讨论一例交互--常用类目","_content":"\n## 问题\n\n在我们的网站后台有个很重要的功能，就是让用户发布产品，发布产品之前需要给该产品选择一个类目。类目的选择有以下三种方式。\n\n### 1.直接浏览类目树\n\n操作方法：选择次级类目……依次类推下去，最多有四级类目。  \n![直接浏览类目树](../../../../images/category-browse.jpg)\n\n### 2.通过关键字搜索\n\n操作方法：在“请输入产品关键字”之后的输入框中输入关键字后，点击搜索按钮就可以看到相应类目。\n![通过关键字搜索类目](../../../../images/category-search.jpg)\n\n### 3.常用类目选择\n\n为了用户操作遍历，我们提供了更好用的功能，常用类目列表。我们网站的客户是外贸企业，他们的产品类型一般比较单调，比如一般不会有一个企业既卖大型机械，又卖 MP3，所以一个客户的类目也就那么几种，并且越是常用的类目越是靠前，很容易在常用列表中找到。  \n操作方法：点击“您经常使用的类目”Tab，然后选择一个常用类目。  \n![通过关键字搜索类目](../../../../images/category-search.jpg)\n\n以上三种方法都介绍完了，请你猜一猜有多少用户选择了方法 1（浏览），多少用户选择了方法 2（搜索），又有多少用户选择了方法 3（常用类目）。如果你是用户，你会使用那种方法呢？\n\n针对该问题我进行了 Google Analytics 打点，得到如下表格。  \n![通过关键字搜索类目](../../../../images/category-ga.jpg)\n\n从表格中可以看出。50%的用户发现搜索起来更快更容易找到自己想要的类目，有 14%的用户不负我们网站的苦衷，使用常用类目快速找到其想要的类目，但是仍然有 36%的用户选择直接浏览器类目，不厌其烦地一级一级选择类目。这个数据让我大失所望，我一直认为应该由更多的用户选择常用类目。\n\n失望归失望，我们还是要分析问题，解决问题。\n\n## 分析\n\n### 1.常用类目过于隐蔽\n\n由于页面上要显示的内容很多，而页面就那么大一块地方，所以我们就需要让内容折叠起来，这时候 Tab 作为一种很好的展现方式，被大多数网站所使用，但是不得不说，用户为了看到 Tab 中隐藏的内容，需要用户将鼠标移动到相应 Tab 头上，甚至需要多一次点击，比起默认显示的内容，**多了一个操作步骤**，这些都是用户需要付出的操作成本。另外一个问题，就是当初我们实现扁平化设计以及简约的网站风格，将**Tab 头的背景色调的很淡**。如果用户不仔细看都看不到还不到“您经常使用的类目”这几个字，即使看到了，还不一定知道这是 Tab 头，还可以点击，其背后还有一个桃花源。\n\n关于操作步骤，在《点石成金 访客之上的网页设计秘笈》（也就《别让我思考》）一书中，作者也强调这个问题，比如作者就十分痛恨为了节省空间，使用 Select 下拉框的行为。他认为下拉框具有以下缺陷，① 用户必须点击下拉框才能看到其所有选项，多了一个操作 ② 当选项过多时，很难看清楚，很容易选错。即使设计师意识到这一点，想为其设置更加友好优美的样式，也很难，因为在很多浏览器其样式不可更改或者不能完全更改，等等。\n\n### 2.首次使用网站时，常用类目列表为空\n\n当用户第一次进入该网站时，假如说他注意到了还有常用类目这一项，他可能会点进去看个究竟，但是进去之后却发现空空如也，没有我想要的东西，用户失望地回到 Tab 的第一页，他也不知道该用什么关键字来搜索他想要的类目，只能一级一级地找寻，一级一级的选择，就这样该用户一直延续这个习惯。\n\n我们的网站在设计的时候还是犯了一个错误，在新用户第一次进入网站，还没有发布任何产品，系统也不为其生成常用类目的时候，仍然在页面上显示了这样一个 Tab，用户点进去什么也看不到，就可能形成一种意识，这里没有任何东西，并有可能以后再也不会点击这个 Tab 了。\n\n### 3.常用类目使用 Iframe 加载\n\n**使用 iframe 加载较慢**，部分用户可能因为无法忍受又多一次加载过程，而放弃。\n\n以上只是结合 GA 打点结果，针对常用类目做的一些 YY 猜想，不一定准确的，但是在找到更好的办法之前，需要针对以上几点做一个改变，希望更多的用户使用搜索类目或者常用类目。做到真正的方便用户，用户第一。\n","source":"_posts/2014-05-22-how-to-select-category.md","raw":"---\ntitle: 讨论一例交互--常用类目\n---\n\n## 问题\n\n在我们的网站后台有个很重要的功能，就是让用户发布产品，发布产品之前需要给该产品选择一个类目。类目的选择有以下三种方式。\n\n### 1.直接浏览类目树\n\n操作方法：选择次级类目……依次类推下去，最多有四级类目。  \n![直接浏览类目树](../../../../images/category-browse.jpg)\n\n### 2.通过关键字搜索\n\n操作方法：在“请输入产品关键字”之后的输入框中输入关键字后，点击搜索按钮就可以看到相应类目。\n![通过关键字搜索类目](../../../../images/category-search.jpg)\n\n### 3.常用类目选择\n\n为了用户操作遍历，我们提供了更好用的功能，常用类目列表。我们网站的客户是外贸企业，他们的产品类型一般比较单调，比如一般不会有一个企业既卖大型机械，又卖 MP3，所以一个客户的类目也就那么几种，并且越是常用的类目越是靠前，很容易在常用列表中找到。  \n操作方法：点击“您经常使用的类目”Tab，然后选择一个常用类目。  \n![通过关键字搜索类目](../../../../images/category-search.jpg)\n\n以上三种方法都介绍完了，请你猜一猜有多少用户选择了方法 1（浏览），多少用户选择了方法 2（搜索），又有多少用户选择了方法 3（常用类目）。如果你是用户，你会使用那种方法呢？\n\n针对该问题我进行了 Google Analytics 打点，得到如下表格。  \n![通过关键字搜索类目](../../../../images/category-ga.jpg)\n\n从表格中可以看出。50%的用户发现搜索起来更快更容易找到自己想要的类目，有 14%的用户不负我们网站的苦衷，使用常用类目快速找到其想要的类目，但是仍然有 36%的用户选择直接浏览器类目，不厌其烦地一级一级选择类目。这个数据让我大失所望，我一直认为应该由更多的用户选择常用类目。\n\n失望归失望，我们还是要分析问题，解决问题。\n\n## 分析\n\n### 1.常用类目过于隐蔽\n\n由于页面上要显示的内容很多，而页面就那么大一块地方，所以我们就需要让内容折叠起来，这时候 Tab 作为一种很好的展现方式，被大多数网站所使用，但是不得不说，用户为了看到 Tab 中隐藏的内容，需要用户将鼠标移动到相应 Tab 头上，甚至需要多一次点击，比起默认显示的内容，**多了一个操作步骤**，这些都是用户需要付出的操作成本。另外一个问题，就是当初我们实现扁平化设计以及简约的网站风格，将**Tab 头的背景色调的很淡**。如果用户不仔细看都看不到还不到“您经常使用的类目”这几个字，即使看到了，还不一定知道这是 Tab 头，还可以点击，其背后还有一个桃花源。\n\n关于操作步骤，在《点石成金 访客之上的网页设计秘笈》（也就《别让我思考》）一书中，作者也强调这个问题，比如作者就十分痛恨为了节省空间，使用 Select 下拉框的行为。他认为下拉框具有以下缺陷，① 用户必须点击下拉框才能看到其所有选项，多了一个操作 ② 当选项过多时，很难看清楚，很容易选错。即使设计师意识到这一点，想为其设置更加友好优美的样式，也很难，因为在很多浏览器其样式不可更改或者不能完全更改，等等。\n\n### 2.首次使用网站时，常用类目列表为空\n\n当用户第一次进入该网站时，假如说他注意到了还有常用类目这一项，他可能会点进去看个究竟，但是进去之后却发现空空如也，没有我想要的东西，用户失望地回到 Tab 的第一页，他也不知道该用什么关键字来搜索他想要的类目，只能一级一级地找寻，一级一级的选择，就这样该用户一直延续这个习惯。\n\n我们的网站在设计的时候还是犯了一个错误，在新用户第一次进入网站，还没有发布任何产品，系统也不为其生成常用类目的时候，仍然在页面上显示了这样一个 Tab，用户点进去什么也看不到，就可能形成一种意识，这里没有任何东西，并有可能以后再也不会点击这个 Tab 了。\n\n### 3.常用类目使用 Iframe 加载\n\n**使用 iframe 加载较慢**，部分用户可能因为无法忍受又多一次加载过程，而放弃。\n\n以上只是结合 GA 打点结果，针对常用类目做的一些 YY 猜想，不一定准确的，但是在找到更好的办法之前，需要针对以上几点做一个改变，希望更多的用户使用搜索类目或者常用类目。做到真正的方便用户，用户第一。\n","slug":"how-to-select-category","published":1,"date":"2014-05-21T16:00:00.000Z","updated":"2018-12-07T02:52:34.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfm9z0015w8wk2ccjyew9","content":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在我们的网站后台有个很重要的功能，就是让用户发布产品，发布产品之前需要给该产品选择一个类目。类目的选择有以下三种方式。</p>\n<h3 id=\"1-直接浏览类目树\"><a href=\"#1-直接浏览类目树\" class=\"headerlink\" title=\"1.直接浏览类目树\"></a>1.直接浏览类目树</h3><p>操作方法：选择次级类目……依次类推下去，最多有四级类目。<br><img src=\"../../../../images/category-browse.jpg\" alt=\"直接浏览类目树\"></p>\n<h3 id=\"2-通过关键字搜索\"><a href=\"#2-通过关键字搜索\" class=\"headerlink\" title=\"2.通过关键字搜索\"></a>2.通过关键字搜索</h3><p>操作方法：在“请输入产品关键字”之后的输入框中输入关键字后，点击搜索按钮就可以看到相应类目。<br><img src=\"../../../../images/category-search.jpg\" alt=\"通过关键字搜索类目\"></p>\n<h3 id=\"3-常用类目选择\"><a href=\"#3-常用类目选择\" class=\"headerlink\" title=\"3.常用类目选择\"></a>3.常用类目选择</h3><p>为了用户操作遍历，我们提供了更好用的功能，常用类目列表。我们网站的客户是外贸企业，他们的产品类型一般比较单调，比如一般不会有一个企业既卖大型机械，又卖 MP3，所以一个客户的类目也就那么几种，并且越是常用的类目越是靠前，很容易在常用列表中找到。<br>操作方法：点击“您经常使用的类目”Tab，然后选择一个常用类目。<br><img src=\"../../../../images/category-search.jpg\" alt=\"通过关键字搜索类目\"></p>\n<p>以上三种方法都介绍完了，请你猜一猜有多少用户选择了方法 1（浏览），多少用户选择了方法 2（搜索），又有多少用户选择了方法 3（常用类目）。如果你是用户，你会使用那种方法呢？</p>\n<p>针对该问题我进行了 Google Analytics 打点，得到如下表格。<br><img src=\"../../../../images/category-ga.jpg\" alt=\"通过关键字搜索类目\"></p>\n<p>从表格中可以看出。50%的用户发现搜索起来更快更容易找到自己想要的类目，有 14%的用户不负我们网站的苦衷，使用常用类目快速找到其想要的类目，但是仍然有 36%的用户选择直接浏览器类目，不厌其烦地一级一级选择类目。这个数据让我大失所望，我一直认为应该由更多的用户选择常用类目。</p>\n<p>失望归失望，我们还是要分析问题，解决问题。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><h3 id=\"1-常用类目过于隐蔽\"><a href=\"#1-常用类目过于隐蔽\" class=\"headerlink\" title=\"1.常用类目过于隐蔽\"></a>1.常用类目过于隐蔽</h3><p>由于页面上要显示的内容很多，而页面就那么大一块地方，所以我们就需要让内容折叠起来，这时候 Tab 作为一种很好的展现方式，被大多数网站所使用，但是不得不说，用户为了看到 Tab 中隐藏的内容，需要用户将鼠标移动到相应 Tab 头上，甚至需要多一次点击，比起默认显示的内容，<strong>多了一个操作步骤</strong>，这些都是用户需要付出的操作成本。另外一个问题，就是当初我们实现扁平化设计以及简约的网站风格，将<strong>Tab 头的背景色调的很淡</strong>。如果用户不仔细看都看不到还不到“您经常使用的类目”这几个字，即使看到了，还不一定知道这是 Tab 头，还可以点击，其背后还有一个桃花源。</p>\n<p>关于操作步骤，在《点石成金 访客之上的网页设计秘笈》（也就《别让我思考》）一书中，作者也强调这个问题，比如作者就十分痛恨为了节省空间，使用 Select 下拉框的行为。他认为下拉框具有以下缺陷，① 用户必须点击下拉框才能看到其所有选项，多了一个操作 ② 当选项过多时，很难看清楚，很容易选错。即使设计师意识到这一点，想为其设置更加友好优美的样式，也很难，因为在很多浏览器其样式不可更改或者不能完全更改，等等。</p>\n<h3 id=\"2-首次使用网站时，常用类目列表为空\"><a href=\"#2-首次使用网站时，常用类目列表为空\" class=\"headerlink\" title=\"2.首次使用网站时，常用类目列表为空\"></a>2.首次使用网站时，常用类目列表为空</h3><p>当用户第一次进入该网站时，假如说他注意到了还有常用类目这一项，他可能会点进去看个究竟，但是进去之后却发现空空如也，没有我想要的东西，用户失望地回到 Tab 的第一页，他也不知道该用什么关键字来搜索他想要的类目，只能一级一级地找寻，一级一级的选择，就这样该用户一直延续这个习惯。</p>\n<p>我们的网站在设计的时候还是犯了一个错误，在新用户第一次进入网站，还没有发布任何产品，系统也不为其生成常用类目的时候，仍然在页面上显示了这样一个 Tab，用户点进去什么也看不到，就可能形成一种意识，这里没有任何东西，并有可能以后再也不会点击这个 Tab 了。</p>\n<h3 id=\"3-常用类目使用-Iframe-加载\"><a href=\"#3-常用类目使用-Iframe-加载\" class=\"headerlink\" title=\"3.常用类目使用 Iframe 加载\"></a>3.常用类目使用 Iframe 加载</h3><p><strong>使用 iframe 加载较慢</strong>，部分用户可能因为无法忍受又多一次加载过程，而放弃。</p>\n<p>以上只是结合 GA 打点结果，针对常用类目做的一些 YY 猜想，不一定准确的，但是在找到更好的办法之前，需要针对以上几点做一个改变，希望更多的用户使用搜索类目或者常用类目。做到真正的方便用户，用户第一。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在我们的网站后台有个很重要的功能，就是让用户发布产品，发布产品之前需要给该产品选择一个类目。类目的选择有以下三种方式。</p>\n<h3 id=\"1-直接浏览类目树\"><a href=\"#1-直接浏览类目树\" class=\"headerlink\" title=\"1.直接浏览类目树\"></a>1.直接浏览类目树</h3><p>操作方法：选择次级类目……依次类推下去，最多有四级类目。<br><img src=\"../../../../images/category-browse.jpg\" alt=\"直接浏览类目树\"></p>\n<h3 id=\"2-通过关键字搜索\"><a href=\"#2-通过关键字搜索\" class=\"headerlink\" title=\"2.通过关键字搜索\"></a>2.通过关键字搜索</h3><p>操作方法：在“请输入产品关键字”之后的输入框中输入关键字后，点击搜索按钮就可以看到相应类目。<br><img src=\"../../../../images/category-search.jpg\" alt=\"通过关键字搜索类目\"></p>\n<h3 id=\"3-常用类目选择\"><a href=\"#3-常用类目选择\" class=\"headerlink\" title=\"3.常用类目选择\"></a>3.常用类目选择</h3><p>为了用户操作遍历，我们提供了更好用的功能，常用类目列表。我们网站的客户是外贸企业，他们的产品类型一般比较单调，比如一般不会有一个企业既卖大型机械，又卖 MP3，所以一个客户的类目也就那么几种，并且越是常用的类目越是靠前，很容易在常用列表中找到。<br>操作方法：点击“您经常使用的类目”Tab，然后选择一个常用类目。<br><img src=\"../../../../images/category-search.jpg\" alt=\"通过关键字搜索类目\"></p>\n<p>以上三种方法都介绍完了，请你猜一猜有多少用户选择了方法 1（浏览），多少用户选择了方法 2（搜索），又有多少用户选择了方法 3（常用类目）。如果你是用户，你会使用那种方法呢？</p>\n<p>针对该问题我进行了 Google Analytics 打点，得到如下表格。<br><img src=\"../../../../images/category-ga.jpg\" alt=\"通过关键字搜索类目\"></p>\n<p>从表格中可以看出。50%的用户发现搜索起来更快更容易找到自己想要的类目，有 14%的用户不负我们网站的苦衷，使用常用类目快速找到其想要的类目，但是仍然有 36%的用户选择直接浏览器类目，不厌其烦地一级一级选择类目。这个数据让我大失所望，我一直认为应该由更多的用户选择常用类目。</p>\n<p>失望归失望，我们还是要分析问题，解决问题。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><h3 id=\"1-常用类目过于隐蔽\"><a href=\"#1-常用类目过于隐蔽\" class=\"headerlink\" title=\"1.常用类目过于隐蔽\"></a>1.常用类目过于隐蔽</h3><p>由于页面上要显示的内容很多，而页面就那么大一块地方，所以我们就需要让内容折叠起来，这时候 Tab 作为一种很好的展现方式，被大多数网站所使用，但是不得不说，用户为了看到 Tab 中隐藏的内容，需要用户将鼠标移动到相应 Tab 头上，甚至需要多一次点击，比起默认显示的内容，<strong>多了一个操作步骤</strong>，这些都是用户需要付出的操作成本。另外一个问题，就是当初我们实现扁平化设计以及简约的网站风格，将<strong>Tab 头的背景色调的很淡</strong>。如果用户不仔细看都看不到还不到“您经常使用的类目”这几个字，即使看到了，还不一定知道这是 Tab 头，还可以点击，其背后还有一个桃花源。</p>\n<p>关于操作步骤，在《点石成金 访客之上的网页设计秘笈》（也就《别让我思考》）一书中，作者也强调这个问题，比如作者就十分痛恨为了节省空间，使用 Select 下拉框的行为。他认为下拉框具有以下缺陷，① 用户必须点击下拉框才能看到其所有选项，多了一个操作 ② 当选项过多时，很难看清楚，很容易选错。即使设计师意识到这一点，想为其设置更加友好优美的样式，也很难，因为在很多浏览器其样式不可更改或者不能完全更改，等等。</p>\n<h3 id=\"2-首次使用网站时，常用类目列表为空\"><a href=\"#2-首次使用网站时，常用类目列表为空\" class=\"headerlink\" title=\"2.首次使用网站时，常用类目列表为空\"></a>2.首次使用网站时，常用类目列表为空</h3><p>当用户第一次进入该网站时，假如说他注意到了还有常用类目这一项，他可能会点进去看个究竟，但是进去之后却发现空空如也，没有我想要的东西，用户失望地回到 Tab 的第一页，他也不知道该用什么关键字来搜索他想要的类目，只能一级一级地找寻，一级一级的选择，就这样该用户一直延续这个习惯。</p>\n<p>我们的网站在设计的时候还是犯了一个错误，在新用户第一次进入网站，还没有发布任何产品，系统也不为其生成常用类目的时候，仍然在页面上显示了这样一个 Tab，用户点进去什么也看不到，就可能形成一种意识，这里没有任何东西，并有可能以后再也不会点击这个 Tab 了。</p>\n<h3 id=\"3-常用类目使用-Iframe-加载\"><a href=\"#3-常用类目使用-Iframe-加载\" class=\"headerlink\" title=\"3.常用类目使用 Iframe 加载\"></a>3.常用类目使用 Iframe 加载</h3><p><strong>使用 iframe 加载较慢</strong>，部分用户可能因为无法忍受又多一次加载过程，而放弃。</p>\n<p>以上只是结合 GA 打点结果，针对常用类目做的一些 YY 猜想，不一定准确的，但是在找到更好的办法之前，需要针对以上几点做一个改变，希望更多的用户使用搜索类目或者常用类目。做到真正的方便用户，用户第一。</p>\n"},{"title":"Backbone中的几个小问题","_content":"\nBackbone 用起来还行，但是在某些方面还是有不方便之处。比如，\n\n1. 需要手动将数据填充到 DOM 中，需要手动从 DOM 中抽取数据\n\n```js\n// 手动填充数据\nthis.$el.html(this.template(this.model.toJSON()));\n// 手动收集用户输入的表单数据\nvar arr = $('form-id').serializeArray();\n```\n\n2. 需要重复绑定事件，由于其模板引擎是基于字符串的，所以在 model 更新时，需要替换掉相应 DOM 树，而不是在原有 DOM 上更新，每次 DOM 替换后，都需要重复绑定事件。当然你可以选择使用事件代理，但是并不是什么时候都可以使用事件代理的，比如你依赖的组件不支持事件代理，这时候就很郁闷啦。\n\n3. 同样由于其模板引擎是基于字符串的，所以如果你监听了 model 的 change 事件，那么你需要注意，你需要尽可能的批量更新 model，否则会导致连续的多次大块 DOM 替换。\n\n```js\n// 不好，可能导致多次大块DOM渲染\nmodel.set({ name: 'Name' });\nmodel.set({ age: 28 });\n\n// 好，只有一次DOM渲染。\nmodel.set({\n    name: 'Name',\n    age: 28,\n});\n```\n\n除了这一点外，还需要考虑缩小监听范围，比如\n\n```js\n// 仅仅监听isShown字段是否被修改，忽略其他字段\nmodel.bind('change:isShown', this.display);\n```\n\n今天又遇到一个问题，先说一下背景吧。最近网站由于故障频发，要求后端必须灰度发布，就是首先发布到线上的一台机器，测试，如果没有问题再发布到所有机器上，否则回滚；而且前端和后端是分别发布，并且前端没有灰度发布。这样一来，前端需要同时兼容后端的新旧两个版本。所以前端发布时需要测试两种情况：新后端+新前端，旧后端+新前端。在新后端+新前端测试通过后，测试旧后端+新前端时，发现了`ReferenceError: XXX is not defined`这样的错误。根据 Chrome 控制台提供的信息可以看到，是由于**Backbone 的模板引擎是通过 with 实现的**。我们知道 with 有一个问题：在 with 作用域内引用对象上不存在的属性，则会报出 ReferenceError 错误。比如：\n\n```js\nvar obj = { a: 1 };\nwith (obj) {\n    console.log(a); // OK\n    console.log(unExistedAttr); // ReferenceError: unExistedAttr is not defined\n}\n```\n\n在新版本中某个 Ajax 请求中增加一个字段，假定为 f，在前端模板中通过`<% if(f){ %> ... <% } %>`引用了该字段，没有任何问题，而在旧版本后端中没有该字段，就会报`ReferenceError: f is not defined`错误。\n\n针对这个问题，一般可以给 model 设置默认属性值，但是总归还是比较麻烦的。也幸好 Chrome 的 Debug 能力很强，通过点击错误就看到了编译后的模板方法。如果使用 Firefox 浏览器，只能看到报了`ReferenceError: f is not defined`，恐怕你还很难猜测到是模板里引用了该变量导致的呢。\n\n顺便说一下，我不太喜欢 backbone 模板引擎的语法的，使用`<% %>`看起来和 html 标签太像，看起来总是觉得不太舒服。还是比较喜欢 doT 的语法风格，\n\n```html\n<div>Hi {{=it.name}}!</div>\n<div>{{=it.age || ''}}</div>\n```\n\n在编辑器中使用了语法高亮之后，看起来好整洁。\n\n以上就是我使用 Backbone 遇到的一些问题，以后有新问题再补充。\n","source":"_posts/2014-05-04-backbone-problems.md","raw":"---\ntitle: Backbone中的几个小问题\n---\n\nBackbone 用起来还行，但是在某些方面还是有不方便之处。比如，\n\n1. 需要手动将数据填充到 DOM 中，需要手动从 DOM 中抽取数据\n\n```js\n// 手动填充数据\nthis.$el.html(this.template(this.model.toJSON()));\n// 手动收集用户输入的表单数据\nvar arr = $('form-id').serializeArray();\n```\n\n2. 需要重复绑定事件，由于其模板引擎是基于字符串的，所以在 model 更新时，需要替换掉相应 DOM 树，而不是在原有 DOM 上更新，每次 DOM 替换后，都需要重复绑定事件。当然你可以选择使用事件代理，但是并不是什么时候都可以使用事件代理的，比如你依赖的组件不支持事件代理，这时候就很郁闷啦。\n\n3. 同样由于其模板引擎是基于字符串的，所以如果你监听了 model 的 change 事件，那么你需要注意，你需要尽可能的批量更新 model，否则会导致连续的多次大块 DOM 替换。\n\n```js\n// 不好，可能导致多次大块DOM渲染\nmodel.set({ name: 'Name' });\nmodel.set({ age: 28 });\n\n// 好，只有一次DOM渲染。\nmodel.set({\n    name: 'Name',\n    age: 28,\n});\n```\n\n除了这一点外，还需要考虑缩小监听范围，比如\n\n```js\n// 仅仅监听isShown字段是否被修改，忽略其他字段\nmodel.bind('change:isShown', this.display);\n```\n\n今天又遇到一个问题，先说一下背景吧。最近网站由于故障频发，要求后端必须灰度发布，就是首先发布到线上的一台机器，测试，如果没有问题再发布到所有机器上，否则回滚；而且前端和后端是分别发布，并且前端没有灰度发布。这样一来，前端需要同时兼容后端的新旧两个版本。所以前端发布时需要测试两种情况：新后端+新前端，旧后端+新前端。在新后端+新前端测试通过后，测试旧后端+新前端时，发现了`ReferenceError: XXX is not defined`这样的错误。根据 Chrome 控制台提供的信息可以看到，是由于**Backbone 的模板引擎是通过 with 实现的**。我们知道 with 有一个问题：在 with 作用域内引用对象上不存在的属性，则会报出 ReferenceError 错误。比如：\n\n```js\nvar obj = { a: 1 };\nwith (obj) {\n    console.log(a); // OK\n    console.log(unExistedAttr); // ReferenceError: unExistedAttr is not defined\n}\n```\n\n在新版本中某个 Ajax 请求中增加一个字段，假定为 f，在前端模板中通过`<% if(f){ %> ... <% } %>`引用了该字段，没有任何问题，而在旧版本后端中没有该字段，就会报`ReferenceError: f is not defined`错误。\n\n针对这个问题，一般可以给 model 设置默认属性值，但是总归还是比较麻烦的。也幸好 Chrome 的 Debug 能力很强，通过点击错误就看到了编译后的模板方法。如果使用 Firefox 浏览器，只能看到报了`ReferenceError: f is not defined`，恐怕你还很难猜测到是模板里引用了该变量导致的呢。\n\n顺便说一下，我不太喜欢 backbone 模板引擎的语法的，使用`<% %>`看起来和 html 标签太像，看起来总是觉得不太舒服。还是比较喜欢 doT 的语法风格，\n\n```html\n<div>Hi {{=it.name}}!</div>\n<div>{{=it.age || ''}}</div>\n```\n\n在编辑器中使用了语法高亮之后，看起来好整洁。\n\n以上就是我使用 Backbone 遇到的一些问题，以后有新问题再补充。\n","slug":"backbone-problems","published":1,"date":"2014-05-03T16:00:00.000Z","updated":"2018-12-07T02:54:44.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfma00016w8wk482mhpus","content":"<p>Backbone 用起来还行，但是在某些方面还是有不方便之处。比如，</p>\n<ol>\n<li>需要手动将数据填充到 DOM 中，需要手动从 DOM 中抽取数据</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手动填充数据</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$el.html(<span class=\"keyword\">this</span>.template(<span class=\"keyword\">this</span>.model.toJSON()));</span><br><span class=\"line\"><span class=\"comment\">// 手动收集用户输入的表单数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = $(<span class=\"string\">'form-id'</span>).serializeArray();</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p>需要重复绑定事件，由于其模板引擎是基于字符串的，所以在 model 更新时，需要替换掉相应 DOM 树，而不是在原有 DOM 上更新，每次 DOM 替换后，都需要重复绑定事件。当然你可以选择使用事件代理，但是并不是什么时候都可以使用事件代理的，比如你依赖的组件不支持事件代理，这时候就很郁闷啦。</p>\n</li>\n<li><p>同样由于其模板引擎是基于字符串的，所以如果你监听了 model 的 change 事件，那么你需要注意，你需要尽可能的批量更新 model，否则会导致连续的多次大块 DOM 替换。</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不好，可能导致多次大块DOM渲染</span></span><br><span class=\"line\">model.set(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Name'</span> &#125;);</span><br><span class=\"line\">model.set(&#123; <span class=\"attr\">age</span>: <span class=\"number\">28</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 好，只有一次DOM渲染。</span></span><br><span class=\"line\">model.set(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Name'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">28</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>除了这一点外，还需要考虑缩小监听范围，比如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 仅仅监听isShown字段是否被修改，忽略其他字段</span></span><br><span class=\"line\">model.bind(<span class=\"string\">'change:isShown'</span>, <span class=\"keyword\">this</span>.display);</span><br></pre></td></tr></table></figure>\n<p>今天又遇到一个问题，先说一下背景吧。最近网站由于故障频发，要求后端必须灰度发布，就是首先发布到线上的一台机器，测试，如果没有问题再发布到所有机器上，否则回滚；而且前端和后端是分别发布，并且前端没有灰度发布。这样一来，前端需要同时兼容后端的新旧两个版本。所以前端发布时需要测试两种情况：新后端+新前端，旧后端+新前端。在新后端+新前端测试通过后，测试旧后端+新前端时，发现了<code>ReferenceError: XXX is not defined</code>这样的错误。根据 Chrome 控制台提供的信息可以看到，是由于<strong>Backbone 的模板引擎是通过 with 实现的</strong>。我们知道 with 有一个问题：在 with 作用域内引用对象上不存在的属性，则会报出 ReferenceError 错误。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// OK</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(unExistedAttr); <span class=\"comment\">// ReferenceError: unExistedAttr is not defined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在新版本中某个 Ajax 请求中增加一个字段，假定为 f，在前端模板中通过<code>&lt;% if(f){ %&gt; ... &lt;% } %&gt;</code>引用了该字段，没有任何问题，而在旧版本后端中没有该字段，就会报<code>ReferenceError: f is not defined</code>错误。</p>\n<p>针对这个问题，一般可以给 model 设置默认属性值，但是总归还是比较麻烦的。也幸好 Chrome 的 Debug 能力很强，通过点击错误就看到了编译后的模板方法。如果使用 Firefox 浏览器，只能看到报了<code>ReferenceError: f is not defined</code>，恐怕你还很难猜测到是模板里引用了该变量导致的呢。</p>\n<p>顺便说一下，我不太喜欢 backbone 模板引擎的语法的，使用<code>&lt;% %&gt;</code>看起来和 html 标签太像，看起来总是觉得不太舒服。还是比较喜欢 doT 的语法风格，</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hi &#123;&#123;=it.name&#125;&#125;!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;=it.age || ''&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在编辑器中使用了语法高亮之后，看起来好整洁。</p>\n<p>以上就是我使用 Backbone 遇到的一些问题，以后有新问题再补充。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Backbone 用起来还行，但是在某些方面还是有不方便之处。比如，</p>\n<ol>\n<li>需要手动将数据填充到 DOM 中，需要手动从 DOM 中抽取数据</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手动填充数据</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$el.html(<span class=\"keyword\">this</span>.template(<span class=\"keyword\">this</span>.model.toJSON()));</span><br><span class=\"line\"><span class=\"comment\">// 手动收集用户输入的表单数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = $(<span class=\"string\">'form-id'</span>).serializeArray();</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><p>需要重复绑定事件，由于其模板引擎是基于字符串的，所以在 model 更新时，需要替换掉相应 DOM 树，而不是在原有 DOM 上更新，每次 DOM 替换后，都需要重复绑定事件。当然你可以选择使用事件代理，但是并不是什么时候都可以使用事件代理的，比如你依赖的组件不支持事件代理，这时候就很郁闷啦。</p>\n</li>\n<li><p>同样由于其模板引擎是基于字符串的，所以如果你监听了 model 的 change 事件，那么你需要注意，你需要尽可能的批量更新 model，否则会导致连续的多次大块 DOM 替换。</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不好，可能导致多次大块DOM渲染</span></span><br><span class=\"line\">model.set(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Name'</span> &#125;);</span><br><span class=\"line\">model.set(&#123; <span class=\"attr\">age</span>: <span class=\"number\">28</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 好，只有一次DOM渲染。</span></span><br><span class=\"line\">model.set(&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Name'</span>,</span><br><span class=\"line\">    age: <span class=\"number\">28</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>除了这一点外，还需要考虑缩小监听范围，比如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 仅仅监听isShown字段是否被修改，忽略其他字段</span></span><br><span class=\"line\">model.bind(<span class=\"string\">'change:isShown'</span>, <span class=\"keyword\">this</span>.display);</span><br></pre></td></tr></table></figure>\n<p>今天又遇到一个问题，先说一下背景吧。最近网站由于故障频发，要求后端必须灰度发布，就是首先发布到线上的一台机器，测试，如果没有问题再发布到所有机器上，否则回滚；而且前端和后端是分别发布，并且前端没有灰度发布。这样一来，前端需要同时兼容后端的新旧两个版本。所以前端发布时需要测试两种情况：新后端+新前端，旧后端+新前端。在新后端+新前端测试通过后，测试旧后端+新前端时，发现了<code>ReferenceError: XXX is not defined</code>这样的错误。根据 Chrome 控制台提供的信息可以看到，是由于<strong>Backbone 的模板引擎是通过 with 实现的</strong>。我们知道 with 有一个问题：在 with 作用域内引用对象上不存在的属性，则会报出 ReferenceError 错误。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">with</span> (obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// OK</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(unExistedAttr); <span class=\"comment\">// ReferenceError: unExistedAttr is not defined</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在新版本中某个 Ajax 请求中增加一个字段，假定为 f，在前端模板中通过<code>&lt;% if(f){ %&gt; ... &lt;% } %&gt;</code>引用了该字段，没有任何问题，而在旧版本后端中没有该字段，就会报<code>ReferenceError: f is not defined</code>错误。</p>\n<p>针对这个问题，一般可以给 model 设置默认属性值，但是总归还是比较麻烦的。也幸好 Chrome 的 Debug 能力很强，通过点击错误就看到了编译后的模板方法。如果使用 Firefox 浏览器，只能看到报了<code>ReferenceError: f is not defined</code>，恐怕你还很难猜测到是模板里引用了该变量导致的呢。</p>\n<p>顺便说一下，我不太喜欢 backbone 模板引擎的语法的，使用<code>&lt;% %&gt;</code>看起来和 html 标签太像，看起来总是觉得不太舒服。还是比较喜欢 doT 的语法风格，</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hi &#123;&#123;=it.name&#125;&#125;!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;=it.age || ''&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在编辑器中使用了语法高亮之后，看起来好整洁。</p>\n<p>以上就是我使用 Backbone 遇到的一些问题，以后有新问题再补充。</p>\n"},{"title":"Javascript编码规范","_content":"\n## 1 变量\n\n1. 如非必要，请不要使用全局变量；局部变量应该尽可能缩小其作用域。\n\n1. 声明全局变量必须使用`window.`前缀；声明局部变量必须使用`var`关键字。比如\n\n```js\n(function() {\n    // 局部变量\n    var config = {};\n    // 全局变量\n    window.global = {};\n})();\n```\n\n1. 同时声明多个变量时，每个变量独立申明。\n\n```js\n// 好的做法\nvar var1 = 1;\nvar var2 = 'string';\nvar var3 = 3;\n```\n\n以前我们经常看到以下写法，以下做法会导致在末尾新增变量声明或者删除第一个变量声明时不方便。\n\n```js\n// 不好的做法\nvar var1 = 1,\n    var2 = 'string',\n    var3 = 3;\n```\n\n1. 鼓励延迟初始化\n\n```js\n```\n\n1. 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如：\n\n```js\nvar isInited = false;\n```\n\n例外：在循环体内可以使用 i, j, k 等无意义但是被广泛使用的变量。\n\n## 2 常量\n\n1. 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如`Math`的常量`PI`,`SQRT1_2`等等。\n\n```js\nvar SECONDS_IN_A_DAY = 60 * 60 * 24;\n```\n\n## 3 语句\n\n### 3.1 行\n\n1. 语句必须以分号结束。\n1. 每一行要控制在 120 字符以内。\n\n### 3.2 空格\n\n1. 数值操作符(如, +/-/\\*/% 等)两边留空;\n2. 赋值操作符/等价判断符两边留一空格;\n3. for 循环条件中, 分号后留一空格;\n4. 变量声明语句, 数组值, 对象值及函数参数值中的逗号后留一空格;\n5. 行尾不要有空格;\n6. 逗号和冒号后一定要跟空格;\n7. 点号前后不要出现空格;\n8. 函数名末尾和左括号之间不要出现空格;\n\n### 3.3 空行\n\n1. 函数与函数声明之间，加一空行\n1. 逻辑上独立的代码片段之间，加一空行。\n\n### 3.4 缩进\n\n1. 缩进使用 2 个空格\n\n### 3.5 小括号\n\n1. `if/else if/while/for`条件表达式必须有小括号;\n1. 一元操作符(如 `delete`, `typeof`, `void`)或在某些关键词(如`return`, `throw`, `case`, `new`) 之后, 不要使用括号;\n\n### 3.6 大括号\n\n1. `if/else if/else/while/for`代码块中必须要有`{}`。\n   例外：函数体顶部出现的某中条件下函数直接返回的情况：`if(typeof arg !== 'string') return false;`，这时可以省略大括号并且将条件表达式和代码块写在同一行中。\n\n### 3.7 内置对象\n\n1. 禁止增加，删除或修改内置对象的方法，除非是 polyfill（在旧浏览器上实现最新的规范）。\n\n### 3.8 with\n\n1. 禁止使用`with`，除非用于接续序列化字符串。\n\n### 3.9 使用 Array/Object 直接量\n\n1. 尽量使用使用 Array/Object 直接量，避免使用 Array/Object 构造器\n\n### 3.10 字符串\n\n1. 字符串应使用单引号。\n1. 多行字符串应该使用`+`或者`Array.prototype.join`拼接字符串，避免使用`\\`拼接。\n\n## 4 注释\n\n### 4.1 注释格式\n\n1. 行级注释`// comment`主要用与代码行或代码片段\n2. 块状注释`/* comment */`主要用于函数。\n\n```js\n/*\n * @desc 记忆函数，对于耗时的运算，运算一次以后就讲结果保存起来，下次就直接返回结果。\n * @param {function} func 运算非常耗时的函数。\n * @param {object} thisObject func的主体对象\n * @param {function} serialize 参数序列化函数，将参数序列化为一个字符串。\n */\nfunction memorize(func, thisObject, serialize) {}\n```\n\n### 4.2 注释书写原则\n\n1. 在写注释之前，看看是否能够通过修改方法名，函数名让其变得见名知意，从而不需要注释。\n1. 注释应该记录代码不能明显体现出来的思路或你对代码的评价。\n1. 注释和代码一样，同样会占用屏幕空间，同样会分散阅读者的注意力，所以请保持言简意赅。\n1. 修改代码的同时，请修改注释以保证注释的有效性。\n\n### 4.3 注释标记\n\n1. TODO 还没有完成的逻辑\n1. FIXME 有错误的逻辑\n\n## 5 函数\n\n1. 函数行数不得超过 40 行，否则考虑拆分成小的函数。\n\n1. 函数体内变量声明应尽可能集中在顶部。\n\n1. 不要在块作用域中声明函数\n   不要写成:\n\n```js\nif (x) {\n    function foo() {}\n}\n```\n\n虽然有很多 JS 引擎都支持块做域内声明函数，但它不是 ECMAScript 规范(见[ECMA-262](http://www.ecma-international.org/publications/standards/Ecma-262.htm), 第 13 和 14 条)。各个浏览器的实现可能不兼容, 也可能与未来的 ECMAScript 草案相违背。ECMAScript 只允许在脚本的根语句或函数中声明函数，如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量:\n\n```js\nif (x) {\n    var foo = function() {};\n}\n```\n\n1. 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如：\n\n```js\nfunction returnTrue() {\n    return true;\n}\n```\n\n1. Getter/Setter 命名\n   这里单独说明 Getter/Setter 命名规范，一般情况下不需要使用 Getter/Setter 方法，直接暴露相应地对象属性即可。如确有必要，请使用 getXxx 和 setXxx 命名，对于 boolean 值，可以使用 isXxx/hasXxx/canDoXxx 等命名。\n\n## 6 模块\n\n1. 建议按照 CMD 或 AMD 规范实现模块，并使用 seajs 或 requirejs 等库加载或管理模块。\n\n```js\ndefine(function(require, exports, module) {\n    var $ = require('$');\n    exports.init = function() {\n        // do something\n    };\n});\n```\n\n## 7 文件\n\n1. 命名规范：命名应能表达该文件的作用。全部小写，单词以连字符分隔，比如`category-manager.js`。\n1. 编码规范：统一使用 UTF-8（无 BOM）格式。\n\n## 8 HTML，CSS 和 Javascript\n\n1. HTML 中引用 javascript 文件时，建议去掉 type 属性。只有当 script 标签存放的不是 javascript 时才需要特别声明。\n\n```html\n<script src=\"path/to/js.js\"></script>\n<script>\n    $(function() {\n        // do something\n    });\n</script>\n<script type=\"text/template\">\n    <div>{i18n.noData}</div>\n</script>\n```\n\n##终极条款\n\n1. 在修改别人的代码时，应该先学习别人的编码规范，并遵守该规范，如果有的话。\n\n##参考\n\n1. [Google JavaScript Style Guide](http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml)\n   http://codeguide.bootcss.com/\n","source":"_posts/2014-06-01-javascript-code-guide.md","raw":"---\ntitle: Javascript编码规范\n---\n\n## 1 变量\n\n1. 如非必要，请不要使用全局变量；局部变量应该尽可能缩小其作用域。\n\n1. 声明全局变量必须使用`window.`前缀；声明局部变量必须使用`var`关键字。比如\n\n```js\n(function() {\n    // 局部变量\n    var config = {};\n    // 全局变量\n    window.global = {};\n})();\n```\n\n1. 同时声明多个变量时，每个变量独立申明。\n\n```js\n// 好的做法\nvar var1 = 1;\nvar var2 = 'string';\nvar var3 = 3;\n```\n\n以前我们经常看到以下写法，以下做法会导致在末尾新增变量声明或者删除第一个变量声明时不方便。\n\n```js\n// 不好的做法\nvar var1 = 1,\n    var2 = 'string',\n    var3 = 3;\n```\n\n1. 鼓励延迟初始化\n\n```js\n```\n\n1. 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如：\n\n```js\nvar isInited = false;\n```\n\n例外：在循环体内可以使用 i, j, k 等无意义但是被广泛使用的变量。\n\n## 2 常量\n\n1. 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如`Math`的常量`PI`,`SQRT1_2`等等。\n\n```js\nvar SECONDS_IN_A_DAY = 60 * 60 * 24;\n```\n\n## 3 语句\n\n### 3.1 行\n\n1. 语句必须以分号结束。\n1. 每一行要控制在 120 字符以内。\n\n### 3.2 空格\n\n1. 数值操作符(如, +/-/\\*/% 等)两边留空;\n2. 赋值操作符/等价判断符两边留一空格;\n3. for 循环条件中, 分号后留一空格;\n4. 变量声明语句, 数组值, 对象值及函数参数值中的逗号后留一空格;\n5. 行尾不要有空格;\n6. 逗号和冒号后一定要跟空格;\n7. 点号前后不要出现空格;\n8. 函数名末尾和左括号之间不要出现空格;\n\n### 3.3 空行\n\n1. 函数与函数声明之间，加一空行\n1. 逻辑上独立的代码片段之间，加一空行。\n\n### 3.4 缩进\n\n1. 缩进使用 2 个空格\n\n### 3.5 小括号\n\n1. `if/else if/while/for`条件表达式必须有小括号;\n1. 一元操作符(如 `delete`, `typeof`, `void`)或在某些关键词(如`return`, `throw`, `case`, `new`) 之后, 不要使用括号;\n\n### 3.6 大括号\n\n1. `if/else if/else/while/for`代码块中必须要有`{}`。\n   例外：函数体顶部出现的某中条件下函数直接返回的情况：`if(typeof arg !== 'string') return false;`，这时可以省略大括号并且将条件表达式和代码块写在同一行中。\n\n### 3.7 内置对象\n\n1. 禁止增加，删除或修改内置对象的方法，除非是 polyfill（在旧浏览器上实现最新的规范）。\n\n### 3.8 with\n\n1. 禁止使用`with`，除非用于接续序列化字符串。\n\n### 3.9 使用 Array/Object 直接量\n\n1. 尽量使用使用 Array/Object 直接量，避免使用 Array/Object 构造器\n\n### 3.10 字符串\n\n1. 字符串应使用单引号。\n1. 多行字符串应该使用`+`或者`Array.prototype.join`拼接字符串，避免使用`\\`拼接。\n\n## 4 注释\n\n### 4.1 注释格式\n\n1. 行级注释`// comment`主要用与代码行或代码片段\n2. 块状注释`/* comment */`主要用于函数。\n\n```js\n/*\n * @desc 记忆函数，对于耗时的运算，运算一次以后就讲结果保存起来，下次就直接返回结果。\n * @param {function} func 运算非常耗时的函数。\n * @param {object} thisObject func的主体对象\n * @param {function} serialize 参数序列化函数，将参数序列化为一个字符串。\n */\nfunction memorize(func, thisObject, serialize) {}\n```\n\n### 4.2 注释书写原则\n\n1. 在写注释之前，看看是否能够通过修改方法名，函数名让其变得见名知意，从而不需要注释。\n1. 注释应该记录代码不能明显体现出来的思路或你对代码的评价。\n1. 注释和代码一样，同样会占用屏幕空间，同样会分散阅读者的注意力，所以请保持言简意赅。\n1. 修改代码的同时，请修改注释以保证注释的有效性。\n\n### 4.3 注释标记\n\n1. TODO 还没有完成的逻辑\n1. FIXME 有错误的逻辑\n\n## 5 函数\n\n1. 函数行数不得超过 40 行，否则考虑拆分成小的函数。\n\n1. 函数体内变量声明应尽可能集中在顶部。\n\n1. 不要在块作用域中声明函数\n   不要写成:\n\n```js\nif (x) {\n    function foo() {}\n}\n```\n\n虽然有很多 JS 引擎都支持块做域内声明函数，但它不是 ECMAScript 规范(见[ECMA-262](http://www.ecma-international.org/publications/standards/Ecma-262.htm), 第 13 和 14 条)。各个浏览器的实现可能不兼容, 也可能与未来的 ECMAScript 草案相违背。ECMAScript 只允许在脚本的根语句或函数中声明函数，如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量:\n\n```js\nif (x) {\n    var foo = function() {};\n}\n```\n\n1. 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如：\n\n```js\nfunction returnTrue() {\n    return true;\n}\n```\n\n1. Getter/Setter 命名\n   这里单独说明 Getter/Setter 命名规范，一般情况下不需要使用 Getter/Setter 方法，直接暴露相应地对象属性即可。如确有必要，请使用 getXxx 和 setXxx 命名，对于 boolean 值，可以使用 isXxx/hasXxx/canDoXxx 等命名。\n\n## 6 模块\n\n1. 建议按照 CMD 或 AMD 规范实现模块，并使用 seajs 或 requirejs 等库加载或管理模块。\n\n```js\ndefine(function(require, exports, module) {\n    var $ = require('$');\n    exports.init = function() {\n        // do something\n    };\n});\n```\n\n## 7 文件\n\n1. 命名规范：命名应能表达该文件的作用。全部小写，单词以连字符分隔，比如`category-manager.js`。\n1. 编码规范：统一使用 UTF-8（无 BOM）格式。\n\n## 8 HTML，CSS 和 Javascript\n\n1. HTML 中引用 javascript 文件时，建议去掉 type 属性。只有当 script 标签存放的不是 javascript 时才需要特别声明。\n\n```html\n<script src=\"path/to/js.js\"></script>\n<script>\n    $(function() {\n        // do something\n    });\n</script>\n<script type=\"text/template\">\n    <div>{i18n.noData}</div>\n</script>\n```\n\n##终极条款\n\n1. 在修改别人的代码时，应该先学习别人的编码规范，并遵守该规范，如果有的话。\n\n##参考\n\n1. [Google JavaScript Style Guide](http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml)\n   http://codeguide.bootcss.com/\n","slug":"javascript-code-guide","published":1,"date":"2014-05-31T16:00:00.000Z","updated":"2018-12-07T02:52:25.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfma00017w8wkq6ev46cz","content":"<h2 id=\"1-变量\"><a href=\"#1-变量\" class=\"headerlink\" title=\"1 变量\"></a>1 变量</h2><ol>\n<li><p>如非必要，请不要使用全局变量；局部变量应该尽可能缩小其作用域。</p>\n</li>\n<li><p>声明全局变量必须使用<code>window.</code>前缀；声明局部变量必须使用<code>var</code>关键字。比如</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> config = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 全局变量</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.global = &#123;&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ol>\n<li>同时声明多个变量时，每个变量独立申明。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 好的做法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> var1 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> var2 = <span class=\"string\">'string'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> var3 = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p>以前我们经常看到以下写法，以下做法会导致在末尾新增变量声明或者删除第一个变量声明时不方便。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不好的做法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> var1 = <span class=\"number\">1</span>,</span><br><span class=\"line\">    var2 = <span class=\"string\">'string'</span>,</span><br><span class=\"line\">    var3 = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>鼓励延迟初始化</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> isInited = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>例外：在循环体内可以使用 i, j, k 等无意义但是被广泛使用的变量。</p>\n<h2 id=\"2-常量\"><a href=\"#2-常量\" class=\"headerlink\" title=\"2 常量\"></a>2 常量</h2><ol>\n<li>命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如<code>Math</code>的常量<code>PI</code>,<code>SQRT1_2</code>等等。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> SECONDS_IN_A_DAY = <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-语句\"><a href=\"#3-语句\" class=\"headerlink\" title=\"3 语句\"></a>3 语句</h2><h3 id=\"3-1-行\"><a href=\"#3-1-行\" class=\"headerlink\" title=\"3.1 行\"></a>3.1 行</h3><ol>\n<li>语句必须以分号结束。</li>\n<li>每一行要控制在 120 字符以内。</li>\n</ol>\n<h3 id=\"3-2-空格\"><a href=\"#3-2-空格\" class=\"headerlink\" title=\"3.2 空格\"></a>3.2 空格</h3><ol>\n<li>数值操作符(如, +/-/*/% 等)两边留空;</li>\n<li>赋值操作符/等价判断符两边留一空格;</li>\n<li>for 循环条件中, 分号后留一空格;</li>\n<li>变量声明语句, 数组值, 对象值及函数参数值中的逗号后留一空格;</li>\n<li>行尾不要有空格;</li>\n<li>逗号和冒号后一定要跟空格;</li>\n<li>点号前后不要出现空格;</li>\n<li>函数名末尾和左括号之间不要出现空格;</li>\n</ol>\n<h3 id=\"3-3-空行\"><a href=\"#3-3-空行\" class=\"headerlink\" title=\"3.3 空行\"></a>3.3 空行</h3><ol>\n<li>函数与函数声明之间，加一空行</li>\n<li>逻辑上独立的代码片段之间，加一空行。</li>\n</ol>\n<h3 id=\"3-4-缩进\"><a href=\"#3-4-缩进\" class=\"headerlink\" title=\"3.4 缩进\"></a>3.4 缩进</h3><ol>\n<li>缩进使用 2 个空格</li>\n</ol>\n<h3 id=\"3-5-小括号\"><a href=\"#3-5-小括号\" class=\"headerlink\" title=\"3.5 小括号\"></a>3.5 小括号</h3><ol>\n<li><code>if/else if/while/for</code>条件表达式必须有小括号;</li>\n<li>一元操作符(如 <code>delete</code>, <code>typeof</code>, <code>void</code>)或在某些关键词(如<code>return</code>, <code>throw</code>, <code>case</code>, <code>new</code>) 之后, 不要使用括号;</li>\n</ol>\n<h3 id=\"3-6-大括号\"><a href=\"#3-6-大括号\" class=\"headerlink\" title=\"3.6 大括号\"></a>3.6 大括号</h3><ol>\n<li><code>if/else if/else/while/for</code>代码块中必须要有<code>{}</code>。<br>例外：函数体顶部出现的某中条件下函数直接返回的情况：<code>if(typeof arg !== &#39;string&#39;) return false;</code>，这时可以省略大括号并且将条件表达式和代码块写在同一行中。</li>\n</ol>\n<h3 id=\"3-7-内置对象\"><a href=\"#3-7-内置对象\" class=\"headerlink\" title=\"3.7 内置对象\"></a>3.7 内置对象</h3><ol>\n<li>禁止增加，删除或修改内置对象的方法，除非是 polyfill（在旧浏览器上实现最新的规范）。</li>\n</ol>\n<h3 id=\"3-8-with\"><a href=\"#3-8-with\" class=\"headerlink\" title=\"3.8 with\"></a>3.8 with</h3><ol>\n<li>禁止使用<code>with</code>，除非用于接续序列化字符串。</li>\n</ol>\n<h3 id=\"3-9-使用-Array-Object-直接量\"><a href=\"#3-9-使用-Array-Object-直接量\" class=\"headerlink\" title=\"3.9 使用 Array/Object 直接量\"></a>3.9 使用 Array/Object 直接量</h3><ol>\n<li>尽量使用使用 Array/Object 直接量，避免使用 Array/Object 构造器</li>\n</ol>\n<h3 id=\"3-10-字符串\"><a href=\"#3-10-字符串\" class=\"headerlink\" title=\"3.10 字符串\"></a>3.10 字符串</h3><ol>\n<li>字符串应使用单引号。</li>\n<li>多行字符串应该使用<code>+</code>或者<code>Array.prototype.join</code>拼接字符串，避免使用<code>\\</code>拼接。</li>\n</ol>\n<h2 id=\"4-注释\"><a href=\"#4-注释\" class=\"headerlink\" title=\"4 注释\"></a>4 注释</h2><h3 id=\"4-1-注释格式\"><a href=\"#4-1-注释格式\" class=\"headerlink\" title=\"4.1 注释格式\"></a>4.1 注释格式</h3><ol>\n<li>行级注释<code>// comment</code>主要用与代码行或代码片段</li>\n<li>块状注释<code>/* comment */</code>主要用于函数。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @desc 记忆函数，对于耗时的运算，运算一次以后就讲结果保存起来，下次就直接返回结果。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; func 运算非常耗时的函数。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;object&#125; thisObject func的主体对象</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; serialize 参数序列化函数，将参数序列化为一个字符串。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memorize</span>(<span class=\"params\">func, thisObject, serialize</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-注释书写原则\"><a href=\"#4-2-注释书写原则\" class=\"headerlink\" title=\"4.2 注释书写原则\"></a>4.2 注释书写原则</h3><ol>\n<li>在写注释之前，看看是否能够通过修改方法名，函数名让其变得见名知意，从而不需要注释。</li>\n<li>注释应该记录代码不能明显体现出来的思路或你对代码的评价。</li>\n<li>注释和代码一样，同样会占用屏幕空间，同样会分散阅读者的注意力，所以请保持言简意赅。</li>\n<li>修改代码的同时，请修改注释以保证注释的有效性。</li>\n</ol>\n<h3 id=\"4-3-注释标记\"><a href=\"#4-3-注释标记\" class=\"headerlink\" title=\"4.3 注释标记\"></a>4.3 注释标记</h3><ol>\n<li>TODO 还没有完成的逻辑</li>\n<li>FIXME 有错误的逻辑</li>\n</ol>\n<h2 id=\"5-函数\"><a href=\"#5-函数\" class=\"headerlink\" title=\"5 函数\"></a>5 函数</h2><ol>\n<li><p>函数行数不得超过 40 行，否则考虑拆分成小的函数。</p>\n</li>\n<li><p>函数体内变量声明应尽可能集中在顶部。</p>\n</li>\n<li><p>不要在块作用域中声明函数<br>不要写成:</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然有很多 JS 引擎都支持块做域内声明函数，但它不是 ECMAScript 规范(见<a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\" rel=\"noopener\">ECMA-262</a>, 第 13 和 14 条)。各个浏览器的实现可能不兼容, 也可能与未来的 ECMAScript 草案相违背。ECMAScript 只允许在脚本的根语句或函数中声明函数，如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">returnTrue</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Getter/Setter 命名<br>这里单独说明 Getter/Setter 命名规范，一般情况下不需要使用 Getter/Setter 方法，直接暴露相应地对象属性即可。如确有必要，请使用 getXxx 和 setXxx 命名，对于 boolean 值，可以使用 isXxx/hasXxx/canDoXxx 等命名。</li>\n</ol>\n<h2 id=\"6-模块\"><a href=\"#6-模块\" class=\"headerlink\" title=\"6 模块\"></a>6 模块</h2><ol>\n<li>建议按照 CMD 或 AMD 规范实现模块，并使用 seajs 或 requirejs 等库加载或管理模块。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'$'</span>);</span><br><span class=\"line\">    exports.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-文件\"><a href=\"#7-文件\" class=\"headerlink\" title=\"7 文件\"></a>7 文件</h2><ol>\n<li>命名规范：命名应能表达该文件的作用。全部小写，单词以连字符分隔，比如<code>category-manager.js</code>。</li>\n<li>编码规范：统一使用 UTF-8（无 BOM）格式。</li>\n</ol>\n<h2 id=\"8-HTML，CSS-和-Javascript\"><a href=\"#8-HTML，CSS-和-Javascript\" class=\"headerlink\" title=\"8 HTML，CSS 和 Javascript\"></a>8 HTML，CSS 和 Javascript</h2><ol>\n<li>HTML 中引用 javascript 文件时，建议去掉 type 属性。只有当 script 标签存放的不是 javascript 时才需要特别声明。</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/js.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    $(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// do something</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/template\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;i18n.noData&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>##终极条款</p>\n<ol>\n<li>在修改别人的代码时，应该先学习别人的编码规范，并遵守该规范，如果有的话。</li>\n</ol>\n<p>##参考</p>\n<ol>\n<li><a href=\"http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml\" target=\"_blank\" rel=\"noopener\">Google JavaScript Style Guide</a><br><a href=\"http://codeguide.bootcss.com/\" target=\"_blank\" rel=\"noopener\">http://codeguide.bootcss.com/</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-变量\"><a href=\"#1-变量\" class=\"headerlink\" title=\"1 变量\"></a>1 变量</h2><ol>\n<li><p>如非必要，请不要使用全局变量；局部变量应该尽可能缩小其作用域。</p>\n</li>\n<li><p>声明全局变量必须使用<code>window.</code>前缀；声明局部变量必须使用<code>var</code>关键字。比如</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> config = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 全局变量</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.global = &#123;&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ol>\n<li>同时声明多个变量时，每个变量独立申明。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 好的做法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> var1 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> var2 = <span class=\"string\">'string'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> var3 = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<p>以前我们经常看到以下写法，以下做法会导致在末尾新增变量声明或者删除第一个变量声明时不方便。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不好的做法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> var1 = <span class=\"number\">1</span>,</span><br><span class=\"line\">    var2 = <span class=\"string\">'string'</span>,</span><br><span class=\"line\">    var3 = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>鼓励延迟初始化</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1. 命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> isInited = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<p>例外：在循环体内可以使用 i, j, k 等无意义但是被广泛使用的变量。</p>\n<h2 id=\"2-常量\"><a href=\"#2-常量\" class=\"headerlink\" title=\"2 常量\"></a>2 常量</h2><ol>\n<li>命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如<code>Math</code>的常量<code>PI</code>,<code>SQRT1_2</code>等等。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> SECONDS_IN_A_DAY = <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">24</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-语句\"><a href=\"#3-语句\" class=\"headerlink\" title=\"3 语句\"></a>3 语句</h2><h3 id=\"3-1-行\"><a href=\"#3-1-行\" class=\"headerlink\" title=\"3.1 行\"></a>3.1 行</h3><ol>\n<li>语句必须以分号结束。</li>\n<li>每一行要控制在 120 字符以内。</li>\n</ol>\n<h3 id=\"3-2-空格\"><a href=\"#3-2-空格\" class=\"headerlink\" title=\"3.2 空格\"></a>3.2 空格</h3><ol>\n<li>数值操作符(如, +/-/*/% 等)两边留空;</li>\n<li>赋值操作符/等价判断符两边留一空格;</li>\n<li>for 循环条件中, 分号后留一空格;</li>\n<li>变量声明语句, 数组值, 对象值及函数参数值中的逗号后留一空格;</li>\n<li>行尾不要有空格;</li>\n<li>逗号和冒号后一定要跟空格;</li>\n<li>点号前后不要出现空格;</li>\n<li>函数名末尾和左括号之间不要出现空格;</li>\n</ol>\n<h3 id=\"3-3-空行\"><a href=\"#3-3-空行\" class=\"headerlink\" title=\"3.3 空行\"></a>3.3 空行</h3><ol>\n<li>函数与函数声明之间，加一空行</li>\n<li>逻辑上独立的代码片段之间，加一空行。</li>\n</ol>\n<h3 id=\"3-4-缩进\"><a href=\"#3-4-缩进\" class=\"headerlink\" title=\"3.4 缩进\"></a>3.4 缩进</h3><ol>\n<li>缩进使用 2 个空格</li>\n</ol>\n<h3 id=\"3-5-小括号\"><a href=\"#3-5-小括号\" class=\"headerlink\" title=\"3.5 小括号\"></a>3.5 小括号</h3><ol>\n<li><code>if/else if/while/for</code>条件表达式必须有小括号;</li>\n<li>一元操作符(如 <code>delete</code>, <code>typeof</code>, <code>void</code>)或在某些关键词(如<code>return</code>, <code>throw</code>, <code>case</code>, <code>new</code>) 之后, 不要使用括号;</li>\n</ol>\n<h3 id=\"3-6-大括号\"><a href=\"#3-6-大括号\" class=\"headerlink\" title=\"3.6 大括号\"></a>3.6 大括号</h3><ol>\n<li><code>if/else if/else/while/for</code>代码块中必须要有<code>{}</code>。<br>例外：函数体顶部出现的某中条件下函数直接返回的情况：<code>if(typeof arg !== &#39;string&#39;) return false;</code>，这时可以省略大括号并且将条件表达式和代码块写在同一行中。</li>\n</ol>\n<h3 id=\"3-7-内置对象\"><a href=\"#3-7-内置对象\" class=\"headerlink\" title=\"3.7 内置对象\"></a>3.7 内置对象</h3><ol>\n<li>禁止增加，删除或修改内置对象的方法，除非是 polyfill（在旧浏览器上实现最新的规范）。</li>\n</ol>\n<h3 id=\"3-8-with\"><a href=\"#3-8-with\" class=\"headerlink\" title=\"3.8 with\"></a>3.8 with</h3><ol>\n<li>禁止使用<code>with</code>，除非用于接续序列化字符串。</li>\n</ol>\n<h3 id=\"3-9-使用-Array-Object-直接量\"><a href=\"#3-9-使用-Array-Object-直接量\" class=\"headerlink\" title=\"3.9 使用 Array/Object 直接量\"></a>3.9 使用 Array/Object 直接量</h3><ol>\n<li>尽量使用使用 Array/Object 直接量，避免使用 Array/Object 构造器</li>\n</ol>\n<h3 id=\"3-10-字符串\"><a href=\"#3-10-字符串\" class=\"headerlink\" title=\"3.10 字符串\"></a>3.10 字符串</h3><ol>\n<li>字符串应使用单引号。</li>\n<li>多行字符串应该使用<code>+</code>或者<code>Array.prototype.join</code>拼接字符串，避免使用<code>\\</code>拼接。</li>\n</ol>\n<h2 id=\"4-注释\"><a href=\"#4-注释\" class=\"headerlink\" title=\"4 注释\"></a>4 注释</h2><h3 id=\"4-1-注释格式\"><a href=\"#4-1-注释格式\" class=\"headerlink\" title=\"4.1 注释格式\"></a>4.1 注释格式</h3><ol>\n<li>行级注释<code>// comment</code>主要用与代码行或代码片段</li>\n<li>块状注释<code>/* comment */</code>主要用于函数。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * @desc 记忆函数，对于耗时的运算，运算一次以后就讲结果保存起来，下次就直接返回结果。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; func 运算非常耗时的函数。</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;object&#125; thisObject func的主体对象</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;function&#125; serialize 参数序列化函数，将参数序列化为一个字符串。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memorize</span>(<span class=\"params\">func, thisObject, serialize</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-注释书写原则\"><a href=\"#4-2-注释书写原则\" class=\"headerlink\" title=\"4.2 注释书写原则\"></a>4.2 注释书写原则</h3><ol>\n<li>在写注释之前，看看是否能够通过修改方法名，函数名让其变得见名知意，从而不需要注释。</li>\n<li>注释应该记录代码不能明显体现出来的思路或你对代码的评价。</li>\n<li>注释和代码一样，同样会占用屏幕空间，同样会分散阅读者的注意力，所以请保持言简意赅。</li>\n<li>修改代码的同时，请修改注释以保证注释的有效性。</li>\n</ol>\n<h3 id=\"4-3-注释标记\"><a href=\"#4-3-注释标记\" class=\"headerlink\" title=\"4.3 注释标记\"></a>4.3 注释标记</h3><ol>\n<li>TODO 还没有完成的逻辑</li>\n<li>FIXME 有错误的逻辑</li>\n</ol>\n<h2 id=\"5-函数\"><a href=\"#5-函数\" class=\"headerlink\" title=\"5 函数\"></a>5 函数</h2><ol>\n<li><p>函数行数不得超过 40 行，否则考虑拆分成小的函数。</p>\n</li>\n<li><p>函数体内变量声明应尽可能集中在顶部。</p>\n</li>\n<li><p>不要在块作用域中声明函数<br>不要写成:</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x) &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然有很多 JS 引擎都支持块做域内声明函数，但它不是 ECMAScript 规范(见<a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\" rel=\"noopener\">ECMA-262</a>, 第 13 和 14 条)。各个浏览器的实现可能不兼容, 也可能与未来的 ECMAScript 草案相违背。ECMAScript 只允许在脚本的根语句或函数中声明函数，如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>命名规范：命名应能够表达该变量的含义，首字母小写的驼峰格式。比如：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">returnTrue</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>Getter/Setter 命名<br>这里单独说明 Getter/Setter 命名规范，一般情况下不需要使用 Getter/Setter 方法，直接暴露相应地对象属性即可。如确有必要，请使用 getXxx 和 setXxx 命名，对于 boolean 值，可以使用 isXxx/hasXxx/canDoXxx 等命名。</li>\n</ol>\n<h2 id=\"6-模块\"><a href=\"#6-模块\" class=\"headerlink\" title=\"6 模块\"></a>6 模块</h2><ol>\n<li>建议按照 CMD 或 AMD 规范实现模块，并使用 seajs 或 requirejs 等库加载或管理模块。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'$'</span>);</span><br><span class=\"line\">    exports.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-文件\"><a href=\"#7-文件\" class=\"headerlink\" title=\"7 文件\"></a>7 文件</h2><ol>\n<li>命名规范：命名应能表达该文件的作用。全部小写，单词以连字符分隔，比如<code>category-manager.js</code>。</li>\n<li>编码规范：统一使用 UTF-8（无 BOM）格式。</li>\n</ol>\n<h2 id=\"8-HTML，CSS-和-Javascript\"><a href=\"#8-HTML，CSS-和-Javascript\" class=\"headerlink\" title=\"8 HTML，CSS 和 Javascript\"></a>8 HTML，CSS 和 Javascript</h2><ol>\n<li>HTML 中引用 javascript 文件时，建议去掉 type 属性。只有当 script 标签存放的不是 javascript 时才需要特别声明。</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"path/to/js.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    $(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"comment\">// do something</span></span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/template\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;i18n.noData&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>##终极条款</p>\n<ol>\n<li>在修改别人的代码时，应该先学习别人的编码规范，并遵守该规范，如果有的话。</li>\n</ol>\n<p>##参考</p>\n<ol>\n<li><a href=\"http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml\" target=\"_blank\" rel=\"noopener\">Google JavaScript Style Guide</a><br><a href=\"http://codeguide.bootcss.com/\" target=\"_blank\" rel=\"noopener\">http://codeguide.bootcss.com/</a></li>\n</ol>\n"},{"title":"设计规范","_content":"\n一. 命名规则 !important\n\n<div id=\"list-inbox\" class=\"mail-list\">list information</div>  //正确\n<div id=\"listInbox\" class=\"mailList\">list information</div>  //错误\nid 与 class 均采用中划线命名法，不得驼峰命名法\n二. 合理命名\n<div id=\"sidebar\">side information</div>  //推荐\n<div id=\"col-left\">side information</div>  //不推荐\n根据内容而不是表象给 id 和 class 合理命名\n三. 标签语义化\n<em>这里是强调文本</em>  //用em标签标识强调文本\n<strong>这里是重点强调文本</strong>  //用strong标签标识重点强调文本\n根据内容选择合适的html标签，尽量避免写入无意义标签，尝试使用微格式(MicroFormats)\n人可以通过视觉的划分判断内容的语义,搜索引擎看到的只是代码。搜索引擎只能通过标签来判断内容的语义。页面的很大一部分流量是来自搜索引擎的，所以我们要使页面尽可能地对搜索引擎友好\nh标签的语意是标题，搜索引擎对这个标签比较敏感，特别是h1,和h2。一个语义良好的页面，h标签应该是完整有序没有断层的。也就是说，要h1,h2,h3,h4这样推下来，不要h1,h3,h4，漏掉h2。一个结构良好的网页，h标签可以组织起一个网页的大纲\n四. 良好的文档结构\n清晰合理的文档结构，对SEO更友好，方便行为层操控DOM结构，使之易于维护、扩展和阅读\n五. 分离的思想\n<div style=\"padding:10px\">sidebar information </div>  //直接插入样式，不推荐\n<div onclick=\"showMenu()\">sidebar information </div>  //直接注册事件，不推荐\n结构层、表现层和行为层的分离，尽可能的不要在 HTML 结构标签中直接插入样式或者 JavaScript 脚本代码\n\n书写规范\n一. 标签的元素和属性名都必须小写 !important\n备注：\n\n1. IE 另存为的 html 文件，会把标签全改为大写，这是不符合标准的，不能直接复制粘贴复用。如有这方面的需要，请用 Firefox 保存，或者用工具(比如:dreamwaver)将标签全部转为小写。\n2. 另一个值得注意的是，通过内联方式(<a href=\"#\" onmouseover=\"\" >link</a>)注册的事件，事件名必须全部小写。\n   <INPUT NAME=\"inputX\" VALUE=\"\" onMouseOver=\"fn()\" /> //错误\n   <input name=\"inputX\" value=\"\" onmouseover=\"fn()\" /> //正确\n   二. 标签必须关闭 !important\n   备注：自封闭的标签必须自封闭，如：<br />, <input />等，所有自封闭的 HTML 标签请点击 这里\n   备注：标签未关闭的错误常见于模版输出和挖天窗的过程中，请相关人员要特别注意分析好页面结构\n   <input name=\"inputX\" value=\"\"> //错误\n   <input name=\"inputX\" value=\"\"></input> //错误\n   <input name=\"inputX\" value=\"\" /> //正确 (最后的斜杠“/”与前面的字符串之间要有一个空格)\n   三. 标签必须正确嵌套 !important\n   <div><p>text</div></p> //错误\n   <div><p>text</p></div> //正确\n   扩展阅读: HTML 标签嵌套规则\n   四. 标签属性必须使用双引号 !important\n   <input name='a' id=b value= /> //错误\n   <input name=\"a\" id=\"b\" value=\"\" /> //正确\n   五. 属性值不能简写，必须是名值对的形式(name=”value”) !important\n   selected=\"selected\" //类似的还有 disabled , checked , readonly , noresize\n   六. 自定义属性，必须以 data-开头(data-name=”value”)，多个单词用‘-’连接 !important\n   <li name=\"a\" value=\"b\" fid=\"1234\" country-code=\"cn\">context</li> //错误\n   <li data-name=\"a\" data-value=\"b\" data-fid=\"1234\" data-country-code=\"cn\">context</li> //正确\n   使用 data-开头的自定义属性，是 HTML5 新增加的功能，可以使用更多 HTML5 的新特性\n   HTML5 JavaScript API 提供了访问这些自定义属性的方法（除了 setAttribute/getAttribute 以外）DOM.dataset 点击查看\n   七. 使用自定义属性(data-role=\"xxx\")代替 class 做“js 钩子” !important\n   <li class=\"J-item\">context</li> //不推荐\n   <li data-role=\"item\">context</li> //推荐使用\n   使用 data-role=\"xxx\"来代替原来的 class=\"J-xxx\"可以更好地将 css 与 js 分离，利于发展维护\n   八. 属性值特别是依赖后端输出的属性值必须经过 html encode，以防止 XSS 攻击 !important\n   其中 a 标签 href 属性 PATH 部分必须经过 encode.\n   前端操作 Cookie 时，涉及用户输入数据的部分也要特别注意这一点，比如: 网站中的 Recent Search 记录\n   安全输出 velocity 变量的宏请猛击这里\n   九. 标签内容，服务器端输出的，根据情况确定是否需要经过 encode !important\n   纯文本，必须。比如:链接文本\n   包含 html 输出时不能编码的，要有意识地联系工程师做好后端输入过滤。比如：富媒体编辑器内容\n   安全输出 velocity 变量的宏请猛击这里\n   十. 特殊字符尽量用相应的符号实体代替\n   特殊字符 对应的符号实体\n   & &amp;\n   < &lt; > &gt;\n   空格 &nbsp;\n   查看更多？猛击这里下载整理的电子书\n   十一. 关于 table 标签\n   table 标签中，如果使用 thead、tfoot 以及 tbody 元素之一，就必须使用全部的元素，它们的出现次序是：thead、tfoot、tbody 。\n   扩展阅读: 标准化 table 标签\n   十二. 代码缩进\n   在书写代码的时候, 缩进并不会影响页面的最终表现, 但使用适当的缩进能使代码更具可读性, 我们推荐的缩进方法是当你开始一个新的元素时缩进一个 Tab 位(按一次 Tab 键——4 个空格的长度). 另外, 记得, 关闭元素的标签与开始标签对齐.示例：\n   <div class=\"container\">\n   hello, Alibaba!\n   </div>\n\n注释规范\n如非必要，HTML 代码中不允许出现 HTML 注释（系统自动生成的除外），用 velocity 的注释代替。\n","source":"_posts/2014-06-05-html-code-guide.md","raw":"---\ntitle: 设计规范\n---\n\n一. 命名规则 !important\n\n<div id=\"list-inbox\" class=\"mail-list\">list information</div>  //正确\n<div id=\"listInbox\" class=\"mailList\">list information</div>  //错误\nid 与 class 均采用中划线命名法，不得驼峰命名法\n二. 合理命名\n<div id=\"sidebar\">side information</div>  //推荐\n<div id=\"col-left\">side information</div>  //不推荐\n根据内容而不是表象给 id 和 class 合理命名\n三. 标签语义化\n<em>这里是强调文本</em>  //用em标签标识强调文本\n<strong>这里是重点强调文本</strong>  //用strong标签标识重点强调文本\n根据内容选择合适的html标签，尽量避免写入无意义标签，尝试使用微格式(MicroFormats)\n人可以通过视觉的划分判断内容的语义,搜索引擎看到的只是代码。搜索引擎只能通过标签来判断内容的语义。页面的很大一部分流量是来自搜索引擎的，所以我们要使页面尽可能地对搜索引擎友好\nh标签的语意是标题，搜索引擎对这个标签比较敏感，特别是h1,和h2。一个语义良好的页面，h标签应该是完整有序没有断层的。也就是说，要h1,h2,h3,h4这样推下来，不要h1,h3,h4，漏掉h2。一个结构良好的网页，h标签可以组织起一个网页的大纲\n四. 良好的文档结构\n清晰合理的文档结构，对SEO更友好，方便行为层操控DOM结构，使之易于维护、扩展和阅读\n五. 分离的思想\n<div style=\"padding:10px\">sidebar information </div>  //直接插入样式，不推荐\n<div onclick=\"showMenu()\">sidebar information </div>  //直接注册事件，不推荐\n结构层、表现层和行为层的分离，尽可能的不要在 HTML 结构标签中直接插入样式或者 JavaScript 脚本代码\n\n书写规范\n一. 标签的元素和属性名都必须小写 !important\n备注：\n\n1. IE 另存为的 html 文件，会把标签全改为大写，这是不符合标准的，不能直接复制粘贴复用。如有这方面的需要，请用 Firefox 保存，或者用工具(比如:dreamwaver)将标签全部转为小写。\n2. 另一个值得注意的是，通过内联方式(<a href=\"#\" onmouseover=\"\" >link</a>)注册的事件，事件名必须全部小写。\n   <INPUT NAME=\"inputX\" VALUE=\"\" onMouseOver=\"fn()\" /> //错误\n   <input name=\"inputX\" value=\"\" onmouseover=\"fn()\" /> //正确\n   二. 标签必须关闭 !important\n   备注：自封闭的标签必须自封闭，如：<br />, <input />等，所有自封闭的 HTML 标签请点击 这里\n   备注：标签未关闭的错误常见于模版输出和挖天窗的过程中，请相关人员要特别注意分析好页面结构\n   <input name=\"inputX\" value=\"\"> //错误\n   <input name=\"inputX\" value=\"\"></input> //错误\n   <input name=\"inputX\" value=\"\" /> //正确 (最后的斜杠“/”与前面的字符串之间要有一个空格)\n   三. 标签必须正确嵌套 !important\n   <div><p>text</div></p> //错误\n   <div><p>text</p></div> //正确\n   扩展阅读: HTML 标签嵌套规则\n   四. 标签属性必须使用双引号 !important\n   <input name='a' id=b value= /> //错误\n   <input name=\"a\" id=\"b\" value=\"\" /> //正确\n   五. 属性值不能简写，必须是名值对的形式(name=”value”) !important\n   selected=\"selected\" //类似的还有 disabled , checked , readonly , noresize\n   六. 自定义属性，必须以 data-开头(data-name=”value”)，多个单词用‘-’连接 !important\n   <li name=\"a\" value=\"b\" fid=\"1234\" country-code=\"cn\">context</li> //错误\n   <li data-name=\"a\" data-value=\"b\" data-fid=\"1234\" data-country-code=\"cn\">context</li> //正确\n   使用 data-开头的自定义属性，是 HTML5 新增加的功能，可以使用更多 HTML5 的新特性\n   HTML5 JavaScript API 提供了访问这些自定义属性的方法（除了 setAttribute/getAttribute 以外）DOM.dataset 点击查看\n   七. 使用自定义属性(data-role=\"xxx\")代替 class 做“js 钩子” !important\n   <li class=\"J-item\">context</li> //不推荐\n   <li data-role=\"item\">context</li> //推荐使用\n   使用 data-role=\"xxx\"来代替原来的 class=\"J-xxx\"可以更好地将 css 与 js 分离，利于发展维护\n   八. 属性值特别是依赖后端输出的属性值必须经过 html encode，以防止 XSS 攻击 !important\n   其中 a 标签 href 属性 PATH 部分必须经过 encode.\n   前端操作 Cookie 时，涉及用户输入数据的部分也要特别注意这一点，比如: 网站中的 Recent Search 记录\n   安全输出 velocity 变量的宏请猛击这里\n   九. 标签内容，服务器端输出的，根据情况确定是否需要经过 encode !important\n   纯文本，必须。比如:链接文本\n   包含 html 输出时不能编码的，要有意识地联系工程师做好后端输入过滤。比如：富媒体编辑器内容\n   安全输出 velocity 变量的宏请猛击这里\n   十. 特殊字符尽量用相应的符号实体代替\n   特殊字符 对应的符号实体\n   & &amp;\n   < &lt; > &gt;\n   空格 &nbsp;\n   查看更多？猛击这里下载整理的电子书\n   十一. 关于 table 标签\n   table 标签中，如果使用 thead、tfoot 以及 tbody 元素之一，就必须使用全部的元素，它们的出现次序是：thead、tfoot、tbody 。\n   扩展阅读: 标准化 table 标签\n   十二. 代码缩进\n   在书写代码的时候, 缩进并不会影响页面的最终表现, 但使用适当的缩进能使代码更具可读性, 我们推荐的缩进方法是当你开始一个新的元素时缩进一个 Tab 位(按一次 Tab 键——4 个空格的长度). 另外, 记得, 关闭元素的标签与开始标签对齐.示例：\n   <div class=\"container\">\n   hello, Alibaba!\n   </div>\n\n注释规范\n如非必要，HTML 代码中不允许出现 HTML 注释（系统自动生成的除外），用 velocity 的注释代替。\n","slug":"html-code-guide","published":1,"date":"2014-06-04T16:00:00.000Z","updated":"2018-12-07T02:48:52.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfma10018w8wkxc6fhin3","content":"<p>一. 命名规则 !important</p>\n<div id=\"list-inbox\" class=\"mail-list\">list information</div>  //正确<br><div id=\"listInbox\" class=\"mailList\">list information</div>  //错误<br>id 与 class 均采用中划线命名法，不得驼峰命名法<br>二. 合理命名<br><div id=\"sidebar\">side information</div>  //推荐<br><div id=\"col-left\">side information</div>  //不推荐<br>根据内容而不是表象给 id 和 class 合理命名<br>三. 标签语义化<br><em>这里是强调文本</em>  //用em标签标识强调文本<br><strong>这里是重点强调文本</strong>  //用strong标签标识重点强调文本<br>根据内容选择合适的html标签，尽量避免写入无意义标签，尝试使用微格式(MicroFormats)<br>人可以通过视觉的划分判断内容的语义,搜索引擎看到的只是代码。搜索引擎只能通过标签来判断内容的语义。页面的很大一部分流量是来自搜索引擎的，所以我们要使页面尽可能地对搜索引擎友好<br>h标签的语意是标题，搜索引擎对这个标签比较敏感，特别是h1,和h2。一个语义良好的页面，h标签应该是完整有序没有断层的。也就是说，要h1,h2,h3,h4这样推下来，不要h1,h3,h4，漏掉h2。一个结构良好的网页，h标签可以组织起一个网页的大纲<br>四. 良好的文档结构<br>清晰合理的文档结构，对SEO更友好，方便行为层操控DOM结构，使之易于维护、扩展和阅读<br>五. 分离的思想<br><div style=\"padding:10px\">sidebar information </div>  //直接插入样式，不推荐<br><div onclick=\"showMenu()\">sidebar information </div>  //直接注册事件，不推荐<br>结构层、表现层和行为层的分离，尽可能的不要在 HTML 结构标签中直接插入样式或者 JavaScript 脚本代码<br><br>书写规范<br>一. 标签的元素和属性名都必须小写 !important<br>备注：<br><br>1. IE 另存为的 html 文件，会把标签全改为大写，这是不符合标准的，不能直接复制粘贴复用。如有这方面的需要，请用 Firefox 保存，或者用工具(比如:dreamwaver)将标签全部转为小写。<br>2. 另一个值得注意的是，通过内联方式(<a href=\"#\" onmouseover=\"\">link</a>)注册的事件，事件名必须全部小写。<br>   <input name=\"inputX\" value=\"\" onmouseover=\"fn()\"> //错误<br>   <input name=\"inputX\" value=\"\" onmouseover=\"fn()\"> //正确<br>   二. 标签必须关闭 !important<br>   备注：自封闭的标签必须自封闭，如：<br>, <input>等，所有自封闭的 HTML 标签请点击 这里<br>   备注：标签未关闭的错误常见于模版输出和挖天窗的过程中，请相关人员要特别注意分析好页面结构<br>   <input name=\"inputX\" value=\"\"> //错误<br>   <input name=\"inputX\" value=\"\"> //错误<br>   <input name=\"inputX\" value=\"\"> //正确 (最后的斜杠“/”与前面的字符串之间要有一个空格)<br>   三. 标签必须正确嵌套 !important<br>   <div><p>text</p></div><p></p> //错误<br>   <div><p>text</p></div> //正确<br>   扩展阅读: HTML 标签嵌套规则<br>   四. 标签属性必须使用双引号 !important<br>   <input name=\"a\" id=\"b\" value=\"/\"> //错误<br>   <input name=\"a\" id=\"b\" value=\"\"> //正确<br>   五. 属性值不能简写，必须是名值对的形式(name=”value”) !important<br>   selected=”selected” //类似的还有 disabled , checked , readonly , noresize<br>   六. 自定义属性，必须以 data-开头(data-name=”value”)，多个单词用‘-’连接 !important<br>   <li name=\"a\" value=\"b\" fid=\"1234\" country-code=\"cn\">context</li> //错误<br>   <li data-name=\"a\" data-value=\"b\" data-fid=\"1234\" data-country-code=\"cn\">context</li> //正确<br>   使用 data-开头的自定义属性，是 HTML5 新增加的功能，可以使用更多 HTML5 的新特性<br>   HTML5 JavaScript API 提供了访问这些自定义属性的方法（除了 setAttribute/getAttribute 以外）DOM.dataset 点击查看<br>   七. 使用自定义属性(data-role=”xxx”)代替 class 做“js 钩子” !important<br>   <li class=\"J-item\">context</li> //不推荐<br>   <li data-role=\"item\">context</li> //推荐使用<br>   使用 data-role=”xxx”来代替原来的 class=”J-xxx”可以更好地将 css 与 js 分离，利于发展维护<br>   八. 属性值特别是依赖后端输出的属性值必须经过 html encode，以防止 XSS 攻击 !important<br>   其中 a 标签 href 属性 PATH 部分必须经过 encode.<br>   前端操作 Cookie 时，涉及用户输入数据的部分也要特别注意这一点，比如: 网站中的 Recent Search 记录<br>   安全输出 velocity 变量的宏请猛击这里<br>   九. 标签内容，服务器端输出的，根据情况确定是否需要经过 encode !important<br>   纯文本，必须。比如:链接文本<br>   包含 html 输出时不能编码的，要有意识地联系工程师做好后端输入过滤。比如：富媒体编辑器内容<br>   安全输出 velocity 变量的宏请猛击这里<br>   十. 特殊字符尽量用相应的符号实体代替<br>   特殊字符 对应的符号实体<br>   &amp; &amp;<br>   &lt; &lt; &gt; &gt;<br>   空格 &nbsp;<br>   查看更多？猛击这里下载整理的电子书<br>   十一. 关于 table 标签<br>   table 标签中，如果使用 thead、tfoot 以及 tbody 元素之一，就必须使用全部的元素，它们的出现次序是：thead、tfoot、tbody 。<br>   扩展阅读: 标准化 table 标签<br>   十二. 代码缩进<br>   在书写代码的时候, 缩进并不会影响页面的最终表现, 但使用适当的缩进能使代码更具可读性, 我们推荐的缩进方法是当你开始一个新的元素时缩进一个 Tab 位(按一次 Tab 键——4 个空格的长度). 另外, 记得, 关闭元素的标签与开始标签对齐.示例：<br>   <div class=\"container\"><br>   hello, Alibaba!<br>   </div>\n\n<p>注释规范<br>如非必要，HTML 代码中不允许出现 HTML 注释（系统自动生成的除外），用 velocity 的注释代替。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一. 命名规则 !important</p>\n<div id=\"list-inbox\" class=\"mail-list\">list information</div>  //正确<br><div id=\"listInbox\" class=\"mailList\">list information</div>  //错误<br>id 与 class 均采用中划线命名法，不得驼峰命名法<br>二. 合理命名<br><div id=\"sidebar\">side information</div>  //推荐<br><div id=\"col-left\">side information</div>  //不推荐<br>根据内容而不是表象给 id 和 class 合理命名<br>三. 标签语义化<br><em>这里是强调文本</em>  //用em标签标识强调文本<br><strong>这里是重点强调文本</strong>  //用strong标签标识重点强调文本<br>根据内容选择合适的html标签，尽量避免写入无意义标签，尝试使用微格式(MicroFormats)<br>人可以通过视觉的划分判断内容的语义,搜索引擎看到的只是代码。搜索引擎只能通过标签来判断内容的语义。页面的很大一部分流量是来自搜索引擎的，所以我们要使页面尽可能地对搜索引擎友好<br>h标签的语意是标题，搜索引擎对这个标签比较敏感，特别是h1,和h2。一个语义良好的页面，h标签应该是完整有序没有断层的。也就是说，要h1,h2,h3,h4这样推下来，不要h1,h3,h4，漏掉h2。一个结构良好的网页，h标签可以组织起一个网页的大纲<br>四. 良好的文档结构<br>清晰合理的文档结构，对SEO更友好，方便行为层操控DOM结构，使之易于维护、扩展和阅读<br>五. 分离的思想<br><div style=\"padding:10px\">sidebar information </div>  //直接插入样式，不推荐<br><div onclick=\"showMenu()\">sidebar information </div>  //直接注册事件，不推荐<br>结构层、表现层和行为层的分离，尽可能的不要在 HTML 结构标签中直接插入样式或者 JavaScript 脚本代码<br><br>书写规范<br>一. 标签的元素和属性名都必须小写 !important<br>备注：<br><br>1. IE 另存为的 html 文件，会把标签全改为大写，这是不符合标准的，不能直接复制粘贴复用。如有这方面的需要，请用 Firefox 保存，或者用工具(比如:dreamwaver)将标签全部转为小写。<br>2. 另一个值得注意的是，通过内联方式(<a href=\"#\" onmouseover=\"\">link</a>)注册的事件，事件名必须全部小写。<br>   <input name=\"inputX\" value=\"\" onmouseover=\"fn()\"> //错误<br>   <input name=\"inputX\" value=\"\" onmouseover=\"fn()\"> //正确<br>   二. 标签必须关闭 !important<br>   备注：自封闭的标签必须自封闭，如：<br>, <input>等，所有自封闭的 HTML 标签请点击 这里<br>   备注：标签未关闭的错误常见于模版输出和挖天窗的过程中，请相关人员要特别注意分析好页面结构<br>   <input name=\"inputX\" value=\"\"> //错误<br>   <input name=\"inputX\" value=\"\"> //错误<br>   <input name=\"inputX\" value=\"\"> //正确 (最后的斜杠“/”与前面的字符串之间要有一个空格)<br>   三. 标签必须正确嵌套 !important<br>   <div><p>text</p></div><p></p> //错误<br>   <div><p>text</p></div> //正确<br>   扩展阅读: HTML 标签嵌套规则<br>   四. 标签属性必须使用双引号 !important<br>   <input name=\"a\" id=\"b\" value=\"/\"> //错误<br>   <input name=\"a\" id=\"b\" value=\"\"> //正确<br>   五. 属性值不能简写，必须是名值对的形式(name=”value”) !important<br>   selected=”selected” //类似的还有 disabled , checked , readonly , noresize<br>   六. 自定义属性，必须以 data-开头(data-name=”value”)，多个单词用‘-’连接 !important<br>   <li name=\"a\" value=\"b\" fid=\"1234\" country-code=\"cn\">context</li> //错误<br>   <li data-name=\"a\" data-value=\"b\" data-fid=\"1234\" data-country-code=\"cn\">context</li> //正确<br>   使用 data-开头的自定义属性，是 HTML5 新增加的功能，可以使用更多 HTML5 的新特性<br>   HTML5 JavaScript API 提供了访问这些自定义属性的方法（除了 setAttribute/getAttribute 以外）DOM.dataset 点击查看<br>   七. 使用自定义属性(data-role=”xxx”)代替 class 做“js 钩子” !important<br>   <li class=\"J-item\">context</li> //不推荐<br>   <li data-role=\"item\">context</li> //推荐使用<br>   使用 data-role=”xxx”来代替原来的 class=”J-xxx”可以更好地将 css 与 js 分离，利于发展维护<br>   八. 属性值特别是依赖后端输出的属性值必须经过 html encode，以防止 XSS 攻击 !important<br>   其中 a 标签 href 属性 PATH 部分必须经过 encode.<br>   前端操作 Cookie 时，涉及用户输入数据的部分也要特别注意这一点，比如: 网站中的 Recent Search 记录<br>   安全输出 velocity 变量的宏请猛击这里<br>   九. 标签内容，服务器端输出的，根据情况确定是否需要经过 encode !important<br>   纯文本，必须。比如:链接文本<br>   包含 html 输出时不能编码的，要有意识地联系工程师做好后端输入过滤。比如：富媒体编辑器内容<br>   安全输出 velocity 变量的宏请猛击这里<br>   十. 特殊字符尽量用相应的符号实体代替<br>   特殊字符 对应的符号实体<br>   &amp; &amp;<br>   &lt; &lt; &gt; &gt;<br>   空格 &nbsp;<br>   查看更多？猛击这里下载整理的电子书<br>   十一. 关于 table 标签<br>   table 标签中，如果使用 thead、tfoot 以及 tbody 元素之一，就必须使用全部的元素，它们的出现次序是：thead、tfoot、tbody 。<br>   扩展阅读: 标准化 table 标签<br>   十二. 代码缩进<br>   在书写代码的时候, 缩进并不会影响页面的最终表现, 但使用适当的缩进能使代码更具可读性, 我们推荐的缩进方法是当你开始一个新的元素时缩进一个 Tab 位(按一次 Tab 键——4 个空格的长度). 另外, 记得, 关闭元素的标签与开始标签对齐.示例：<br>   <div class=\"container\"><br>   hello, Alibaba!<br>   </div>\n\n<p>注释规范<br>如非必要，HTML 代码中不允许出现 HTML 注释（系统自动生成的除外），用 velocity 的注释代替。</p>\n"},{"title":"IE 浏览器的阻止 XSS 攻击功能","_content":"\n昨天接到一个专利搜索结果页面的 bug：在某个搜索条件下，IE10 浏览器不能正常显示。\n\n### 1. 重现问题\n\n我们这里没有 IE10 浏览器，一般都是通过 Windows8.1 上的 IE11 浏览器模拟实现，所以我立即在 IE11 上验证，没有想到 IE11 竟然也重现了这个问题，所以我也没有必要去模拟 IE10 了。\n\n> 开发环境：我们组有三台服务器，一台装 Ubuntu 用来做普通服务器用，剩下两台都用来测试网站在 IE 上兼容性，一台是 Windows Server 2012 安装了 IE8，一台是 Windows 8.1 安装了 IE11。IE9，IE10 都是通过 IE11 模拟测试的。\n\n重现的时候发现两个问题，一个是页面顶部给出提示“Invalid input”(非法输入)，这是我们系统给出的错误提示。另一个就是 IE 给的提示信息“Internet Explorer has modified this page to help prevent cross-site scripting.”\n\n### 2. 从错误提示着手进行调试\n\n因为有我们系统“非法输入”的错误提示，所以我决定通过调试来确定是哪里出错了。\n\n根据经验猜测这个错误很可能是由某个 AJAX 请求出错造成的，在锁定了 AJAX 之后，又对比该请求在 Chrome 和 IE11 浏览器中的不同，发现某个字段中括号（英文的左右括号）被替换成了#，由于该字段是由后台写在`<script></script>`，所以首先去查看网页源代码，令人吃惊的是网页源代码中竟然括号也变成#，这不得不让我怀疑是后台针对 IE 浏览器做了特殊处理。虽然我们知道后台不应该这么做，并且得到后台确切的答案（他们不会这么做）以后，我们决定通过 Fiddler 代理来查看请求和响应数据，而通过 Fiddler 查看到的响应是正确的，难道是 IE 浏览器在搞鬼？\n\n### 3. 从 IE 浏览器的关于 XSS 的提示着手\n\n在网上搜索了“Internet Explorer has modified this page to help prevent cross-site scripting.”，找到了一些[文章](http://answers.microsoft.com/en-us/ie/forum/ie9-windows_7/internet-explorer-9-has-modified-the-page-to-help/84157078-964f-e011-8dfc-68b599b31bf5?tab=MoreHelp&auth=1)，大致说这是由于 IE 检测到页面中可能带有跨站脚本攻击代码，而对页面代码做了一些修改，以保护用户免受跨站脚本攻击。\n并且提供了一些解决方案：点击`Tools->Internet Options->Security->Custom level`，在弹出的对话框中禁用 XSS Filter。这样设置以后页面确实正常显示了。可见该问题确实是有 IE 误判造成的。\n\n但是我们做为在线网络服务的提供商，不能依靠用户修改浏览器设置来解决问题，并且该设置并不是针对某个具体网站，而是整个互联网，意味着用户彻底放弃了 IE 针对 XSS 攻击的保护，得不偿失。还要继续寻找其他方案。终于在[另一篇文章](https://msdn.microsoft.com/zh-cn/library/dd565647%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396)中找到答案。给页面添加一个响应头\n\n```\nX-XSS-Protection: 0\n```\n\n这样就通过禁用响应头彻底解决了该问题。\n\n###4. 解决问题以后的一些思考\n问题解决了，但是还是有写疑问，我们很容易找到 IE 误判为 XSS 攻击的代码，却不知道为什么会被判断为 XSS 攻击代码。只在[这篇文章](http://p42.us/ie8xss/Abusing_IE8s_XSS_Filters.pdf)中找了一些示例，但是我们的页面源代码中都不符合这些规则。估计 IE 官方也不会给出这些规则，否则很容易被黑客利用，设计能够避开这些规则的 XSS 攻击代码。\n\n另外还想谈谈 IE 的阻止 XSS 攻击的功能，我们有时也会在 Chrome 看到相似的提示，但是 Chrome 给出另外一种选择，大概意思是我已经了解可能的风险，并且要继续访问，通过次选项用户可以比较方便地继续浏览其非常信任的网站。在这件事件上，IE 显得非常保守，没有给出第二种选择，用户遇到这种情况，只会怀疑网站除了问题，也不会知道怎样才能查看网页内容。经过 IE 修改后的代码一般很难正确运行，而 IE 却尝试继续运行。远不如 Chrome 实在，检测到危险代码，干脆放弃执行代码，并给用户醒目提示。\n\nIE 对（疑似）XSS 代码处理也真够不遗余力的，连查看源代码都不放弃，个人认为这是 IE 设计上的缺陷，查看源代码，我看的是**“源”**代码，将响应当做普通的不可执行的文档处理，不可能出现 XSS 攻击，还有就此时 IE 修改了源代码，却没有给出任何提示。\n\n打完收工，睡觉。\n","source":"_posts/2015-08-12-ie-prevent-xss.md","raw":"---\ntitle: IE 浏览器的阻止 XSS 攻击功能\n---\n\n昨天接到一个专利搜索结果页面的 bug：在某个搜索条件下，IE10 浏览器不能正常显示。\n\n### 1. 重现问题\n\n我们这里没有 IE10 浏览器，一般都是通过 Windows8.1 上的 IE11 浏览器模拟实现，所以我立即在 IE11 上验证，没有想到 IE11 竟然也重现了这个问题，所以我也没有必要去模拟 IE10 了。\n\n> 开发环境：我们组有三台服务器，一台装 Ubuntu 用来做普通服务器用，剩下两台都用来测试网站在 IE 上兼容性，一台是 Windows Server 2012 安装了 IE8，一台是 Windows 8.1 安装了 IE11。IE9，IE10 都是通过 IE11 模拟测试的。\n\n重现的时候发现两个问题，一个是页面顶部给出提示“Invalid input”(非法输入)，这是我们系统给出的错误提示。另一个就是 IE 给的提示信息“Internet Explorer has modified this page to help prevent cross-site scripting.”\n\n### 2. 从错误提示着手进行调试\n\n因为有我们系统“非法输入”的错误提示，所以我决定通过调试来确定是哪里出错了。\n\n根据经验猜测这个错误很可能是由某个 AJAX 请求出错造成的，在锁定了 AJAX 之后，又对比该请求在 Chrome 和 IE11 浏览器中的不同，发现某个字段中括号（英文的左右括号）被替换成了#，由于该字段是由后台写在`<script></script>`，所以首先去查看网页源代码，令人吃惊的是网页源代码中竟然括号也变成#，这不得不让我怀疑是后台针对 IE 浏览器做了特殊处理。虽然我们知道后台不应该这么做，并且得到后台确切的答案（他们不会这么做）以后，我们决定通过 Fiddler 代理来查看请求和响应数据，而通过 Fiddler 查看到的响应是正确的，难道是 IE 浏览器在搞鬼？\n\n### 3. 从 IE 浏览器的关于 XSS 的提示着手\n\n在网上搜索了“Internet Explorer has modified this page to help prevent cross-site scripting.”，找到了一些[文章](http://answers.microsoft.com/en-us/ie/forum/ie9-windows_7/internet-explorer-9-has-modified-the-page-to-help/84157078-964f-e011-8dfc-68b599b31bf5?tab=MoreHelp&auth=1)，大致说这是由于 IE 检测到页面中可能带有跨站脚本攻击代码，而对页面代码做了一些修改，以保护用户免受跨站脚本攻击。\n并且提供了一些解决方案：点击`Tools->Internet Options->Security->Custom level`，在弹出的对话框中禁用 XSS Filter。这样设置以后页面确实正常显示了。可见该问题确实是有 IE 误判造成的。\n\n但是我们做为在线网络服务的提供商，不能依靠用户修改浏览器设置来解决问题，并且该设置并不是针对某个具体网站，而是整个互联网，意味着用户彻底放弃了 IE 针对 XSS 攻击的保护，得不偿失。还要继续寻找其他方案。终于在[另一篇文章](https://msdn.microsoft.com/zh-cn/library/dd565647%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396)中找到答案。给页面添加一个响应头\n\n```\nX-XSS-Protection: 0\n```\n\n这样就通过禁用响应头彻底解决了该问题。\n\n###4. 解决问题以后的一些思考\n问题解决了，但是还是有写疑问，我们很容易找到 IE 误判为 XSS 攻击的代码，却不知道为什么会被判断为 XSS 攻击代码。只在[这篇文章](http://p42.us/ie8xss/Abusing_IE8s_XSS_Filters.pdf)中找了一些示例，但是我们的页面源代码中都不符合这些规则。估计 IE 官方也不会给出这些规则，否则很容易被黑客利用，设计能够避开这些规则的 XSS 攻击代码。\n\n另外还想谈谈 IE 的阻止 XSS 攻击的功能，我们有时也会在 Chrome 看到相似的提示，但是 Chrome 给出另外一种选择，大概意思是我已经了解可能的风险，并且要继续访问，通过次选项用户可以比较方便地继续浏览其非常信任的网站。在这件事件上，IE 显得非常保守，没有给出第二种选择，用户遇到这种情况，只会怀疑网站除了问题，也不会知道怎样才能查看网页内容。经过 IE 修改后的代码一般很难正确运行，而 IE 却尝试继续运行。远不如 Chrome 实在，检测到危险代码，干脆放弃执行代码，并给用户醒目提示。\n\nIE 对（疑似）XSS 代码处理也真够不遗余力的，连查看源代码都不放弃，个人认为这是 IE 设计上的缺陷，查看源代码，我看的是**“源”**代码，将响应当做普通的不可执行的文档处理，不可能出现 XSS 攻击，还有就此时 IE 修改了源代码，却没有给出任何提示。\n\n打完收工，睡觉。\n","slug":"ie-prevent-xss","published":1,"date":"2015-08-11T16:00:00.000Z","updated":"2018-12-07T02:47:38.815Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfma20019w8wkgp6j2rue","content":"<p>昨天接到一个专利搜索结果页面的 bug：在某个搜索条件下，IE10 浏览器不能正常显示。</p>\n<h3 id=\"1-重现问题\"><a href=\"#1-重现问题\" class=\"headerlink\" title=\"1. 重现问题\"></a>1. 重现问题</h3><p>我们这里没有 IE10 浏览器，一般都是通过 Windows8.1 上的 IE11 浏览器模拟实现，所以我立即在 IE11 上验证，没有想到 IE11 竟然也重现了这个问题，所以我也没有必要去模拟 IE10 了。</p>\n<blockquote>\n<p>开发环境：我们组有三台服务器，一台装 Ubuntu 用来做普通服务器用，剩下两台都用来测试网站在 IE 上兼容性，一台是 Windows Server 2012 安装了 IE8，一台是 Windows 8.1 安装了 IE11。IE9，IE10 都是通过 IE11 模拟测试的。</p>\n</blockquote>\n<p>重现的时候发现两个问题，一个是页面顶部给出提示“Invalid input”(非法输入)，这是我们系统给出的错误提示。另一个就是 IE 给的提示信息“Internet Explorer has modified this page to help prevent cross-site scripting.”</p>\n<h3 id=\"2-从错误提示着手进行调试\"><a href=\"#2-从错误提示着手进行调试\" class=\"headerlink\" title=\"2. 从错误提示着手进行调试\"></a>2. 从错误提示着手进行调试</h3><p>因为有我们系统“非法输入”的错误提示，所以我决定通过调试来确定是哪里出错了。</p>\n<p>根据经验猜测这个错误很可能是由某个 AJAX 请求出错造成的，在锁定了 AJAX 之后，又对比该请求在 Chrome 和 IE11 浏览器中的不同，发现某个字段中括号（英文的左右括号）被替换成了#，由于该字段是由后台写在<code>&lt;script&gt;&lt;/script&gt;</code>，所以首先去查看网页源代码，令人吃惊的是网页源代码中竟然括号也变成#，这不得不让我怀疑是后台针对 IE 浏览器做了特殊处理。虽然我们知道后台不应该这么做，并且得到后台确切的答案（他们不会这么做）以后，我们决定通过 Fiddler 代理来查看请求和响应数据，而通过 Fiddler 查看到的响应是正确的，难道是 IE 浏览器在搞鬼？</p>\n<h3 id=\"3-从-IE-浏览器的关于-XSS-的提示着手\"><a href=\"#3-从-IE-浏览器的关于-XSS-的提示着手\" class=\"headerlink\" title=\"3. 从 IE 浏览器的关于 XSS 的提示着手\"></a>3. 从 IE 浏览器的关于 XSS 的提示着手</h3><p>在网上搜索了“Internet Explorer has modified this page to help prevent cross-site scripting.”，找到了一些<a href=\"http://answers.microsoft.com/en-us/ie/forum/ie9-windows_7/internet-explorer-9-has-modified-the-page-to-help/84157078-964f-e011-8dfc-68b599b31bf5?tab=MoreHelp&amp;auth=1\" target=\"_blank\" rel=\"noopener\">文章</a>，大致说这是由于 IE 检测到页面中可能带有跨站脚本攻击代码，而对页面代码做了一些修改，以保护用户免受跨站脚本攻击。<br>并且提供了一些解决方案：点击<code>Tools-&gt;Internet Options-&gt;Security-&gt;Custom level</code>，在弹出的对话框中禁用 XSS Filter。这样设置以后页面确实正常显示了。可见该问题确实是有 IE 误判造成的。</p>\n<p>但是我们做为在线网络服务的提供商，不能依靠用户修改浏览器设置来解决问题，并且该设置并不是针对某个具体网站，而是整个互联网，意味着用户彻底放弃了 IE 针对 XSS 攻击的保护，得不偿失。还要继续寻找其他方案。终于在<a href=\"https://msdn.microsoft.com/zh-cn/library/dd565647%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396\" target=\"_blank\" rel=\"noopener\">另一篇文章</a>中找到答案。给页面添加一个响应头</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X-XSS-Protection: 0</span><br></pre></td></tr></table></figure>\n<p>这样就通过禁用响应头彻底解决了该问题。</p>\n<p>###4. 解决问题以后的一些思考<br>问题解决了，但是还是有写疑问，我们很容易找到 IE 误判为 XSS 攻击的代码，却不知道为什么会被判断为 XSS 攻击代码。只在<a href=\"http://p42.us/ie8xss/Abusing_IE8s_XSS_Filters.pdf\" target=\"_blank\" rel=\"noopener\">这篇文章</a>中找了一些示例，但是我们的页面源代码中都不符合这些规则。估计 IE 官方也不会给出这些规则，否则很容易被黑客利用，设计能够避开这些规则的 XSS 攻击代码。</p>\n<p>另外还想谈谈 IE 的阻止 XSS 攻击的功能，我们有时也会在 Chrome 看到相似的提示，但是 Chrome 给出另外一种选择，大概意思是我已经了解可能的风险，并且要继续访问，通过次选项用户可以比较方便地继续浏览其非常信任的网站。在这件事件上，IE 显得非常保守，没有给出第二种选择，用户遇到这种情况，只会怀疑网站除了问题，也不会知道怎样才能查看网页内容。经过 IE 修改后的代码一般很难正确运行，而 IE 却尝试继续运行。远不如 Chrome 实在，检测到危险代码，干脆放弃执行代码，并给用户醒目提示。</p>\n<p>IE 对（疑似）XSS 代码处理也真够不遗余力的，连查看源代码都不放弃，个人认为这是 IE 设计上的缺陷，查看源代码，我看的是<strong>“源”</strong>代码，将响应当做普通的不可执行的文档处理，不可能出现 XSS 攻击，还有就此时 IE 修改了源代码，却没有给出任何提示。</p>\n<p>打完收工，睡觉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨天接到一个专利搜索结果页面的 bug：在某个搜索条件下，IE10 浏览器不能正常显示。</p>\n<h3 id=\"1-重现问题\"><a href=\"#1-重现问题\" class=\"headerlink\" title=\"1. 重现问题\"></a>1. 重现问题</h3><p>我们这里没有 IE10 浏览器，一般都是通过 Windows8.1 上的 IE11 浏览器模拟实现，所以我立即在 IE11 上验证，没有想到 IE11 竟然也重现了这个问题，所以我也没有必要去模拟 IE10 了。</p>\n<blockquote>\n<p>开发环境：我们组有三台服务器，一台装 Ubuntu 用来做普通服务器用，剩下两台都用来测试网站在 IE 上兼容性，一台是 Windows Server 2012 安装了 IE8，一台是 Windows 8.1 安装了 IE11。IE9，IE10 都是通过 IE11 模拟测试的。</p>\n</blockquote>\n<p>重现的时候发现两个问题，一个是页面顶部给出提示“Invalid input”(非法输入)，这是我们系统给出的错误提示。另一个就是 IE 给的提示信息“Internet Explorer has modified this page to help prevent cross-site scripting.”</p>\n<h3 id=\"2-从错误提示着手进行调试\"><a href=\"#2-从错误提示着手进行调试\" class=\"headerlink\" title=\"2. 从错误提示着手进行调试\"></a>2. 从错误提示着手进行调试</h3><p>因为有我们系统“非法输入”的错误提示，所以我决定通过调试来确定是哪里出错了。</p>\n<p>根据经验猜测这个错误很可能是由某个 AJAX 请求出错造成的，在锁定了 AJAX 之后，又对比该请求在 Chrome 和 IE11 浏览器中的不同，发现某个字段中括号（英文的左右括号）被替换成了#，由于该字段是由后台写在<code>&lt;script&gt;&lt;/script&gt;</code>，所以首先去查看网页源代码，令人吃惊的是网页源代码中竟然括号也变成#，这不得不让我怀疑是后台针对 IE 浏览器做了特殊处理。虽然我们知道后台不应该这么做，并且得到后台确切的答案（他们不会这么做）以后，我们决定通过 Fiddler 代理来查看请求和响应数据，而通过 Fiddler 查看到的响应是正确的，难道是 IE 浏览器在搞鬼？</p>\n<h3 id=\"3-从-IE-浏览器的关于-XSS-的提示着手\"><a href=\"#3-从-IE-浏览器的关于-XSS-的提示着手\" class=\"headerlink\" title=\"3. 从 IE 浏览器的关于 XSS 的提示着手\"></a>3. 从 IE 浏览器的关于 XSS 的提示着手</h3><p>在网上搜索了“Internet Explorer has modified this page to help prevent cross-site scripting.”，找到了一些<a href=\"http://answers.microsoft.com/en-us/ie/forum/ie9-windows_7/internet-explorer-9-has-modified-the-page-to-help/84157078-964f-e011-8dfc-68b599b31bf5?tab=MoreHelp&amp;auth=1\" target=\"_blank\" rel=\"noopener\">文章</a>，大致说这是由于 IE 检测到页面中可能带有跨站脚本攻击代码，而对页面代码做了一些修改，以保护用户免受跨站脚本攻击。<br>并且提供了一些解决方案：点击<code>Tools-&gt;Internet Options-&gt;Security-&gt;Custom level</code>，在弹出的对话框中禁用 XSS Filter。这样设置以后页面确实正常显示了。可见该问题确实是有 IE 误判造成的。</p>\n<p>但是我们做为在线网络服务的提供商，不能依靠用户修改浏览器设置来解决问题，并且该设置并不是针对某个具体网站，而是整个互联网，意味着用户彻底放弃了 IE 针对 XSS 攻击的保护，得不偿失。还要继续寻找其他方案。终于在<a href=\"https://msdn.microsoft.com/zh-cn/library/dd565647%28v=vs.85%29.aspx?f=255&amp;MSPPError=-2147217396\" target=\"_blank\" rel=\"noopener\">另一篇文章</a>中找到答案。给页面添加一个响应头</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">X-XSS-Protection: 0</span><br></pre></td></tr></table></figure>\n<p>这样就通过禁用响应头彻底解决了该问题。</p>\n<p>###4. 解决问题以后的一些思考<br>问题解决了，但是还是有写疑问，我们很容易找到 IE 误判为 XSS 攻击的代码，却不知道为什么会被判断为 XSS 攻击代码。只在<a href=\"http://p42.us/ie8xss/Abusing_IE8s_XSS_Filters.pdf\" target=\"_blank\" rel=\"noopener\">这篇文章</a>中找了一些示例，但是我们的页面源代码中都不符合这些规则。估计 IE 官方也不会给出这些规则，否则很容易被黑客利用，设计能够避开这些规则的 XSS 攻击代码。</p>\n<p>另外还想谈谈 IE 的阻止 XSS 攻击的功能，我们有时也会在 Chrome 看到相似的提示，但是 Chrome 给出另外一种选择，大概意思是我已经了解可能的风险，并且要继续访问，通过次选项用户可以比较方便地继续浏览其非常信任的网站。在这件事件上，IE 显得非常保守，没有给出第二种选择，用户遇到这种情况，只会怀疑网站除了问题，也不会知道怎样才能查看网页内容。经过 IE 修改后的代码一般很难正确运行，而 IE 却尝试继续运行。远不如 Chrome 实在，检测到危险代码，干脆放弃执行代码，并给用户醒目提示。</p>\n<p>IE 对（疑似）XSS 代码处理也真够不遗余力的，连查看源代码都不放弃，个人认为这是 IE 设计上的缺陷，查看源代码，我看的是<strong>“源”</strong>代码，将响应当做普通的不可执行的文档处理，不可能出现 XSS 攻击，还有就此时 IE 修改了源代码，却没有给出任何提示。</p>\n<p>打完收工，睡觉。</p>\n"},{"title":"Cookie 的共享规则","_content":"\n> 今天是 1024 程序猿的节日，今天不加班，回家加俩菜。\n\n## 问题\n\n昨天同事报出一个问题，给某家客户部署测试环境时遇到一个问题，他们访问该测试环境时完全正常，但是客户却不能访问。这是为什么呢？\n\n原来是这样的，测试环境部署在阿里云上，包括两个系统，称他们分别是系统 A 和系统 B 吧。系统 A 通过`https://customer.exmaple.com` 访问，系统 B 作为系统 A 的子系统以`iframe`方式嵌入到系统 A，并且通过`https://customer.exmaple.com:8010`访问。部署完成之后我们同事正常访问，但是客户能访问系统 A，但是不能访问被`iframe`嵌入系统 B。通过浏览器控制台可以看到报错.\n\n> Failed to load resource: net::ERR_TUNNEL_CONNECTION_FAILED.\n\n## 解决\n\n从报错的信息上看，隧道连接失败，隧道还不通，也就是请求就没有发送到服务器端去。我很快注意到系统 B 使用`https`协议和 8010 端口，并猜想会不会`https`协议必须使用 443 端口。我部署`https`系统较少，没有看到或留意非 443 端口的`https`应用。但是这个猜测很快被同事证明是错误的，因为我们的另外一个客户也是这样部署的，但是能够正常访问，突然感觉自己的网络方面的知识还是很欠缺的，其实这个也是很容易推断出来的，因为`https`协议就是在 http 协议的基础上加了 SSL。http 协议支持的端口`https`也应该支持。\n\n请求根本就没有发送到服务器端去，不可能是服务器端的问题，这也被另一个现象佐证：我们同事可以正常访问。可以确定是客户网络问题，考虑到 8010 端口的`https`实在少见，猜测是客户网络设置中禁止了非 443 端口的`https`协议，那么怎么解决这个问题呢？让用户调整网络设置当然是最简单的，但是客户公司是整个集团统一设置的网络安全策略，想修改一定要有足够理由才行，在这之前还是想想有没有其他方案吧。\n\n如果系统 A 和系统 B 使用相同的`https`协议，相同的 443 端口，但是不同的域名呢？很快就找到 CTO 申请了一个`customer-s.example.com`，部署之后发现上面的错误没有了，系统 B 的页面可以访问了，但是页面还是出不来，系统 B 的请求大多报错了。\n\n> Uncaught Type Error: Cannot read property 'job' of undefined\n\n从浏览器端的错误信息可以看出该页面没有给出合适的初始化数据。经过后端同事诊断之后发现是系统 A 的`Cookie`没有带过去，所以请求出现错误。啊？这是什么道理？访问系统 B 为什么要让浏览器自动带上系统 A 设置的`Cookie`？\n\n原来系统 A 和系统 B 并没有实现单点登录，而是系统 A 在即将打开系统 B 的`iframe`时，首先调用系统 B 的登录接口换取登录`URL`和`token`，并在`iframe`中打开系统 B，系统 B 的后端没有完备的数据给客户端使用，还会通过`http`请求从系统 A 中获取数据，而系统 A 不知道系统 B 的服务器端程序要获取哪个用户的数据，怎么办呢？\n\n猜测故事是这样的，开发阶段两个系统使用相同的 localhost 域名使用不同的端口，同时部署在本地，调试系统 B 的服务器端代码时发现原来可以获得系统 A 设置的`Cookie`，那我把系统 A 的`Cookie`带上去访问系统 A 的接口，模拟了一个浏览器请求，不就可以系统 A 获取当前用户的数据了吗？这样也就不需要系统 A 单独为系统 B 开发接口了，就这么办了。这里不去评价糟糕的设计，乱七八糟的设计最终也算是跑通了。\n\n终于说到了这篇文章的主题了，`Cookie`的作用域是整个域名，跨协议（`HTTP`或`HTTPS`，可以指定`Cookie`仅适用于`HTTPS`），跨端口共享。了解更详细内容请参考[RFC6265](https://tools.ietf.org/html/rfc6265#section-8.5)。这是我以前没有注意到的，又长知识了。\n\n由于解耦两个系统的工作量较大，目前还是采取跟客户沟通，对`HTTPS`协议开放某个非 433 的端口。\n\n## 总结\n\n1. 在解决问题过程中暴露了我两个知识点上的欠缺。\n1. `HTTPS`协议和`HTTP`协议一样，可以绑定在不同的端口上。\n1. `Cookie`的作用域是整个域名，跨协议跨端口共享。\n1. 在遇到复杂系统通信时，需要做一些架构评审，防止出现上面提到的很不专业的处理方法。\n","source":"_posts/2017-10-24-shared-cookie.md","raw":"---\ntitle: Cookie 的共享规则\n---\n\n> 今天是 1024 程序猿的节日，今天不加班，回家加俩菜。\n\n## 问题\n\n昨天同事报出一个问题，给某家客户部署测试环境时遇到一个问题，他们访问该测试环境时完全正常，但是客户却不能访问。这是为什么呢？\n\n原来是这样的，测试环境部署在阿里云上，包括两个系统，称他们分别是系统 A 和系统 B 吧。系统 A 通过`https://customer.exmaple.com` 访问，系统 B 作为系统 A 的子系统以`iframe`方式嵌入到系统 A，并且通过`https://customer.exmaple.com:8010`访问。部署完成之后我们同事正常访问，但是客户能访问系统 A，但是不能访问被`iframe`嵌入系统 B。通过浏览器控制台可以看到报错.\n\n> Failed to load resource: net::ERR_TUNNEL_CONNECTION_FAILED.\n\n## 解决\n\n从报错的信息上看，隧道连接失败，隧道还不通，也就是请求就没有发送到服务器端去。我很快注意到系统 B 使用`https`协议和 8010 端口，并猜想会不会`https`协议必须使用 443 端口。我部署`https`系统较少，没有看到或留意非 443 端口的`https`应用。但是这个猜测很快被同事证明是错误的，因为我们的另外一个客户也是这样部署的，但是能够正常访问，突然感觉自己的网络方面的知识还是很欠缺的，其实这个也是很容易推断出来的，因为`https`协议就是在 http 协议的基础上加了 SSL。http 协议支持的端口`https`也应该支持。\n\n请求根本就没有发送到服务器端去，不可能是服务器端的问题，这也被另一个现象佐证：我们同事可以正常访问。可以确定是客户网络问题，考虑到 8010 端口的`https`实在少见，猜测是客户网络设置中禁止了非 443 端口的`https`协议，那么怎么解决这个问题呢？让用户调整网络设置当然是最简单的，但是客户公司是整个集团统一设置的网络安全策略，想修改一定要有足够理由才行，在这之前还是想想有没有其他方案吧。\n\n如果系统 A 和系统 B 使用相同的`https`协议，相同的 443 端口，但是不同的域名呢？很快就找到 CTO 申请了一个`customer-s.example.com`，部署之后发现上面的错误没有了，系统 B 的页面可以访问了，但是页面还是出不来，系统 B 的请求大多报错了。\n\n> Uncaught Type Error: Cannot read property 'job' of undefined\n\n从浏览器端的错误信息可以看出该页面没有给出合适的初始化数据。经过后端同事诊断之后发现是系统 A 的`Cookie`没有带过去，所以请求出现错误。啊？这是什么道理？访问系统 B 为什么要让浏览器自动带上系统 A 设置的`Cookie`？\n\n原来系统 A 和系统 B 并没有实现单点登录，而是系统 A 在即将打开系统 B 的`iframe`时，首先调用系统 B 的登录接口换取登录`URL`和`token`，并在`iframe`中打开系统 B，系统 B 的后端没有完备的数据给客户端使用，还会通过`http`请求从系统 A 中获取数据，而系统 A 不知道系统 B 的服务器端程序要获取哪个用户的数据，怎么办呢？\n\n猜测故事是这样的，开发阶段两个系统使用相同的 localhost 域名使用不同的端口，同时部署在本地，调试系统 B 的服务器端代码时发现原来可以获得系统 A 设置的`Cookie`，那我把系统 A 的`Cookie`带上去访问系统 A 的接口，模拟了一个浏览器请求，不就可以系统 A 获取当前用户的数据了吗？这样也就不需要系统 A 单独为系统 B 开发接口了，就这么办了。这里不去评价糟糕的设计，乱七八糟的设计最终也算是跑通了。\n\n终于说到了这篇文章的主题了，`Cookie`的作用域是整个域名，跨协议（`HTTP`或`HTTPS`，可以指定`Cookie`仅适用于`HTTPS`），跨端口共享。了解更详细内容请参考[RFC6265](https://tools.ietf.org/html/rfc6265#section-8.5)。这是我以前没有注意到的，又长知识了。\n\n由于解耦两个系统的工作量较大，目前还是采取跟客户沟通，对`HTTPS`协议开放某个非 433 的端口。\n\n## 总结\n\n1. 在解决问题过程中暴露了我两个知识点上的欠缺。\n1. `HTTPS`协议和`HTTP`协议一样，可以绑定在不同的端口上。\n1. `Cookie`的作用域是整个域名，跨协议跨端口共享。\n1. 在遇到复杂系统通信时，需要做一些架构评审，防止出现上面提到的很不专业的处理方法。\n","slug":"shared-cookie","published":1,"date":"2017-10-23T16:00:00.000Z","updated":"2018-12-07T02:38:38.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfma3001aw8wkh4tfejvi","content":"<blockquote>\n<p>今天是 1024 程序猿的节日，今天不加班，回家加俩菜。</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>昨天同事报出一个问题，给某家客户部署测试环境时遇到一个问题，他们访问该测试环境时完全正常，但是客户却不能访问。这是为什么呢？</p>\n<p>原来是这样的，测试环境部署在阿里云上，包括两个系统，称他们分别是系统 A 和系统 B 吧。系统 A 通过<code>https://customer.exmaple.com</code> 访问，系统 B 作为系统 A 的子系统以<code>iframe</code>方式嵌入到系统 A，并且通过<code>https://customer.exmaple.com:8010</code>访问。部署完成之后我们同事正常访问，但是客户能访问系统 A，但是不能访问被<code>iframe</code>嵌入系统 B。通过浏览器控制台可以看到报错.</p>\n<blockquote>\n<p>Failed to load resource: net::ERR_TUNNEL_CONNECTION_FAILED.</p>\n</blockquote>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>从报错的信息上看，隧道连接失败，隧道还不通，也就是请求就没有发送到服务器端去。我很快注意到系统 B 使用<code>https</code>协议和 8010 端口，并猜想会不会<code>https</code>协议必须使用 443 端口。我部署<code>https</code>系统较少，没有看到或留意非 443 端口的<code>https</code>应用。但是这个猜测很快被同事证明是错误的，因为我们的另外一个客户也是这样部署的，但是能够正常访问，突然感觉自己的网络方面的知识还是很欠缺的，其实这个也是很容易推断出来的，因为<code>https</code>协议就是在 http 协议的基础上加了 SSL。http 协议支持的端口<code>https</code>也应该支持。</p>\n<p>请求根本就没有发送到服务器端去，不可能是服务器端的问题，这也被另一个现象佐证：我们同事可以正常访问。可以确定是客户网络问题，考虑到 8010 端口的<code>https</code>实在少见，猜测是客户网络设置中禁止了非 443 端口的<code>https</code>协议，那么怎么解决这个问题呢？让用户调整网络设置当然是最简单的，但是客户公司是整个集团统一设置的网络安全策略，想修改一定要有足够理由才行，在这之前还是想想有没有其他方案吧。</p>\n<p>如果系统 A 和系统 B 使用相同的<code>https</code>协议，相同的 443 端口，但是不同的域名呢？很快就找到 CTO 申请了一个<code>customer-s.example.com</code>，部署之后发现上面的错误没有了，系统 B 的页面可以访问了，但是页面还是出不来，系统 B 的请求大多报错了。</p>\n<blockquote>\n<p>Uncaught Type Error: Cannot read property ‘job’ of undefined</p>\n</blockquote>\n<p>从浏览器端的错误信息可以看出该页面没有给出合适的初始化数据。经过后端同事诊断之后发现是系统 A 的<code>Cookie</code>没有带过去，所以请求出现错误。啊？这是什么道理？访问系统 B 为什么要让浏览器自动带上系统 A 设置的<code>Cookie</code>？</p>\n<p>原来系统 A 和系统 B 并没有实现单点登录，而是系统 A 在即将打开系统 B 的<code>iframe</code>时，首先调用系统 B 的登录接口换取登录<code>URL</code>和<code>token</code>，并在<code>iframe</code>中打开系统 B，系统 B 的后端没有完备的数据给客户端使用，还会通过<code>http</code>请求从系统 A 中获取数据，而系统 A 不知道系统 B 的服务器端程序要获取哪个用户的数据，怎么办呢？</p>\n<p>猜测故事是这样的，开发阶段两个系统使用相同的 localhost 域名使用不同的端口，同时部署在本地，调试系统 B 的服务器端代码时发现原来可以获得系统 A 设置的<code>Cookie</code>，那我把系统 A 的<code>Cookie</code>带上去访问系统 A 的接口，模拟了一个浏览器请求，不就可以系统 A 获取当前用户的数据了吗？这样也就不需要系统 A 单独为系统 B 开发接口了，就这么办了。这里不去评价糟糕的设计，乱七八糟的设计最终也算是跑通了。</p>\n<p>终于说到了这篇文章的主题了，<code>Cookie</code>的作用域是整个域名，跨协议（<code>HTTP</code>或<code>HTTPS</code>，可以指定<code>Cookie</code>仅适用于<code>HTTPS</code>），跨端口共享。了解更详细内容请参考<a href=\"https://tools.ietf.org/html/rfc6265#section-8.5\" target=\"_blank\" rel=\"noopener\">RFC6265</a>。这是我以前没有注意到的，又长知识了。</p>\n<p>由于解耦两个系统的工作量较大，目前还是采取跟客户沟通，对<code>HTTPS</code>协议开放某个非 433 的端口。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>在解决问题过程中暴露了我两个知识点上的欠缺。</li>\n<li><code>HTTPS</code>协议和<code>HTTP</code>协议一样，可以绑定在不同的端口上。</li>\n<li><code>Cookie</code>的作用域是整个域名，跨协议跨端口共享。</li>\n<li>在遇到复杂系统通信时，需要做一些架构评审，防止出现上面提到的很不专业的处理方法。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>今天是 1024 程序猿的节日，今天不加班，回家加俩菜。</p>\n</blockquote>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>昨天同事报出一个问题，给某家客户部署测试环境时遇到一个问题，他们访问该测试环境时完全正常，但是客户却不能访问。这是为什么呢？</p>\n<p>原来是这样的，测试环境部署在阿里云上，包括两个系统，称他们分别是系统 A 和系统 B 吧。系统 A 通过<code>https://customer.exmaple.com</code> 访问，系统 B 作为系统 A 的子系统以<code>iframe</code>方式嵌入到系统 A，并且通过<code>https://customer.exmaple.com:8010</code>访问。部署完成之后我们同事正常访问，但是客户能访问系统 A，但是不能访问被<code>iframe</code>嵌入系统 B。通过浏览器控制台可以看到报错.</p>\n<blockquote>\n<p>Failed to load resource: net::ERR_TUNNEL_CONNECTION_FAILED.</p>\n</blockquote>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>从报错的信息上看，隧道连接失败，隧道还不通，也就是请求就没有发送到服务器端去。我很快注意到系统 B 使用<code>https</code>协议和 8010 端口，并猜想会不会<code>https</code>协议必须使用 443 端口。我部署<code>https</code>系统较少，没有看到或留意非 443 端口的<code>https</code>应用。但是这个猜测很快被同事证明是错误的，因为我们的另外一个客户也是这样部署的，但是能够正常访问，突然感觉自己的网络方面的知识还是很欠缺的，其实这个也是很容易推断出来的，因为<code>https</code>协议就是在 http 协议的基础上加了 SSL。http 协议支持的端口<code>https</code>也应该支持。</p>\n<p>请求根本就没有发送到服务器端去，不可能是服务器端的问题，这也被另一个现象佐证：我们同事可以正常访问。可以确定是客户网络问题，考虑到 8010 端口的<code>https</code>实在少见，猜测是客户网络设置中禁止了非 443 端口的<code>https</code>协议，那么怎么解决这个问题呢？让用户调整网络设置当然是最简单的，但是客户公司是整个集团统一设置的网络安全策略，想修改一定要有足够理由才行，在这之前还是想想有没有其他方案吧。</p>\n<p>如果系统 A 和系统 B 使用相同的<code>https</code>协议，相同的 443 端口，但是不同的域名呢？很快就找到 CTO 申请了一个<code>customer-s.example.com</code>，部署之后发现上面的错误没有了，系统 B 的页面可以访问了，但是页面还是出不来，系统 B 的请求大多报错了。</p>\n<blockquote>\n<p>Uncaught Type Error: Cannot read property ‘job’ of undefined</p>\n</blockquote>\n<p>从浏览器端的错误信息可以看出该页面没有给出合适的初始化数据。经过后端同事诊断之后发现是系统 A 的<code>Cookie</code>没有带过去，所以请求出现错误。啊？这是什么道理？访问系统 B 为什么要让浏览器自动带上系统 A 设置的<code>Cookie</code>？</p>\n<p>原来系统 A 和系统 B 并没有实现单点登录，而是系统 A 在即将打开系统 B 的<code>iframe</code>时，首先调用系统 B 的登录接口换取登录<code>URL</code>和<code>token</code>，并在<code>iframe</code>中打开系统 B，系统 B 的后端没有完备的数据给客户端使用，还会通过<code>http</code>请求从系统 A 中获取数据，而系统 A 不知道系统 B 的服务器端程序要获取哪个用户的数据，怎么办呢？</p>\n<p>猜测故事是这样的，开发阶段两个系统使用相同的 localhost 域名使用不同的端口，同时部署在本地，调试系统 B 的服务器端代码时发现原来可以获得系统 A 设置的<code>Cookie</code>，那我把系统 A 的<code>Cookie</code>带上去访问系统 A 的接口，模拟了一个浏览器请求，不就可以系统 A 获取当前用户的数据了吗？这样也就不需要系统 A 单独为系统 B 开发接口了，就这么办了。这里不去评价糟糕的设计，乱七八糟的设计最终也算是跑通了。</p>\n<p>终于说到了这篇文章的主题了，<code>Cookie</code>的作用域是整个域名，跨协议（<code>HTTP</code>或<code>HTTPS</code>，可以指定<code>Cookie</code>仅适用于<code>HTTPS</code>），跨端口共享。了解更详细内容请参考<a href=\"https://tools.ietf.org/html/rfc6265#section-8.5\" target=\"_blank\" rel=\"noopener\">RFC6265</a>。这是我以前没有注意到的，又长知识了。</p>\n<p>由于解耦两个系统的工作量较大，目前还是采取跟客户沟通，对<code>HTTPS</code>协议开放某个非 433 的端口。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>在解决问题过程中暴露了我两个知识点上的欠缺。</li>\n<li><code>HTTPS</code>协议和<code>HTTP</code>协议一样，可以绑定在不同的端口上。</li>\n<li><code>Cookie</code>的作用域是整个域名，跨协议跨端口共享。</li>\n<li>在遇到复杂系统通信时，需要做一些架构评审，防止出现上面提到的很不专业的处理方法。</li>\n</ol>\n"},{"title":"IIS 的 URL 重写（反向代理）","_content":"\n以前我使用过`Apache`或`Nginx`实现反向代理，但是目前后端使用的是`.Net`语言，服务器操作系统是`Windows Server`，并且后端应用程序就部署在`IIS`上，因此不打算再安装`Nginx`，改为使用`IIS`。\n\n在操作过程中，遇到各种问题也耽误了不少时间，现在将一些操作流程记录下来，以备再用。\n\n## 项目简介\n\n项目采用前后端分离方式开发，两个代码仓库，并部署为两个应用。后端接口地址全部以`/api`打头，方便简化转发规则。现在就需要在前端应用中将`/api`打头的请求转至后端应用。\n\n## IIS 默认不支持反向代理，需要额外安装插件\n\n很难想象`IIS`(Internet Information Service)竟然不默认支持反向代理，需要安装官方提供的两个插件。\n安装插件：\n\n1. [Application Request Routing](https://www.iis.net/downloads/microsoft/application-request-routing)\n2. [URL Rewrite](https://www.iis.net/downloads/microsoft/url-rewrite)\n   安装完成之后重新启动一下`IIS`.\n\n## 启用反向代理功能\n\n1. 双击`IIS`根目录，双击`Application Request Routing Cache`，双击右侧的`Server Proxy Settings`。\n   ![](../../../../images/iis-url-rewrite/1.click-iis-root-select-arr.png)\n   ![](../../../../images/iis-url-rewrite/2.server-proxy-setting.png)\n2. 勾选`Enable proxy`\n   ![](../../../../images/iis-url-rewrite/3.enable-proxy.png)\n\n## 添加入站规则\n\n1. 点击前端应用，双击`URL Rewrite` -> `Add Rules`(新建规则) -> `Blank rule`(空白规则)\n   ![](../../../../images/iis-url-rewrite/4.select-url-rewrite.png)\n2. 填写入站规则信息\n   ![](../../../../images/iis-url-rewrite/5.add-rule.png)\n\n3. 填写转发条件\n   ![](../../../../images/iis-url-rewrite/6.add-condition.png)\n\n4. 填写操作部分\n   ![](../../../../images/iis-url-rewrite/7.add-operation.png)\n\n5. 点击右侧应用\n\n## 最后\n\n反向代理的配置相比`Nginx`等复杂太多了，还需要额外理解 IIS 自己定义的一些概念，比如入站规则等。相信大部分刚毕业的同学跟我一样，一度特别喜欢有操作界面的软件，随着对系统掌握程度的增加，这个想法会慢慢的逆转。\n","source":"_posts/2018-01-12-iis-url-rewrite.md","raw":"---\ntitle: IIS 的 URL 重写（反向代理）\n---\n\n以前我使用过`Apache`或`Nginx`实现反向代理，但是目前后端使用的是`.Net`语言，服务器操作系统是`Windows Server`，并且后端应用程序就部署在`IIS`上，因此不打算再安装`Nginx`，改为使用`IIS`。\n\n在操作过程中，遇到各种问题也耽误了不少时间，现在将一些操作流程记录下来，以备再用。\n\n## 项目简介\n\n项目采用前后端分离方式开发，两个代码仓库，并部署为两个应用。后端接口地址全部以`/api`打头，方便简化转发规则。现在就需要在前端应用中将`/api`打头的请求转至后端应用。\n\n## IIS 默认不支持反向代理，需要额外安装插件\n\n很难想象`IIS`(Internet Information Service)竟然不默认支持反向代理，需要安装官方提供的两个插件。\n安装插件：\n\n1. [Application Request Routing](https://www.iis.net/downloads/microsoft/application-request-routing)\n2. [URL Rewrite](https://www.iis.net/downloads/microsoft/url-rewrite)\n   安装完成之后重新启动一下`IIS`.\n\n## 启用反向代理功能\n\n1. 双击`IIS`根目录，双击`Application Request Routing Cache`，双击右侧的`Server Proxy Settings`。\n   ![](../../../../images/iis-url-rewrite/1.click-iis-root-select-arr.png)\n   ![](../../../../images/iis-url-rewrite/2.server-proxy-setting.png)\n2. 勾选`Enable proxy`\n   ![](../../../../images/iis-url-rewrite/3.enable-proxy.png)\n\n## 添加入站规则\n\n1. 点击前端应用，双击`URL Rewrite` -> `Add Rules`(新建规则) -> `Blank rule`(空白规则)\n   ![](../../../../images/iis-url-rewrite/4.select-url-rewrite.png)\n2. 填写入站规则信息\n   ![](../../../../images/iis-url-rewrite/5.add-rule.png)\n\n3. 填写转发条件\n   ![](../../../../images/iis-url-rewrite/6.add-condition.png)\n\n4. 填写操作部分\n   ![](../../../../images/iis-url-rewrite/7.add-operation.png)\n\n5. 点击右侧应用\n\n## 最后\n\n反向代理的配置相比`Nginx`等复杂太多了，还需要额外理解 IIS 自己定义的一些概念，比如入站规则等。相信大部分刚毕业的同学跟我一样，一度特别喜欢有操作界面的软件，随着对系统掌握程度的增加，这个想法会慢慢的逆转。\n","slug":"iis-url-rewrite","published":1,"date":"2018-01-11T16:00:00.000Z","updated":"2018-12-07T02:38:05.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfma3001bw8wk0xs1d7in","content":"<p>以前我使用过<code>Apache</code>或<code>Nginx</code>实现反向代理，但是目前后端使用的是<code>.Net</code>语言，服务器操作系统是<code>Windows Server</code>，并且后端应用程序就部署在<code>IIS</code>上，因此不打算再安装<code>Nginx</code>，改为使用<code>IIS</code>。</p>\n<p>在操作过程中，遇到各种问题也耽误了不少时间，现在将一些操作流程记录下来，以备再用。</p>\n<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>项目采用前后端分离方式开发，两个代码仓库，并部署为两个应用。后端接口地址全部以<code>/api</code>打头，方便简化转发规则。现在就需要在前端应用中将<code>/api</code>打头的请求转至后端应用。</p>\n<h2 id=\"IIS-默认不支持反向代理，需要额外安装插件\"><a href=\"#IIS-默认不支持反向代理，需要额外安装插件\" class=\"headerlink\" title=\"IIS 默认不支持反向代理，需要额外安装插件\"></a>IIS 默认不支持反向代理，需要额外安装插件</h2><p>很难想象<code>IIS</code>(Internet Information Service)竟然不默认支持反向代理，需要安装官方提供的两个插件。<br>安装插件：</p>\n<ol>\n<li><a href=\"https://www.iis.net/downloads/microsoft/application-request-routing\" target=\"_blank\" rel=\"noopener\">Application Request Routing</a></li>\n<li><a href=\"https://www.iis.net/downloads/microsoft/url-rewrite\" target=\"_blank\" rel=\"noopener\">URL Rewrite</a><br>安装完成之后重新启动一下<code>IIS</code>.</li>\n</ol>\n<h2 id=\"启用反向代理功能\"><a href=\"#启用反向代理功能\" class=\"headerlink\" title=\"启用反向代理功能\"></a>启用反向代理功能</h2><ol>\n<li>双击<code>IIS</code>根目录，双击<code>Application Request Routing Cache</code>，双击右侧的<code>Server Proxy Settings</code>。<br><img src=\"../../../../images/iis-url-rewrite/1.click-iis-root-select-arr.png\" alt=\"\"><br><img src=\"../../../../images/iis-url-rewrite/2.server-proxy-setting.png\" alt=\"\"></li>\n<li>勾选<code>Enable proxy</code><br><img src=\"../../../../images/iis-url-rewrite/3.enable-proxy.png\" alt=\"\"></li>\n</ol>\n<h2 id=\"添加入站规则\"><a href=\"#添加入站规则\" class=\"headerlink\" title=\"添加入站规则\"></a>添加入站规则</h2><ol>\n<li>点击前端应用，双击<code>URL Rewrite</code> -&gt; <code>Add Rules</code>(新建规则) -&gt; <code>Blank rule</code>(空白规则)<br><img src=\"../../../../images/iis-url-rewrite/4.select-url-rewrite.png\" alt=\"\"></li>\n<li><p>填写入站规则信息<br><img src=\"../../../../images/iis-url-rewrite/5.add-rule.png\" alt=\"\"></p>\n</li>\n<li><p>填写转发条件<br><img src=\"../../../../images/iis-url-rewrite/6.add-condition.png\" alt=\"\"></p>\n</li>\n<li><p>填写操作部分<br><img src=\"../../../../images/iis-url-rewrite/7.add-operation.png\" alt=\"\"></p>\n</li>\n<li><p>点击右侧应用</p>\n</li>\n</ol>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>反向代理的配置相比<code>Nginx</code>等复杂太多了，还需要额外理解 IIS 自己定义的一些概念，比如入站规则等。相信大部分刚毕业的同学跟我一样，一度特别喜欢有操作界面的软件，随着对系统掌握程度的增加，这个想法会慢慢的逆转。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以前我使用过<code>Apache</code>或<code>Nginx</code>实现反向代理，但是目前后端使用的是<code>.Net</code>语言，服务器操作系统是<code>Windows Server</code>，并且后端应用程序就部署在<code>IIS</code>上，因此不打算再安装<code>Nginx</code>，改为使用<code>IIS</code>。</p>\n<p>在操作过程中，遇到各种问题也耽误了不少时间，现在将一些操作流程记录下来，以备再用。</p>\n<h2 id=\"项目简介\"><a href=\"#项目简介\" class=\"headerlink\" title=\"项目简介\"></a>项目简介</h2><p>项目采用前后端分离方式开发，两个代码仓库，并部署为两个应用。后端接口地址全部以<code>/api</code>打头，方便简化转发规则。现在就需要在前端应用中将<code>/api</code>打头的请求转至后端应用。</p>\n<h2 id=\"IIS-默认不支持反向代理，需要额外安装插件\"><a href=\"#IIS-默认不支持反向代理，需要额外安装插件\" class=\"headerlink\" title=\"IIS 默认不支持反向代理，需要额外安装插件\"></a>IIS 默认不支持反向代理，需要额外安装插件</h2><p>很难想象<code>IIS</code>(Internet Information Service)竟然不默认支持反向代理，需要安装官方提供的两个插件。<br>安装插件：</p>\n<ol>\n<li><a href=\"https://www.iis.net/downloads/microsoft/application-request-routing\" target=\"_blank\" rel=\"noopener\">Application Request Routing</a></li>\n<li><a href=\"https://www.iis.net/downloads/microsoft/url-rewrite\" target=\"_blank\" rel=\"noopener\">URL Rewrite</a><br>安装完成之后重新启动一下<code>IIS</code>.</li>\n</ol>\n<h2 id=\"启用反向代理功能\"><a href=\"#启用反向代理功能\" class=\"headerlink\" title=\"启用反向代理功能\"></a>启用反向代理功能</h2><ol>\n<li>双击<code>IIS</code>根目录，双击<code>Application Request Routing Cache</code>，双击右侧的<code>Server Proxy Settings</code>。<br><img src=\"../../../../images/iis-url-rewrite/1.click-iis-root-select-arr.png\" alt=\"\"><br><img src=\"../../../../images/iis-url-rewrite/2.server-proxy-setting.png\" alt=\"\"></li>\n<li>勾选<code>Enable proxy</code><br><img src=\"../../../../images/iis-url-rewrite/3.enable-proxy.png\" alt=\"\"></li>\n</ol>\n<h2 id=\"添加入站规则\"><a href=\"#添加入站规则\" class=\"headerlink\" title=\"添加入站规则\"></a>添加入站规则</h2><ol>\n<li>点击前端应用，双击<code>URL Rewrite</code> -&gt; <code>Add Rules</code>(新建规则) -&gt; <code>Blank rule</code>(空白规则)<br><img src=\"../../../../images/iis-url-rewrite/4.select-url-rewrite.png\" alt=\"\"></li>\n<li><p>填写入站规则信息<br><img src=\"../../../../images/iis-url-rewrite/5.add-rule.png\" alt=\"\"></p>\n</li>\n<li><p>填写转发条件<br><img src=\"../../../../images/iis-url-rewrite/6.add-condition.png\" alt=\"\"></p>\n</li>\n<li><p>填写操作部分<br><img src=\"../../../../images/iis-url-rewrite/7.add-operation.png\" alt=\"\"></p>\n</li>\n<li><p>点击右侧应用</p>\n</li>\n</ol>\n<h2 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h2><p>反向代理的配置相比<code>Nginx</code>等复杂太多了，还需要额外理解 IIS 自己定义的一些概念，比如入站规则等。相信大部分刚毕业的同学跟我一样，一度特别喜欢有操作界面的软件，随着对系统掌握程度的增加，这个想法会慢慢的逆转。</p>\n"},{"title":"运行时指定 Webpack 的 publicPath","_content":"\n## 问题描述\n\n一般情况下，我们在使用`Webpack`时，都会通过以下方式指定`publicPath`，它表示静态资源的访问地址。\n\n```js\n{\n    output: {\n        path: `${__dirname}/dest`,\n        filename: 'app-[hash].js',\n        publicPath: '',\n    }\n}\n```\n\n如果你需要把静态资源放在 CDN 上，则同样可行。\n\n```js\n{\n    output: {\n        path: `${__dirname}/dest`,\n        filename: 'app-[hash].js',\n        publicPath: 'https://cdn.example.com/',\n    }\n}\n```\n\n但是这样就把静态资源的地址写死了，而测试环境和生成环境的静态资源往往存在在不同的地方。OK，下面我就通过`__webpack_public_path__`变量来实现。\n\n## 解决方法\n\n1. 在`webpack`配置文件（比如`webpack.config.babel.js`）中删除`publicPath`的选项。\n\n```js\noutput: {\n    path: `${__dirname}/dest`,\n    filename: 'app-[hash].js',\n}\n```\n\n2. 在`html`模板文件中添加以下代码\n\n```html\n<script>\n    window.webpackPublicPath = '<这里可以由后端负责填写>';\n</script>\n```\n\n3. 上个步骤中后端已经给我们提供了静态资源访问地址了，那么怎么应用到静态资源中呢？创建一个新文件，名字自己定，比如叫做`webpack.js`。\n\n```\n/* eslint-disable */\n__webpack_public_path__ = window.webpackPublicPath;\n```\n\n4. 在 App 的入口文件的首行添加以下代码，其中`./webpack.js`就代表第三步创建的文件。\n\n```\n/* eslint-disable import/first */\nimport './webpack.js';\n```\n\n通过以上 4 个步骤即可实现有后端在代码运行时期指定`publicPath`了。\n","source":"_posts/2018-02-08-webpack-public-path.md","raw":"---\ntitle: 运行时指定 Webpack 的 publicPath\n---\n\n## 问题描述\n\n一般情况下，我们在使用`Webpack`时，都会通过以下方式指定`publicPath`，它表示静态资源的访问地址。\n\n```js\n{\n    output: {\n        path: `${__dirname}/dest`,\n        filename: 'app-[hash].js',\n        publicPath: '',\n    }\n}\n```\n\n如果你需要把静态资源放在 CDN 上，则同样可行。\n\n```js\n{\n    output: {\n        path: `${__dirname}/dest`,\n        filename: 'app-[hash].js',\n        publicPath: 'https://cdn.example.com/',\n    }\n}\n```\n\n但是这样就把静态资源的地址写死了，而测试环境和生成环境的静态资源往往存在在不同的地方。OK，下面我就通过`__webpack_public_path__`变量来实现。\n\n## 解决方法\n\n1. 在`webpack`配置文件（比如`webpack.config.babel.js`）中删除`publicPath`的选项。\n\n```js\noutput: {\n    path: `${__dirname}/dest`,\n    filename: 'app-[hash].js',\n}\n```\n\n2. 在`html`模板文件中添加以下代码\n\n```html\n<script>\n    window.webpackPublicPath = '<这里可以由后端负责填写>';\n</script>\n```\n\n3. 上个步骤中后端已经给我们提供了静态资源访问地址了，那么怎么应用到静态资源中呢？创建一个新文件，名字自己定，比如叫做`webpack.js`。\n\n```\n/* eslint-disable */\n__webpack_public_path__ = window.webpackPublicPath;\n```\n\n4. 在 App 的入口文件的首行添加以下代码，其中`./webpack.js`就代表第三步创建的文件。\n\n```\n/* eslint-disable import/first */\nimport './webpack.js';\n```\n\n通过以上 4 个步骤即可实现有后端在代码运行时期指定`publicPath`了。\n","slug":"webpack-public-path","published":1,"date":"2018-02-07T16:00:00.000Z","updated":"2018-12-07T02:38:19.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfma4001cw8wk53frqir8","content":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>一般情况下，我们在使用<code>Webpack</code>时，都会通过以下方式指定<code>publicPath</code>，它表示静态资源的访问地址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">`<span class=\"subst\">$&#123;__dirname&#125;</span>/dest`</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">'app-[hash].js'</span>,</span><br><span class=\"line\">        publicPath: <span class=\"string\">''</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你需要把静态资源放在 CDN 上，则同样可行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">`<span class=\"subst\">$&#123;__dirname&#125;</span>/dest`</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">'app-[hash].js'</span>,</span><br><span class=\"line\">        publicPath: <span class=\"string\">'https://cdn.example.com/'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这样就把静态资源的地址写死了，而测试环境和生成环境的静态资源往往存在在不同的地方。OK，下面我就通过<code>__webpack_public_path__</code>变量来实现。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><ol>\n<li>在<code>webpack</code>配置文件（比如<code>webpack.config.babel.js</code>）中删除<code>publicPath</code>的选项。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: <span class=\"string\">`<span class=\"subst\">$&#123;__dirname&#125;</span>/dest`</span>,</span><br><span class=\"line\">    filename: <span class=\"string\">'app-[hash].js'</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在<code>html</code>模板文件中添加以下代码</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>.webpackPublicPath = <span class=\"string\">'&lt;这里可以由后端负责填写&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>上个步骤中后端已经给我们提供了静态资源访问地址了，那么怎么应用到静态资源中呢？创建一个新文件，名字自己定，比如叫做<code>webpack.js</code>。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/* eslint-disable */</span><br><span class=\"line\">__webpack_public_path__ = window.webpackPublicPath;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>在 App 的入口文件的首行添加以下代码，其中<code>./webpack.js</code>就代表第三步创建的文件。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/* eslint-disable import/first */</span><br><span class=\"line\">import &apos;./webpack.js&apos;;</span><br></pre></td></tr></table></figure>\n<p>通过以上 4 个步骤即可实现有后端在代码运行时期指定<code>publicPath</code>了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>一般情况下，我们在使用<code>Webpack</code>时，都会通过以下方式指定<code>publicPath</code>，它表示静态资源的访问地址。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">`<span class=\"subst\">$&#123;__dirname&#125;</span>/dest`</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">'app-[hash].js'</span>,</span><br><span class=\"line\">        publicPath: <span class=\"string\">''</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果你需要把静态资源放在 CDN 上，则同样可行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: <span class=\"string\">`<span class=\"subst\">$&#123;__dirname&#125;</span>/dest`</span>,</span><br><span class=\"line\">        filename: <span class=\"string\">'app-[hash].js'</span>,</span><br><span class=\"line\">        publicPath: <span class=\"string\">'https://cdn.example.com/'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这样就把静态资源的地址写死了，而测试环境和生成环境的静态资源往往存在在不同的地方。OK，下面我就通过<code>__webpack_public_path__</code>变量来实现。</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><ol>\n<li>在<code>webpack</code>配置文件（比如<code>webpack.config.babel.js</code>）中删除<code>publicPath</code>的选项。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: <span class=\"string\">`<span class=\"subst\">$&#123;__dirname&#125;</span>/dest`</span>,</span><br><span class=\"line\">    filename: <span class=\"string\">'app-[hash].js'</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在<code>html</code>模板文件中添加以下代码</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>.webpackPublicPath = <span class=\"string\">'&lt;这里可以由后端负责填写&gt;'</span>;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>上个步骤中后端已经给我们提供了静态资源访问地址了，那么怎么应用到静态资源中呢？创建一个新文件，名字自己定，比如叫做<code>webpack.js</code>。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/* eslint-disable */</span><br><span class=\"line\">__webpack_public_path__ = window.webpackPublicPath;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>在 App 的入口文件的首行添加以下代码，其中<code>./webpack.js</code>就代表第三步创建的文件。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">/* eslint-disable import/first */</span><br><span class=\"line\">import &apos;./webpack.js&apos;;</span><br></pre></td></tr></table></figure>\n<p>通过以上 4 个步骤即可实现有后端在代码运行时期指定<code>publicPath</code>了。</p>\n"},{"title":"打造高效的macOS开发环境 - 添加打印机","_content":"\n公司内使用苹果电脑的并不多，IT 部门给出的相关文档中也很少。怎样在苹果电脑上安装打印机就是这样，IT 部门给出的文章中仅仅说明了如何在 Windows 系统使用打印机，却没有说明在 macOS 系统中怎么做。很长一段时间以来，我都是将要打印的文件发给其他同事，让他们代为打印。\n\n在前些天一次打印时，我就想了，每次都找人帮忙还是挺麻烦的，实在不够极客啊。很多高端用户都使用苹果电脑，打印机厂商没有理由不支持 macOS 系统。因此我决定在我的苹果电脑上安装打印机。\n\n首先我查看了通过 IT 部门提供的文档得知，我们的打印机型号是`FXDocuCentre-II C3000`，`IP`是`192.168.0.8`。在网上进行一番搜索之后，总结了以下操作步骤，以飨读者。\n\n注意，根据`macOS`[官方文档](https://support.apple.com/kb/PH25081?locale=zh_CN)显示，除了“AirPrint”协议之外，还支持“HP Jetdirect – Socket”，“行式打印机监控程序 - LPD”和“互联网打印协议 - IPP”协议等。\n\n![](../../../../images/macos-printer-01.png)\n![](../../../../images/macos-printer-02.png)\n![](../../../../images/macos-printer-03.png)\n![](../../../../images/macos-printer-04.png)\n\n不需要额外安装驱动程序，是不是非常简单，非常优雅呢？\n","source":"_posts/2018-12-06-macos-printer.md","raw":"---\ntitle: 打造高效的macOS开发环境 - 添加打印机\n---\n\n公司内使用苹果电脑的并不多，IT 部门给出的相关文档中也很少。怎样在苹果电脑上安装打印机就是这样，IT 部门给出的文章中仅仅说明了如何在 Windows 系统使用打印机，却没有说明在 macOS 系统中怎么做。很长一段时间以来，我都是将要打印的文件发给其他同事，让他们代为打印。\n\n在前些天一次打印时，我就想了，每次都找人帮忙还是挺麻烦的，实在不够极客啊。很多高端用户都使用苹果电脑，打印机厂商没有理由不支持 macOS 系统。因此我决定在我的苹果电脑上安装打印机。\n\n首先我查看了通过 IT 部门提供的文档得知，我们的打印机型号是`FXDocuCentre-II C3000`，`IP`是`192.168.0.8`。在网上进行一番搜索之后，总结了以下操作步骤，以飨读者。\n\n注意，根据`macOS`[官方文档](https://support.apple.com/kb/PH25081?locale=zh_CN)显示，除了“AirPrint”协议之外，还支持“HP Jetdirect – Socket”，“行式打印机监控程序 - LPD”和“互联网打印协议 - IPP”协议等。\n\n![](../../../../images/macos-printer-01.png)\n![](../../../../images/macos-printer-02.png)\n![](../../../../images/macos-printer-03.png)\n![](../../../../images/macos-printer-04.png)\n\n不需要额外安装驱动程序，是不是非常简单，非常优雅呢？\n","slug":"macos-printer","published":1,"date":"2018-12-05T16:00:00.000Z","updated":"2018-12-07T02:38:22.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfma4001dw8wkoh4fif0m","content":"<p>公司内使用苹果电脑的并不多，IT 部门给出的相关文档中也很少。怎样在苹果电脑上安装打印机就是这样，IT 部门给出的文章中仅仅说明了如何在 Windows 系统使用打印机，却没有说明在 macOS 系统中怎么做。很长一段时间以来，我都是将要打印的文件发给其他同事，让他们代为打印。</p>\n<p>在前些天一次打印时，我就想了，每次都找人帮忙还是挺麻烦的，实在不够极客啊。很多高端用户都使用苹果电脑，打印机厂商没有理由不支持 macOS 系统。因此我决定在我的苹果电脑上安装打印机。</p>\n<p>首先我查看了通过 IT 部门提供的文档得知，我们的打印机型号是<code>FXDocuCentre-II C3000</code>，<code>IP</code>是<code>192.168.0.8</code>。在网上进行一番搜索之后，总结了以下操作步骤，以飨读者。</p>\n<p>注意，根据<code>macOS</code><a href=\"https://support.apple.com/kb/PH25081?locale=zh_CN\" target=\"_blank\" rel=\"noopener\">官方文档</a>显示，除了“AirPrint”协议之外，还支持“HP Jetdirect – Socket”，“行式打印机监控程序 - LPD”和“互联网打印协议 - IPP”协议等。</p>\n<p><img src=\"../../../../images/macos-printer-01.png\" alt=\"\"><br><img src=\"../../../../images/macos-printer-02.png\" alt=\"\"><br><img src=\"../../../../images/macos-printer-03.png\" alt=\"\"><br><img src=\"../../../../images/macos-printer-04.png\" alt=\"\"></p>\n<p>不需要额外安装驱动程序，是不是非常简单，非常优雅呢？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>公司内使用苹果电脑的并不多，IT 部门给出的相关文档中也很少。怎样在苹果电脑上安装打印机就是这样，IT 部门给出的文章中仅仅说明了如何在 Windows 系统使用打印机，却没有说明在 macOS 系统中怎么做。很长一段时间以来，我都是将要打印的文件发给其他同事，让他们代为打印。</p>\n<p>在前些天一次打印时，我就想了，每次都找人帮忙还是挺麻烦的，实在不够极客啊。很多高端用户都使用苹果电脑，打印机厂商没有理由不支持 macOS 系统。因此我决定在我的苹果电脑上安装打印机。</p>\n<p>首先我查看了通过 IT 部门提供的文档得知，我们的打印机型号是<code>FXDocuCentre-II C3000</code>，<code>IP</code>是<code>192.168.0.8</code>。在网上进行一番搜索之后，总结了以下操作步骤，以飨读者。</p>\n<p>注意，根据<code>macOS</code><a href=\"https://support.apple.com/kb/PH25081?locale=zh_CN\" target=\"_blank\" rel=\"noopener\">官方文档</a>显示，除了“AirPrint”协议之外，还支持“HP Jetdirect – Socket”，“行式打印机监控程序 - LPD”和“互联网打印协议 - IPP”协议等。</p>\n<p><img src=\"../../../../images/macos-printer-01.png\" alt=\"\"><br><img src=\"../../../../images/macos-printer-02.png\" alt=\"\"><br><img src=\"../../../../images/macos-printer-03.png\" alt=\"\"><br><img src=\"../../../../images/macos-printer-04.png\" alt=\"\"></p>\n<p>不需要额外安装驱动程序，是不是非常简单，非常优雅呢？</p>\n"},{"title":"【翻译】优秀的用户界面设计","_content":"\n一个好的用户界面不但容易使用，还可以带来很高的转化率。换句话说，它兼顾了商业利益的同时，也让用户更加容易使用。以下是一个不断更新的最佳实践的列表。\n\n1. ###用一列布局代替多列布局\n   一列布局让你对故事有着更多的控制能力，它能够以你预期的方式引导用户从顶部浏览到底部。然而多列布局却有一定风险让用户忽视了该页面的主要目的。用单一故事和底部一个显眼的 Call To Action 引导用户。  \n   ![One Column Layout](http://www.goodui.org/images/idea001.png)\n\n2. ###回赠礼物而不是立即关闭页面\n   以一种友好的姿态，比如回赠顾客一个礼物。更深一个层面讲，回赠礼物是一种有效的基于互惠规则的说服策略。通过礼物表达谢意，将来用户会用好感来报答你。\n   ![Giving a Gift](http://www.goodui.org/images/idea002.png)\n\n3. ###整合相似的功能点，而不是分布的到处都是\n   在整个构建过程中，我们很容易去创建具有相同功能的多个区域，元素和特性。注意有着不同标签的相同功能点，因为他们给用户造成一种压力。通常界面中片段越多，用户的学习曲线越陡峭。一旦你需要将相似功能点放在一个页面时，请考虑重构用户界面。\n   ![Merge simular functions](http://www.goodui.org/images/idea003.png)\n\n4. ###使用社交化证据而不是自卖自夸\n   社交化证据是提高转化率的另一个说服策略。看到别人对你的认可并在讨论你提供的产品和服务，是促使用户 call to action 的一个伟大的方法。尝试使用证书和数据来证明别人在使用你的产品和服务。  \n   ![Social Proof](http://www.goodui.org/images/idea004.png)\n\n5. ###重复显示主要 action，而不要仅仅显示一次\n   较长的页面中适合重复多次显示 Call to Action，你也可以在多个页面中重复显示。当然你不会在同一屏中显示 10 次来激怒用户。长页面变得越来越流行，在顶部提供一个软的可点击按钮，在底部也提供一个，没有坏处。当人们浏览到底部时，他们停下来思考该干什么————a potential solid place to make an offer or close a deal.\n   ![Repeat your primary action](http://www.goodui.org/images/idea005.png)\n\n6. ###对可点击和已选择的条目使用不同的样式\n   可视化的样式，比如颜色，深度，对比等，是帮助用户了解界面导航的一种可靠的暗示：我在那里，我能去哪里。为了能够清楚的告诉用户这些东西，可点击条目（链接，按钮），已选择条目和普通文本应该使用不同的样式，并且在所有界面中达到统一。在下面的例子中，我使用蓝色去标志可点击条目，使用黑色标志已选择条目或者说用户当前位置。样式应用得当的话，用户可以很容易地学会并使用这些暗示。模糊不清的样式会让用户使用起来更加困难。\n   ![Distinct styles between clickable and selected Items.](http://www.goodui.org/images/idea006.png)\n\n7. ###推荐，而不是没有区别的显示各种选择\n   当你提供多种选择时，特别强调和推荐其中一个会比较好，因为大家都需要被怂恿一下。我相信有心理学研究表明，选择越多，做出最后决定的机会越小。为了避免这种现象，请尝试高亮某个选项。\n   ![](http://www.goodui.org/images/idea007.png)\n\n8. ###不让用户确认，而是提供取消操作的功能\n   假设你刚刚按下了一个按钮或者链接，提供取消操作功能会尊重你的意愿，让操作正常执行下去。而确认行为则假定用户不知道他们的操作并且总要确认一下。我相信大多数情况下，用户正确地根据意愿做出操作，只有少数操作是意外。需要重复地确认信息，这是多么低效和丑陋的。通过提供取消操作功能，让你的用户有一切都在掌握之中的感觉，而不是每次都请求用户确认。\n   ![undos](http://www.goodui.org/images/idea008.png)\n\n9. ###告诉你的目标客户群，这是特地为你做的。\n   告诉你的用户，这是为你做的，而不是为所有人做的。你的产品是面向所有用户的吗？还是有着清晰的目标群体？通过限定目标客户，给予一种独占的感觉，你可以更他们交流的更多。这个策略的风险就是限制了潜在的用户群体，透明成就信任。\n   ![Try Telling Who It's For instead of targeting everyone.](http://www.goodui.org/images/idea009.png)\n\n10. ###更加直接而不要犹豫不决\n    你可以以不确定的语气，也可以以非常肯定的的语气传达你的意思。如果你的消息以问号结束，使用“也许”，“可能”，“是否感兴趣？”， “想要”这样的词汇，那么你还可以加强一下语气，告诉用户接下来做什么，对于转化率优化还是有一定空间的。\n    ![Try Being Direct instead of indecisive.](http://www.goodui.org/images/idea010.png)\n\n11. ###使用更大的差异\n    让 CTA 更加突出，与周边其他元素差别更大，会使得 UI 更加强劲。突出主要的 CAT 有以下几种方法，色调可以让某个元素颜色变深或者变浅。最后，也可以使用色环中的互补色（比如黄色和紫色）让差别更大。总之要考虑 CTA 和其他内容的差异。\n    ![More contrast](http://www.goodui.org/images/idea011.png)\n\n12. ###告诉用户该产品的产地\n    告诉用户你在哪里，也就是告诉用户产品或者服务产在何处，同时，留下你个人的联系方式。人们在自我介绍时通常会提及国家，省份或者城市。如果你这么做了，用户会认为你很友好。通常，指出产品的产地也会让用户感觉产品的质量更高一些。这是双赢的。\n    ![Tell the users where you are](http://www.goodui.org/images/idea012.png)\n\n13. ###减少表单项\n    人们生来讨厌劳动密集的任务，这同样适用于填写表单。每一个表单项都增加了用户放弃的风险。每个人的打字速度不同，在手机上打字一般都是个苦差事。思考每个表单项是不是必须的，并尽可能多地删除它们。如果有一些可选的表单项，可以考虑把它们移到表单提交后的另一个页面。繁琐的表单很容易，然后更少的表单项转化率更高。\n    ![Less form fields](http://www.goodui.org/images/idea013.png)\n\n14. ###暴露选项\n    每个下拉菜单都隐藏了一些选项，你要做一些操作才能找到它们。如果这些隐藏的选项是用户完成任务的主线操作，你应该考虑将它们放在明面上。保留哪些可预料的不需要用户思考的下拉菜单，比如日历中的日期和时间，或者国家，省份等地理位置。有时候下拉菜单还可以用于那些用户一直反复使用的行为。当心不要在转化途中的主要项目上使用下拉菜单。\n    ![Avoid to use dropdown menu](http://www.goodui.org/images/idea014.png)\n\n15. ###内容的连续性（章节之间没有大的空隙）\n    错误的底部是转化率杀手。是的，滚动到底部是 OK 的，但是注意不要在节与节之间，给访客一个页面已经结束的感觉。如果页面需要滚屏，那么尝试建立一种可视的模式，用户可以学习这种模式并信赖它去往下读取更多内容。\n    ![Continuity](http://www.goodui.org/images/idea015.png)\n\n16. ###保持关注，而不要淹没在链接中。\n    为了尽可能满足用户的各种需求，很容易就在一个页面中放置了很多链接。然而如果你是为了页面底部的一个特定的 Call to Action 而创建的故事型页面，那你就要再考虑一下了。你要意识到在 CTA 前面的任何链接都有可能带走用户。关注页面中链接数量，平衡好探索性性页面（链接比较重）和通道型页面（更少的链接，更高的转化率）。减少无关的链接可以有效地提高访客到达重要按钮的几率。\n    ![Keeping Focus instead of drowning with links](http://www.goodui.org/images/idea016.png)\n\n17. ###显示状态\n    在用户界面中，可能需要显示有着不同状态的元素。邮件可能是已读，也可能是未读。发票可能是已支付，也可能是未支付。提示用户每一个元素所处的特定状态，是提供反馈的好方法。界面状态可以帮助人们理解他们刚才的操作是否已经执行，以及是否应该进行某项操作。\n    ![Showing State](http://www.goodui.org/images/idea017.png)\n\n18. ###Try Benefit Buttons instead of just task based ones.\n    假设页面上有两个简单的按钮，一个写着“省钱”，一个写着“注册”。我敢打赌第一个按钮有着更高点击率。因为“注册”没有内在的价值。注册过程费事并且通常要填写长长的表单。注明有利可图的按钮有着更高的转化率。或者也可以将利益信息放在操作按钮旁边，来提醒用户为什么他们将要做此操作。当然了，在不是那么需要说服用户并且重复多次使用的情况，还是可以保留任务型按钮的。\n    ![Benifit buttons](http://www.goodui.org/images/idea018.png)\n\n19. ###不要使用没有上下文的菜单，而是使用更加直观的操作按钮。\n    相对于列举一些无关的普通操作选项，能够直接操作特定元素更有意义。举个例子，当显示一组数据时，通常允许用户操作某个数据项。点击或者鼠标悬停在某数据项时，可以显示该数据项可以进行的操作（比如删除，重命名等）。再举一个例子，当点击某个数据项（比如一个地址文本），就会变成一个可编辑的输入框。与那些没有上下文的普通操作，启用这样的交互方式，会减少一些不必要操作步骤。\n    ![Direct Manipulation](http://www.goodui.org/images/idea019.png)\n\n20. ###直接显示表单，而不使用单独页面\n    当创建落地页面来表达价值时，表单最好显示在该页面。相比额外创建几张注册页面，整合注册表单和落地页面带来以下好处：首先，我们去除了流程中额外的步骤，并且占用用户更少的时间。其次，在落地页显示几个表单项，也给用户一种注册过程只要很短时间的感觉。表单越短越容易，当然表单就应该尽可能精简。\n    ![Try Exposing Fields instead of creating separate form pages.](http://www.goodui.org/images/idea020.png)\n\n[点击我查看英文原版](http://www.goodui.org/)\n","source":"_posts/2013-06-28-Good-UI.md","raw":"---\ntitle: 【翻译】优秀的用户界面设计\n---\n\n一个好的用户界面不但容易使用，还可以带来很高的转化率。换句话说，它兼顾了商业利益的同时，也让用户更加容易使用。以下是一个不断更新的最佳实践的列表。\n\n1. ###用一列布局代替多列布局\n   一列布局让你对故事有着更多的控制能力，它能够以你预期的方式引导用户从顶部浏览到底部。然而多列布局却有一定风险让用户忽视了该页面的主要目的。用单一故事和底部一个显眼的 Call To Action 引导用户。  \n   ![One Column Layout](http://www.goodui.org/images/idea001.png)\n\n2. ###回赠礼物而不是立即关闭页面\n   以一种友好的姿态，比如回赠顾客一个礼物。更深一个层面讲，回赠礼物是一种有效的基于互惠规则的说服策略。通过礼物表达谢意，将来用户会用好感来报答你。\n   ![Giving a Gift](http://www.goodui.org/images/idea002.png)\n\n3. ###整合相似的功能点，而不是分布的到处都是\n   在整个构建过程中，我们很容易去创建具有相同功能的多个区域，元素和特性。注意有着不同标签的相同功能点，因为他们给用户造成一种压力。通常界面中片段越多，用户的学习曲线越陡峭。一旦你需要将相似功能点放在一个页面时，请考虑重构用户界面。\n   ![Merge simular functions](http://www.goodui.org/images/idea003.png)\n\n4. ###使用社交化证据而不是自卖自夸\n   社交化证据是提高转化率的另一个说服策略。看到别人对你的认可并在讨论你提供的产品和服务，是促使用户 call to action 的一个伟大的方法。尝试使用证书和数据来证明别人在使用你的产品和服务。  \n   ![Social Proof](http://www.goodui.org/images/idea004.png)\n\n5. ###重复显示主要 action，而不要仅仅显示一次\n   较长的页面中适合重复多次显示 Call to Action，你也可以在多个页面中重复显示。当然你不会在同一屏中显示 10 次来激怒用户。长页面变得越来越流行，在顶部提供一个软的可点击按钮，在底部也提供一个，没有坏处。当人们浏览到底部时，他们停下来思考该干什么————a potential solid place to make an offer or close a deal.\n   ![Repeat your primary action](http://www.goodui.org/images/idea005.png)\n\n6. ###对可点击和已选择的条目使用不同的样式\n   可视化的样式，比如颜色，深度，对比等，是帮助用户了解界面导航的一种可靠的暗示：我在那里，我能去哪里。为了能够清楚的告诉用户这些东西，可点击条目（链接，按钮），已选择条目和普通文本应该使用不同的样式，并且在所有界面中达到统一。在下面的例子中，我使用蓝色去标志可点击条目，使用黑色标志已选择条目或者说用户当前位置。样式应用得当的话，用户可以很容易地学会并使用这些暗示。模糊不清的样式会让用户使用起来更加困难。\n   ![Distinct styles between clickable and selected Items.](http://www.goodui.org/images/idea006.png)\n\n7. ###推荐，而不是没有区别的显示各种选择\n   当你提供多种选择时，特别强调和推荐其中一个会比较好，因为大家都需要被怂恿一下。我相信有心理学研究表明，选择越多，做出最后决定的机会越小。为了避免这种现象，请尝试高亮某个选项。\n   ![](http://www.goodui.org/images/idea007.png)\n\n8. ###不让用户确认，而是提供取消操作的功能\n   假设你刚刚按下了一个按钮或者链接，提供取消操作功能会尊重你的意愿，让操作正常执行下去。而确认行为则假定用户不知道他们的操作并且总要确认一下。我相信大多数情况下，用户正确地根据意愿做出操作，只有少数操作是意外。需要重复地确认信息，这是多么低效和丑陋的。通过提供取消操作功能，让你的用户有一切都在掌握之中的感觉，而不是每次都请求用户确认。\n   ![undos](http://www.goodui.org/images/idea008.png)\n\n9. ###告诉你的目标客户群，这是特地为你做的。\n   告诉你的用户，这是为你做的，而不是为所有人做的。你的产品是面向所有用户的吗？还是有着清晰的目标群体？通过限定目标客户，给予一种独占的感觉，你可以更他们交流的更多。这个策略的风险就是限制了潜在的用户群体，透明成就信任。\n   ![Try Telling Who It's For instead of targeting everyone.](http://www.goodui.org/images/idea009.png)\n\n10. ###更加直接而不要犹豫不决\n    你可以以不确定的语气，也可以以非常肯定的的语气传达你的意思。如果你的消息以问号结束，使用“也许”，“可能”，“是否感兴趣？”， “想要”这样的词汇，那么你还可以加强一下语气，告诉用户接下来做什么，对于转化率优化还是有一定空间的。\n    ![Try Being Direct instead of indecisive.](http://www.goodui.org/images/idea010.png)\n\n11. ###使用更大的差异\n    让 CTA 更加突出，与周边其他元素差别更大，会使得 UI 更加强劲。突出主要的 CAT 有以下几种方法，色调可以让某个元素颜色变深或者变浅。最后，也可以使用色环中的互补色（比如黄色和紫色）让差别更大。总之要考虑 CTA 和其他内容的差异。\n    ![More contrast](http://www.goodui.org/images/idea011.png)\n\n12. ###告诉用户该产品的产地\n    告诉用户你在哪里，也就是告诉用户产品或者服务产在何处，同时，留下你个人的联系方式。人们在自我介绍时通常会提及国家，省份或者城市。如果你这么做了，用户会认为你很友好。通常，指出产品的产地也会让用户感觉产品的质量更高一些。这是双赢的。\n    ![Tell the users where you are](http://www.goodui.org/images/idea012.png)\n\n13. ###减少表单项\n    人们生来讨厌劳动密集的任务，这同样适用于填写表单。每一个表单项都增加了用户放弃的风险。每个人的打字速度不同，在手机上打字一般都是个苦差事。思考每个表单项是不是必须的，并尽可能多地删除它们。如果有一些可选的表单项，可以考虑把它们移到表单提交后的另一个页面。繁琐的表单很容易，然后更少的表单项转化率更高。\n    ![Less form fields](http://www.goodui.org/images/idea013.png)\n\n14. ###暴露选项\n    每个下拉菜单都隐藏了一些选项，你要做一些操作才能找到它们。如果这些隐藏的选项是用户完成任务的主线操作，你应该考虑将它们放在明面上。保留哪些可预料的不需要用户思考的下拉菜单，比如日历中的日期和时间，或者国家，省份等地理位置。有时候下拉菜单还可以用于那些用户一直反复使用的行为。当心不要在转化途中的主要项目上使用下拉菜单。\n    ![Avoid to use dropdown menu](http://www.goodui.org/images/idea014.png)\n\n15. ###内容的连续性（章节之间没有大的空隙）\n    错误的底部是转化率杀手。是的，滚动到底部是 OK 的，但是注意不要在节与节之间，给访客一个页面已经结束的感觉。如果页面需要滚屏，那么尝试建立一种可视的模式，用户可以学习这种模式并信赖它去往下读取更多内容。\n    ![Continuity](http://www.goodui.org/images/idea015.png)\n\n16. ###保持关注，而不要淹没在链接中。\n    为了尽可能满足用户的各种需求，很容易就在一个页面中放置了很多链接。然而如果你是为了页面底部的一个特定的 Call to Action 而创建的故事型页面，那你就要再考虑一下了。你要意识到在 CTA 前面的任何链接都有可能带走用户。关注页面中链接数量，平衡好探索性性页面（链接比较重）和通道型页面（更少的链接，更高的转化率）。减少无关的链接可以有效地提高访客到达重要按钮的几率。\n    ![Keeping Focus instead of drowning with links](http://www.goodui.org/images/idea016.png)\n\n17. ###显示状态\n    在用户界面中，可能需要显示有着不同状态的元素。邮件可能是已读，也可能是未读。发票可能是已支付，也可能是未支付。提示用户每一个元素所处的特定状态，是提供反馈的好方法。界面状态可以帮助人们理解他们刚才的操作是否已经执行，以及是否应该进行某项操作。\n    ![Showing State](http://www.goodui.org/images/idea017.png)\n\n18. ###Try Benefit Buttons instead of just task based ones.\n    假设页面上有两个简单的按钮，一个写着“省钱”，一个写着“注册”。我敢打赌第一个按钮有着更高点击率。因为“注册”没有内在的价值。注册过程费事并且通常要填写长长的表单。注明有利可图的按钮有着更高的转化率。或者也可以将利益信息放在操作按钮旁边，来提醒用户为什么他们将要做此操作。当然了，在不是那么需要说服用户并且重复多次使用的情况，还是可以保留任务型按钮的。\n    ![Benifit buttons](http://www.goodui.org/images/idea018.png)\n\n19. ###不要使用没有上下文的菜单，而是使用更加直观的操作按钮。\n    相对于列举一些无关的普通操作选项，能够直接操作特定元素更有意义。举个例子，当显示一组数据时，通常允许用户操作某个数据项。点击或者鼠标悬停在某数据项时，可以显示该数据项可以进行的操作（比如删除，重命名等）。再举一个例子，当点击某个数据项（比如一个地址文本），就会变成一个可编辑的输入框。与那些没有上下文的普通操作，启用这样的交互方式，会减少一些不必要操作步骤。\n    ![Direct Manipulation](http://www.goodui.org/images/idea019.png)\n\n20. ###直接显示表单，而不使用单独页面\n    当创建落地页面来表达价值时，表单最好显示在该页面。相比额外创建几张注册页面，整合注册表单和落地页面带来以下好处：首先，我们去除了流程中额外的步骤，并且占用用户更少的时间。其次，在落地页显示几个表单项，也给用户一种注册过程只要很短时间的感觉。表单越短越容易，当然表单就应该尽可能精简。\n    ![Try Exposing Fields instead of creating separate form pages.](http://www.goodui.org/images/idea020.png)\n\n[点击我查看英文原版](http://www.goodui.org/)\n","slug":"Good-UI","published":1,"date":"2013-06-27T16:00:00.000Z","updated":"2018-12-07T03:00:29.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmag001ew8wk1h2cujxn","content":"<p>一个好的用户界面不但容易使用，还可以带来很高的转化率。换句话说，它兼顾了商业利益的同时，也让用户更加容易使用。以下是一个不断更新的最佳实践的列表。</p>\n<ol>\n<li><p>###用一列布局代替多列布局<br>一列布局让你对故事有着更多的控制能力，它能够以你预期的方式引导用户从顶部浏览到底部。然而多列布局却有一定风险让用户忽视了该页面的主要目的。用单一故事和底部一个显眼的 Call To Action 引导用户。<br><img src=\"http://www.goodui.org/images/idea001.png\" alt=\"One Column Layout\"></p>\n</li>\n<li><p>###回赠礼物而不是立即关闭页面<br>以一种友好的姿态，比如回赠顾客一个礼物。更深一个层面讲，回赠礼物是一种有效的基于互惠规则的说服策略。通过礼物表达谢意，将来用户会用好感来报答你。<br><img src=\"http://www.goodui.org/images/idea002.png\" alt=\"Giving a Gift\"></p>\n</li>\n<li><p>###整合相似的功能点，而不是分布的到处都是<br>在整个构建过程中，我们很容易去创建具有相同功能的多个区域，元素和特性。注意有着不同标签的相同功能点，因为他们给用户造成一种压力。通常界面中片段越多，用户的学习曲线越陡峭。一旦你需要将相似功能点放在一个页面时，请考虑重构用户界面。<br><img src=\"http://www.goodui.org/images/idea003.png\" alt=\"Merge simular functions\"></p>\n</li>\n<li><p>###使用社交化证据而不是自卖自夸<br>社交化证据是提高转化率的另一个说服策略。看到别人对你的认可并在讨论你提供的产品和服务，是促使用户 call to action 的一个伟大的方法。尝试使用证书和数据来证明别人在使用你的产品和服务。<br><img src=\"http://www.goodui.org/images/idea004.png\" alt=\"Social Proof\"></p>\n</li>\n<li><p>###重复显示主要 action，而不要仅仅显示一次<br>较长的页面中适合重复多次显示 Call to Action，你也可以在多个页面中重复显示。当然你不会在同一屏中显示 10 次来激怒用户。长页面变得越来越流行，在顶部提供一个软的可点击按钮，在底部也提供一个，没有坏处。当人们浏览到底部时，他们停下来思考该干什么————a potential solid place to make an offer or close a deal.<br><img src=\"http://www.goodui.org/images/idea005.png\" alt=\"Repeat your primary action\"></p>\n</li>\n<li><p>###对可点击和已选择的条目使用不同的样式<br>可视化的样式，比如颜色，深度，对比等，是帮助用户了解界面导航的一种可靠的暗示：我在那里，我能去哪里。为了能够清楚的告诉用户这些东西，可点击条目（链接，按钮），已选择条目和普通文本应该使用不同的样式，并且在所有界面中达到统一。在下面的例子中，我使用蓝色去标志可点击条目，使用黑色标志已选择条目或者说用户当前位置。样式应用得当的话，用户可以很容易地学会并使用这些暗示。模糊不清的样式会让用户使用起来更加困难。<br><img src=\"http://www.goodui.org/images/idea006.png\" alt=\"Distinct styles between clickable and selected Items.\"></p>\n</li>\n<li><p>###推荐，而不是没有区别的显示各种选择<br>当你提供多种选择时，特别强调和推荐其中一个会比较好，因为大家都需要被怂恿一下。我相信有心理学研究表明，选择越多，做出最后决定的机会越小。为了避免这种现象，请尝试高亮某个选项。<br><img src=\"http://www.goodui.org/images/idea007.png\" alt=\"\"></p>\n</li>\n<li><p>###不让用户确认，而是提供取消操作的功能<br>假设你刚刚按下了一个按钮或者链接，提供取消操作功能会尊重你的意愿，让操作正常执行下去。而确认行为则假定用户不知道他们的操作并且总要确认一下。我相信大多数情况下，用户正确地根据意愿做出操作，只有少数操作是意外。需要重复地确认信息，这是多么低效和丑陋的。通过提供取消操作功能，让你的用户有一切都在掌握之中的感觉，而不是每次都请求用户确认。<br><img src=\"http://www.goodui.org/images/idea008.png\" alt=\"undos\"></p>\n</li>\n<li><p>###告诉你的目标客户群，这是特地为你做的。<br>告诉你的用户，这是为你做的，而不是为所有人做的。你的产品是面向所有用户的吗？还是有着清晰的目标群体？通过限定目标客户，给予一种独占的感觉，你可以更他们交流的更多。这个策略的风险就是限制了潜在的用户群体，透明成就信任。<br><img src=\"http://www.goodui.org/images/idea009.png\" alt=\"Try Telling Who It&#39;s For instead of targeting everyone.\"></p>\n</li>\n<li><p>###更加直接而不要犹豫不决<br>你可以以不确定的语气，也可以以非常肯定的的语气传达你的意思。如果你的消息以问号结束，使用“也许”，“可能”，“是否感兴趣？”， “想要”这样的词汇，那么你还可以加强一下语气，告诉用户接下来做什么，对于转化率优化还是有一定空间的。<br><img src=\"http://www.goodui.org/images/idea010.png\" alt=\"Try Being Direct instead of indecisive.\"></p>\n</li>\n<li><p>###使用更大的差异<br>让 CTA 更加突出，与周边其他元素差别更大，会使得 UI 更加强劲。突出主要的 CAT 有以下几种方法，色调可以让某个元素颜色变深或者变浅。最后，也可以使用色环中的互补色（比如黄色和紫色）让差别更大。总之要考虑 CTA 和其他内容的差异。<br><img src=\"http://www.goodui.org/images/idea011.png\" alt=\"More contrast\"></p>\n</li>\n<li><p>###告诉用户该产品的产地<br>告诉用户你在哪里，也就是告诉用户产品或者服务产在何处，同时，留下你个人的联系方式。人们在自我介绍时通常会提及国家，省份或者城市。如果你这么做了，用户会认为你很友好。通常，指出产品的产地也会让用户感觉产品的质量更高一些。这是双赢的。<br><img src=\"http://www.goodui.org/images/idea012.png\" alt=\"Tell the users where you are\"></p>\n</li>\n<li><p>###减少表单项<br>人们生来讨厌劳动密集的任务，这同样适用于填写表单。每一个表单项都增加了用户放弃的风险。每个人的打字速度不同，在手机上打字一般都是个苦差事。思考每个表单项是不是必须的，并尽可能多地删除它们。如果有一些可选的表单项，可以考虑把它们移到表单提交后的另一个页面。繁琐的表单很容易，然后更少的表单项转化率更高。<br><img src=\"http://www.goodui.org/images/idea013.png\" alt=\"Less form fields\"></p>\n</li>\n<li><p>###暴露选项<br>每个下拉菜单都隐藏了一些选项，你要做一些操作才能找到它们。如果这些隐藏的选项是用户完成任务的主线操作，你应该考虑将它们放在明面上。保留哪些可预料的不需要用户思考的下拉菜单，比如日历中的日期和时间，或者国家，省份等地理位置。有时候下拉菜单还可以用于那些用户一直反复使用的行为。当心不要在转化途中的主要项目上使用下拉菜单。<br><img src=\"http://www.goodui.org/images/idea014.png\" alt=\"Avoid to use dropdown menu\"></p>\n</li>\n<li><p>###内容的连续性（章节之间没有大的空隙）<br>错误的底部是转化率杀手。是的，滚动到底部是 OK 的，但是注意不要在节与节之间，给访客一个页面已经结束的感觉。如果页面需要滚屏，那么尝试建立一种可视的模式，用户可以学习这种模式并信赖它去往下读取更多内容。<br><img src=\"http://www.goodui.org/images/idea015.png\" alt=\"Continuity\"></p>\n</li>\n<li><p>###保持关注，而不要淹没在链接中。<br>为了尽可能满足用户的各种需求，很容易就在一个页面中放置了很多链接。然而如果你是为了页面底部的一个特定的 Call to Action 而创建的故事型页面，那你就要再考虑一下了。你要意识到在 CTA 前面的任何链接都有可能带走用户。关注页面中链接数量，平衡好探索性性页面（链接比较重）和通道型页面（更少的链接，更高的转化率）。减少无关的链接可以有效地提高访客到达重要按钮的几率。<br><img src=\"http://www.goodui.org/images/idea016.png\" alt=\"Keeping Focus instead of drowning with links\"></p>\n</li>\n<li><p>###显示状态<br>在用户界面中，可能需要显示有着不同状态的元素。邮件可能是已读，也可能是未读。发票可能是已支付，也可能是未支付。提示用户每一个元素所处的特定状态，是提供反馈的好方法。界面状态可以帮助人们理解他们刚才的操作是否已经执行，以及是否应该进行某项操作。<br><img src=\"http://www.goodui.org/images/idea017.png\" alt=\"Showing State\"></p>\n</li>\n<li><p>###Try Benefit Buttons instead of just task based ones.<br>假设页面上有两个简单的按钮，一个写着“省钱”，一个写着“注册”。我敢打赌第一个按钮有着更高点击率。因为“注册”没有内在的价值。注册过程费事并且通常要填写长长的表单。注明有利可图的按钮有着更高的转化率。或者也可以将利益信息放在操作按钮旁边，来提醒用户为什么他们将要做此操作。当然了，在不是那么需要说服用户并且重复多次使用的情况，还是可以保留任务型按钮的。<br><img src=\"http://www.goodui.org/images/idea018.png\" alt=\"Benifit buttons\"></p>\n</li>\n<li><p>###不要使用没有上下文的菜单，而是使用更加直观的操作按钮。<br>相对于列举一些无关的普通操作选项，能够直接操作特定元素更有意义。举个例子，当显示一组数据时，通常允许用户操作某个数据项。点击或者鼠标悬停在某数据项时，可以显示该数据项可以进行的操作（比如删除，重命名等）。再举一个例子，当点击某个数据项（比如一个地址文本），就会变成一个可编辑的输入框。与那些没有上下文的普通操作，启用这样的交互方式，会减少一些不必要操作步骤。<br><img src=\"http://www.goodui.org/images/idea019.png\" alt=\"Direct Manipulation\"></p>\n</li>\n<li><p>###直接显示表单，而不使用单独页面<br>当创建落地页面来表达价值时，表单最好显示在该页面。相比额外创建几张注册页面，整合注册表单和落地页面带来以下好处：首先，我们去除了流程中额外的步骤，并且占用用户更少的时间。其次，在落地页显示几个表单项，也给用户一种注册过程只要很短时间的感觉。表单越短越容易，当然表单就应该尽可能精简。<br><img src=\"http://www.goodui.org/images/idea020.png\" alt=\"Try Exposing Fields instead of creating separate form pages.\"></p>\n</li>\n</ol>\n<p><a href=\"http://www.goodui.org/\" target=\"_blank\" rel=\"noopener\">点击我查看英文原版</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个好的用户界面不但容易使用，还可以带来很高的转化率。换句话说，它兼顾了商业利益的同时，也让用户更加容易使用。以下是一个不断更新的最佳实践的列表。</p>\n<ol>\n<li><p>###用一列布局代替多列布局<br>一列布局让你对故事有着更多的控制能力，它能够以你预期的方式引导用户从顶部浏览到底部。然而多列布局却有一定风险让用户忽视了该页面的主要目的。用单一故事和底部一个显眼的 Call To Action 引导用户。<br><img src=\"http://www.goodui.org/images/idea001.png\" alt=\"One Column Layout\"></p>\n</li>\n<li><p>###回赠礼物而不是立即关闭页面<br>以一种友好的姿态，比如回赠顾客一个礼物。更深一个层面讲，回赠礼物是一种有效的基于互惠规则的说服策略。通过礼物表达谢意，将来用户会用好感来报答你。<br><img src=\"http://www.goodui.org/images/idea002.png\" alt=\"Giving a Gift\"></p>\n</li>\n<li><p>###整合相似的功能点，而不是分布的到处都是<br>在整个构建过程中，我们很容易去创建具有相同功能的多个区域，元素和特性。注意有着不同标签的相同功能点，因为他们给用户造成一种压力。通常界面中片段越多，用户的学习曲线越陡峭。一旦你需要将相似功能点放在一个页面时，请考虑重构用户界面。<br><img src=\"http://www.goodui.org/images/idea003.png\" alt=\"Merge simular functions\"></p>\n</li>\n<li><p>###使用社交化证据而不是自卖自夸<br>社交化证据是提高转化率的另一个说服策略。看到别人对你的认可并在讨论你提供的产品和服务，是促使用户 call to action 的一个伟大的方法。尝试使用证书和数据来证明别人在使用你的产品和服务。<br><img src=\"http://www.goodui.org/images/idea004.png\" alt=\"Social Proof\"></p>\n</li>\n<li><p>###重复显示主要 action，而不要仅仅显示一次<br>较长的页面中适合重复多次显示 Call to Action，你也可以在多个页面中重复显示。当然你不会在同一屏中显示 10 次来激怒用户。长页面变得越来越流行，在顶部提供一个软的可点击按钮，在底部也提供一个，没有坏处。当人们浏览到底部时，他们停下来思考该干什么————a potential solid place to make an offer or close a deal.<br><img src=\"http://www.goodui.org/images/idea005.png\" alt=\"Repeat your primary action\"></p>\n</li>\n<li><p>###对可点击和已选择的条目使用不同的样式<br>可视化的样式，比如颜色，深度，对比等，是帮助用户了解界面导航的一种可靠的暗示：我在那里，我能去哪里。为了能够清楚的告诉用户这些东西，可点击条目（链接，按钮），已选择条目和普通文本应该使用不同的样式，并且在所有界面中达到统一。在下面的例子中，我使用蓝色去标志可点击条目，使用黑色标志已选择条目或者说用户当前位置。样式应用得当的话，用户可以很容易地学会并使用这些暗示。模糊不清的样式会让用户使用起来更加困难。<br><img src=\"http://www.goodui.org/images/idea006.png\" alt=\"Distinct styles between clickable and selected Items.\"></p>\n</li>\n<li><p>###推荐，而不是没有区别的显示各种选择<br>当你提供多种选择时，特别强调和推荐其中一个会比较好，因为大家都需要被怂恿一下。我相信有心理学研究表明，选择越多，做出最后决定的机会越小。为了避免这种现象，请尝试高亮某个选项。<br><img src=\"http://www.goodui.org/images/idea007.png\" alt=\"\"></p>\n</li>\n<li><p>###不让用户确认，而是提供取消操作的功能<br>假设你刚刚按下了一个按钮或者链接，提供取消操作功能会尊重你的意愿，让操作正常执行下去。而确认行为则假定用户不知道他们的操作并且总要确认一下。我相信大多数情况下，用户正确地根据意愿做出操作，只有少数操作是意外。需要重复地确认信息，这是多么低效和丑陋的。通过提供取消操作功能，让你的用户有一切都在掌握之中的感觉，而不是每次都请求用户确认。<br><img src=\"http://www.goodui.org/images/idea008.png\" alt=\"undos\"></p>\n</li>\n<li><p>###告诉你的目标客户群，这是特地为你做的。<br>告诉你的用户，这是为你做的，而不是为所有人做的。你的产品是面向所有用户的吗？还是有着清晰的目标群体？通过限定目标客户，给予一种独占的感觉，你可以更他们交流的更多。这个策略的风险就是限制了潜在的用户群体，透明成就信任。<br><img src=\"http://www.goodui.org/images/idea009.png\" alt=\"Try Telling Who It&#39;s For instead of targeting everyone.\"></p>\n</li>\n<li><p>###更加直接而不要犹豫不决<br>你可以以不确定的语气，也可以以非常肯定的的语气传达你的意思。如果你的消息以问号结束，使用“也许”，“可能”，“是否感兴趣？”， “想要”这样的词汇，那么你还可以加强一下语气，告诉用户接下来做什么，对于转化率优化还是有一定空间的。<br><img src=\"http://www.goodui.org/images/idea010.png\" alt=\"Try Being Direct instead of indecisive.\"></p>\n</li>\n<li><p>###使用更大的差异<br>让 CTA 更加突出，与周边其他元素差别更大，会使得 UI 更加强劲。突出主要的 CAT 有以下几种方法，色调可以让某个元素颜色变深或者变浅。最后，也可以使用色环中的互补色（比如黄色和紫色）让差别更大。总之要考虑 CTA 和其他内容的差异。<br><img src=\"http://www.goodui.org/images/idea011.png\" alt=\"More contrast\"></p>\n</li>\n<li><p>###告诉用户该产品的产地<br>告诉用户你在哪里，也就是告诉用户产品或者服务产在何处，同时，留下你个人的联系方式。人们在自我介绍时通常会提及国家，省份或者城市。如果你这么做了，用户会认为你很友好。通常，指出产品的产地也会让用户感觉产品的质量更高一些。这是双赢的。<br><img src=\"http://www.goodui.org/images/idea012.png\" alt=\"Tell the users where you are\"></p>\n</li>\n<li><p>###减少表单项<br>人们生来讨厌劳动密集的任务，这同样适用于填写表单。每一个表单项都增加了用户放弃的风险。每个人的打字速度不同，在手机上打字一般都是个苦差事。思考每个表单项是不是必须的，并尽可能多地删除它们。如果有一些可选的表单项，可以考虑把它们移到表单提交后的另一个页面。繁琐的表单很容易，然后更少的表单项转化率更高。<br><img src=\"http://www.goodui.org/images/idea013.png\" alt=\"Less form fields\"></p>\n</li>\n<li><p>###暴露选项<br>每个下拉菜单都隐藏了一些选项，你要做一些操作才能找到它们。如果这些隐藏的选项是用户完成任务的主线操作，你应该考虑将它们放在明面上。保留哪些可预料的不需要用户思考的下拉菜单，比如日历中的日期和时间，或者国家，省份等地理位置。有时候下拉菜单还可以用于那些用户一直反复使用的行为。当心不要在转化途中的主要项目上使用下拉菜单。<br><img src=\"http://www.goodui.org/images/idea014.png\" alt=\"Avoid to use dropdown menu\"></p>\n</li>\n<li><p>###内容的连续性（章节之间没有大的空隙）<br>错误的底部是转化率杀手。是的，滚动到底部是 OK 的，但是注意不要在节与节之间，给访客一个页面已经结束的感觉。如果页面需要滚屏，那么尝试建立一种可视的模式，用户可以学习这种模式并信赖它去往下读取更多内容。<br><img src=\"http://www.goodui.org/images/idea015.png\" alt=\"Continuity\"></p>\n</li>\n<li><p>###保持关注，而不要淹没在链接中。<br>为了尽可能满足用户的各种需求，很容易就在一个页面中放置了很多链接。然而如果你是为了页面底部的一个特定的 Call to Action 而创建的故事型页面，那你就要再考虑一下了。你要意识到在 CTA 前面的任何链接都有可能带走用户。关注页面中链接数量，平衡好探索性性页面（链接比较重）和通道型页面（更少的链接，更高的转化率）。减少无关的链接可以有效地提高访客到达重要按钮的几率。<br><img src=\"http://www.goodui.org/images/idea016.png\" alt=\"Keeping Focus instead of drowning with links\"></p>\n</li>\n<li><p>###显示状态<br>在用户界面中，可能需要显示有着不同状态的元素。邮件可能是已读，也可能是未读。发票可能是已支付，也可能是未支付。提示用户每一个元素所处的特定状态，是提供反馈的好方法。界面状态可以帮助人们理解他们刚才的操作是否已经执行，以及是否应该进行某项操作。<br><img src=\"http://www.goodui.org/images/idea017.png\" alt=\"Showing State\"></p>\n</li>\n<li><p>###Try Benefit Buttons instead of just task based ones.<br>假设页面上有两个简单的按钮，一个写着“省钱”，一个写着“注册”。我敢打赌第一个按钮有着更高点击率。因为“注册”没有内在的价值。注册过程费事并且通常要填写长长的表单。注明有利可图的按钮有着更高的转化率。或者也可以将利益信息放在操作按钮旁边，来提醒用户为什么他们将要做此操作。当然了，在不是那么需要说服用户并且重复多次使用的情况，还是可以保留任务型按钮的。<br><img src=\"http://www.goodui.org/images/idea018.png\" alt=\"Benifit buttons\"></p>\n</li>\n<li><p>###不要使用没有上下文的菜单，而是使用更加直观的操作按钮。<br>相对于列举一些无关的普通操作选项，能够直接操作特定元素更有意义。举个例子，当显示一组数据时，通常允许用户操作某个数据项。点击或者鼠标悬停在某数据项时，可以显示该数据项可以进行的操作（比如删除，重命名等）。再举一个例子，当点击某个数据项（比如一个地址文本），就会变成一个可编辑的输入框。与那些没有上下文的普通操作，启用这样的交互方式，会减少一些不必要操作步骤。<br><img src=\"http://www.goodui.org/images/idea019.png\" alt=\"Direct Manipulation\"></p>\n</li>\n<li><p>###直接显示表单，而不使用单独页面<br>当创建落地页面来表达价值时，表单最好显示在该页面。相比额外创建几张注册页面，整合注册表单和落地页面带来以下好处：首先，我们去除了流程中额外的步骤，并且占用用户更少的时间。其次，在落地页显示几个表单项，也给用户一种注册过程只要很短时间的感觉。表单越短越容易，当然表单就应该尽可能精简。<br><img src=\"http://www.goodui.org/images/idea020.png\" alt=\"Try Exposing Fields instead of creating separate form pages.\"></p>\n</li>\n</ol>\n<p><a href=\"http://www.goodui.org/\" target=\"_blank\" rel=\"noopener\">点击我查看英文原版</a></p>\n"},{"title":"【翻译】RequireJS的五个有用的小技巧","_content":"\n[查看原文](http://tech.pro/blog/1561/five-helpful-tips-when-using-requirejs)\n\nRequireJS--Javascript 的文件和模块加载器--是 Web 应用中组织，管理，构建和加载 Javascript 的一种很强大的方式。我已经使用它好几年了，and while it's admittedly difficult to limit myself to only five, 我要是早点知道这几条提示就好了。注意，该文章假定你了解 RequireJS，或者至少知道 AMD，CommonJS 和脚本加载器。RequireJS 官方网站是一个让你知其然并且知其所以然的很好的站点。\n\n在这篇文章中，我们仅仅关注在 RequireJS 本身，而不包括 r.js（RequireJS 的优化工具）。我打算以后写一篇关于 r.js 的文章。\n\n## 1. 知道定义模块的几种方式\n\n大多数使用 RequireJS 的人都知道以下这种定义模块的方法。\n\n```js\ndefine(['dependencyA', 'dependencyB'], function(depA, depB) {\n    /* module code here using depA and depB */\n    return myModule;\n});\n```\n\n在 98%的情况下，我使用上面的方法。但是还有其他几种选择，选择哪种，取决于你的需要。一个模块不需要任何依赖，那么你可以这么做：\n\n```js\ndefine({\n    someProp: 'Oooh, how interesting!',\n    someMethod: function() {\n        // do interesting work\n        return compellingValue;\n    },\n});\n```\n\n如果这个模块没有任何依赖，但是你需要做一些准备工作或者保存私有状态，那么你可以这么做：\n\n```js\ndefine(function(){\n  var secretValue = 'seekret';\n  // do other initialization work here...\n  return {\n    someProp: 'Oooh, how interesting!',\n    tellMeSecrets: function(){\n      // do interesting work\n      return secretValue;\n    }\n  };\n}\n});\n```\n\n## 2. 怎么配合非 AMD 库一起工作\n\n世界上有非常多的很好的 Javascript 库，大多数都没有遵循 AMD 规范，但是不用担心，你照样可以使用它们。从 RequireJS 2.1.0 版本开始，RequireJS 有了一个叫做‘shim’的特性，让你设置你要用到的哪些不满足 AMD 规范的库，并且像其他 AMD 库一样加载进来。下面我们来看个非 AMD 库的例子。  \n**加载没有依赖的非 AMD 库**  \n你获取还记得 Backbone 和 Underscore 取消 AMD 支持的情景，多亏了 shim 特性，我们依然可以容易地在 RequireJS 中使用这些库。\n\n```js\nrequire.config({\n    paths: {\n        underscore: 'libs/underscore.min',\n    },\n    shim: {\n        underscore: {\n            exports: '_',\n        },\n    },\n});\n```\n\n上面的 require.config 调用中我们提供了压缩后的 underscore.js 文件路径，后面在 shim 对象中，添加了一个和同样的属性，并且值是一个对象，它有一个 exports 属性，用来告诉 RequireJS 全局对象（如果是浏览器的话当然就 window 对象了）上某个属性就是这个模块实际值。既然 Underscore 把自己声明为 window 上的*属性，那么我们就让 exports 的值为*。从此以后，如果有一个 AMD 模块依赖 Underscore，RequireJS 会用全局对象的\\_值代替。  \n这个例子很简单，因为 Underscore 没有任意依赖。那么如果加载一个有其他依赖的非 AMD 库吗？  \n**加载有依赖的非 AMD 库**  \n下面我们看看怎么加载依赖于 Underscore 和 jQuery 的 Backbone 吧。\n\n```js\nrequire.config({\n    paths: {\n        jquery: 'libs/jquery.min',\n        backbone: 'libs/backbone.min',\n        underscore: 'libs/underscore.min',\n    },\n    shim: {\n        underscore: {\n            exports: '_',\n        },\n        backbone: {\n            deps: ['jquery', 'underscore'],\n            exports: 'Backbone',\n        },\n    },\n});\n```\n\nBackbone 的 shim 配置除了 exports 属性外还有 deps 属性，deps 是一个包含了 Backbone 所有依赖的库名字数组，他们必须先于 Underscore 加载，一旦这些依赖加载完成之后，Backbone 也会被加载，然后 RequireJS 就会从全局对象上获取 Backbone 属性来作为 backbone 模块的值。  \n那么 CommonJS 又是怎样的呢？  \n假定你要 RequireJS 中使用一个 CommonJS 模块，没问题，你可以定义一个模块，并提供一个带有三个参数的工厂函数，这三个函数分别是：require，exports 和 module。多数情况下你都可以忽略其他两个参数，而只考虑如何使用 require 参数。通过 require 参数可以通过 CommonJS 的语法获取一个模块，比如：\n\n```js\ndefine(function(require, exports, module) {\n    var cjs = require('myCommonJSModule');\n    return {\n        findDroids: function(droids) {\n            var res = [],\n                i = 0,\n                len = droids.length;\n            for (; i < len; i++) {\n                if (cjs.isDroidWareLookingFor(droids[i])) {\n                    res.push(droids[i]);\n                }\n            }\n            return res;\n        },\n    };\n});\n```\n\n特别注意我接下来的一片关于 r.js 的文章，当你使用 r.js 优化工具时，也可以使用更多的 CommonJS 工具库。你可以选择将 CommonJS 模块转换成用 deine()方法包裹起来的模块。你还需要知道，如果你的 CommonJS 模块有分支逻辑去有条件地调用 require，那么转换方法就会失效。比如上面的 myCommonJSModule 有以下内部逻辑（参考代码片段中去思考是什么让它不能和 RequireJS 不能一起工作）：\n\n```js\n// inside myCommonJSModule\nmodule.exports = {\n    isDroidWeAreLookingFor: function(droid) {\n        var finder;\n        // OHSNAP! The conditional logic around require\n        // means we cannot wrap it with define in RequireJS\n        if (isObiWanPresent) {\n            finder = require('forceFilter');\n        } else {\n            finder = require('normalFilter');\n        }\n        return finder.find(droid);\n    },\n};\n```\n\n## 3. CND Fallbacks\n\n虽然 CDN（内容分发网络）可以提高站点的加载性能，但是不希望万一 CDN 挂掉时，你的站点也会挂掉。幸好 RequireJS 可以容易地设置后备地址。一般配置如下：\n\n```js\nrequire.config({\n    paths: {\n        kendoui: 'http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js',\n    },\n});\n```\n\n当然我们希望 CDN 永远不会挂掉，但是如果它挂掉了，我们可以通过修改配置来使用后备地址：\n\n```js\nrequire.config({\n    paths: {\n        kendoui: ['http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js', 'libs/kendoui/kendoui.min'],\n    },\n});\n```\n\n我们给 kendoui 设置了一个地址数组，而不再是一个字符串，根据以上配置，RequireJS 将会尝试从 CDN 上加载，如果失败了，再尝试从第二个地址加载。使用后备地址的确会使得脚本加载时间变长，但是总比站点不可用要好得多。\n\n## 4. 插件\n\nRequireJS 中最好的一个增值点或许就是加载插件。加载插件可以用来加载各种非 Javascript 资源，就像其他依赖模块一样加载他们。最常见的是文本插件，它允许你加载一个普通文本文件（比如 HTML 或者 CSS 等），这对加载模板特别有用。为了让你理解它多么有用，让我们看看今天人们是怎么使用它的。\n\n下面的代码片段展示了 Backbone 视图怎样获取 unders.js 模板内容，预编译，然后渲染页面，但是代码中你却看不到 RequireJS/text 插件的痕迹。\n\n```js\nvar MyView = Backbone.View.extends({\n    initialize: function() {\n        this.template = _.template($('generated-gif-template').text());\n    },\n    render: function() {\n        this.$el.html(this.template(this.model.toJSON()));\n    },\n});\n```\n\n注意到这个视图应该放在页面里面。很多人会添加一个`script`标签，并给出一个假冒的`type`属性（这样就不会被当做 Javascript 执行），将模板内容放进去，如下：\n\n```html\n<script type=\"text/underscore-template\" id=\"generated-gif-template\">\n    <span class=\"glyphicon glyphicon-remove\"></span>\n    <a href=\"<%= dataURL %>\" download=\"<%= id %>\">\n      <span class=\"glyphicon glyphicon-save\"></span>\n    </a>\n    <img src=\"<%= dataURL %>\" class=\"img-thumbnail gif-item\">\n    <div>\n      <input style=\"display:none\" type=\"text\" id=\"fileName\" value=\"<%= fileName %>\" />\n      <span id=\"lblFileName\"><%= fileName %></span>\n    </div>\n</script>\n```\n\n这方法肯定是可行的，但是有一些缺点。把模板内容嵌套在 script 标签中会丧失语法高亮和其他 IDE 提供的功能。这个模板必须出现在所有要使用它的页面。在一个多页面的站点中，这意味着你可能要多次拷贝模板内容，或者额外的构建步骤将模板嵌入每个目标 HTML 页面。在 AMD 应用中，像这样将模板保存在 DOM 中意味着该模块除了显示传递给它的依赖之外，还依赖其他东西。这使得你的应用比较脆弱。理想情况下，我们希望将模板传递给我们的模块，就像其他的脚本依赖一样。这就是文本插件产生的原因。\n\n```js\ndefine(['backbone', 'text!templates/generated-gif.html'], function(Backbone, template) {\n    return Backbone.View.extend({\n        initialize: function() {\n            this.template = _.template(template);\n        },\n        render: function() {\n            this.$el.html(this.template(this.model.toJSON()));\n        },\n    });\n});\n```\n\n我们将模板路径作为依赖加进来，用`text!`作为前缀，来告诉 RequireJS 使用一个叫做 text 的插件来处理。模板的文本内容作为`template`参数传递给模块。使用这个方法有如下好处：  \n（一）开发过程中，模板作为一个单独的文件存在，因此我们使用 IDE 带给我们的便利（语法高亮等），还避免了我们必须穿过数百行甚至更多的 HTML 代码去编辑代码。  \n（二）模板可以和其他模块同等对待，显示传递到模块中，让模块对模板的依赖更加显而易见。这和当模块执行时期望模板在 DOM 中正好相反。  \n当我们使用 r.js 构建和优化 RequireJS 应用时，模板可以和其他模板一起部署，因为文本插件可以有效地将模板包装在模块定义调用中，创建一个返回模板文件内容的模块。  \n以上就是对文本插件的惊鸿一瞥，下面是其他一些插件。  \n[i18n](http://requirejs.org/docs/api.html#i18n) - 国际化  \n[image](https://github.com/millermedeiros/requirejs-plugins) - 像加载其他模块一样加载图片  \n[mdown](https://github.com/millermedeiros/requirejs-plugins/) - 加载 markdown 文件，它会给你编译成 html  \n[font](https://github.com/millermedeiros/requirejs-plugins) - 加载 Web 字体\n\n## 5. 故障检修小技巧\n\n你可以在代码中使用以下 API，我还发现在 Chrome 控制台中也非常有用。  \n`require.defined(moduleId)` - 返回 true 如果该模块已经被定义并且可用。\n`require.specified(moduleId)` - 返回 true 如果该模块被其他模块依赖。该函数返回 true 并不意味着该模块可用。\n`requirejs.s.contexts._.config` - 我从[Vernon Kesner](https://twitter.com/vernonk)那里学来的这招。这是一个技术上的后门，文档中没有说明的方法，所以它可能在没有任何警告的情况下被修改或者去除。但是它返回一个非常有用的包含配置信息的对象。  \n以下是在 Chrome 控制台中它返回结果：  \n![Chrome控制台中它返回结果](http://tpstatic.com/img/usermedia/_TBvB2AB50KM-TASuLKFsw/w645.png)  \n以上就是我在 Devlink 用来演示[Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker)的一个[生成 GIF 示例应用](https://github.com/ifandelse/gif-stitch)中调用 requirejs.s.contexts.\\_.config 返回的结果。你可以看到所有相关配置数据：根 URL，路径，shim 配置等。\n当进行 Debug 时其他两个关键是`errbacks`和`requirejs.onError`方法。  \n`RequireJS ‘errbacks’`\n当你调用`require`时，可以传入第三个参数-发生错误时的回调，允许你对错误做出反应，而不是产生一个未捕获的异常。比如：\n\n```js\nrequire(['backbone'], function(Backbone) {\n    return Backbone.View.extend({\n        /* your magic here */\n    });\n}, function(err) {\n    /* \n      err has err.requireType (timeout, nodefine, scripterror)\n      and err.requireModules (an array of module Ids/paths)\n      Inside here you could requirejs.undef('backbone') to clear\n      the module from require locally - and you could even redefine\n      it here or fetch it from a different location (though the\n      fallback approach earlier takes care of this use-case more succinctly)\n    */\n});\n```\n\n`requirejs.onError`  \nRequireJS 有一个全局的错误处理函数，它可以捕捉到所有未被`errbacks`处理的异常。代码如下：\n\n```js\nrequirejs.onError = function(err) {\n    /* \n    err has the same info as the errback callback:\n    err.requireType & err.requireModules\n  */\n    console.log(err.requireType);\n    // Be sure to rethrow if you don't want to\n    // blindly swallow exceptions here!!!\n};\n```\n\n## 总结\n\n无论你是刚接触 RequireJS 或者已有很多经验的用户，就像我前面提到的，我将会在另一篇文章中介绍`r.js`，敬请期待。你是否发现了其他有用的关于 RequireJS 使用的技巧，方法和 API，期待你的交流。\n","source":"_posts/2013-09-12-Five-Helpful-Tips-When-Using-RequireJS.md","raw":"---\ntitle: 【翻译】RequireJS的五个有用的小技巧\n---\n\n[查看原文](http://tech.pro/blog/1561/five-helpful-tips-when-using-requirejs)\n\nRequireJS--Javascript 的文件和模块加载器--是 Web 应用中组织，管理，构建和加载 Javascript 的一种很强大的方式。我已经使用它好几年了，and while it's admittedly difficult to limit myself to only five, 我要是早点知道这几条提示就好了。注意，该文章假定你了解 RequireJS，或者至少知道 AMD，CommonJS 和脚本加载器。RequireJS 官方网站是一个让你知其然并且知其所以然的很好的站点。\n\n在这篇文章中，我们仅仅关注在 RequireJS 本身，而不包括 r.js（RequireJS 的优化工具）。我打算以后写一篇关于 r.js 的文章。\n\n## 1. 知道定义模块的几种方式\n\n大多数使用 RequireJS 的人都知道以下这种定义模块的方法。\n\n```js\ndefine(['dependencyA', 'dependencyB'], function(depA, depB) {\n    /* module code here using depA and depB */\n    return myModule;\n});\n```\n\n在 98%的情况下，我使用上面的方法。但是还有其他几种选择，选择哪种，取决于你的需要。一个模块不需要任何依赖，那么你可以这么做：\n\n```js\ndefine({\n    someProp: 'Oooh, how interesting!',\n    someMethod: function() {\n        // do interesting work\n        return compellingValue;\n    },\n});\n```\n\n如果这个模块没有任何依赖，但是你需要做一些准备工作或者保存私有状态，那么你可以这么做：\n\n```js\ndefine(function(){\n  var secretValue = 'seekret';\n  // do other initialization work here...\n  return {\n    someProp: 'Oooh, how interesting!',\n    tellMeSecrets: function(){\n      // do interesting work\n      return secretValue;\n    }\n  };\n}\n});\n```\n\n## 2. 怎么配合非 AMD 库一起工作\n\n世界上有非常多的很好的 Javascript 库，大多数都没有遵循 AMD 规范，但是不用担心，你照样可以使用它们。从 RequireJS 2.1.0 版本开始，RequireJS 有了一个叫做‘shim’的特性，让你设置你要用到的哪些不满足 AMD 规范的库，并且像其他 AMD 库一样加载进来。下面我们来看个非 AMD 库的例子。  \n**加载没有依赖的非 AMD 库**  \n你获取还记得 Backbone 和 Underscore 取消 AMD 支持的情景，多亏了 shim 特性，我们依然可以容易地在 RequireJS 中使用这些库。\n\n```js\nrequire.config({\n    paths: {\n        underscore: 'libs/underscore.min',\n    },\n    shim: {\n        underscore: {\n            exports: '_',\n        },\n    },\n});\n```\n\n上面的 require.config 调用中我们提供了压缩后的 underscore.js 文件路径，后面在 shim 对象中，添加了一个和同样的属性，并且值是一个对象，它有一个 exports 属性，用来告诉 RequireJS 全局对象（如果是浏览器的话当然就 window 对象了）上某个属性就是这个模块实际值。既然 Underscore 把自己声明为 window 上的*属性，那么我们就让 exports 的值为*。从此以后，如果有一个 AMD 模块依赖 Underscore，RequireJS 会用全局对象的\\_值代替。  \n这个例子很简单，因为 Underscore 没有任意依赖。那么如果加载一个有其他依赖的非 AMD 库吗？  \n**加载有依赖的非 AMD 库**  \n下面我们看看怎么加载依赖于 Underscore 和 jQuery 的 Backbone 吧。\n\n```js\nrequire.config({\n    paths: {\n        jquery: 'libs/jquery.min',\n        backbone: 'libs/backbone.min',\n        underscore: 'libs/underscore.min',\n    },\n    shim: {\n        underscore: {\n            exports: '_',\n        },\n        backbone: {\n            deps: ['jquery', 'underscore'],\n            exports: 'Backbone',\n        },\n    },\n});\n```\n\nBackbone 的 shim 配置除了 exports 属性外还有 deps 属性，deps 是一个包含了 Backbone 所有依赖的库名字数组，他们必须先于 Underscore 加载，一旦这些依赖加载完成之后，Backbone 也会被加载，然后 RequireJS 就会从全局对象上获取 Backbone 属性来作为 backbone 模块的值。  \n那么 CommonJS 又是怎样的呢？  \n假定你要 RequireJS 中使用一个 CommonJS 模块，没问题，你可以定义一个模块，并提供一个带有三个参数的工厂函数，这三个函数分别是：require，exports 和 module。多数情况下你都可以忽略其他两个参数，而只考虑如何使用 require 参数。通过 require 参数可以通过 CommonJS 的语法获取一个模块，比如：\n\n```js\ndefine(function(require, exports, module) {\n    var cjs = require('myCommonJSModule');\n    return {\n        findDroids: function(droids) {\n            var res = [],\n                i = 0,\n                len = droids.length;\n            for (; i < len; i++) {\n                if (cjs.isDroidWareLookingFor(droids[i])) {\n                    res.push(droids[i]);\n                }\n            }\n            return res;\n        },\n    };\n});\n```\n\n特别注意我接下来的一片关于 r.js 的文章，当你使用 r.js 优化工具时，也可以使用更多的 CommonJS 工具库。你可以选择将 CommonJS 模块转换成用 deine()方法包裹起来的模块。你还需要知道，如果你的 CommonJS 模块有分支逻辑去有条件地调用 require，那么转换方法就会失效。比如上面的 myCommonJSModule 有以下内部逻辑（参考代码片段中去思考是什么让它不能和 RequireJS 不能一起工作）：\n\n```js\n// inside myCommonJSModule\nmodule.exports = {\n    isDroidWeAreLookingFor: function(droid) {\n        var finder;\n        // OHSNAP! The conditional logic around require\n        // means we cannot wrap it with define in RequireJS\n        if (isObiWanPresent) {\n            finder = require('forceFilter');\n        } else {\n            finder = require('normalFilter');\n        }\n        return finder.find(droid);\n    },\n};\n```\n\n## 3. CND Fallbacks\n\n虽然 CDN（内容分发网络）可以提高站点的加载性能，但是不希望万一 CDN 挂掉时，你的站点也会挂掉。幸好 RequireJS 可以容易地设置后备地址。一般配置如下：\n\n```js\nrequire.config({\n    paths: {\n        kendoui: 'http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js',\n    },\n});\n```\n\n当然我们希望 CDN 永远不会挂掉，但是如果它挂掉了，我们可以通过修改配置来使用后备地址：\n\n```js\nrequire.config({\n    paths: {\n        kendoui: ['http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js', 'libs/kendoui/kendoui.min'],\n    },\n});\n```\n\n我们给 kendoui 设置了一个地址数组，而不再是一个字符串，根据以上配置，RequireJS 将会尝试从 CDN 上加载，如果失败了，再尝试从第二个地址加载。使用后备地址的确会使得脚本加载时间变长，但是总比站点不可用要好得多。\n\n## 4. 插件\n\nRequireJS 中最好的一个增值点或许就是加载插件。加载插件可以用来加载各种非 Javascript 资源，就像其他依赖模块一样加载他们。最常见的是文本插件，它允许你加载一个普通文本文件（比如 HTML 或者 CSS 等），这对加载模板特别有用。为了让你理解它多么有用，让我们看看今天人们是怎么使用它的。\n\n下面的代码片段展示了 Backbone 视图怎样获取 unders.js 模板内容，预编译，然后渲染页面，但是代码中你却看不到 RequireJS/text 插件的痕迹。\n\n```js\nvar MyView = Backbone.View.extends({\n    initialize: function() {\n        this.template = _.template($('generated-gif-template').text());\n    },\n    render: function() {\n        this.$el.html(this.template(this.model.toJSON()));\n    },\n});\n```\n\n注意到这个视图应该放在页面里面。很多人会添加一个`script`标签，并给出一个假冒的`type`属性（这样就不会被当做 Javascript 执行），将模板内容放进去，如下：\n\n```html\n<script type=\"text/underscore-template\" id=\"generated-gif-template\">\n    <span class=\"glyphicon glyphicon-remove\"></span>\n    <a href=\"<%= dataURL %>\" download=\"<%= id %>\">\n      <span class=\"glyphicon glyphicon-save\"></span>\n    </a>\n    <img src=\"<%= dataURL %>\" class=\"img-thumbnail gif-item\">\n    <div>\n      <input style=\"display:none\" type=\"text\" id=\"fileName\" value=\"<%= fileName %>\" />\n      <span id=\"lblFileName\"><%= fileName %></span>\n    </div>\n</script>\n```\n\n这方法肯定是可行的，但是有一些缺点。把模板内容嵌套在 script 标签中会丧失语法高亮和其他 IDE 提供的功能。这个模板必须出现在所有要使用它的页面。在一个多页面的站点中，这意味着你可能要多次拷贝模板内容，或者额外的构建步骤将模板嵌入每个目标 HTML 页面。在 AMD 应用中，像这样将模板保存在 DOM 中意味着该模块除了显示传递给它的依赖之外，还依赖其他东西。这使得你的应用比较脆弱。理想情况下，我们希望将模板传递给我们的模块，就像其他的脚本依赖一样。这就是文本插件产生的原因。\n\n```js\ndefine(['backbone', 'text!templates/generated-gif.html'], function(Backbone, template) {\n    return Backbone.View.extend({\n        initialize: function() {\n            this.template = _.template(template);\n        },\n        render: function() {\n            this.$el.html(this.template(this.model.toJSON()));\n        },\n    });\n});\n```\n\n我们将模板路径作为依赖加进来，用`text!`作为前缀，来告诉 RequireJS 使用一个叫做 text 的插件来处理。模板的文本内容作为`template`参数传递给模块。使用这个方法有如下好处：  \n（一）开发过程中，模板作为一个单独的文件存在，因此我们使用 IDE 带给我们的便利（语法高亮等），还避免了我们必须穿过数百行甚至更多的 HTML 代码去编辑代码。  \n（二）模板可以和其他模块同等对待，显示传递到模块中，让模块对模板的依赖更加显而易见。这和当模块执行时期望模板在 DOM 中正好相反。  \n当我们使用 r.js 构建和优化 RequireJS 应用时，模板可以和其他模板一起部署，因为文本插件可以有效地将模板包装在模块定义调用中，创建一个返回模板文件内容的模块。  \n以上就是对文本插件的惊鸿一瞥，下面是其他一些插件。  \n[i18n](http://requirejs.org/docs/api.html#i18n) - 国际化  \n[image](https://github.com/millermedeiros/requirejs-plugins) - 像加载其他模块一样加载图片  \n[mdown](https://github.com/millermedeiros/requirejs-plugins/) - 加载 markdown 文件，它会给你编译成 html  \n[font](https://github.com/millermedeiros/requirejs-plugins) - 加载 Web 字体\n\n## 5. 故障检修小技巧\n\n你可以在代码中使用以下 API，我还发现在 Chrome 控制台中也非常有用。  \n`require.defined(moduleId)` - 返回 true 如果该模块已经被定义并且可用。\n`require.specified(moduleId)` - 返回 true 如果该模块被其他模块依赖。该函数返回 true 并不意味着该模块可用。\n`requirejs.s.contexts._.config` - 我从[Vernon Kesner](https://twitter.com/vernonk)那里学来的这招。这是一个技术上的后门，文档中没有说明的方法，所以它可能在没有任何警告的情况下被修改或者去除。但是它返回一个非常有用的包含配置信息的对象。  \n以下是在 Chrome 控制台中它返回结果：  \n![Chrome控制台中它返回结果](http://tpstatic.com/img/usermedia/_TBvB2AB50KM-TASuLKFsw/w645.png)  \n以上就是我在 Devlink 用来演示[Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker)的一个[生成 GIF 示例应用](https://github.com/ifandelse/gif-stitch)中调用 requirejs.s.contexts.\\_.config 返回的结果。你可以看到所有相关配置数据：根 URL，路径，shim 配置等。\n当进行 Debug 时其他两个关键是`errbacks`和`requirejs.onError`方法。  \n`RequireJS ‘errbacks’`\n当你调用`require`时，可以传入第三个参数-发生错误时的回调，允许你对错误做出反应，而不是产生一个未捕获的异常。比如：\n\n```js\nrequire(['backbone'], function(Backbone) {\n    return Backbone.View.extend({\n        /* your magic here */\n    });\n}, function(err) {\n    /* \n      err has err.requireType (timeout, nodefine, scripterror)\n      and err.requireModules (an array of module Ids/paths)\n      Inside here you could requirejs.undef('backbone') to clear\n      the module from require locally - and you could even redefine\n      it here or fetch it from a different location (though the\n      fallback approach earlier takes care of this use-case more succinctly)\n    */\n});\n```\n\n`requirejs.onError`  \nRequireJS 有一个全局的错误处理函数，它可以捕捉到所有未被`errbacks`处理的异常。代码如下：\n\n```js\nrequirejs.onError = function(err) {\n    /* \n    err has the same info as the errback callback:\n    err.requireType & err.requireModules\n  */\n    console.log(err.requireType);\n    // Be sure to rethrow if you don't want to\n    // blindly swallow exceptions here!!!\n};\n```\n\n## 总结\n\n无论你是刚接触 RequireJS 或者已有很多经验的用户，就像我前面提到的，我将会在另一篇文章中介绍`r.js`，敬请期待。你是否发现了其他有用的关于 RequireJS 使用的技巧，方法和 API，期待你的交流。\n","slug":"Five-Helpful-Tips-When-Using-RequireJS","published":1,"date":"2013-09-11T16:00:00.000Z","updated":"2018-12-07T02:59:39.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmai001fw8wkmufonm5v","content":"<p><a href=\"http://tech.pro/blog/1561/five-helpful-tips-when-using-requirejs\" target=\"_blank\" rel=\"noopener\">查看原文</a></p>\n<p>RequireJS–Javascript 的文件和模块加载器–是 Web 应用中组织，管理，构建和加载 Javascript 的一种很强大的方式。我已经使用它好几年了，and while it’s admittedly difficult to limit myself to only five, 我要是早点知道这几条提示就好了。注意，该文章假定你了解 RequireJS，或者至少知道 AMD，CommonJS 和脚本加载器。RequireJS 官方网站是一个让你知其然并且知其所以然的很好的站点。</p>\n<p>在这篇文章中，我们仅仅关注在 RequireJS 本身，而不包括 r.js（RequireJS 的优化工具）。我打算以后写一篇关于 r.js 的文章。</p>\n<h2 id=\"1-知道定义模块的几种方式\"><a href=\"#1-知道定义模块的几种方式\" class=\"headerlink\" title=\"1. 知道定义模块的几种方式\"></a>1. 知道定义模块的几种方式</h2><p>大多数使用 RequireJS 的人都知道以下这种定义模块的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'dependencyA'</span>, <span class=\"string\">'dependencyB'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">depA, depB</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* module code here using depA and depB */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> myModule;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在 98%的情况下，我使用上面的方法。但是还有其他几种选择，选择哪种，取决于你的需要。一个模块不需要任何依赖，那么你可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(&#123;</span><br><span class=\"line\">    someProp: <span class=\"string\">'Oooh, how interesting!'</span>,</span><br><span class=\"line\">    someMethod: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do interesting work</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> compellingValue;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果这个模块没有任何依赖，但是你需要做一些准备工作或者保存私有状态，那么你可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> secretValue = <span class=\"string\">'seekret'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// do other initialization work here...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    someProp: <span class=\"string\">'Oooh, how interesting!'</span>,</span><br><span class=\"line\">    tellMeSecrets: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// do interesting work</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> secretValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-怎么配合非-AMD-库一起工作\"><a href=\"#2-怎么配合非-AMD-库一起工作\" class=\"headerlink\" title=\"2. 怎么配合非 AMD 库一起工作\"></a>2. 怎么配合非 AMD 库一起工作</h2><p>世界上有非常多的很好的 Javascript 库，大多数都没有遵循 AMD 规范，但是不用担心，你照样可以使用它们。从 RequireJS 2.1.0 版本开始，RequireJS 有了一个叫做‘shim’的特性，让你设置你要用到的哪些不满足 AMD 规范的库，并且像其他 AMD 库一样加载进来。下面我们来看个非 AMD 库的例子。<br><strong>加载没有依赖的非 AMD 库</strong><br>你获取还记得 Backbone 和 Underscore 取消 AMD 支持的情景，多亏了 shim 特性，我们依然可以容易地在 RequireJS 中使用这些库。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        underscore: <span class=\"string\">'libs/underscore.min'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    shim: &#123;</span><br><span class=\"line\">        underscore: &#123;</span><br><span class=\"line\">            exports: <span class=\"string\">'_'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的 require.config 调用中我们提供了压缩后的 underscore.js 文件路径，后面在 shim 对象中，添加了一个和同样的属性，并且值是一个对象，它有一个 exports 属性，用来告诉 RequireJS 全局对象（如果是浏览器的话当然就 window 对象了）上某个属性就是这个模块实际值。既然 Underscore 把自己声明为 window 上的<em>属性，那么我们就让 exports 的值为</em>。从此以后，如果有一个 AMD 模块依赖 Underscore，RequireJS 会用全局对象的_值代替。<br>这个例子很简单，因为 Underscore 没有任意依赖。那么如果加载一个有其他依赖的非 AMD 库吗？<br><strong>加载有依赖的非 AMD 库</strong><br>下面我们看看怎么加载依赖于 Underscore 和 jQuery 的 Backbone 吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        jquery: <span class=\"string\">'libs/jquery.min'</span>,</span><br><span class=\"line\">        backbone: <span class=\"string\">'libs/backbone.min'</span>,</span><br><span class=\"line\">        underscore: <span class=\"string\">'libs/underscore.min'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    shim: &#123;</span><br><span class=\"line\">        underscore: &#123;</span><br><span class=\"line\">            exports: <span class=\"string\">'_'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        backbone: &#123;</span><br><span class=\"line\">            deps: [<span class=\"string\">'jquery'</span>, <span class=\"string\">'underscore'</span>],</span><br><span class=\"line\">            exports: <span class=\"string\">'Backbone'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Backbone 的 shim 配置除了 exports 属性外还有 deps 属性，deps 是一个包含了 Backbone 所有依赖的库名字数组，他们必须先于 Underscore 加载，一旦这些依赖加载完成之后，Backbone 也会被加载，然后 RequireJS 就会从全局对象上获取 Backbone 属性来作为 backbone 模块的值。<br>那么 CommonJS 又是怎样的呢？<br>假定你要 RequireJS 中使用一个 CommonJS 模块，没问题，你可以定义一个模块，并提供一个带有三个参数的工厂函数，这三个函数分别是：require，exports 和 module。多数情况下你都可以忽略其他两个参数，而只考虑如何使用 require 参数。通过 require 参数可以通过 CommonJS 的语法获取一个模块，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cjs = <span class=\"built_in\">require</span>(<span class=\"string\">'myCommonJSModule'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        findDroids: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">droids</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> res = [],</span><br><span class=\"line\">                i = <span class=\"number\">0</span>,</span><br><span class=\"line\">                len = droids.length;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cjs.isDroidWareLookingFor(droids[i])) &#123;</span><br><span class=\"line\">                    res.push(droids[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>特别注意我接下来的一片关于 r.js 的文章，当你使用 r.js 优化工具时，也可以使用更多的 CommonJS 工具库。你可以选择将 CommonJS 模块转换成用 deine()方法包裹起来的模块。你还需要知道，如果你的 CommonJS 模块有分支逻辑去有条件地调用 require，那么转换方法就会失效。比如上面的 myCommonJSModule 有以下内部逻辑（参考代码片段中去思考是什么让它不能和 RequireJS 不能一起工作）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inside myCommonJSModule</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    isDroidWeAreLookingFor: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">droid</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> finder;</span><br><span class=\"line\">        <span class=\"comment\">// OHSNAP! The conditional logic around require</span></span><br><span class=\"line\">        <span class=\"comment\">// means we cannot wrap it with define in RequireJS</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isObiWanPresent) &#123;</span><br><span class=\"line\">            finder = <span class=\"built_in\">require</span>(<span class=\"string\">'forceFilter'</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            finder = <span class=\"built_in\">require</span>(<span class=\"string\">'normalFilter'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> finder.find(droid);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-CND-Fallbacks\"><a href=\"#3-CND-Fallbacks\" class=\"headerlink\" title=\"3. CND Fallbacks\"></a>3. CND Fallbacks</h2><p>虽然 CDN（内容分发网络）可以提高站点的加载性能，但是不希望万一 CDN 挂掉时，你的站点也会挂掉。幸好 RequireJS 可以容易地设置后备地址。一般配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        kendoui: <span class=\"string\">'http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当然我们希望 CDN 永远不会挂掉，但是如果它挂掉了，我们可以通过修改配置来使用后备地址：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        kendoui: [<span class=\"string\">'http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js'</span>, <span class=\"string\">'libs/kendoui/kendoui.min'</span>],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们给 kendoui 设置了一个地址数组，而不再是一个字符串，根据以上配置，RequireJS 将会尝试从 CDN 上加载，如果失败了，再尝试从第二个地址加载。使用后备地址的确会使得脚本加载时间变长，但是总比站点不可用要好得多。</p>\n<h2 id=\"4-插件\"><a href=\"#4-插件\" class=\"headerlink\" title=\"4. 插件\"></a>4. 插件</h2><p>RequireJS 中最好的一个增值点或许就是加载插件。加载插件可以用来加载各种非 Javascript 资源，就像其他依赖模块一样加载他们。最常见的是文本插件，它允许你加载一个普通文本文件（比如 HTML 或者 CSS 等），这对加载模板特别有用。为了让你理解它多么有用，让我们看看今天人们是怎么使用它的。</p>\n<p>下面的代码片段展示了 Backbone 视图怎样获取 unders.js 模板内容，预编译，然后渲染页面，但是代码中你却看不到 RequireJS/text 插件的痕迹。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyView = Backbone.View.extends(&#123;</span><br><span class=\"line\">    initialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.template = _.template($(<span class=\"string\">'generated-gif-template'</span>).text());</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.$el.html(<span class=\"keyword\">this</span>.template(<span class=\"keyword\">this</span>.model.toJSON()));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意到这个视图应该放在页面里面。很多人会添加一个<code>script</code>标签，并给出一个假冒的<code>type</code>属性（这样就不会被当做 Javascript 执行），将模板内容放进去，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/underscore-template\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"generated-gif-template\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"glyphicon glyphicon-remove\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&lt;%= dataURL %&gt;\"</span> <span class=\"attr\">download</span>=<span class=\"string\">\"&lt;%= id %&gt;\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"javascript\">      &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"glyphicon glyphicon-save\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"javascript\">    &lt;img src=<span class=\"string\">\"&lt;%= dataURL %&gt;\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-thumbnail gif-item\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display:none\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"fileName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"&lt;%= fileName %&gt;\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"javascript\">      &lt;span id=<span class=\"string\">\"lblFileName\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">fileName</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这方法肯定是可行的，但是有一些缺点。把模板内容嵌套在 script 标签中会丧失语法高亮和其他 IDE 提供的功能。这个模板必须出现在所有要使用它的页面。在一个多页面的站点中，这意味着你可能要多次拷贝模板内容，或者额外的构建步骤将模板嵌入每个目标 HTML 页面。在 AMD 应用中，像这样将模板保存在 DOM 中意味着该模块除了显示传递给它的依赖之外，还依赖其他东西。这使得你的应用比较脆弱。理想情况下，我们希望将模板传递给我们的模块，就像其他的脚本依赖一样。这就是文本插件产生的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'backbone'</span>, <span class=\"string\">'text!templates/generated-gif.html'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Backbone, template</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Backbone.View.extend(&#123;</span><br><span class=\"line\">        initialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.template = _.template(template);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.$el.html(<span class=\"keyword\">this</span>.template(<span class=\"keyword\">this</span>.model.toJSON()));</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们将模板路径作为依赖加进来，用<code>text!</code>作为前缀，来告诉 RequireJS 使用一个叫做 text 的插件来处理。模板的文本内容作为<code>template</code>参数传递给模块。使用这个方法有如下好处：<br>（一）开发过程中，模板作为一个单独的文件存在，因此我们使用 IDE 带给我们的便利（语法高亮等），还避免了我们必须穿过数百行甚至更多的 HTML 代码去编辑代码。<br>（二）模板可以和其他模块同等对待，显示传递到模块中，让模块对模板的依赖更加显而易见。这和当模块执行时期望模板在 DOM 中正好相反。<br>当我们使用 r.js 构建和优化 RequireJS 应用时，模板可以和其他模板一起部署，因为文本插件可以有效地将模板包装在模块定义调用中，创建一个返回模板文件内容的模块。<br>以上就是对文本插件的惊鸿一瞥，下面是其他一些插件。<br><a href=\"http://requirejs.org/docs/api.html#i18n\" target=\"_blank\" rel=\"noopener\">i18n</a> - 国际化<br><a href=\"https://github.com/millermedeiros/requirejs-plugins\" target=\"_blank\" rel=\"noopener\">image</a> - 像加载其他模块一样加载图片<br><a href=\"https://github.com/millermedeiros/requirejs-plugins/\" target=\"_blank\" rel=\"noopener\">mdown</a> - 加载 markdown 文件，它会给你编译成 html<br><a href=\"https://github.com/millermedeiros/requirejs-plugins\" target=\"_blank\" rel=\"noopener\">font</a> - 加载 Web 字体</p>\n<h2 id=\"5-故障检修小技巧\"><a href=\"#5-故障检修小技巧\" class=\"headerlink\" title=\"5. 故障检修小技巧\"></a>5. 故障检修小技巧</h2><p>你可以在代码中使用以下 API，我还发现在 Chrome 控制台中也非常有用。<br><code>require.defined(moduleId)</code> - 返回 true 如果该模块已经被定义并且可用。<br><code>require.specified(moduleId)</code> - 返回 true 如果该模块被其他模块依赖。该函数返回 true 并不意味着该模块可用。<br><code>requirejs.s.contexts._.config</code> - 我从<a href=\"https://twitter.com/vernonk\" target=\"_blank\" rel=\"noopener\">Vernon Kesner</a>那里学来的这招。这是一个技术上的后门，文档中没有说明的方法，所以它可能在没有任何警告的情况下被修改或者去除。但是它返回一个非常有用的包含配置信息的对象。<br>以下是在 Chrome 控制台中它返回结果：<br><img src=\"http://tpstatic.com/img/usermedia/_TBvB2AB50KM-TASuLKFsw/w645.png\" alt=\"Chrome控制台中它返回结果\"><br>以上就是我在 Devlink 用来演示<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Worker\" target=\"_blank\" rel=\"noopener\">Web Worker</a>的一个<a href=\"https://github.com/ifandelse/gif-stitch\" target=\"_blank\" rel=\"noopener\">生成 GIF 示例应用</a>中调用 requirejs.s.contexts._.config 返回的结果。你可以看到所有相关配置数据：根 URL，路径，shim 配置等。<br>当进行 Debug 时其他两个关键是<code>errbacks</code>和<code>requirejs.onError</code>方法。<br><code>RequireJS ‘errbacks’</code><br>当你调用<code>require</code>时，可以传入第三个参数-发生错误时的回调，允许你对错误做出反应，而不是产生一个未捕获的异常。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'backbone'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Backbone</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Backbone.View.extend(&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* your magic here */</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">      err has err.requireType (timeout, nodefine, scripterror)</span></span><br><span class=\"line\"><span class=\"comment\">      and err.requireModules (an array of module Ids/paths)</span></span><br><span class=\"line\"><span class=\"comment\">      Inside here you could requirejs.undef('backbone') to clear</span></span><br><span class=\"line\"><span class=\"comment\">      the module from require locally - and you could even redefine</span></span><br><span class=\"line\"><span class=\"comment\">      it here or fetch it from a different location (though the</span></span><br><span class=\"line\"><span class=\"comment\">      fallback approach earlier takes care of this use-case more succinctly)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>requirejs.onError</code><br>RequireJS 有一个全局的错误处理函数，它可以捕捉到所有未被<code>errbacks</code>处理的异常。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">requirejs.onError = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    err has the same info as the errback callback:</span></span><br><span class=\"line\"><span class=\"comment\">    err.requireType &amp; err.requireModules</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.requireType);</span><br><span class=\"line\">    <span class=\"comment\">// Be sure to rethrow if you don't want to</span></span><br><span class=\"line\">    <span class=\"comment\">// blindly swallow exceptions here!!!</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>无论你是刚接触 RequireJS 或者已有很多经验的用户，就像我前面提到的，我将会在另一篇文章中介绍<code>r.js</code>，敬请期待。你是否发现了其他有用的关于 RequireJS 使用的技巧，方法和 API，期待你的交流。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://tech.pro/blog/1561/five-helpful-tips-when-using-requirejs\" target=\"_blank\" rel=\"noopener\">查看原文</a></p>\n<p>RequireJS–Javascript 的文件和模块加载器–是 Web 应用中组织，管理，构建和加载 Javascript 的一种很强大的方式。我已经使用它好几年了，and while it’s admittedly difficult to limit myself to only five, 我要是早点知道这几条提示就好了。注意，该文章假定你了解 RequireJS，或者至少知道 AMD，CommonJS 和脚本加载器。RequireJS 官方网站是一个让你知其然并且知其所以然的很好的站点。</p>\n<p>在这篇文章中，我们仅仅关注在 RequireJS 本身，而不包括 r.js（RequireJS 的优化工具）。我打算以后写一篇关于 r.js 的文章。</p>\n<h2 id=\"1-知道定义模块的几种方式\"><a href=\"#1-知道定义模块的几种方式\" class=\"headerlink\" title=\"1. 知道定义模块的几种方式\"></a>1. 知道定义模块的几种方式</h2><p>大多数使用 RequireJS 的人都知道以下这种定义模块的方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'dependencyA'</span>, <span class=\"string\">'dependencyB'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">depA, depB</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* module code here using depA and depB */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> myModule;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>在 98%的情况下，我使用上面的方法。但是还有其他几种选择，选择哪种，取决于你的需要。一个模块不需要任何依赖，那么你可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(&#123;</span><br><span class=\"line\">    someProp: <span class=\"string\">'Oooh, how interesting!'</span>,</span><br><span class=\"line\">    someMethod: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do interesting work</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> compellingValue;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>如果这个模块没有任何依赖，但是你需要做一些准备工作或者保存私有状态，那么你可以这么做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> secretValue = <span class=\"string\">'seekret'</span>;</span><br><span class=\"line\">  <span class=\"comment\">// do other initialization work here...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    someProp: <span class=\"string\">'Oooh, how interesting!'</span>,</span><br><span class=\"line\">    tellMeSecrets: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// do interesting work</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> secretValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-怎么配合非-AMD-库一起工作\"><a href=\"#2-怎么配合非-AMD-库一起工作\" class=\"headerlink\" title=\"2. 怎么配合非 AMD 库一起工作\"></a>2. 怎么配合非 AMD 库一起工作</h2><p>世界上有非常多的很好的 Javascript 库，大多数都没有遵循 AMD 规范，但是不用担心，你照样可以使用它们。从 RequireJS 2.1.0 版本开始，RequireJS 有了一个叫做‘shim’的特性，让你设置你要用到的哪些不满足 AMD 规范的库，并且像其他 AMD 库一样加载进来。下面我们来看个非 AMD 库的例子。<br><strong>加载没有依赖的非 AMD 库</strong><br>你获取还记得 Backbone 和 Underscore 取消 AMD 支持的情景，多亏了 shim 特性，我们依然可以容易地在 RequireJS 中使用这些库。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        underscore: <span class=\"string\">'libs/underscore.min'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    shim: &#123;</span><br><span class=\"line\">        underscore: &#123;</span><br><span class=\"line\">            exports: <span class=\"string\">'_'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>上面的 require.config 调用中我们提供了压缩后的 underscore.js 文件路径，后面在 shim 对象中，添加了一个和同样的属性，并且值是一个对象，它有一个 exports 属性，用来告诉 RequireJS 全局对象（如果是浏览器的话当然就 window 对象了）上某个属性就是这个模块实际值。既然 Underscore 把自己声明为 window 上的<em>属性，那么我们就让 exports 的值为</em>。从此以后，如果有一个 AMD 模块依赖 Underscore，RequireJS 会用全局对象的_值代替。<br>这个例子很简单，因为 Underscore 没有任意依赖。那么如果加载一个有其他依赖的非 AMD 库吗？<br><strong>加载有依赖的非 AMD 库</strong><br>下面我们看看怎么加载依赖于 Underscore 和 jQuery 的 Backbone 吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        jquery: <span class=\"string\">'libs/jquery.min'</span>,</span><br><span class=\"line\">        backbone: <span class=\"string\">'libs/backbone.min'</span>,</span><br><span class=\"line\">        underscore: <span class=\"string\">'libs/underscore.min'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    shim: &#123;</span><br><span class=\"line\">        underscore: &#123;</span><br><span class=\"line\">            exports: <span class=\"string\">'_'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        backbone: &#123;</span><br><span class=\"line\">            deps: [<span class=\"string\">'jquery'</span>, <span class=\"string\">'underscore'</span>],</span><br><span class=\"line\">            exports: <span class=\"string\">'Backbone'</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Backbone 的 shim 配置除了 exports 属性外还有 deps 属性，deps 是一个包含了 Backbone 所有依赖的库名字数组，他们必须先于 Underscore 加载，一旦这些依赖加载完成之后，Backbone 也会被加载，然后 RequireJS 就会从全局对象上获取 Backbone 属性来作为 backbone 模块的值。<br>那么 CommonJS 又是怎样的呢？<br>假定你要 RequireJS 中使用一个 CommonJS 模块，没问题，你可以定义一个模块，并提供一个带有三个参数的工厂函数，这三个函数分别是：require，exports 和 module。多数情况下你都可以忽略其他两个参数，而只考虑如何使用 require 参数。通过 require 参数可以通过 CommonJS 的语法获取一个模块，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> cjs = <span class=\"built_in\">require</span>(<span class=\"string\">'myCommonJSModule'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        findDroids: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">droids</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> res = [],</span><br><span class=\"line\">                i = <span class=\"number\">0</span>,</span><br><span class=\"line\">                len = droids.length;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cjs.isDroidWareLookingFor(droids[i])) &#123;</span><br><span class=\"line\">                    res.push(droids[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>特别注意我接下来的一片关于 r.js 的文章，当你使用 r.js 优化工具时，也可以使用更多的 CommonJS 工具库。你可以选择将 CommonJS 模块转换成用 deine()方法包裹起来的模块。你还需要知道，如果你的 CommonJS 模块有分支逻辑去有条件地调用 require，那么转换方法就会失效。比如上面的 myCommonJSModule 有以下内部逻辑（参考代码片段中去思考是什么让它不能和 RequireJS 不能一起工作）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// inside myCommonJSModule</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    isDroidWeAreLookingFor: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">droid</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> finder;</span><br><span class=\"line\">        <span class=\"comment\">// OHSNAP! The conditional logic around require</span></span><br><span class=\"line\">        <span class=\"comment\">// means we cannot wrap it with define in RequireJS</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isObiWanPresent) &#123;</span><br><span class=\"line\">            finder = <span class=\"built_in\">require</span>(<span class=\"string\">'forceFilter'</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            finder = <span class=\"built_in\">require</span>(<span class=\"string\">'normalFilter'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> finder.find(droid);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-CND-Fallbacks\"><a href=\"#3-CND-Fallbacks\" class=\"headerlink\" title=\"3. CND Fallbacks\"></a>3. CND Fallbacks</h2><p>虽然 CDN（内容分发网络）可以提高站点的加载性能，但是不希望万一 CDN 挂掉时，你的站点也会挂掉。幸好 RequireJS 可以容易地设置后备地址。一般配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        kendoui: <span class=\"string\">'http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js'</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当然我们希望 CDN 永远不会挂掉，但是如果它挂掉了，我们可以通过修改配置来使用后备地址：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>.config(&#123;</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        kendoui: [<span class=\"string\">'http://cdn.kendostatic.com/2013.2.716/js/kendo.all.min.js'</span>, <span class=\"string\">'libs/kendoui/kendoui.min'</span>],</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们给 kendoui 设置了一个地址数组，而不再是一个字符串，根据以上配置，RequireJS 将会尝试从 CDN 上加载，如果失败了，再尝试从第二个地址加载。使用后备地址的确会使得脚本加载时间变长，但是总比站点不可用要好得多。</p>\n<h2 id=\"4-插件\"><a href=\"#4-插件\" class=\"headerlink\" title=\"4. 插件\"></a>4. 插件</h2><p>RequireJS 中最好的一个增值点或许就是加载插件。加载插件可以用来加载各种非 Javascript 资源，就像其他依赖模块一样加载他们。最常见的是文本插件，它允许你加载一个普通文本文件（比如 HTML 或者 CSS 等），这对加载模板特别有用。为了让你理解它多么有用，让我们看看今天人们是怎么使用它的。</p>\n<p>下面的代码片段展示了 Backbone 视图怎样获取 unders.js 模板内容，预编译，然后渲染页面，但是代码中你却看不到 RequireJS/text 插件的痕迹。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> MyView = Backbone.View.extends(&#123;</span><br><span class=\"line\">    initialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.template = _.template($(<span class=\"string\">'generated-gif-template'</span>).text());</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.$el.html(<span class=\"keyword\">this</span>.template(<span class=\"keyword\">this</span>.model.toJSON()));</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>注意到这个视图应该放在页面里面。很多人会添加一个<code>script</code>标签，并给出一个假冒的<code>type</code>属性（这样就不会被当做 Javascript 执行），将模板内容放进去，如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/underscore-template\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"generated-gif-template\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\">    &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"glyphicon glyphicon-remove\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"&lt;%= dataURL %&gt;\"</span> <span class=\"attr\">download</span>=<span class=\"string\">\"&lt;%= id %&gt;\"</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"javascript\">      &lt;span <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"glyphicon glyphicon-save\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"javascript\">    &lt;img src=<span class=\"string\">\"&lt;%= dataURL %&gt;\"</span> <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-thumbnail gif-item\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">style</span>=<span class=\"string\">\"display:none\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"fileName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"&lt;%= fileName %&gt;\"</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"javascript\">      &lt;span id=<span class=\"string\">\"lblFileName\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">%=</span> <span class=\"attr\">fileName</span> %&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这方法肯定是可行的，但是有一些缺点。把模板内容嵌套在 script 标签中会丧失语法高亮和其他 IDE 提供的功能。这个模板必须出现在所有要使用它的页面。在一个多页面的站点中，这意味着你可能要多次拷贝模板内容，或者额外的构建步骤将模板嵌入每个目标 HTML 页面。在 AMD 应用中，像这样将模板保存在 DOM 中意味着该模块除了显示传递给它的依赖之外，还依赖其他东西。这使得你的应用比较脆弱。理想情况下，我们希望将模板传递给我们的模块，就像其他的脚本依赖一样。这就是文本插件产生的原因。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'backbone'</span>, <span class=\"string\">'text!templates/generated-gif.html'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Backbone, template</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Backbone.View.extend(&#123;</span><br><span class=\"line\">        initialize: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.template = _.template(template);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.$el.html(<span class=\"keyword\">this</span>.template(<span class=\"keyword\">this</span>.model.toJSON()));</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>我们将模板路径作为依赖加进来，用<code>text!</code>作为前缀，来告诉 RequireJS 使用一个叫做 text 的插件来处理。模板的文本内容作为<code>template</code>参数传递给模块。使用这个方法有如下好处：<br>（一）开发过程中，模板作为一个单独的文件存在，因此我们使用 IDE 带给我们的便利（语法高亮等），还避免了我们必须穿过数百行甚至更多的 HTML 代码去编辑代码。<br>（二）模板可以和其他模块同等对待，显示传递到模块中，让模块对模板的依赖更加显而易见。这和当模块执行时期望模板在 DOM 中正好相反。<br>当我们使用 r.js 构建和优化 RequireJS 应用时，模板可以和其他模板一起部署，因为文本插件可以有效地将模板包装在模块定义调用中，创建一个返回模板文件内容的模块。<br>以上就是对文本插件的惊鸿一瞥，下面是其他一些插件。<br><a href=\"http://requirejs.org/docs/api.html#i18n\" target=\"_blank\" rel=\"noopener\">i18n</a> - 国际化<br><a href=\"https://github.com/millermedeiros/requirejs-plugins\" target=\"_blank\" rel=\"noopener\">image</a> - 像加载其他模块一样加载图片<br><a href=\"https://github.com/millermedeiros/requirejs-plugins/\" target=\"_blank\" rel=\"noopener\">mdown</a> - 加载 markdown 文件，它会给你编译成 html<br><a href=\"https://github.com/millermedeiros/requirejs-plugins\" target=\"_blank\" rel=\"noopener\">font</a> - 加载 Web 字体</p>\n<h2 id=\"5-故障检修小技巧\"><a href=\"#5-故障检修小技巧\" class=\"headerlink\" title=\"5. 故障检修小技巧\"></a>5. 故障检修小技巧</h2><p>你可以在代码中使用以下 API，我还发现在 Chrome 控制台中也非常有用。<br><code>require.defined(moduleId)</code> - 返回 true 如果该模块已经被定义并且可用。<br><code>require.specified(moduleId)</code> - 返回 true 如果该模块被其他模块依赖。该函数返回 true 并不意味着该模块可用。<br><code>requirejs.s.contexts._.config</code> - 我从<a href=\"https://twitter.com/vernonk\" target=\"_blank\" rel=\"noopener\">Vernon Kesner</a>那里学来的这招。这是一个技术上的后门，文档中没有说明的方法，所以它可能在没有任何警告的情况下被修改或者去除。但是它返回一个非常有用的包含配置信息的对象。<br>以下是在 Chrome 控制台中它返回结果：<br><img src=\"http://tpstatic.com/img/usermedia/_TBvB2AB50KM-TASuLKFsw/w645.png\" alt=\"Chrome控制台中它返回结果\"><br>以上就是我在 Devlink 用来演示<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Worker\" target=\"_blank\" rel=\"noopener\">Web Worker</a>的一个<a href=\"https://github.com/ifandelse/gif-stitch\" target=\"_blank\" rel=\"noopener\">生成 GIF 示例应用</a>中调用 requirejs.s.contexts._.config 返回的结果。你可以看到所有相关配置数据：根 URL，路径，shim 配置等。<br>当进行 Debug 时其他两个关键是<code>errbacks</code>和<code>requirejs.onError</code>方法。<br><code>RequireJS ‘errbacks’</code><br>当你调用<code>require</code>时，可以传入第三个参数-发生错误时的回调，允许你对错误做出反应，而不是产生一个未捕获的异常。比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'backbone'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Backbone</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Backbone.View.extend(&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* your magic here */</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">      err has err.requireType (timeout, nodefine, scripterror)</span></span><br><span class=\"line\"><span class=\"comment\">      and err.requireModules (an array of module Ids/paths)</span></span><br><span class=\"line\"><span class=\"comment\">      Inside here you could requirejs.undef('backbone') to clear</span></span><br><span class=\"line\"><span class=\"comment\">      the module from require locally - and you could even redefine</span></span><br><span class=\"line\"><span class=\"comment\">      it here or fetch it from a different location (though the</span></span><br><span class=\"line\"><span class=\"comment\">      fallback approach earlier takes care of this use-case more succinctly)</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>requirejs.onError</code><br>RequireJS 有一个全局的错误处理函数，它可以捕捉到所有未被<code>errbacks</code>处理的异常。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">requirejs.onError = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">    err has the same info as the errback callback:</span></span><br><span class=\"line\"><span class=\"comment\">    err.requireType &amp; err.requireModules</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err.requireType);</span><br><span class=\"line\">    <span class=\"comment\">// Be sure to rethrow if you don't want to</span></span><br><span class=\"line\">    <span class=\"comment\">// blindly swallow exceptions here!!!</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>无论你是刚接触 RequireJS 或者已有很多经验的用户，就像我前面提到的，我将会在另一篇文章中介绍<code>r.js</code>，敬请期待。你是否发现了其他有用的关于 RequireJS 使用的技巧，方法和 API，期待你的交流。</p>\n"},{"title":"CSS编码规范","_content":"\n为了提高 CSS 的可读性、维护性、扩展性、复用性，制定以下书写规范。\n\n##1 命名规范\n\n1. Id 和 Class 全部小写，并用中划线隔开。\n\n##2 书写规范\n\n1. 样式和内容分离，不使用 style 属性定义样式。\n1. 【建议】属性书写顺序\n   显示属性\n   display, position, float\n   盒模型属性\n   width, max-width, min-width,\n   height, max-height, min-height,\n   border\n   margin, margin-top, margin-right, margin-bottom, margin-left,\n   padding, padding-top, padding-right, padding-bottom, padding-left,\n   文本属性(color, font, text-decoration, text-align, vertical-align, white-space, other text, content)\n1.\n1. （由于性能问题）不许使用表达式`expression`，请使用 Javascript 替代。\n1. 【建议】在模块的开头和结尾通过注释。\n\n```css\n/* XX模块 开始*/\n/* XX模块 结束*/\n```\n\nhttp://blog.segmentfault.com/tychio/1190000000531277\n\nCSS 命名规范\n一、类名 !important\n全部采用中划线命名法\n<a rel=\"nofollow\" href=\"javascript:void(0);\" class=\"titleMore\">More</a> // 错误\n<a rel=\"nofollow\" href=\"javascript:void(0);\" class=\"title-more\">More</a> // 正确\n二、文件名 !important\nCSS 文件名统一采用小写字母加下划线的方式，单词之间用中划线(-)分割, 不允许出现大写或者其他符号。正确的如：feedback-send.css\nCSS 文件默认情况下的编码必须采用 utf-8（无 bom），其他编码方式均不可！！！（某些专门给中文用户使用的网页中的 CSS 除外）\n\n书写规范\n一. 不得在 css 中使用 expression !important\n//由于性能的问题，不准使用 (通过重置触发该 Expression 的 CSS 属性来优化性能，但是也可能有其他问题)，请用 js 代替\n.header {height:expression(document.documentElement.height)}\n\n五. CSS 选择符组\n如果是选择符组，则这些选择符(selector)各占一行\n.style1,\n.style2 {background:url(xxx.gif) no-repeat ;}\n\n七. 采用属性缩写方式\n.style {margin:10px 5px; font:normal 12px/1.5 Verdana; color:#F60; } //颜色值能简写的使用简写\n属性缩写所代表的意思请点击 这里\n七. 写成一行\n.yellowish-btn,.yellow-btn{display:inline-block;zoom:1;border:0 none;background:none;}\n.yellowish-btn:hover,.yellow-btn:hover {text-decoration:none;}\n.yellowish-btn input,.yellow-btn input, .yellowish-btn button,.yellow-btn button {float:left;width:100%;border:0 none;}\n.yellowish-btn input, .yellowish-btn button {height:27px;color:#7A2D01;}\n为了方便区域阅读，属性写成一行。\n\n框架设计原则\n\n在使用中避免不必要的复杂\n能用 CSS 完成的不动用其他资源手段\n\n有原则的优雅退化\n加速远古浏览器的消亡, 让现代浏览器更舒适\n\n统一风格\n让代码和使用方式以同一种机理对外服务\n\n框架实现原则\n\n科学的模块化, 减少不必要的依赖,降低耦合的可能性\n以模块和模块组的概念提供积木, 不需要使用者做过多的额外编码工作\n使用独立完整的代码片段, 结构化和规范化所有管辖范围内的编码方式\n多组合, 少复写\nHTML 结构设计原则\n\n完整封闭的模块结构\n语义化和可及性\n杜绝不必要的冗余, 保留合理结构增强定义灵活性\n\n命名规约\n\nnormalize(reset & typegraphy)直接以 HTML 元素作为选择器定义, 无额外 class 或 id 定义.\nstructure(grids & layouts)遵循定义中的命名方式, 无特殊要求.\nutility 以 util-作为前缀, 标识为工具类, 无视觉样式定义.\nmod 中各模块以 ui-作为前缀, 标识为与视觉样式相关模块.\n以\\_(下划线)作为前缀, 标识为内部未开放/不开放对外服务的部分.\n模块名尽量让人看到名字就能知道是什么模块.\n\ngood case: ui-button\n\n模块内部实现结构同样借鉴 YUI3 widget 文档中对于 widget 在结构上的规约, 模块同样存在 bounding box 和 content box, 但会根据模块本身的复杂度将这两层分层模型的规约进行合并, 分解或者省略, 而 bounding box 和 content box 指的都是 DOM 结构上的设计, 并非 CSS 的 class 声明.\n\nbounding box\n\nbounding box 是指模块最外层的包裹容器的 DOM 结构, 她更多时候承担的是申明独立模块边界的职责, 而她基本不会定义和视觉渲染样式相关的声明.\n\n在 bounding box 上附着模块名 ui-{MOD_NAME}, 而 ui-{MOD_NAME}负责定义的包括: display, position, float\n在 bounding box 上附着模块的矩阵(在下文中有详细描述)中的主维度状态 ui-{MOD_NAME}-{STATUS}, 例如-system, -customize\ncontent box\n\ncontent box 是定义具体模块内容的 DOM 结构, 她更多时候承担的是申明模块内部内容包裹的职责.\n\n完整情况下, 在 content box 上附着 ui-{MOD_NAME}-content, 仅用以申明该结构承担具体模块内容\n在 content box 上附着模块矩阵(在下文中有详细描述)中的次维度类型 ui-{MOD_NAME}-{TYPE}, 例如-error, -success, 她负责具体的样式声明\nbounding box 和 content box 在模块实现中的具体操作说明\n\nQ: 任何时候都需要定义 bounding box 和 content box 吗?\n\nA:\n\nbounding box 在任何情况下都需要定义, 因为 bounding box 标示模块的最外围容器.\ncontent box 是否定义的情况就相对复杂了, 它是否需要声明, 或者是否需要独立声明是由模块在设计定义中区分出来的维度和一些认为判断性的原则决定的.\n如果设计定义的分类能够在一个维度进行抽象, 那可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.\n如果设计定义的分类是多维度的矩阵情况, 而设计定义作用的元素本身在语义结构合理性上判断不应由多层结构构成, 且能够通过复写的方式实现多维度定义的情况下, 可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.\n如果设计定义的分类是多维度的矩阵情况, 在语义允许的情况下, 并且在使用复写的方式存在比较大的兼容性问题时, 那 content box 这层结构就必须存在, 为了让 bounding box 和 content box 上彼此附着的不同维度进行组合, 从而实现模块复杂多样性的矩阵.\n就 bounding box 和 content box 在抽象过程中的示例:\n\n多维度必须交叉组合实现定义的多样性\nexample: DPL 中对 feedback 的定义, 根据分析结果(如何分析设计定义就不展开了), 我们就能够建立一个简单的矩阵来描述设计定义中抽象出来的组合矩阵:\n\n[ ['standalone','addon'],['alert','error','success'] ]\n\n第一维度我们定义成: standalone(独立使用)和 addon(作为附属)\n\n第二维度我们定义成: alert(警告), error(出错)和 success(成功)\n\nps. 两类维度并没有强制的规约, 仅从语义上描述分类的便利性上做出区分.\n\n只有两个维度互相组合才能描述清楚模块在设计上的分类, 那在具体的 HTML 结构设计上, 就会变成这样:\n\n<BLOCK class=\"ui-feedback ui-feedback-{STATUS}\">\n    <BLOCK class=\"ui-feedback-content ui-feedback-{TYPE}\">\n        …some contents here\n    </BLOCK>\n</BLOCK>\nbounding box 上附着两种 class:\n\nui-feedback : MOD_NAME 部分, 仅声明当前这个闭合 DOM 文档结构是何种模块. 该声明对应的样式部分仅包含(如有需要): display, position, float 等和模块整体形式位置相关的定义.\n\nui-feedback-addon 或者 ui-feedback-standalone : MOD_NAME-{STATUS}部分, 作为多维度中模块的状态声明, 为多维度的划分方式提供第一级的 namespace.\n\ncontent box 上附着两种 class:\n\nui-feedback-content : 与 ui-feedback 所起作用基本一致, 声明当前容器是 feedback 模块中具体内容的包裹容器, 不做样式定义声明用.\n\nui-feedback-error 或者 ui-feedback-alert 或者 ui-feedback-success : MOD_NAME-{TYPE}部分, 作为多维度中模块的类型声明, 为多维度的划分方式提供第二级的 namespace.\n\n利用状态声明(bounding box 上)和类型声明(content box 上)来进行组合实现多重维度的设计定义:\n\nui-feedback-addon\n|- ui-feedback-error\n|- ui-feedback-alert\n|- ui-feedback-success\n\nui-feedback-standalone\n|- ui-feedback-error\n|- ui-feedback-alert\n|- ui-feedback-success\n当然也能是:\n\nui-feedback-error\n|- ui-feedback-addon\n|- ui-feedback-standalone\n...\n多重维度可通过复写实现多样性\nexample: DPL 中对 button 的定义, 照例按照分析结果, 我们得到一个简单的矩阵来描述设计定义中抽象出来的组合矩阵:\n\n[ [primary, normal] , [large, medium, small] ]\n\n第一维度我们定义成: primary(主要的)和 normal(普通的)\n\n第二维度我们定义成: large(大号), medium(中号)和 small(小号)\n\n从定义分解上看, 也需要多重维度才能描述清楚模块的分类, 但是对于一个简单的 button 结构来说, 使用两层 DOM 来描述真的不靠谱且没意义. 再设计定义的维度分类之上我们在加入一个语义结构合理性的原则, 那由此, 具体的 HTML 结构设计就会是这样:\n\n<INLINE class=\"ui-button ui-button-{STATUS} ui-button-{TYPE}\" />\n\n在这个例子中 bounding box 依旧坚挺的存在,而对于模型而言, content box 同样存在, 只是在实际情况下隐形了.\n\nps. 考虑到单一结构承担 bounding box 和 content box 时 class 值过长等人性判断介入的信息, 在实际声明中如果出现 content box 声明(注意, 不是 content box 模型)可有可无, 原则性选择不声明 content box 的 class.\n\n单一维度\nexample: DPL 中对 balloon 的定义, 根据设计定义分类, balloon 模块只有一个维度需要描述--箭头出现的位置, 那在 HTML 结构上的设计是:\n\n<BLOCK class=\"ui-balloon ui-balloon-{STATUS}\">\n    …some contents here\n</BLOCK>\n在这个例子中, bounding box 中的 STATUS 声明就足够将设计定义中的维度表达清楚了, 那content box的声明就没有为多维度构建可组合的职责了, 当然它可以继续充当其他职责, 比如(1)表达模块内部内容或(2)区分与内容无关的区块. 用balloon来举例, 在目前的实现中:\n\n<div class=\"ui-balloon ui-balloon-tl\">\n    <div class=\"ui-balloon-content\">\n        balloon top left\n    </div>\n    <a class=\"ui-balloon-arrow\"></a>\n</div>\n在该示例中同样存在ui-balloon-content的申明, 在结构上和上文中的ui-feedback-content很类似, 但是在balloon中更多承担的是区分在balloon内部内容和balloon的指向性箭头结构, 让其在语义化和操作便利性上更加合理.\n\n对于某些特殊场景下需要的模块属性\nexample : DPL 中对 button 的定义, 还是用 button 来举例, button 除了在上文中具备的二维分类外, 还有一个特殊场景 disabled(禁用), 在模块多维度组合的抽象结构, disable 是和其他两个维度处于同等维度上, 但是在实现上基本可以用复写的方式完成, 以减少因为组合的维度增加导致代码组织上的大量重定义.\n\n对于复写场景的编码技巧\n这里阐述的是一种小技巧, 在出现.class-a.class-b 声明的场景时由于需要照顾到低级浏览器(shit!)的兼容性问题, 要想办法让在高级浏览器中能够工作的多 class 声明的方式同样在低级浏览器中同样生效, 运气好的话可以直接用 class-b 的声明完全复写成想要的实现, 但是遇到 class-b 同样也要单独服务或者需要和其他一个命名空间配合服务(比如.class-c.class-b)的时候, 这样的情况运气就用完了. 好吧, 只能在有限的条件下将 class-a 和 class-c 这两个命名空间区分开, 比方, 在.class-a.class-b 的前面加个 p...这只能小范围解决问题, 无法杜绝问题的发生, 认命吧, 骚年!\n\n给一些命名后缀的建议\n对于模块的分类维度, 在这里给出一些常见的命名建议, 省的大家在写模块时抓破头皮.\n\n状态(STATUS)\n\nsystem / customize\nstandalone / addon\nhorizontal / vertical\nfrontend / backend\nwrap / separate\nnormal / primary\n类型(TYPE)\n\nerror / alert / success\nsmall / medium / large\nblock / nonblock\n属性(ATTRIBUTE)\n\ndisabled / readonly\ncurrent / active\nfixed / locked\n","source":"_posts/2014-06-04-css-code-guide.md","raw":"---\ntitle: CSS编码规范\n---\n\n为了提高 CSS 的可读性、维护性、扩展性、复用性，制定以下书写规范。\n\n##1 命名规范\n\n1. Id 和 Class 全部小写，并用中划线隔开。\n\n##2 书写规范\n\n1. 样式和内容分离，不使用 style 属性定义样式。\n1. 【建议】属性书写顺序\n   显示属性\n   display, position, float\n   盒模型属性\n   width, max-width, min-width,\n   height, max-height, min-height,\n   border\n   margin, margin-top, margin-right, margin-bottom, margin-left,\n   padding, padding-top, padding-right, padding-bottom, padding-left,\n   文本属性(color, font, text-decoration, text-align, vertical-align, white-space, other text, content)\n1.\n1. （由于性能问题）不许使用表达式`expression`，请使用 Javascript 替代。\n1. 【建议】在模块的开头和结尾通过注释。\n\n```css\n/* XX模块 开始*/\n/* XX模块 结束*/\n```\n\nhttp://blog.segmentfault.com/tychio/1190000000531277\n\nCSS 命名规范\n一、类名 !important\n全部采用中划线命名法\n<a rel=\"nofollow\" href=\"javascript:void(0);\" class=\"titleMore\">More</a> // 错误\n<a rel=\"nofollow\" href=\"javascript:void(0);\" class=\"title-more\">More</a> // 正确\n二、文件名 !important\nCSS 文件名统一采用小写字母加下划线的方式，单词之间用中划线(-)分割, 不允许出现大写或者其他符号。正确的如：feedback-send.css\nCSS 文件默认情况下的编码必须采用 utf-8（无 bom），其他编码方式均不可！！！（某些专门给中文用户使用的网页中的 CSS 除外）\n\n书写规范\n一. 不得在 css 中使用 expression !important\n//由于性能的问题，不准使用 (通过重置触发该 Expression 的 CSS 属性来优化性能，但是也可能有其他问题)，请用 js 代替\n.header {height:expression(document.documentElement.height)}\n\n五. CSS 选择符组\n如果是选择符组，则这些选择符(selector)各占一行\n.style1,\n.style2 {background:url(xxx.gif) no-repeat ;}\n\n七. 采用属性缩写方式\n.style {margin:10px 5px; font:normal 12px/1.5 Verdana; color:#F60; } //颜色值能简写的使用简写\n属性缩写所代表的意思请点击 这里\n七. 写成一行\n.yellowish-btn,.yellow-btn{display:inline-block;zoom:1;border:0 none;background:none;}\n.yellowish-btn:hover,.yellow-btn:hover {text-decoration:none;}\n.yellowish-btn input,.yellow-btn input, .yellowish-btn button,.yellow-btn button {float:left;width:100%;border:0 none;}\n.yellowish-btn input, .yellowish-btn button {height:27px;color:#7A2D01;}\n为了方便区域阅读，属性写成一行。\n\n框架设计原则\n\n在使用中避免不必要的复杂\n能用 CSS 完成的不动用其他资源手段\n\n有原则的优雅退化\n加速远古浏览器的消亡, 让现代浏览器更舒适\n\n统一风格\n让代码和使用方式以同一种机理对外服务\n\n框架实现原则\n\n科学的模块化, 减少不必要的依赖,降低耦合的可能性\n以模块和模块组的概念提供积木, 不需要使用者做过多的额外编码工作\n使用独立完整的代码片段, 结构化和规范化所有管辖范围内的编码方式\n多组合, 少复写\nHTML 结构设计原则\n\n完整封闭的模块结构\n语义化和可及性\n杜绝不必要的冗余, 保留合理结构增强定义灵活性\n\n命名规约\n\nnormalize(reset & typegraphy)直接以 HTML 元素作为选择器定义, 无额外 class 或 id 定义.\nstructure(grids & layouts)遵循定义中的命名方式, 无特殊要求.\nutility 以 util-作为前缀, 标识为工具类, 无视觉样式定义.\nmod 中各模块以 ui-作为前缀, 标识为与视觉样式相关模块.\n以\\_(下划线)作为前缀, 标识为内部未开放/不开放对外服务的部分.\n模块名尽量让人看到名字就能知道是什么模块.\n\ngood case: ui-button\n\n模块内部实现结构同样借鉴 YUI3 widget 文档中对于 widget 在结构上的规约, 模块同样存在 bounding box 和 content box, 但会根据模块本身的复杂度将这两层分层模型的规约进行合并, 分解或者省略, 而 bounding box 和 content box 指的都是 DOM 结构上的设计, 并非 CSS 的 class 声明.\n\nbounding box\n\nbounding box 是指模块最外层的包裹容器的 DOM 结构, 她更多时候承担的是申明独立模块边界的职责, 而她基本不会定义和视觉渲染样式相关的声明.\n\n在 bounding box 上附着模块名 ui-{MOD_NAME}, 而 ui-{MOD_NAME}负责定义的包括: display, position, float\n在 bounding box 上附着模块的矩阵(在下文中有详细描述)中的主维度状态 ui-{MOD_NAME}-{STATUS}, 例如-system, -customize\ncontent box\n\ncontent box 是定义具体模块内容的 DOM 结构, 她更多时候承担的是申明模块内部内容包裹的职责.\n\n完整情况下, 在 content box 上附着 ui-{MOD_NAME}-content, 仅用以申明该结构承担具体模块内容\n在 content box 上附着模块矩阵(在下文中有详细描述)中的次维度类型 ui-{MOD_NAME}-{TYPE}, 例如-error, -success, 她负责具体的样式声明\nbounding box 和 content box 在模块实现中的具体操作说明\n\nQ: 任何时候都需要定义 bounding box 和 content box 吗?\n\nA:\n\nbounding box 在任何情况下都需要定义, 因为 bounding box 标示模块的最外围容器.\ncontent box 是否定义的情况就相对复杂了, 它是否需要声明, 或者是否需要独立声明是由模块在设计定义中区分出来的维度和一些认为判断性的原则决定的.\n如果设计定义的分类能够在一个维度进行抽象, 那可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.\n如果设计定义的分类是多维度的矩阵情况, 而设计定义作用的元素本身在语义结构合理性上判断不应由多层结构构成, 且能够通过复写的方式实现多维度定义的情况下, 可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.\n如果设计定义的分类是多维度的矩阵情况, 在语义允许的情况下, 并且在使用复写的方式存在比较大的兼容性问题时, 那 content box 这层结构就必须存在, 为了让 bounding box 和 content box 上彼此附着的不同维度进行组合, 从而实现模块复杂多样性的矩阵.\n就 bounding box 和 content box 在抽象过程中的示例:\n\n多维度必须交叉组合实现定义的多样性\nexample: DPL 中对 feedback 的定义, 根据分析结果(如何分析设计定义就不展开了), 我们就能够建立一个简单的矩阵来描述设计定义中抽象出来的组合矩阵:\n\n[ ['standalone','addon'],['alert','error','success'] ]\n\n第一维度我们定义成: standalone(独立使用)和 addon(作为附属)\n\n第二维度我们定义成: alert(警告), error(出错)和 success(成功)\n\nps. 两类维度并没有强制的规约, 仅从语义上描述分类的便利性上做出区分.\n\n只有两个维度互相组合才能描述清楚模块在设计上的分类, 那在具体的 HTML 结构设计上, 就会变成这样:\n\n<BLOCK class=\"ui-feedback ui-feedback-{STATUS}\">\n    <BLOCK class=\"ui-feedback-content ui-feedback-{TYPE}\">\n        …some contents here\n    </BLOCK>\n</BLOCK>\nbounding box 上附着两种 class:\n\nui-feedback : MOD_NAME 部分, 仅声明当前这个闭合 DOM 文档结构是何种模块. 该声明对应的样式部分仅包含(如有需要): display, position, float 等和模块整体形式位置相关的定义.\n\nui-feedback-addon 或者 ui-feedback-standalone : MOD_NAME-{STATUS}部分, 作为多维度中模块的状态声明, 为多维度的划分方式提供第一级的 namespace.\n\ncontent box 上附着两种 class:\n\nui-feedback-content : 与 ui-feedback 所起作用基本一致, 声明当前容器是 feedback 模块中具体内容的包裹容器, 不做样式定义声明用.\n\nui-feedback-error 或者 ui-feedback-alert 或者 ui-feedback-success : MOD_NAME-{TYPE}部分, 作为多维度中模块的类型声明, 为多维度的划分方式提供第二级的 namespace.\n\n利用状态声明(bounding box 上)和类型声明(content box 上)来进行组合实现多重维度的设计定义:\n\nui-feedback-addon\n|- ui-feedback-error\n|- ui-feedback-alert\n|- ui-feedback-success\n\nui-feedback-standalone\n|- ui-feedback-error\n|- ui-feedback-alert\n|- ui-feedback-success\n当然也能是:\n\nui-feedback-error\n|- ui-feedback-addon\n|- ui-feedback-standalone\n...\n多重维度可通过复写实现多样性\nexample: DPL 中对 button 的定义, 照例按照分析结果, 我们得到一个简单的矩阵来描述设计定义中抽象出来的组合矩阵:\n\n[ [primary, normal] , [large, medium, small] ]\n\n第一维度我们定义成: primary(主要的)和 normal(普通的)\n\n第二维度我们定义成: large(大号), medium(中号)和 small(小号)\n\n从定义分解上看, 也需要多重维度才能描述清楚模块的分类, 但是对于一个简单的 button 结构来说, 使用两层 DOM 来描述真的不靠谱且没意义. 再设计定义的维度分类之上我们在加入一个语义结构合理性的原则, 那由此, 具体的 HTML 结构设计就会是这样:\n\n<INLINE class=\"ui-button ui-button-{STATUS} ui-button-{TYPE}\" />\n\n在这个例子中 bounding box 依旧坚挺的存在,而对于模型而言, content box 同样存在, 只是在实际情况下隐形了.\n\nps. 考虑到单一结构承担 bounding box 和 content box 时 class 值过长等人性判断介入的信息, 在实际声明中如果出现 content box 声明(注意, 不是 content box 模型)可有可无, 原则性选择不声明 content box 的 class.\n\n单一维度\nexample: DPL 中对 balloon 的定义, 根据设计定义分类, balloon 模块只有一个维度需要描述--箭头出现的位置, 那在 HTML 结构上的设计是:\n\n<BLOCK class=\"ui-balloon ui-balloon-{STATUS}\">\n    …some contents here\n</BLOCK>\n在这个例子中, bounding box 中的 STATUS 声明就足够将设计定义中的维度表达清楚了, 那content box的声明就没有为多维度构建可组合的职责了, 当然它可以继续充当其他职责, 比如(1)表达模块内部内容或(2)区分与内容无关的区块. 用balloon来举例, 在目前的实现中:\n\n<div class=\"ui-balloon ui-balloon-tl\">\n    <div class=\"ui-balloon-content\">\n        balloon top left\n    </div>\n    <a class=\"ui-balloon-arrow\"></a>\n</div>\n在该示例中同样存在ui-balloon-content的申明, 在结构上和上文中的ui-feedback-content很类似, 但是在balloon中更多承担的是区分在balloon内部内容和balloon的指向性箭头结构, 让其在语义化和操作便利性上更加合理.\n\n对于某些特殊场景下需要的模块属性\nexample : DPL 中对 button 的定义, 还是用 button 来举例, button 除了在上文中具备的二维分类外, 还有一个特殊场景 disabled(禁用), 在模块多维度组合的抽象结构, disable 是和其他两个维度处于同等维度上, 但是在实现上基本可以用复写的方式完成, 以减少因为组合的维度增加导致代码组织上的大量重定义.\n\n对于复写场景的编码技巧\n这里阐述的是一种小技巧, 在出现.class-a.class-b 声明的场景时由于需要照顾到低级浏览器(shit!)的兼容性问题, 要想办法让在高级浏览器中能够工作的多 class 声明的方式同样在低级浏览器中同样生效, 运气好的话可以直接用 class-b 的声明完全复写成想要的实现, 但是遇到 class-b 同样也要单独服务或者需要和其他一个命名空间配合服务(比如.class-c.class-b)的时候, 这样的情况运气就用完了. 好吧, 只能在有限的条件下将 class-a 和 class-c 这两个命名空间区分开, 比方, 在.class-a.class-b 的前面加个 p...这只能小范围解决问题, 无法杜绝问题的发生, 认命吧, 骚年!\n\n给一些命名后缀的建议\n对于模块的分类维度, 在这里给出一些常见的命名建议, 省的大家在写模块时抓破头皮.\n\n状态(STATUS)\n\nsystem / customize\nstandalone / addon\nhorizontal / vertical\nfrontend / backend\nwrap / separate\nnormal / primary\n类型(TYPE)\n\nerror / alert / success\nsmall / medium / large\nblock / nonblock\n属性(ATTRIBUTE)\n\ndisabled / readonly\ncurrent / active\nfixed / locked\n","slug":"css-code-guide","published":1,"date":"2014-06-03T16:00:00.000Z","updated":"2018-12-07T02:51:40.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmaj001gw8wkk4exroxf","content":"<p>为了提高 CSS 的可读性、维护性、扩展性、复用性，制定以下书写规范。</p>\n<p>##1 命名规范</p>\n<ol>\n<li>Id 和 Class 全部小写，并用中划线隔开。</li>\n</ol>\n<p>##2 书写规范</p>\n<ol>\n<li>样式和内容分离，不使用 style 属性定义样式。</li>\n<li>【建议】属性书写顺序<br>显示属性<br>display, position, float<br>盒模型属性<br>width, max-width, min-width,<br>height, max-height, min-height,<br>border<br>margin, margin-top, margin-right, margin-bottom, margin-left,<br>padding, padding-top, padding-right, padding-bottom, padding-left,<br>文本属性(color, font, text-decoration, text-align, vertical-align, white-space, other text, content)<br>1.</li>\n<li>（由于性能问题）不许使用表达式<code>expression</code>，请使用 Javascript 替代。</li>\n<li>【建议】在模块的开头和结尾通过注释。</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* XX模块 开始*/</span></span><br><span class=\"line\"><span class=\"comment\">/* XX模块 结束*/</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"http://blog.segmentfault.com/tychio/1190000000531277\" target=\"_blank\" rel=\"noopener\">http://blog.segmentfault.com/tychio/1190000000531277</a></p>\n<p>CSS 命名规范<br>一、类名 !important<br>全部采用中划线命名法<br><a rel=\"noopener\" href=\"javascript:void(0);\" class=\"titleMore\" target=\"_blank\">More</a> // 错误<br><a rel=\"noopener\" href=\"javascript:void(0);\" class=\"title-more\" target=\"_blank\">More</a> // 正确<br>二、文件名 !important<br>CSS 文件名统一采用小写字母加下划线的方式，单词之间用中划线(-)分割, 不允许出现大写或者其他符号。正确的如：feedback-send.css<br>CSS 文件默认情况下的编码必须采用 utf-8（无 bom），其他编码方式均不可！！！（某些专门给中文用户使用的网页中的 CSS 除外）</p>\n<p>书写规范<br>一. 不得在 css 中使用 expression !important<br>//由于性能的问题，不准使用 (通过重置触发该 Expression 的 CSS 属性来优化性能，但是也可能有其他问题)，请用 js 代替<br>.header {height:expression(document.documentElement.height)}</p>\n<p>五. CSS 选择符组<br>如果是选择符组，则这些选择符(selector)各占一行<br>.style1,<br>.style2 {background:url(xxx.gif) no-repeat ;}</p>\n<p>七. 采用属性缩写方式<br>.style {margin:10px 5px; font:normal 12px/1.5 Verdana; color:#F60; } //颜色值能简写的使用简写<br>属性缩写所代表的意思请点击 这里<br>七. 写成一行<br>.yellowish-btn,.yellow-btn{display:inline-block;zoom:1;border:0 none;background:none;}<br>.yellowish-btn:hover,.yellow-btn:hover {text-decoration:none;}<br>.yellowish-btn input,.yellow-btn input, .yellowish-btn button,.yellow-btn button {float:left;width:100%;border:0 none;}<br>.yellowish-btn input, .yellowish-btn button {height:27px;color:#7A2D01;}<br>为了方便区域阅读，属性写成一行。</p>\n<p>框架设计原则</p>\n<p>在使用中避免不必要的复杂<br>能用 CSS 完成的不动用其他资源手段</p>\n<p>有原则的优雅退化<br>加速远古浏览器的消亡, 让现代浏览器更舒适</p>\n<p>统一风格<br>让代码和使用方式以同一种机理对外服务</p>\n<p>框架实现原则</p>\n<p>科学的模块化, 减少不必要的依赖,降低耦合的可能性<br>以模块和模块组的概念提供积木, 不需要使用者做过多的额外编码工作<br>使用独立完整的代码片段, 结构化和规范化所有管辖范围内的编码方式<br>多组合, 少复写<br>HTML 结构设计原则</p>\n<p>完整封闭的模块结构<br>语义化和可及性<br>杜绝不必要的冗余, 保留合理结构增强定义灵活性</p>\n<p>命名规约</p>\n<p>normalize(reset &amp; typegraphy)直接以 HTML 元素作为选择器定义, 无额外 class 或 id 定义.<br>structure(grids &amp; layouts)遵循定义中的命名方式, 无特殊要求.<br>utility 以 util-作为前缀, 标识为工具类, 无视觉样式定义.<br>mod 中各模块以 ui-作为前缀, 标识为与视觉样式相关模块.<br>以_(下划线)作为前缀, 标识为内部未开放/不开放对外服务的部分.<br>模块名尽量让人看到名字就能知道是什么模块.</p>\n<p>good case: ui-button</p>\n<p>模块内部实现结构同样借鉴 YUI3 widget 文档中对于 widget 在结构上的规约, 模块同样存在 bounding box 和 content box, 但会根据模块本身的复杂度将这两层分层模型的规约进行合并, 分解或者省略, 而 bounding box 和 content box 指的都是 DOM 结构上的设计, 并非 CSS 的 class 声明.</p>\n<p>bounding box</p>\n<p>bounding box 是指模块最外层的包裹容器的 DOM 结构, 她更多时候承担的是申明独立模块边界的职责, 而她基本不会定义和视觉渲染样式相关的声明.</p>\n<p>在 bounding box 上附着模块名 ui-{MOD_NAME}, 而 ui-{MOD_NAME}负责定义的包括: display, position, float<br>在 bounding box 上附着模块的矩阵(在下文中有详细描述)中的主维度状态 ui-{MOD_NAME}-{STATUS}, 例如-system, -customize<br>content box</p>\n<p>content box 是定义具体模块内容的 DOM 结构, 她更多时候承担的是申明模块内部内容包裹的职责.</p>\n<p>完整情况下, 在 content box 上附着 ui-{MOD_NAME}-content, 仅用以申明该结构承担具体模块内容<br>在 content box 上附着模块矩阵(在下文中有详细描述)中的次维度类型 ui-{MOD_NAME}-{TYPE}, 例如-error, -success, 她负责具体的样式声明<br>bounding box 和 content box 在模块实现中的具体操作说明</p>\n<p>Q: 任何时候都需要定义 bounding box 和 content box 吗?</p>\n<p>A:</p>\n<p>bounding box 在任何情况下都需要定义, 因为 bounding box 标示模块的最外围容器.<br>content box 是否定义的情况就相对复杂了, 它是否需要声明, 或者是否需要独立声明是由模块在设计定义中区分出来的维度和一些认为判断性的原则决定的.<br>如果设计定义的分类能够在一个维度进行抽象, 那可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.<br>如果设计定义的分类是多维度的矩阵情况, 而设计定义作用的元素本身在语义结构合理性上判断不应由多层结构构成, 且能够通过复写的方式实现多维度定义的情况下, 可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.<br>如果设计定义的分类是多维度的矩阵情况, 在语义允许的情况下, 并且在使用复写的方式存在比较大的兼容性问题时, 那 content box 这层结构就必须存在, 为了让 bounding box 和 content box 上彼此附着的不同维度进行组合, 从而实现模块复杂多样性的矩阵.<br>就 bounding box 和 content box 在抽象过程中的示例:</p>\n<p>多维度必须交叉组合实现定义的多样性<br>example: DPL 中对 feedback 的定义, 根据分析结果(如何分析设计定义就不展开了), 我们就能够建立一个简单的矩阵来描述设计定义中抽象出来的组合矩阵:</p>\n<p>[ [‘standalone’,’addon’],[‘alert’,’error’,’success’] ]</p>\n<p>第一维度我们定义成: standalone(独立使用)和 addon(作为附属)</p>\n<p>第二维度我们定义成: alert(警告), error(出错)和 success(成功)</p>\n<p>ps. 两类维度并没有强制的规约, 仅从语义上描述分类的便利性上做出区分.</p>\n<p>只有两个维度互相组合才能描述清楚模块在设计上的分类, 那在具体的 HTML 结构设计上, 就会变成这样:</p>\n<p><block class=\"ui-feedback ui-feedback-{STATUS}\"><br>    <block class=\"ui-feedback-content ui-feedback-{TYPE}\"><br>        …some contents here<br>    </block><br></block><br>bounding box 上附着两种 class:</p>\n<p>ui-feedback : MOD_NAME 部分, 仅声明当前这个闭合 DOM 文档结构是何种模块. 该声明对应的样式部分仅包含(如有需要): display, position, float 等和模块整体形式位置相关的定义.</p>\n<p>ui-feedback-addon 或者 ui-feedback-standalone : MOD_NAME-{STATUS}部分, 作为多维度中模块的状态声明, 为多维度的划分方式提供第一级的 namespace.</p>\n<p>content box 上附着两种 class:</p>\n<p>ui-feedback-content : 与 ui-feedback 所起作用基本一致, 声明当前容器是 feedback 模块中具体内容的包裹容器, 不做样式定义声明用.</p>\n<p>ui-feedback-error 或者 ui-feedback-alert 或者 ui-feedback-success : MOD_NAME-{TYPE}部分, 作为多维度中模块的类型声明, 为多维度的划分方式提供第二级的 namespace.</p>\n<p>利用状态声明(bounding box 上)和类型声明(content box 上)来进行组合实现多重维度的设计定义:</p>\n<p>ui-feedback-addon<br>|- ui-feedback-error<br>|- ui-feedback-alert<br>|- ui-feedback-success</p>\n<p>ui-feedback-standalone<br>|- ui-feedback-error<br>|- ui-feedback-alert<br>|- ui-feedback-success<br>当然也能是:</p>\n<p>ui-feedback-error<br>|- ui-feedback-addon<br>|- ui-feedback-standalone<br>…<br>多重维度可通过复写实现多样性<br>example: DPL 中对 button 的定义, 照例按照分析结果, 我们得到一个简单的矩阵来描述设计定义中抽象出来的组合矩阵:</p>\n<p>[ [primary, normal] , [large, medium, small] ]</p>\n<p>第一维度我们定义成: primary(主要的)和 normal(普通的)</p>\n<p>第二维度我们定义成: large(大号), medium(中号)和 small(小号)</p>\n<p>从定义分解上看, 也需要多重维度才能描述清楚模块的分类, 但是对于一个简单的 button 结构来说, 使用两层 DOM 来描述真的不靠谱且没意义. 再设计定义的维度分类之上我们在加入一个语义结构合理性的原则, 那由此, 具体的 HTML 结构设计就会是这样:</p>\n<inline class=\"ui-button ui-button-{STATUS} ui-button-{TYPE}\">\n\n<p>在这个例子中 bounding box 依旧坚挺的存在,而对于模型而言, content box 同样存在, 只是在实际情况下隐形了.</p>\n<p>ps. 考虑到单一结构承担 bounding box 和 content box 时 class 值过长等人性判断介入的信息, 在实际声明中如果出现 content box 声明(注意, 不是 content box 模型)可有可无, 原则性选择不声明 content box 的 class.</p>\n<p>单一维度<br>example: DPL 中对 balloon 的定义, 根据设计定义分类, balloon 模块只有一个维度需要描述–箭头出现的位置, 那在 HTML 结构上的设计是:</p>\n<p><block class=\"ui-balloon ui-balloon-{STATUS}\"><br>    …some contents here<br></block><br>在这个例子中, bounding box 中的 STATUS 声明就足够将设计定义中的维度表达清楚了, 那content box的声明就没有为多维度构建可组合的职责了, 当然它可以继续充当其他职责, 比如(1)表达模块内部内容或(2)区分与内容无关的区块. 用balloon来举例, 在目前的实现中:</p>\n<p><div class=\"ui-balloon ui-balloon-tl\"><br>    <div class=\"ui-balloon-content\"><br>        balloon top left<br>    </div><br>    <a class=\"ui-balloon-arrow\"></a><br></div><br>在该示例中同样存在ui-balloon-content的申明, 在结构上和上文中的ui-feedback-content很类似, 但是在balloon中更多承担的是区分在balloon内部内容和balloon的指向性箭头结构, 让其在语义化和操作便利性上更加合理.</p>\n<p>对于某些特殊场景下需要的模块属性<br>example : DPL 中对 button 的定义, 还是用 button 来举例, button 除了在上文中具备的二维分类外, 还有一个特殊场景 disabled(禁用), 在模块多维度组合的抽象结构, disable 是和其他两个维度处于同等维度上, 但是在实现上基本可以用复写的方式完成, 以减少因为组合的维度增加导致代码组织上的大量重定义.</p>\n<p>对于复写场景的编码技巧<br>这里阐述的是一种小技巧, 在出现.class-a.class-b 声明的场景时由于需要照顾到低级浏览器(shit!)的兼容性问题, 要想办法让在高级浏览器中能够工作的多 class 声明的方式同样在低级浏览器中同样生效, 运气好的话可以直接用 class-b 的声明完全复写成想要的实现, 但是遇到 class-b 同样也要单独服务或者需要和其他一个命名空间配合服务(比如.class-c.class-b)的时候, 这样的情况运气就用完了. 好吧, 只能在有限的条件下将 class-a 和 class-c 这两个命名空间区分开, 比方, 在.class-a.class-b 的前面加个 p…这只能小范围解决问题, 无法杜绝问题的发生, 认命吧, 骚年!</p>\n<p>给一些命名后缀的建议<br>对于模块的分类维度, 在这里给出一些常见的命名建议, 省的大家在写模块时抓破头皮.</p>\n<p>状态(STATUS)</p>\n<p>system / customize<br>standalone / addon<br>horizontal / vertical<br>frontend / backend<br>wrap / separate<br>normal / primary<br>类型(TYPE)</p>\n<p>error / alert / success<br>small / medium / large<br>block / nonblock<br>属性(ATTRIBUTE)</p>\n<p>disabled / readonly<br>current / active<br>fixed / locked</p>\n</inline>","site":{"data":{}},"excerpt":"","more":"<p>为了提高 CSS 的可读性、维护性、扩展性、复用性，制定以下书写规范。</p>\n<p>##1 命名规范</p>\n<ol>\n<li>Id 和 Class 全部小写，并用中划线隔开。</li>\n</ol>\n<p>##2 书写规范</p>\n<ol>\n<li>样式和内容分离，不使用 style 属性定义样式。</li>\n<li>【建议】属性书写顺序<br>显示属性<br>display, position, float<br>盒模型属性<br>width, max-width, min-width,<br>height, max-height, min-height,<br>border<br>margin, margin-top, margin-right, margin-bottom, margin-left,<br>padding, padding-top, padding-right, padding-bottom, padding-left,<br>文本属性(color, font, text-decoration, text-align, vertical-align, white-space, other text, content)<br>1.</li>\n<li>（由于性能问题）不许使用表达式<code>expression</code>，请使用 Javascript 替代。</li>\n<li>【建议】在模块的开头和结尾通过注释。</li>\n</ol>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* XX模块 开始*/</span></span><br><span class=\"line\"><span class=\"comment\">/* XX模块 结束*/</span></span><br></pre></td></tr></table></figure>\n<p><a href=\"http://blog.segmentfault.com/tychio/1190000000531277\" target=\"_blank\" rel=\"noopener\">http://blog.segmentfault.com/tychio/1190000000531277</a></p>\n<p>CSS 命名规范<br>一、类名 !important<br>全部采用中划线命名法<br><a rel=\"noopener\" href=\"javascript:void(0);\" class=\"titleMore\" target=\"_blank\">More</a> // 错误<br><a rel=\"noopener\" href=\"javascript:void(0);\" class=\"title-more\" target=\"_blank\">More</a> // 正确<br>二、文件名 !important<br>CSS 文件名统一采用小写字母加下划线的方式，单词之间用中划线(-)分割, 不允许出现大写或者其他符号。正确的如：feedback-send.css<br>CSS 文件默认情况下的编码必须采用 utf-8（无 bom），其他编码方式均不可！！！（某些专门给中文用户使用的网页中的 CSS 除外）</p>\n<p>书写规范<br>一. 不得在 css 中使用 expression !important<br>//由于性能的问题，不准使用 (通过重置触发该 Expression 的 CSS 属性来优化性能，但是也可能有其他问题)，请用 js 代替<br>.header {height:expression(document.documentElement.height)}</p>\n<p>五. CSS 选择符组<br>如果是选择符组，则这些选择符(selector)各占一行<br>.style1,<br>.style2 {background:url(xxx.gif) no-repeat ;}</p>\n<p>七. 采用属性缩写方式<br>.style {margin:10px 5px; font:normal 12px/1.5 Verdana; color:#F60; } //颜色值能简写的使用简写<br>属性缩写所代表的意思请点击 这里<br>七. 写成一行<br>.yellowish-btn,.yellow-btn{display:inline-block;zoom:1;border:0 none;background:none;}<br>.yellowish-btn:hover,.yellow-btn:hover {text-decoration:none;}<br>.yellowish-btn input,.yellow-btn input, .yellowish-btn button,.yellow-btn button {float:left;width:100%;border:0 none;}<br>.yellowish-btn input, .yellowish-btn button {height:27px;color:#7A2D01;}<br>为了方便区域阅读，属性写成一行。</p>\n<p>框架设计原则</p>\n<p>在使用中避免不必要的复杂<br>能用 CSS 完成的不动用其他资源手段</p>\n<p>有原则的优雅退化<br>加速远古浏览器的消亡, 让现代浏览器更舒适</p>\n<p>统一风格<br>让代码和使用方式以同一种机理对外服务</p>\n<p>框架实现原则</p>\n<p>科学的模块化, 减少不必要的依赖,降低耦合的可能性<br>以模块和模块组的概念提供积木, 不需要使用者做过多的额外编码工作<br>使用独立完整的代码片段, 结构化和规范化所有管辖范围内的编码方式<br>多组合, 少复写<br>HTML 结构设计原则</p>\n<p>完整封闭的模块结构<br>语义化和可及性<br>杜绝不必要的冗余, 保留合理结构增强定义灵活性</p>\n<p>命名规约</p>\n<p>normalize(reset &amp; typegraphy)直接以 HTML 元素作为选择器定义, 无额外 class 或 id 定义.<br>structure(grids &amp; layouts)遵循定义中的命名方式, 无特殊要求.<br>utility 以 util-作为前缀, 标识为工具类, 无视觉样式定义.<br>mod 中各模块以 ui-作为前缀, 标识为与视觉样式相关模块.<br>以_(下划线)作为前缀, 标识为内部未开放/不开放对外服务的部分.<br>模块名尽量让人看到名字就能知道是什么模块.</p>\n<p>good case: ui-button</p>\n<p>模块内部实现结构同样借鉴 YUI3 widget 文档中对于 widget 在结构上的规约, 模块同样存在 bounding box 和 content box, 但会根据模块本身的复杂度将这两层分层模型的规约进行合并, 分解或者省略, 而 bounding box 和 content box 指的都是 DOM 结构上的设计, 并非 CSS 的 class 声明.</p>\n<p>bounding box</p>\n<p>bounding box 是指模块最外层的包裹容器的 DOM 结构, 她更多时候承担的是申明独立模块边界的职责, 而她基本不会定义和视觉渲染样式相关的声明.</p>\n<p>在 bounding box 上附着模块名 ui-{MOD_NAME}, 而 ui-{MOD_NAME}负责定义的包括: display, position, float<br>在 bounding box 上附着模块的矩阵(在下文中有详细描述)中的主维度状态 ui-{MOD_NAME}-{STATUS}, 例如-system, -customize<br>content box</p>\n<p>content box 是定义具体模块内容的 DOM 结构, 她更多时候承担的是申明模块内部内容包裹的职责.</p>\n<p>完整情况下, 在 content box 上附着 ui-{MOD_NAME}-content, 仅用以申明该结构承担具体模块内容<br>在 content box 上附着模块矩阵(在下文中有详细描述)中的次维度类型 ui-{MOD_NAME}-{TYPE}, 例如-error, -success, 她负责具体的样式声明<br>bounding box 和 content box 在模块实现中的具体操作说明</p>\n<p>Q: 任何时候都需要定义 bounding box 和 content box 吗?</p>\n<p>A:</p>\n<p>bounding box 在任何情况下都需要定义, 因为 bounding box 标示模块的最外围容器.<br>content box 是否定义的情况就相对复杂了, 它是否需要声明, 或者是否需要独立声明是由模块在设计定义中区分出来的维度和一些认为判断性的原则决定的.<br>如果设计定义的分类能够在一个维度进行抽象, 那可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.<br>如果设计定义的分类是多维度的矩阵情况, 而设计定义作用的元素本身在语义结构合理性上判断不应由多层结构构成, 且能够通过复写的方式实现多维度定义的情况下, 可以不显性声明 content box 的 class, 而 content box 的结构由 bounding box 的结构承担.<br>如果设计定义的分类是多维度的矩阵情况, 在语义允许的情况下, 并且在使用复写的方式存在比较大的兼容性问题时, 那 content box 这层结构就必须存在, 为了让 bounding box 和 content box 上彼此附着的不同维度进行组合, 从而实现模块复杂多样性的矩阵.<br>就 bounding box 和 content box 在抽象过程中的示例:</p>\n<p>多维度必须交叉组合实现定义的多样性<br>example: DPL 中对 feedback 的定义, 根据分析结果(如何分析设计定义就不展开了), 我们就能够建立一个简单的矩阵来描述设计定义中抽象出来的组合矩阵:</p>\n<p>[ [‘standalone’,’addon’],[‘alert’,’error’,’success’] ]</p>\n<p>第一维度我们定义成: standalone(独立使用)和 addon(作为附属)</p>\n<p>第二维度我们定义成: alert(警告), error(出错)和 success(成功)</p>\n<p>ps. 两类维度并没有强制的规约, 仅从语义上描述分类的便利性上做出区分.</p>\n<p>只有两个维度互相组合才能描述清楚模块在设计上的分类, 那在具体的 HTML 结构设计上, 就会变成这样:</p>\n<p><block class=\"ui-feedback ui-feedback-{STATUS}\"><br>    <block class=\"ui-feedback-content ui-feedback-{TYPE}\"><br>        …some contents here<br>    </block><br></block><br>bounding box 上附着两种 class:</p>\n<p>ui-feedback : MOD_NAME 部分, 仅声明当前这个闭合 DOM 文档结构是何种模块. 该声明对应的样式部分仅包含(如有需要): display, position, float 等和模块整体形式位置相关的定义.</p>\n<p>ui-feedback-addon 或者 ui-feedback-standalone : MOD_NAME-{STATUS}部分, 作为多维度中模块的状态声明, 为多维度的划分方式提供第一级的 namespace.</p>\n<p>content box 上附着两种 class:</p>\n<p>ui-feedback-content : 与 ui-feedback 所起作用基本一致, 声明当前容器是 feedback 模块中具体内容的包裹容器, 不做样式定义声明用.</p>\n<p>ui-feedback-error 或者 ui-feedback-alert 或者 ui-feedback-success : MOD_NAME-{TYPE}部分, 作为多维度中模块的类型声明, 为多维度的划分方式提供第二级的 namespace.</p>\n<p>利用状态声明(bounding box 上)和类型声明(content box 上)来进行组合实现多重维度的设计定义:</p>\n<p>ui-feedback-addon<br>|- ui-feedback-error<br>|- ui-feedback-alert<br>|- ui-feedback-success</p>\n<p>ui-feedback-standalone<br>|- ui-feedback-error<br>|- ui-feedback-alert<br>|- ui-feedback-success<br>当然也能是:</p>\n<p>ui-feedback-error<br>|- ui-feedback-addon<br>|- ui-feedback-standalone<br>…<br>多重维度可通过复写实现多样性<br>example: DPL 中对 button 的定义, 照例按照分析结果, 我们得到一个简单的矩阵来描述设计定义中抽象出来的组合矩阵:</p>\n<p>[ [primary, normal] , [large, medium, small] ]</p>\n<p>第一维度我们定义成: primary(主要的)和 normal(普通的)</p>\n<p>第二维度我们定义成: large(大号), medium(中号)和 small(小号)</p>\n<p>从定义分解上看, 也需要多重维度才能描述清楚模块的分类, 但是对于一个简单的 button 结构来说, 使用两层 DOM 来描述真的不靠谱且没意义. 再设计定义的维度分类之上我们在加入一个语义结构合理性的原则, 那由此, 具体的 HTML 结构设计就会是这样:</p>\n<inline class=\"ui-button ui-button-{STATUS} ui-button-{TYPE}\">\n\n<p>在这个例子中 bounding box 依旧坚挺的存在,而对于模型而言, content box 同样存在, 只是在实际情况下隐形了.</p>\n<p>ps. 考虑到单一结构承担 bounding box 和 content box 时 class 值过长等人性判断介入的信息, 在实际声明中如果出现 content box 声明(注意, 不是 content box 模型)可有可无, 原则性选择不声明 content box 的 class.</p>\n<p>单一维度<br>example: DPL 中对 balloon 的定义, 根据设计定义分类, balloon 模块只有一个维度需要描述–箭头出现的位置, 那在 HTML 结构上的设计是:</p>\n<p><block class=\"ui-balloon ui-balloon-{STATUS}\"><br>    …some contents here<br></block><br>在这个例子中, bounding box 中的 STATUS 声明就足够将设计定义中的维度表达清楚了, 那content box的声明就没有为多维度构建可组合的职责了, 当然它可以继续充当其他职责, 比如(1)表达模块内部内容或(2)区分与内容无关的区块. 用balloon来举例, 在目前的实现中:</p>\n<p><div class=\"ui-balloon ui-balloon-tl\"><br>    <div class=\"ui-balloon-content\"><br>        balloon top left<br>    </div><br>    <a class=\"ui-balloon-arrow\"></a><br></div><br>在该示例中同样存在ui-balloon-content的申明, 在结构上和上文中的ui-feedback-content很类似, 但是在balloon中更多承担的是区分在balloon内部内容和balloon的指向性箭头结构, 让其在语义化和操作便利性上更加合理.</p>\n<p>对于某些特殊场景下需要的模块属性<br>example : DPL 中对 button 的定义, 还是用 button 来举例, button 除了在上文中具备的二维分类外, 还有一个特殊场景 disabled(禁用), 在模块多维度组合的抽象结构, disable 是和其他两个维度处于同等维度上, 但是在实现上基本可以用复写的方式完成, 以减少因为组合的维度增加导致代码组织上的大量重定义.</p>\n<p>对于复写场景的编码技巧<br>这里阐述的是一种小技巧, 在出现.class-a.class-b 声明的场景时由于需要照顾到低级浏览器(shit!)的兼容性问题, 要想办法让在高级浏览器中能够工作的多 class 声明的方式同样在低级浏览器中同样生效, 运气好的话可以直接用 class-b 的声明完全复写成想要的实现, 但是遇到 class-b 同样也要单独服务或者需要和其他一个命名空间配合服务(比如.class-c.class-b)的时候, 这样的情况运气就用完了. 好吧, 只能在有限的条件下将 class-a 和 class-c 这两个命名空间区分开, 比方, 在.class-a.class-b 的前面加个 p…这只能小范围解决问题, 无法杜绝问题的发生, 认命吧, 骚年!</p>\n<p>给一些命名后缀的建议<br>对于模块的分类维度, 在这里给出一些常见的命名建议, 省的大家在写模块时抓破头皮.</p>\n<p>状态(STATUS)</p>\n<p>system / customize<br>standalone / addon<br>horizontal / vertical<br>frontend / backend<br>wrap / separate<br>normal / primary<br>类型(TYPE)</p>\n<p>error / alert / success<br>small / medium / large<br>block / nonblock<br>属性(ATTRIBUTE)</p>\n<p>disabled / readonly<br>current / active<br>fixed / locked</p>\n</inline>"},{"title":"主要CSS3，HTML5特性兼容性调查","_content":"\n## CSS3 HTML5 部分特性\n\n| 特性组     | 特性                           | IE8 | IE9 | IE10 | IE11 | Edge | CH  | FF  | SF  | 参考                                                                                                              |\n| ---------- | :----------------------------- | :-: | :-: | :--: | :--: | :--: | :-: | :-- | --- | ----------------------------------------------------------------------------------------------------------------- |\n| values     |\n|            | calc                           |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   | [caniuse](http://caniuse.com/#search=calc)                                                                        |\n|            | rem                            |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   | [caniuse](http://caniuse.com/#search=rem)                                                                         |\n|            | vw,vh                          |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   | [caniuse](http://caniuse.com/#search=vw)                                                                          |\n| color      |\n|            | currentColor                   |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | hsl hsla rgba                  |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| background |\n|            | border-radius                  |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | border-images                  |  ×  |  ×  |  ×   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| images     |\n|            | linear-gradient                |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | radial-gradient                |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | repeating-linear-gradient      |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | repeating-radial-gradient      |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| animation  |\n|            | keyframes                      |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | requestAnimationFrame          |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| transform  |\n|            | 2d                             |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | 3d                             |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| postion    |\n|            | position:sticky                |  ×  |  -  |  -   |  -   |  -   |  -  | √   | √   | [caniuse](http://caniuse.com/#search=sticky), [polyfill](https://github.com/wilddeer/stickyfill)                  |\n| selector   |\n|            | querySelector querySelectorAll |  √  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| webfonts   |\n|            | @font-face                     |  √  |  √  |  √   |  √   |  √   |  √  | √   | √   | [小米案例](http://www.mi.com/mi4/)                                                                                |\n| ui         |\n|            | sizing-box                     |  √  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| dom        |\n|            | mutation-observers             |  ×  |  -  |  -   |  √   |  √   |  √  | √   | √   | [caniuse](http://caniuse.com/#search=MutationEvents), [polyfill](https://github.com/webmodules/mutation-observer) |\n| HTML5      |\n|            | audio                          |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | video                          |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| ECMA5      |\n|            | Promises                       |  -  |  -  |  -   |  -   |  √   |  √  | √   | √   |                                                                                                                   |\n\n## CSS 选择器\n\n| -                      | CSS 选择器                                                | IE8+ | IE9 | IE10+ |\n| ---------------------- | --------------------------------------------------------- | ---- | --- | ----- |\n| CSS2.1                 |\n| \\*                     | 通配符                                                    | √    | √   | √     |\n| #foo                   | ID 选择器                                                 | √    | √   | √     |\n| .foo                   | 类选择器                                                  | √    | √   | √     |\n| foo                    | 节点选择器                                                | √    | √   | √     |\n| \\>                     | 子选择器                                                  | √    | √   | √     |\n| +                      | 后一个兄弟节点                                            | √    | √   | √     |\n| [attr]                 | 带有 attr 属性的元素                                      | √    | √   | √     |\n| [attr=\"val\"]           | &lt;div attr=\"val\"/&gt;                                   | √    | √   | √     |\n| [attr~=\"val\"]          | &lt;div attr=\"val val1\"/&gt;                              | √    | √   | √     |\n| [attr&#124;=\"val\"]     | &lt;div attr=\"val-val1\"/&gt;                              | √    | √   | √     |\n| :first-child           | 第一个子元素                                              | √    | √   | √     |\n| :link, :visited        | 伪类，仅适用于 a 标签                                     | √    | √   | √     |\n| :active, :hover        | 伪类，适用于所有元素                                      | √    | √   | √     |\n| :focus                 | 伪类，获取焦点的元素                                      | √    | √   | √     |\n| :lang()                | 伪类，&lt;div lang=\"en\"/&gt;                              | √    | √   | √     |\n| CSS3                   |\n| [attr^=\"val\"]          | 带有 attr 属性并且值以 val 打头                           | √    | √   | √     |\n| [attr$=\"val\"]          | 带有 attr 属性并且值以 val 结束                           | √    | √   | √     |\n| [attr*=\"val\"]          | 带有 attr 属性并且值中带有 val 字眼                       | √    | √   | √     |\n| ~                      | 后面兄弟选择器                                            | √    | √   | √     |\n| :last-child            | 最后一个子元素                                            | ×    | √   | √     |\n| :root                  | 根元素                                                    | ×    | √   | √     |\n| :only-child            | 唯一的子节点                                              | ×    | √   | √     |\n| :nth-child()           | 选择一个或多个子元素，参数 n 代表 0-+∞                    | ×    | √   | √     |\n| :nth-last-child()      | 选择一个或多个子元素，参数 n 代表 0-+∞，从后往前选择      | ×    | √   | √     |\n| tag:only-of-type       | 唯一 tag 元素                                             | ×    | √   | √     |\n| tag:nth-of-type        | 选择一个或多个子 tag 元素，参数 n 代表 0-+∞               | ×    | √   | √     |\n| tag:nth-last-of-type() | 选择一个或多个子 tag 元素，参数 n 代表 0-+∞，从后往前选择 | ×    | √   | √     |\n| tag:first-of-type      | 选择第一个 tag 元素                                       | ×    | √   | √     |\n| tag:last-of-type       | 选择最后一个 tag 元素                                     | ×    | √   | √     |\n| :empty                 | 匹配空节点                                                | ×    | √   | √     |\n| :target                | 匹配 hash 相应的元素                                      | ×    | √   | √     |\n| :enabled, :disabled    | 匹配表单中启用或禁用的元素                                | ×    | √   | √     |\n| :checked               | 匹配表单中选中的元素                                      | ×    | √   | √     |\n| :not()                 | 否定选择器                                                | ×    | √   | √     |\n\n备注：没有添加伪元素。\n\n## CSS2.1 之前的一些不为人知的特性\n\n| 特性        | 可选值以及含义                                                                                                                             |\n| ----------- | :----------------------------------------------------------------------------------------------------------------------------------------- |\n| empty-cells | hide：当 td 的子元素都是隐藏的时候，自动隐藏该 td 的边框和背景<br/>show：永远显示<br/>不过该属性只有在 border-collapse:separate;时才有效。 |\n\n## 参考：\n\n1. [CSS Current Work](http://www.w3.org/Style/CSS/current-work) 这里记载着 CSS 规范子集的进度（稳定级别）：工作草案，最后通告，候选标准，推荐标准和标准。\n2. [W3C Technical Report Development Process](http://www.w3.org/2005/10/Process-20051014/tr.html) W3C 技术报告开发过程\n3. [《W3C 技术报告开发过程》](http://www.w3ctech.com/topic/746) 只翻译一部分\n4. [Mozilla CSS support chart](https://developer.mozilla.org/en-US/docs/Web/CSS/Mozilla_support_chart) 火狐浏览器 CSS 特性支持\n5. [Safari CSS Reference](https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariCSSRef/Introduction.html)\n6. [Comparison of layout engines (Cascading Style Sheets)](<https://en.wikipedia.org/wiki/Comparison_of_layout_engines_(Cascading_Style_Sheets)>) 中文版[浏览器引擎 CSS 支持比较](https://zh.wikipedia.org/zh-cn/%E7%80%8F%E8%A6%BD%E5%99%A8%E5%BC%95%E6%93%8ECSS%E6%94%AF%E6%8F%B4%E6%AF%94%E8%BC%83)\n7. http://t337.org-w3c-region-chinese-html5.w3ctalk.info/w3c-t337.html\n","source":"_posts/2016-07-04-css3-html5-feature-compatibility-survey.md","raw":"---\ntitle: 主要CSS3，HTML5特性兼容性调查\n---\n\n## CSS3 HTML5 部分特性\n\n| 特性组     | 特性                           | IE8 | IE9 | IE10 | IE11 | Edge | CH  | FF  | SF  | 参考                                                                                                              |\n| ---------- | :----------------------------- | :-: | :-: | :--: | :--: | :--: | :-: | :-- | --- | ----------------------------------------------------------------------------------------------------------------- |\n| values     |\n|            | calc                           |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   | [caniuse](http://caniuse.com/#search=calc)                                                                        |\n|            | rem                            |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   | [caniuse](http://caniuse.com/#search=rem)                                                                         |\n|            | vw,vh                          |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   | [caniuse](http://caniuse.com/#search=vw)                                                                          |\n| color      |\n|            | currentColor                   |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | hsl hsla rgba                  |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| background |\n|            | border-radius                  |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | border-images                  |  ×  |  ×  |  ×   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| images     |\n|            | linear-gradient                |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | radial-gradient                |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | repeating-linear-gradient      |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | repeating-radial-gradient      |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| animation  |\n|            | keyframes                      |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | requestAnimationFrame          |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| transform  |\n|            | 2d                             |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | 3d                             |  ×  |  ×  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| postion    |\n|            | position:sticky                |  ×  |  -  |  -   |  -   |  -   |  -  | √   | √   | [caniuse](http://caniuse.com/#search=sticky), [polyfill](https://github.com/wilddeer/stickyfill)                  |\n| selector   |\n|            | querySelector querySelectorAll |  √  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| webfonts   |\n|            | @font-face                     |  √  |  √  |  √   |  √   |  √   |  √  | √   | √   | [小米案例](http://www.mi.com/mi4/)                                                                                |\n| ui         |\n|            | sizing-box                     |  √  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| dom        |\n|            | mutation-observers             |  ×  |  -  |  -   |  √   |  √   |  √  | √   | √   | [caniuse](http://caniuse.com/#search=MutationEvents), [polyfill](https://github.com/webmodules/mutation-observer) |\n| HTML5      |\n|            | audio                          |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n|            | video                          |  ×  |  √  |  √   |  √   |  √   |  √  | √   | √   |                                                                                                                   |\n| ECMA5      |\n|            | Promises                       |  -  |  -  |  -   |  -   |  √   |  √  | √   | √   |                                                                                                                   |\n\n## CSS 选择器\n\n| -                      | CSS 选择器                                                | IE8+ | IE9 | IE10+ |\n| ---------------------- | --------------------------------------------------------- | ---- | --- | ----- |\n| CSS2.1                 |\n| \\*                     | 通配符                                                    | √    | √   | √     |\n| #foo                   | ID 选择器                                                 | √    | √   | √     |\n| .foo                   | 类选择器                                                  | √    | √   | √     |\n| foo                    | 节点选择器                                                | √    | √   | √     |\n| \\>                     | 子选择器                                                  | √    | √   | √     |\n| +                      | 后一个兄弟节点                                            | √    | √   | √     |\n| [attr]                 | 带有 attr 属性的元素                                      | √    | √   | √     |\n| [attr=\"val\"]           | &lt;div attr=\"val\"/&gt;                                   | √    | √   | √     |\n| [attr~=\"val\"]          | &lt;div attr=\"val val1\"/&gt;                              | √    | √   | √     |\n| [attr&#124;=\"val\"]     | &lt;div attr=\"val-val1\"/&gt;                              | √    | √   | √     |\n| :first-child           | 第一个子元素                                              | √    | √   | √     |\n| :link, :visited        | 伪类，仅适用于 a 标签                                     | √    | √   | √     |\n| :active, :hover        | 伪类，适用于所有元素                                      | √    | √   | √     |\n| :focus                 | 伪类，获取焦点的元素                                      | √    | √   | √     |\n| :lang()                | 伪类，&lt;div lang=\"en\"/&gt;                              | √    | √   | √     |\n| CSS3                   |\n| [attr^=\"val\"]          | 带有 attr 属性并且值以 val 打头                           | √    | √   | √     |\n| [attr$=\"val\"]          | 带有 attr 属性并且值以 val 结束                           | √    | √   | √     |\n| [attr*=\"val\"]          | 带有 attr 属性并且值中带有 val 字眼                       | √    | √   | √     |\n| ~                      | 后面兄弟选择器                                            | √    | √   | √     |\n| :last-child            | 最后一个子元素                                            | ×    | √   | √     |\n| :root                  | 根元素                                                    | ×    | √   | √     |\n| :only-child            | 唯一的子节点                                              | ×    | √   | √     |\n| :nth-child()           | 选择一个或多个子元素，参数 n 代表 0-+∞                    | ×    | √   | √     |\n| :nth-last-child()      | 选择一个或多个子元素，参数 n 代表 0-+∞，从后往前选择      | ×    | √   | √     |\n| tag:only-of-type       | 唯一 tag 元素                                             | ×    | √   | √     |\n| tag:nth-of-type        | 选择一个或多个子 tag 元素，参数 n 代表 0-+∞               | ×    | √   | √     |\n| tag:nth-last-of-type() | 选择一个或多个子 tag 元素，参数 n 代表 0-+∞，从后往前选择 | ×    | √   | √     |\n| tag:first-of-type      | 选择第一个 tag 元素                                       | ×    | √   | √     |\n| tag:last-of-type       | 选择最后一个 tag 元素                                     | ×    | √   | √     |\n| :empty                 | 匹配空节点                                                | ×    | √   | √     |\n| :target                | 匹配 hash 相应的元素                                      | ×    | √   | √     |\n| :enabled, :disabled    | 匹配表单中启用或禁用的元素                                | ×    | √   | √     |\n| :checked               | 匹配表单中选中的元素                                      | ×    | √   | √     |\n| :not()                 | 否定选择器                                                | ×    | √   | √     |\n\n备注：没有添加伪元素。\n\n## CSS2.1 之前的一些不为人知的特性\n\n| 特性        | 可选值以及含义                                                                                                                             |\n| ----------- | :----------------------------------------------------------------------------------------------------------------------------------------- |\n| empty-cells | hide：当 td 的子元素都是隐藏的时候，自动隐藏该 td 的边框和背景<br/>show：永远显示<br/>不过该属性只有在 border-collapse:separate;时才有效。 |\n\n## 参考：\n\n1. [CSS Current Work](http://www.w3.org/Style/CSS/current-work) 这里记载着 CSS 规范子集的进度（稳定级别）：工作草案，最后通告，候选标准，推荐标准和标准。\n2. [W3C Technical Report Development Process](http://www.w3.org/2005/10/Process-20051014/tr.html) W3C 技术报告开发过程\n3. [《W3C 技术报告开发过程》](http://www.w3ctech.com/topic/746) 只翻译一部分\n4. [Mozilla CSS support chart](https://developer.mozilla.org/en-US/docs/Web/CSS/Mozilla_support_chart) 火狐浏览器 CSS 特性支持\n5. [Safari CSS Reference](https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariCSSRef/Introduction.html)\n6. [Comparison of layout engines (Cascading Style Sheets)](<https://en.wikipedia.org/wiki/Comparison_of_layout_engines_(Cascading_Style_Sheets)>) 中文版[浏览器引擎 CSS 支持比较](https://zh.wikipedia.org/zh-cn/%E7%80%8F%E8%A6%BD%E5%99%A8%E5%BC%95%E6%93%8ECSS%E6%94%AF%E6%8F%B4%E6%AF%94%E8%BC%83)\n7. http://t337.org-w3c-region-chinese-html5.w3ctalk.info/w3c-t337.html\n","slug":"css3-html5-feature-compatibility-survey","published":1,"date":"2016-07-03T16:00:00.000Z","updated":"2018-12-07T02:43:42.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmak001hw8wkixsyy9gv","content":"<h2 id=\"CSS3-HTML5-部分特性\"><a href=\"#CSS3-HTML5-部分特性\" class=\"headerlink\" title=\"CSS3 HTML5 部分特性\"></a>CSS3 HTML5 部分特性</h2><table>\n<thead>\n<tr>\n<th>特性组</th>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:center\">IE8</th>\n<th style=\"text-align:center\">IE9</th>\n<th style=\"text-align:center\">IE10</th>\n<th style=\"text-align:center\">IE11</th>\n<th style=\"text-align:center\">Edge</th>\n<th style=\"text-align:center\">CH</th>\n<th style=\"text-align:left\">FF</th>\n<th>SF</th>\n<th>参考</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>values</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">calc</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=calc\" target=\"_blank\" rel=\"noopener\">caniuse</a></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">rem</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=rem\" target=\"_blank\" rel=\"noopener\">caniuse</a></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">vw,vh</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=vw\" target=\"_blank\" rel=\"noopener\">caniuse</a></td>\n</tr>\n<tr>\n<td>color</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">currentColor</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">hsl hsla rgba</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>background</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">border-radius</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">border-images</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>images</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">linear-gradient</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">radial-gradient</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">repeating-linear-gradient</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">repeating-radial-gradient</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>animation</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">keyframes</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">requestAnimationFrame</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>transform</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">2d</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">3d</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>postion</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">position:sticky</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=sticky\" target=\"_blank\" rel=\"noopener\">caniuse</a>, <a href=\"https://github.com/wilddeer/stickyfill\" target=\"_blank\" rel=\"noopener\">polyfill</a></td>\n</tr>\n<tr>\n<td>selector</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">querySelector querySelectorAll</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>webfonts</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">@font-face</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://www.mi.com/mi4/\" target=\"_blank\" rel=\"noopener\">小米案例</a></td>\n</tr>\n<tr>\n<td>ui</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">sizing-box</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>dom</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">mutation-observers</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=MutationEvents\" target=\"_blank\" rel=\"noopener\">caniuse</a>, <a href=\"https://github.com/webmodules/mutation-observer\" target=\"_blank\" rel=\"noopener\">polyfill</a></td>\n</tr>\n<tr>\n<td>HTML5</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">audio</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">video</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>ECMA5</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">Promises</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"CSS-选择器\"><a href=\"#CSS-选择器\" class=\"headerlink\" title=\"CSS 选择器\"></a>CSS 选择器</h2><table>\n<thead>\n<tr>\n<th>-</th>\n<th>CSS 选择器</th>\n<th>IE8+</th>\n<th>IE9</th>\n<th>IE10+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CSS2.1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>通配符</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>#foo</td>\n<td>ID 选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>.foo</td>\n<td>类选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>foo</td>\n<td>节点选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>></td>\n<td>子选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>+</td>\n<td>后一个兄弟节点</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr]</td>\n<td>带有 attr 属性的元素</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr=”val”]</td>\n<td>&lt;div attr=”val”/&gt;</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr~=”val”]</td>\n<td>&lt;div attr=”val val1”/&gt;</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr&#124;=”val”]</td>\n<td>&lt;div attr=”val-val1”/&gt;</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:first-child</td>\n<td>第一个子元素</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:link, :visited</td>\n<td>伪类，仅适用于 a 标签</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:active, :hover</td>\n<td>伪类，适用于所有元素</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:focus</td>\n<td>伪类，获取焦点的元素</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:lang()</td>\n<td>伪类，&lt;div lang=”en”/&gt;</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>CSS3</td>\n</tr>\n<tr>\n<td>[attr^=”val”]</td>\n<td>带有 attr 属性并且值以 val 打头</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr$=”val”]</td>\n<td>带有 attr 属性并且值以 val 结束</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr*=”val”]</td>\n<td>带有 attr 属性并且值中带有 val 字眼</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>~</td>\n<td>后面兄弟选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:last-child</td>\n<td>最后一个子元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:root</td>\n<td>根元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:only-child</td>\n<td>唯一的子节点</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:nth-child()</td>\n<td>选择一个或多个子元素，参数 n 代表 0-+∞</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:nth-last-child()</td>\n<td>选择一个或多个子元素，参数 n 代表 0-+∞，从后往前选择</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:only-of-type</td>\n<td>唯一 tag 元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:nth-of-type</td>\n<td>选择一个或多个子 tag 元素，参数 n 代表 0-+∞</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:nth-last-of-type()</td>\n<td>选择一个或多个子 tag 元素，参数 n 代表 0-+∞，从后往前选择</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:first-of-type</td>\n<td>选择第一个 tag 元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:last-of-type</td>\n<td>选择最后一个 tag 元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:empty</td>\n<td>匹配空节点</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:target</td>\n<td>匹配 hash 相应的元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:enabled, :disabled</td>\n<td>匹配表单中启用或禁用的元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:checked</td>\n<td>匹配表单中选中的元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:not()</td>\n<td>否定选择器</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody>\n</table>\n<p>备注：没有添加伪元素。</p>\n<h2 id=\"CSS2-1-之前的一些不为人知的特性\"><a href=\"#CSS2-1-之前的一些不为人知的特性\" class=\"headerlink\" title=\"CSS2.1 之前的一些不为人知的特性\"></a>CSS2.1 之前的一些不为人知的特性</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th style=\"text-align:left\">可选值以及含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>empty-cells</td>\n<td style=\"text-align:left\">hide：当 td 的子元素都是隐藏的时候，自动隐藏该 td 的边框和背景<br>show：永远显示<br>不过该属性只有在 border-collapse:separate;时才有效。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ol>\n<li><a href=\"http://www.w3.org/Style/CSS/current-work\" target=\"_blank\" rel=\"noopener\">CSS Current Work</a> 这里记载着 CSS 规范子集的进度（稳定级别）：工作草案，最后通告，候选标准，推荐标准和标准。</li>\n<li><a href=\"http://www.w3.org/2005/10/Process-20051014/tr.html\" target=\"_blank\" rel=\"noopener\">W3C Technical Report Development Process</a> W3C 技术报告开发过程</li>\n<li><a href=\"http://www.w3ctech.com/topic/746\" target=\"_blank\" rel=\"noopener\">《W3C 技术报告开发过程》</a> 只翻译一部分</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Mozilla_support_chart\" target=\"_blank\" rel=\"noopener\">Mozilla CSS support chart</a> 火狐浏览器 CSS 特性支持</li>\n<li><a href=\"https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariCSSRef/Introduction.html\" target=\"_blank\" rel=\"noopener\">Safari CSS Reference</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Comparison_of_layout_engines_(Cascading_Style_Sheets\" target=\"_blank\" rel=\"noopener\">Comparison of layout engines (Cascading Style Sheets)</a>&gt;) 中文版<a href=\"https://zh.wikipedia.org/zh-cn/%E7%80%8F%E8%A6%BD%E5%99%A8%E5%BC%95%E6%93%8ECSS%E6%94%AF%E6%8F%B4%E6%AF%94%E8%BC%83\" target=\"_blank\" rel=\"noopener\">浏览器引擎 CSS 支持比较</a></li>\n<li><a href=\"http://t337.org-w3c-region-chinese-html5.w3ctalk.info/w3c-t337.html\" target=\"_blank\" rel=\"noopener\">http://t337.org-w3c-region-chinese-html5.w3ctalk.info/w3c-t337.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CSS3-HTML5-部分特性\"><a href=\"#CSS3-HTML5-部分特性\" class=\"headerlink\" title=\"CSS3 HTML5 部分特性\"></a>CSS3 HTML5 部分特性</h2><table>\n<thead>\n<tr>\n<th>特性组</th>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:center\">IE8</th>\n<th style=\"text-align:center\">IE9</th>\n<th style=\"text-align:center\">IE10</th>\n<th style=\"text-align:center\">IE11</th>\n<th style=\"text-align:center\">Edge</th>\n<th style=\"text-align:center\">CH</th>\n<th style=\"text-align:left\">FF</th>\n<th>SF</th>\n<th>参考</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>values</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">calc</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=calc\" target=\"_blank\" rel=\"noopener\">caniuse</a></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">rem</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=rem\" target=\"_blank\" rel=\"noopener\">caniuse</a></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">vw,vh</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=vw\" target=\"_blank\" rel=\"noopener\">caniuse</a></td>\n</tr>\n<tr>\n<td>color</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">currentColor</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">hsl hsla rgba</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>background</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">border-radius</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">border-images</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>images</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">linear-gradient</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">radial-gradient</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">repeating-linear-gradient</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">repeating-radial-gradient</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>animation</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">keyframes</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">requestAnimationFrame</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>transform</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">2d</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">3d</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>postion</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">position:sticky</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=sticky\" target=\"_blank\" rel=\"noopener\">caniuse</a>, <a href=\"https://github.com/wilddeer/stickyfill\" target=\"_blank\" rel=\"noopener\">polyfill</a></td>\n</tr>\n<tr>\n<td>selector</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">querySelector querySelectorAll</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>webfonts</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">@font-face</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://www.mi.com/mi4/\" target=\"_blank\" rel=\"noopener\">小米案例</a></td>\n</tr>\n<tr>\n<td>ui</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">sizing-box</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>dom</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">mutation-observers</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td><a href=\"http://caniuse.com/#search=MutationEvents\" target=\"_blank\" rel=\"noopener\">caniuse</a>, <a href=\"https://github.com/webmodules/mutation-observer\" target=\"_blank\" rel=\"noopener\">polyfill</a></td>\n</tr>\n<tr>\n<td>HTML5</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">audio</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">video</td>\n<td style=\"text-align:center\">×</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n<td></td>\n</tr>\n<tr>\n<td>ECMA5</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">Promises</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:center\">√</td>\n<td style=\"text-align:left\">√</td>\n<td>√</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"CSS-选择器\"><a href=\"#CSS-选择器\" class=\"headerlink\" title=\"CSS 选择器\"></a>CSS 选择器</h2><table>\n<thead>\n<tr>\n<th>-</th>\n<th>CSS 选择器</th>\n<th>IE8+</th>\n<th>IE9</th>\n<th>IE10+</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CSS2.1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>通配符</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>#foo</td>\n<td>ID 选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>.foo</td>\n<td>类选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>foo</td>\n<td>节点选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>></td>\n<td>子选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>+</td>\n<td>后一个兄弟节点</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr]</td>\n<td>带有 attr 属性的元素</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr=”val”]</td>\n<td>&lt;div attr=”val”/&gt;</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr~=”val”]</td>\n<td>&lt;div attr=”val val1”/&gt;</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr&#124;=”val”]</td>\n<td>&lt;div attr=”val-val1”/&gt;</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:first-child</td>\n<td>第一个子元素</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:link, :visited</td>\n<td>伪类，仅适用于 a 标签</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:active, :hover</td>\n<td>伪类，适用于所有元素</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:focus</td>\n<td>伪类，获取焦点的元素</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:lang()</td>\n<td>伪类，&lt;div lang=”en”/&gt;</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>CSS3</td>\n</tr>\n<tr>\n<td>[attr^=”val”]</td>\n<td>带有 attr 属性并且值以 val 打头</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr$=”val”]</td>\n<td>带有 attr 属性并且值以 val 结束</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>[attr*=”val”]</td>\n<td>带有 attr 属性并且值中带有 val 字眼</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>~</td>\n<td>后面兄弟选择器</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:last-child</td>\n<td>最后一个子元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:root</td>\n<td>根元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:only-child</td>\n<td>唯一的子节点</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:nth-child()</td>\n<td>选择一个或多个子元素，参数 n 代表 0-+∞</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:nth-last-child()</td>\n<td>选择一个或多个子元素，参数 n 代表 0-+∞，从后往前选择</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:only-of-type</td>\n<td>唯一 tag 元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:nth-of-type</td>\n<td>选择一个或多个子 tag 元素，参数 n 代表 0-+∞</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:nth-last-of-type()</td>\n<td>选择一个或多个子 tag 元素，参数 n 代表 0-+∞，从后往前选择</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:first-of-type</td>\n<td>选择第一个 tag 元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>tag:last-of-type</td>\n<td>选择最后一个 tag 元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:empty</td>\n<td>匹配空节点</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:target</td>\n<td>匹配 hash 相应的元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:enabled, :disabled</td>\n<td>匹配表单中启用或禁用的元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:checked</td>\n<td>匹配表单中选中的元素</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>:not()</td>\n<td>否定选择器</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n</tbody>\n</table>\n<p>备注：没有添加伪元素。</p>\n<h2 id=\"CSS2-1-之前的一些不为人知的特性\"><a href=\"#CSS2-1-之前的一些不为人知的特性\" class=\"headerlink\" title=\"CSS2.1 之前的一些不为人知的特性\"></a>CSS2.1 之前的一些不为人知的特性</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th style=\"text-align:left\">可选值以及含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>empty-cells</td>\n<td style=\"text-align:left\">hide：当 td 的子元素都是隐藏的时候，自动隐藏该 td 的边框和背景<br>show：永远显示<br>不过该属性只有在 border-collapse:separate;时才有效。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h2><ol>\n<li><a href=\"http://www.w3.org/Style/CSS/current-work\" target=\"_blank\" rel=\"noopener\">CSS Current Work</a> 这里记载着 CSS 规范子集的进度（稳定级别）：工作草案，最后通告，候选标准，推荐标准和标准。</li>\n<li><a href=\"http://www.w3.org/2005/10/Process-20051014/tr.html\" target=\"_blank\" rel=\"noopener\">W3C Technical Report Development Process</a> W3C 技术报告开发过程</li>\n<li><a href=\"http://www.w3ctech.com/topic/746\" target=\"_blank\" rel=\"noopener\">《W3C 技术报告开发过程》</a> 只翻译一部分</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Mozilla_support_chart\" target=\"_blank\" rel=\"noopener\">Mozilla CSS support chart</a> 火狐浏览器 CSS 特性支持</li>\n<li><a href=\"https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariCSSRef/Introduction.html\" target=\"_blank\" rel=\"noopener\">Safari CSS Reference</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Comparison_of_layout_engines_(Cascading_Style_Sheets\" target=\"_blank\" rel=\"noopener\">Comparison of layout engines (Cascading Style Sheets)</a>&gt;) 中文版<a href=\"https://zh.wikipedia.org/zh-cn/%E7%80%8F%E8%A6%BD%E5%99%A8%E5%BC%95%E6%93%8ECSS%E6%94%AF%E6%8F%B4%E6%AF%94%E8%BC%83\" target=\"_blank\" rel=\"noopener\">浏览器引擎 CSS 支持比较</a></li>\n<li><a href=\"http://t337.org-w3c-region-chinese-html5.w3ctalk.info/w3c-t337.html\" target=\"_blank\" rel=\"noopener\">http://t337.org-w3c-region-chinese-html5.w3ctalk.info/w3c-t337.html</a></li>\n</ol>\n"},{"title":"ES5简介","_content":"\n这是我组织的 ES6 特性分享的预热篇，主要介绍 ES5 的特性。\n\n## 既是入门，又是回顾\n\n-   相信很多人还没有完全在项目中使用\n\n-   `2011`年正式发布的`IE9`实现了几乎所有`ES5`的特性\n-   `ES6`，`ES7`……都已经或将要来了\n\n## ES5 中最有用的特性：JSON\n\n### JSON 简介\n\n![Douglas Crockford](https://c2.staticflickr.com/4/3002/3117853012_9b2b508e94_b.jpg)\n\n1. Douglas Crockford 在 2002 年创建，\n1. JSON JavaScript 对象标记（Notation）\n1. JavaScript 语言的一个子集\n1. 一种轻量级的数据交换格式\n1. 易于人阅读和编写，同时也易于机器解析和生成。\n\n更多细节：[RFC7159](http://www.ietf.org/rfc/rfc7159.txt)，[ECMA-404](http://www.ecma-international.org/publications/standards/Ecma-404.htm)，[介绍 JSON](http://json.org/json-zh.html)\n\n### 那段不堪回首的过去\n\n```javascript\nvar data = eval('(' + response + ')');\n```\n\n或\n\n```xml\n<script src=\"/javascript/json2.js\"></script>\n<script>\nvar data = JSON.parse(response);\n</script>\n```\n\n### JSON.stringify(value[, replacer [, space]])\n\n```javascript\nvar obj = { a: 'x', b: { c: 1 } };\nvar string = JSON.stringify(obj);\n//\nvar string = JSON.stringify(obj, function(key, value) {\n    return typeof value === 'number' ? 0 : value;\n});\nconsole.log(string); //{\"a\":\"x\",\"b\":{\"c\":0}}\n\n//美化JSON\nvar string = JSON.stringify(obj, null, '\\t');\nvar string = JSON.stringify(obj, null, 2);\nconsole.log(string);\n\nobj.toJSON = function() {\n    return 'something';\n};\nvar string = JSON.stringify(obj);\nconsole.log(string); //nothing\n```\n\n### JSON.parse(text[, reviver])\n\n```javascript\n//将字符串解析成JSON对象\nvar data = JSON.parse('{\"a\":1,\"b\":{\"c\":1}}');\n\n//将字符串解析成JSON对象，并对象中的每个数值加1\nvar data = JSON.parse('{\"a\":1,\"b\":{\"c\":1}}', function(key, value) {\n    console.log(key, value);\n    return typeof value === 'number' ? value + 1 : value;\n});\nconsole.log(JSON.stringify(data)); //{\"a\":2,\"b\":{\"c\":2}}\n```\n\n### JSON 用法举例\n\n1. 解析 JSON 格式的 AJAX 响应\n2. localStorage，sessionStorage 只能存储字符串\n3. PHP 使用 SpiderMonkey 引擎创建 JS 上下并输入数据\n\n### JSON 的替代协议 Protocol Buffers\n\n[Protocol Buffers](https://developers.google.com/protocol-buffers/)，[Github](https://github.com/google/protobuf)\n![Protocol Buffers 截屏](../../../../images/protocol-buffers.png)\n\n### JSON 的替代协议 MessagePack\n\n[MessagePack](http://msgpack.org/)\n![MessagePack 截屏](../../../../images/message-pack.png)\n\n## ES5 中最强大的特性：Object 扩展\n\n以下是 ES5 对 Object 对象的所有扩展\n\n```\nObject.defineProperty\nObject.defineProperties\nObject.create\nObject.getPrototypeOf\nObject.keys\nObject.seal\nObject.freeze\nObject.preventExtensions\nObject.isSealed\nObject.isFrozen\nObject.isExtensible\nObject.getOwnPropertyDescriptor\nObject.getOwnPropertyNames\n```\n\n### Object.defineProperty(obj, prop, descriptor)\n\n直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, 'key', {\n    value: 'val', //默认 undefined\n    configurable: false, //默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改\n    enumerable: false, //默认 false，属性是否可以枚举\n    writable: false, //默认 false，能够使用赋值运算符改变属性值\n    get: function() {\n        return this.value;\n    },\n    set: function(newValue) {\n        this.value = newValue;\n    },\n});\n//以上代码仅为示例，get/set 不能和 value，writable同时出现。\n```\n\n### Object.defineProperty 数据描述符 configurable\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, 'key', {\n    value: 'val',\n    // 默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改\n    configurable: true,\n});\n\nObject.defineProperty(obj, 'key', { value: 'changed', configurable: false });\nconsole.log(obj.key); //changed\n\ntry {\n    Object.defineProperty(obj, 'key', {\n        configurable: true,\n    });\n} catch (e) {\n    console.log(e);\n} //TypeError: Cannot redefine property: key(…)\n\ndelete obj.key;\nconsole.log(obj.key); //changed\n```\n\n### Object.defineProperty 数据描述符 enumerable\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, 'key', {\n    value: 'val',\n    enumerable: false, // 默认 false，属性是否可以枚举\n});\n\nconsole.log(obj.propertyIsEnumerable('key')); // false\n\nconsole.log(Object.keys(obj)); // []\nfor (var k in obj) {\n    console.log(k); //什么也不会打印\n}\n```\n\n### 使用 Object.defineProperty 调试\n\n```\nfunction debugObject(obj, key){\n    //将相应值保存起来\n    var value = obj.key;\n    //重新定义该属性\n    Object.defineProperty(obj, key, {\n            get: function(){\n                return value;\n            },\n            set: function(val){\n                debugger;\n                value = val;\n            }\n        });\n}\n```\n\n在 ES7 草案中，还有一个方法`Object.observe(ob, callback)`可以更加方便地监听对象变化。\n\n### Object.defineProperties(obj, props)\n\n添加或修改 1+个属性，并返回该对象。\n\n```javascript\nvar obj = {};\nObject.defineProperties({\n    key1: {\n        writable: false,\n    },\n    key2: {\n        enumerable: false,\n    },\n});\n```\n\n### Object.create(prototype, descriptors)\n\n```javascript\nvar Man = {\n    race: function() {\n        console.log('race');\n    },\n};\nvar peter = Object.create(Man, {\n    firstName: { value: 'Xiaoming' },\n    lastName: { value: 'Li' },\n    fullName: {\n        get: function() {\n            return this.firstName + ' ' + this.lastName;\n        },\n    },\n});\nconsole.log(peter.fullName); // Xiaoming Li\n```\n\n### Object.create(prototype, descriptors)\n\n```javascript\nvar obj = Object.create(null);\n\nconsole.log( Object.keys(obj) ); //[]\n\nconsole.log( typeof obj ); //object\n\nconsole.log( Object.prototype.toString.call(obj) ); //[object Object]\n\nconsole.log( obj instanseof Object ); //false\n```\n\n### Object.getOwnPropertyDescriptor(obj, prop) 获取属性描述符\n\n```javascript\nvar obj = { a: 1 };\nObject.defineProperty(obj, 'b', {\n    //value: 2,\n    enumerable: false,\n    get: function() {\n        return 1;\n    },\n});\n\nconsole.log(Object.getOwnPropertyDescriptor(obj, 'a'));\n\nvar descriptor = Object.getOwnPropertyDescriptor(obj, 'b');\nconsole.log(descriptor);\n```\n\n### Object.getOwnPropertyNames(obj) 获取所有自有属性名\n\n获取所有自有属性名，包含可枚举以及不可枚举的，但是不包含原型链上的。\n\n```javascript\nvar prototype = { a: 0 };\nvar obj = Object.create(prototype, {\n    b: {\n        value: 1,\n    },\n    c: {\n        value: 2,\n        enumerable: false,\n    },\n});\n\nconsole.log(Object.getOwnPropertyNames(obj)); // [\"b\", \"c\"]\n```\n\n### Object.freeze(obj) 冻结一个对象\n\n冻结一个对象，意味着该对象的属性不能增删改，属性的各个特性也不能改。\n而`Object.isFrozen(obj)`可以用来判断一个对象有没有冻结。\n\n```javascript\nvar obj = { key: 'val', key1: {} };\nObject.freeze(obj);\n\nconsole.log(Object.isFrozen(obj)); // true\n\nobj.key2 = 1;\nconsole.log(obj.key2); // undefined\ndelete obj.key;\nconsole.log(obj.key); // val\nobj.key = 1;\nconsole.log(obj.key); // val\nobj.key1.a = 2;\nconsole.log(obj.key1.a); // 2 ------冻结仅仅冻结一层\n\n//Uncaught TypeError: Cannot redefine property: key\nObject.defineProperty(obj, 'key', { enumerable: false });\n```\n\n### 怎样完全冻结一个对象\n\n```javascript\nfunction deepFreeze(obj) {\n    for (var key in obj) {\n        var val = obj[key];\n        //忽略原型链上的属性\n        if (!obj.hasOwnProperty(key)) continue;\n        //忽略不是对象的属性\n        if (typeof val !== 'object') continue;\n        //忽略已经冻结的属性\n        if (Object.isFrozen(val)) continue;\n        //递归地冻结对象属性\n        deepFreeze(val);\n    }\n}\n```\n\n### Object.seal(obj) 密封一个对象\n\n密封，比冻结宽松一点，仅仅能修改属性的值。\n而`Object.isSealed(obj)`可以用来判断一个对象有没有密封。\n\n```javascript\nvar obj = { key: 'val', key1: {} };\nObject.seal(obj);\n\nconsole.log(Object.isSealed(obj)); // true\n\nobj.key2 = 1;\nconsole.log(obj.key2); // undefined\ndelete obj.key;\nconsole.log(obj.key); // val\nobj.key = 1;\nconsole.log(obj.key); // 1----跟冻结唯一不同的地方\nobj.key1.a = 2;\nconsole.log(obj.key1.a); // 2\n\n//Uncaught TypeError: Cannot redefine property: key\nObject.defineProperty(obj, 'key', { enumerable: false });\n```\n\n### Object.preventExtensions(obj) 不能添加新属性\n\n`Object.isExtensible`用来检查一个对象能不能添加新属性\n\n```javascript\nvar obj = { key: 'val', key1: {} };\nObject.preventExtensions(obj);\n\nconsole.log(Object.isExtensible(obj)); // false\n\nobj.key2 = 1;\nconsole.log(obj.key2); // undefined，不能添加新属性\nobj.key = 'value';\nconsole.log(obj.key); // value，能够修改已有属性\n\nObject.defineProperty(obj, 'key', { enumerable: false });\nconsole.log(Object.keys(obj)); // [\"key1\"]，能够修改属性特性\n\ndelete obj.key;\nconsole.log(obj.key); // undefined，能够删除已有属性\n\nobj.key1.a = 'a';\nconsole.log(obj.key1.a); // a，不影响给扩展已有属性\n```\n\n### Object.getPrototypeOf(obj)\n\n```javascript\nfunction Car() {}\nvar prototype = (Car.prototype = {});\nObject.getPrototypeOf(new Car()) === prototype; // true\n\nvar prototype = {};\nvar car = Object.create(prototype);\nObject.getPrototypeOf(car) === prototype; // true\n```\n\n## Array 扩展\n\n`Array.isArray(obj)` 判断一个对象是不是数组\n\n```javascript\nvar array = [1, 2, 3];\n\nArray.isArray(array); //true，\n\n//等价于\n\nfunction isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n}\n```\n\n### Array 实例扩展\n\n```javascript\nvar array = [1, 2, 2, 3];\n\narray.indexOf(2); // 1\narray.lastIndexOf(2); // 2\n```\n\n## 保留字作为属性名\n\n```javascript\nvar obj = {\n    if: 1,\n    var: 's',\n    switch: true,\n};\nconsole.log(obj.if);\nconsole.log(obj.var);\nconsole.log(obj.switch);\n```\n\n## 使用 get/set 进行属性初始化\n\n```\nvar obj = {\n        firstName: '',\n        lastName: '',\n        get fullName(){\n            return (this.firstName + ' ' + this.lastName).trim();\n        },\n        set fullName(fullName){\n            if(!fullName) return;\n            var index = fullName.indexOf(' ');\n            this.firstName = fullName.substring(0, index);\n            this.lastName  = fullName.substring(index+1);\n        }\n    };\n\nconsole.log( obj.fullName );  // 空字符串\nobj.fullName = 'San Zhang';\nconsole.log( obj.firstName ); // San\nconsole.log( obj.lastName );  // Zhang\nconsole.log( obj.fullName );  // San Zhang\n```\n\n## 全局 undefined 对象\n\n以前，undefined 对象是这样产生的。\n\n```javascript\nvar undef;\nconsole.log(typeof undef === 'undefined'); // true\n\nvar undef = 1;\nundef = void 0;\nconsole.log(typeof undef === 'undefined'); // true\n\n//jQuery 1.8.3源码片段\n(function(window, undefined) {\n    console.log(typeof undefined === 'undefined'); // true\n})(window);\n```\n\n在 ES5 中有了不可变的全局的`undefined`对象。\n\n```javascript\nvar undefined = 1;\nconsole.log(undefined); // undefined\n\n(function(undefined) {\n    undefined = 1;\n    console.log(undefined); // 1\n\n    window.undefined = 1;\n    console.log(window.undefined); // undefined\n})();\n```\n\n## Function 实例扩展\n\n### Function.prototype.bind\n\n`fun.bind(thisArg[, arg1[, arg2[, ...]]])`\n\n```javascript\nfunction a() {\n    console.log(this, arguments);\n}\n\na.bind({ key: 'a' }, 1, 2); // function bound a() { [native code] }\n\na.bind('ab', 1, 2)(); //String {0: \"a\", 1: \"b\", length: 2, [[PrimitiveValue]]: \"ab\"} [1, 2]\n\na.bind({ key: 'a' }, 1, 2).bind({ key: 'b' }, 3, 4)(); // {key: 'a'}, [1,2,3,4]\n```\n\n### Curry（柯里化）\n\n预先设定函数的前面若干个实参，生成一个接受剩余实参的新函数。\n\n```javascript\nfunction curry(fn) {\n    var slice = Array.prototype.slice,\n        args = slice.call(arguments, 1);\n    return function() {\n        return fn.apply(null, args.concat(slice.apply(arguments)));\n    };\n}\n```\n\n### 柯里化案例\n\n```javascript\nmodel.groups = _.filter(model.groups, function(g) {\n    return g.id !== group.id;\n});\nmodel.groups = _.sortBy(model.groups, 'updateTime');\nmodel.groups = _.map(model.groups, 'name');\n\n// _.prototype 上的方法都是 _ 上相应方法的柯里化\nmodel.groups = _.chain(groups)\n    .filter(function(g) {\n        return g.id !== group.id;\n    })\n    .sortBy('updateTime')\n    .map('name')\n    .value();\n```\n\n### _.curry & _.curryRight\n\n```javascript\nvar abc = function(a, b, c) {\n    return [a, b, c];\n};\n\nvar curried = _.curry(abc);\n\ncurried(1)(2)(3); //[1,2,3]\n\ncurried(1, 2)(3); //[1,2,3]\n\ncurried(_, 2)(_, 3)(1); //[1,2,3]\n```\n\n## 严格模式\n\n把**整段代码**或**某个函数**放在严格操作的环境中运行，严格环境有诸多限制：\n\n1. 将失误转成异常\n2. 简化变量的使用\n3. 让 eval 和 arguments 变的简单\n4. \"安全的\" JavaScript\n5. 为未来的 ECMAScript 版本铺平道路\n\n## 严格模式：将失误转成异常\n\n1. 意外地创建全局变量\n\n```javascript\n(function() {\n    'use strict';\n    variable = 10;\n})(); // ReferenceError\n//解决方法1：明确指定我要创建全局变量\n(function() {\n    'use strict';\n    window.variable = 10;\n})();\n//解决方法2：事先定义好全局变量\nvar variable;\n(function() {\n    'use strict';\n    variable = 10;\n})();\n```\n\n2. 不再静默失败，而是抛出异常\n\n```javascript\nvar fixed = {};\nObject.preventExtensions(fixed);\nfixed.attr = 'value'; // SyntaxError\n```\n\n3. 形参命名不能重复\n\n```javascript\n(function(a, a){'use strict'; })(); //SyntaxError\n```\n\n注意：严格模式下，ES5 中定义变量时，字段名也不能重复，但是 ES6 又允许了。\n\n4. 严格模式禁止八进制数字语法\n\n```javascript\n//FireFox: SyntaxError, Chrome/IE10: SyntaxError\n(function(){'use strict';  console.log(010); })();\n//FireFox: SyntaxError, Chrome/IE10: 19\n(function(){'use strict';  console.log(019); })();\n```\n\n## 严格模式：简化变量的使用\n\n1. 禁用`with`\n\n```javascript\n(function(){\n    'use strict';\n    var key = 'attr';\n    var obj = {key: 1};\n    with(obj){ //SyntaxError\n        console.log(key);\n    }\n})();\n```\n\n2. `eval`不再为上层作用域引入新变量\n\n```javascript\n(function() {\n    'use strict';\n    var x = 1;\n    var y = eval('var x = 2; x'); //== eval('\"use strict\"; var x = 2; x')\n    console.log(x, y); // 1, 2 在正常模式下，返回2, 2\n})();\n```\n\n## 严格模式：简化变量的使用\n\n3. `call` & `apply`对`this`的修改规则简化\n\n```javascript\n(function() {\n    'use strict';\n    function printThis() {\n        console.log(this);\n    }\n    printThis.call(2); // 2 ，不再包装成对象类型\n    printThis.call(null); // null，不再自动替换成window对象\n    printThis.call(); // undefined，不再自动替换成window对象\n})();\n```\n\n4. 不能使用`caller`和`callee`\n\n```javascript\n(function restricted(a) {\n    'use strict';\n    console.log(restricted.caller); //TypeError\n    console.log(restricted.arguments); //TypeError\n    console.log(arguments.caller); //TypeError\n    console.log(arguments.callee); //TypeError\n})(1);\n```\n\n## 其他小的特性\n\n### 1. Date.prototype.toISOString\n\n转换成 `YYYY-MM-DDTHH:mm:ss.sssZ` 这种格式\n\n### 2. Date.now()\n\n和 `new Date().getTime()` 一样。\n\n### 3. String.prototype.trim\n\n和`$.trim`，`_.trim`一样。\n\n### 4. 把字符串当做数组一样访问\n\n```javascript\n'foobar'[1] === 'o'; // true\n```\n\n### 5. parseInt 忽略前置 0\n\n```\nparseInt('012'); // 12，在ES3中，因为前置0而按照八进制解析成10\nparseInt('0X12'); // 18，仍然因为前置0X而按照十六进制解析成18\n```\n\n## 思考题\n\n1. 以下这种情况是为什么？\n\n```\nvar array = [];\nconsole.log( array.length ); // 0\nconsole.log( Object.keys(array) ); // []\n```\n\n## 参考\n\n1. [MDN Javascript 参考文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference)\n2. [es5-shim](https://github.com/es-shims/es5-shim)\n3. [Douglas Crockford](https://zh.wikipedia.org/wiki/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%C2%B7%E5%85%8B%E7%BE%85%E5%85%8B%E7%A6%8F%E7%89%B9)\n","source":"_posts/2015-09-21-es5.md","raw":"---\ntitle: ES5简介\n---\n\n这是我组织的 ES6 特性分享的预热篇，主要介绍 ES5 的特性。\n\n## 既是入门，又是回顾\n\n-   相信很多人还没有完全在项目中使用\n\n-   `2011`年正式发布的`IE9`实现了几乎所有`ES5`的特性\n-   `ES6`，`ES7`……都已经或将要来了\n\n## ES5 中最有用的特性：JSON\n\n### JSON 简介\n\n![Douglas Crockford](https://c2.staticflickr.com/4/3002/3117853012_9b2b508e94_b.jpg)\n\n1. Douglas Crockford 在 2002 年创建，\n1. JSON JavaScript 对象标记（Notation）\n1. JavaScript 语言的一个子集\n1. 一种轻量级的数据交换格式\n1. 易于人阅读和编写，同时也易于机器解析和生成。\n\n更多细节：[RFC7159](http://www.ietf.org/rfc/rfc7159.txt)，[ECMA-404](http://www.ecma-international.org/publications/standards/Ecma-404.htm)，[介绍 JSON](http://json.org/json-zh.html)\n\n### 那段不堪回首的过去\n\n```javascript\nvar data = eval('(' + response + ')');\n```\n\n或\n\n```xml\n<script src=\"/javascript/json2.js\"></script>\n<script>\nvar data = JSON.parse(response);\n</script>\n```\n\n### JSON.stringify(value[, replacer [, space]])\n\n```javascript\nvar obj = { a: 'x', b: { c: 1 } };\nvar string = JSON.stringify(obj);\n//\nvar string = JSON.stringify(obj, function(key, value) {\n    return typeof value === 'number' ? 0 : value;\n});\nconsole.log(string); //{\"a\":\"x\",\"b\":{\"c\":0}}\n\n//美化JSON\nvar string = JSON.stringify(obj, null, '\\t');\nvar string = JSON.stringify(obj, null, 2);\nconsole.log(string);\n\nobj.toJSON = function() {\n    return 'something';\n};\nvar string = JSON.stringify(obj);\nconsole.log(string); //nothing\n```\n\n### JSON.parse(text[, reviver])\n\n```javascript\n//将字符串解析成JSON对象\nvar data = JSON.parse('{\"a\":1,\"b\":{\"c\":1}}');\n\n//将字符串解析成JSON对象，并对象中的每个数值加1\nvar data = JSON.parse('{\"a\":1,\"b\":{\"c\":1}}', function(key, value) {\n    console.log(key, value);\n    return typeof value === 'number' ? value + 1 : value;\n});\nconsole.log(JSON.stringify(data)); //{\"a\":2,\"b\":{\"c\":2}}\n```\n\n### JSON 用法举例\n\n1. 解析 JSON 格式的 AJAX 响应\n2. localStorage，sessionStorage 只能存储字符串\n3. PHP 使用 SpiderMonkey 引擎创建 JS 上下并输入数据\n\n### JSON 的替代协议 Protocol Buffers\n\n[Protocol Buffers](https://developers.google.com/protocol-buffers/)，[Github](https://github.com/google/protobuf)\n![Protocol Buffers 截屏](../../../../images/protocol-buffers.png)\n\n### JSON 的替代协议 MessagePack\n\n[MessagePack](http://msgpack.org/)\n![MessagePack 截屏](../../../../images/message-pack.png)\n\n## ES5 中最强大的特性：Object 扩展\n\n以下是 ES5 对 Object 对象的所有扩展\n\n```\nObject.defineProperty\nObject.defineProperties\nObject.create\nObject.getPrototypeOf\nObject.keys\nObject.seal\nObject.freeze\nObject.preventExtensions\nObject.isSealed\nObject.isFrozen\nObject.isExtensible\nObject.getOwnPropertyDescriptor\nObject.getOwnPropertyNames\n```\n\n### Object.defineProperty(obj, prop, descriptor)\n\n直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, 'key', {\n    value: 'val', //默认 undefined\n    configurable: false, //默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改\n    enumerable: false, //默认 false，属性是否可以枚举\n    writable: false, //默认 false，能够使用赋值运算符改变属性值\n    get: function() {\n        return this.value;\n    },\n    set: function(newValue) {\n        this.value = newValue;\n    },\n});\n//以上代码仅为示例，get/set 不能和 value，writable同时出现。\n```\n\n### Object.defineProperty 数据描述符 configurable\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, 'key', {\n    value: 'val',\n    // 默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改\n    configurable: true,\n});\n\nObject.defineProperty(obj, 'key', { value: 'changed', configurable: false });\nconsole.log(obj.key); //changed\n\ntry {\n    Object.defineProperty(obj, 'key', {\n        configurable: true,\n    });\n} catch (e) {\n    console.log(e);\n} //TypeError: Cannot redefine property: key(…)\n\ndelete obj.key;\nconsole.log(obj.key); //changed\n```\n\n### Object.defineProperty 数据描述符 enumerable\n\n```javascript\nvar obj = {};\nObject.defineProperty(obj, 'key', {\n    value: 'val',\n    enumerable: false, // 默认 false，属性是否可以枚举\n});\n\nconsole.log(obj.propertyIsEnumerable('key')); // false\n\nconsole.log(Object.keys(obj)); // []\nfor (var k in obj) {\n    console.log(k); //什么也不会打印\n}\n```\n\n### 使用 Object.defineProperty 调试\n\n```\nfunction debugObject(obj, key){\n    //将相应值保存起来\n    var value = obj.key;\n    //重新定义该属性\n    Object.defineProperty(obj, key, {\n            get: function(){\n                return value;\n            },\n            set: function(val){\n                debugger;\n                value = val;\n            }\n        });\n}\n```\n\n在 ES7 草案中，还有一个方法`Object.observe(ob, callback)`可以更加方便地监听对象变化。\n\n### Object.defineProperties(obj, props)\n\n添加或修改 1+个属性，并返回该对象。\n\n```javascript\nvar obj = {};\nObject.defineProperties({\n    key1: {\n        writable: false,\n    },\n    key2: {\n        enumerable: false,\n    },\n});\n```\n\n### Object.create(prototype, descriptors)\n\n```javascript\nvar Man = {\n    race: function() {\n        console.log('race');\n    },\n};\nvar peter = Object.create(Man, {\n    firstName: { value: 'Xiaoming' },\n    lastName: { value: 'Li' },\n    fullName: {\n        get: function() {\n            return this.firstName + ' ' + this.lastName;\n        },\n    },\n});\nconsole.log(peter.fullName); // Xiaoming Li\n```\n\n### Object.create(prototype, descriptors)\n\n```javascript\nvar obj = Object.create(null);\n\nconsole.log( Object.keys(obj) ); //[]\n\nconsole.log( typeof obj ); //object\n\nconsole.log( Object.prototype.toString.call(obj) ); //[object Object]\n\nconsole.log( obj instanseof Object ); //false\n```\n\n### Object.getOwnPropertyDescriptor(obj, prop) 获取属性描述符\n\n```javascript\nvar obj = { a: 1 };\nObject.defineProperty(obj, 'b', {\n    //value: 2,\n    enumerable: false,\n    get: function() {\n        return 1;\n    },\n});\n\nconsole.log(Object.getOwnPropertyDescriptor(obj, 'a'));\n\nvar descriptor = Object.getOwnPropertyDescriptor(obj, 'b');\nconsole.log(descriptor);\n```\n\n### Object.getOwnPropertyNames(obj) 获取所有自有属性名\n\n获取所有自有属性名，包含可枚举以及不可枚举的，但是不包含原型链上的。\n\n```javascript\nvar prototype = { a: 0 };\nvar obj = Object.create(prototype, {\n    b: {\n        value: 1,\n    },\n    c: {\n        value: 2,\n        enumerable: false,\n    },\n});\n\nconsole.log(Object.getOwnPropertyNames(obj)); // [\"b\", \"c\"]\n```\n\n### Object.freeze(obj) 冻结一个对象\n\n冻结一个对象，意味着该对象的属性不能增删改，属性的各个特性也不能改。\n而`Object.isFrozen(obj)`可以用来判断一个对象有没有冻结。\n\n```javascript\nvar obj = { key: 'val', key1: {} };\nObject.freeze(obj);\n\nconsole.log(Object.isFrozen(obj)); // true\n\nobj.key2 = 1;\nconsole.log(obj.key2); // undefined\ndelete obj.key;\nconsole.log(obj.key); // val\nobj.key = 1;\nconsole.log(obj.key); // val\nobj.key1.a = 2;\nconsole.log(obj.key1.a); // 2 ------冻结仅仅冻结一层\n\n//Uncaught TypeError: Cannot redefine property: key\nObject.defineProperty(obj, 'key', { enumerable: false });\n```\n\n### 怎样完全冻结一个对象\n\n```javascript\nfunction deepFreeze(obj) {\n    for (var key in obj) {\n        var val = obj[key];\n        //忽略原型链上的属性\n        if (!obj.hasOwnProperty(key)) continue;\n        //忽略不是对象的属性\n        if (typeof val !== 'object') continue;\n        //忽略已经冻结的属性\n        if (Object.isFrozen(val)) continue;\n        //递归地冻结对象属性\n        deepFreeze(val);\n    }\n}\n```\n\n### Object.seal(obj) 密封一个对象\n\n密封，比冻结宽松一点，仅仅能修改属性的值。\n而`Object.isSealed(obj)`可以用来判断一个对象有没有密封。\n\n```javascript\nvar obj = { key: 'val', key1: {} };\nObject.seal(obj);\n\nconsole.log(Object.isSealed(obj)); // true\n\nobj.key2 = 1;\nconsole.log(obj.key2); // undefined\ndelete obj.key;\nconsole.log(obj.key); // val\nobj.key = 1;\nconsole.log(obj.key); // 1----跟冻结唯一不同的地方\nobj.key1.a = 2;\nconsole.log(obj.key1.a); // 2\n\n//Uncaught TypeError: Cannot redefine property: key\nObject.defineProperty(obj, 'key', { enumerable: false });\n```\n\n### Object.preventExtensions(obj) 不能添加新属性\n\n`Object.isExtensible`用来检查一个对象能不能添加新属性\n\n```javascript\nvar obj = { key: 'val', key1: {} };\nObject.preventExtensions(obj);\n\nconsole.log(Object.isExtensible(obj)); // false\n\nobj.key2 = 1;\nconsole.log(obj.key2); // undefined，不能添加新属性\nobj.key = 'value';\nconsole.log(obj.key); // value，能够修改已有属性\n\nObject.defineProperty(obj, 'key', { enumerable: false });\nconsole.log(Object.keys(obj)); // [\"key1\"]，能够修改属性特性\n\ndelete obj.key;\nconsole.log(obj.key); // undefined，能够删除已有属性\n\nobj.key1.a = 'a';\nconsole.log(obj.key1.a); // a，不影响给扩展已有属性\n```\n\n### Object.getPrototypeOf(obj)\n\n```javascript\nfunction Car() {}\nvar prototype = (Car.prototype = {});\nObject.getPrototypeOf(new Car()) === prototype; // true\n\nvar prototype = {};\nvar car = Object.create(prototype);\nObject.getPrototypeOf(car) === prototype; // true\n```\n\n## Array 扩展\n\n`Array.isArray(obj)` 判断一个对象是不是数组\n\n```javascript\nvar array = [1, 2, 3];\n\nArray.isArray(array); //true，\n\n//等价于\n\nfunction isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n}\n```\n\n### Array 实例扩展\n\n```javascript\nvar array = [1, 2, 2, 3];\n\narray.indexOf(2); // 1\narray.lastIndexOf(2); // 2\n```\n\n## 保留字作为属性名\n\n```javascript\nvar obj = {\n    if: 1,\n    var: 's',\n    switch: true,\n};\nconsole.log(obj.if);\nconsole.log(obj.var);\nconsole.log(obj.switch);\n```\n\n## 使用 get/set 进行属性初始化\n\n```\nvar obj = {\n        firstName: '',\n        lastName: '',\n        get fullName(){\n            return (this.firstName + ' ' + this.lastName).trim();\n        },\n        set fullName(fullName){\n            if(!fullName) return;\n            var index = fullName.indexOf(' ');\n            this.firstName = fullName.substring(0, index);\n            this.lastName  = fullName.substring(index+1);\n        }\n    };\n\nconsole.log( obj.fullName );  // 空字符串\nobj.fullName = 'San Zhang';\nconsole.log( obj.firstName ); // San\nconsole.log( obj.lastName );  // Zhang\nconsole.log( obj.fullName );  // San Zhang\n```\n\n## 全局 undefined 对象\n\n以前，undefined 对象是这样产生的。\n\n```javascript\nvar undef;\nconsole.log(typeof undef === 'undefined'); // true\n\nvar undef = 1;\nundef = void 0;\nconsole.log(typeof undef === 'undefined'); // true\n\n//jQuery 1.8.3源码片段\n(function(window, undefined) {\n    console.log(typeof undefined === 'undefined'); // true\n})(window);\n```\n\n在 ES5 中有了不可变的全局的`undefined`对象。\n\n```javascript\nvar undefined = 1;\nconsole.log(undefined); // undefined\n\n(function(undefined) {\n    undefined = 1;\n    console.log(undefined); // 1\n\n    window.undefined = 1;\n    console.log(window.undefined); // undefined\n})();\n```\n\n## Function 实例扩展\n\n### Function.prototype.bind\n\n`fun.bind(thisArg[, arg1[, arg2[, ...]]])`\n\n```javascript\nfunction a() {\n    console.log(this, arguments);\n}\n\na.bind({ key: 'a' }, 1, 2); // function bound a() { [native code] }\n\na.bind('ab', 1, 2)(); //String {0: \"a\", 1: \"b\", length: 2, [[PrimitiveValue]]: \"ab\"} [1, 2]\n\na.bind({ key: 'a' }, 1, 2).bind({ key: 'b' }, 3, 4)(); // {key: 'a'}, [1,2,3,4]\n```\n\n### Curry（柯里化）\n\n预先设定函数的前面若干个实参，生成一个接受剩余实参的新函数。\n\n```javascript\nfunction curry(fn) {\n    var slice = Array.prototype.slice,\n        args = slice.call(arguments, 1);\n    return function() {\n        return fn.apply(null, args.concat(slice.apply(arguments)));\n    };\n}\n```\n\n### 柯里化案例\n\n```javascript\nmodel.groups = _.filter(model.groups, function(g) {\n    return g.id !== group.id;\n});\nmodel.groups = _.sortBy(model.groups, 'updateTime');\nmodel.groups = _.map(model.groups, 'name');\n\n// _.prototype 上的方法都是 _ 上相应方法的柯里化\nmodel.groups = _.chain(groups)\n    .filter(function(g) {\n        return g.id !== group.id;\n    })\n    .sortBy('updateTime')\n    .map('name')\n    .value();\n```\n\n### _.curry & _.curryRight\n\n```javascript\nvar abc = function(a, b, c) {\n    return [a, b, c];\n};\n\nvar curried = _.curry(abc);\n\ncurried(1)(2)(3); //[1,2,3]\n\ncurried(1, 2)(3); //[1,2,3]\n\ncurried(_, 2)(_, 3)(1); //[1,2,3]\n```\n\n## 严格模式\n\n把**整段代码**或**某个函数**放在严格操作的环境中运行，严格环境有诸多限制：\n\n1. 将失误转成异常\n2. 简化变量的使用\n3. 让 eval 和 arguments 变的简单\n4. \"安全的\" JavaScript\n5. 为未来的 ECMAScript 版本铺平道路\n\n## 严格模式：将失误转成异常\n\n1. 意外地创建全局变量\n\n```javascript\n(function() {\n    'use strict';\n    variable = 10;\n})(); // ReferenceError\n//解决方法1：明确指定我要创建全局变量\n(function() {\n    'use strict';\n    window.variable = 10;\n})();\n//解决方法2：事先定义好全局变量\nvar variable;\n(function() {\n    'use strict';\n    variable = 10;\n})();\n```\n\n2. 不再静默失败，而是抛出异常\n\n```javascript\nvar fixed = {};\nObject.preventExtensions(fixed);\nfixed.attr = 'value'; // SyntaxError\n```\n\n3. 形参命名不能重复\n\n```javascript\n(function(a, a){'use strict'; })(); //SyntaxError\n```\n\n注意：严格模式下，ES5 中定义变量时，字段名也不能重复，但是 ES6 又允许了。\n\n4. 严格模式禁止八进制数字语法\n\n```javascript\n//FireFox: SyntaxError, Chrome/IE10: SyntaxError\n(function(){'use strict';  console.log(010); })();\n//FireFox: SyntaxError, Chrome/IE10: 19\n(function(){'use strict';  console.log(019); })();\n```\n\n## 严格模式：简化变量的使用\n\n1. 禁用`with`\n\n```javascript\n(function(){\n    'use strict';\n    var key = 'attr';\n    var obj = {key: 1};\n    with(obj){ //SyntaxError\n        console.log(key);\n    }\n})();\n```\n\n2. `eval`不再为上层作用域引入新变量\n\n```javascript\n(function() {\n    'use strict';\n    var x = 1;\n    var y = eval('var x = 2; x'); //== eval('\"use strict\"; var x = 2; x')\n    console.log(x, y); // 1, 2 在正常模式下，返回2, 2\n})();\n```\n\n## 严格模式：简化变量的使用\n\n3. `call` & `apply`对`this`的修改规则简化\n\n```javascript\n(function() {\n    'use strict';\n    function printThis() {\n        console.log(this);\n    }\n    printThis.call(2); // 2 ，不再包装成对象类型\n    printThis.call(null); // null，不再自动替换成window对象\n    printThis.call(); // undefined，不再自动替换成window对象\n})();\n```\n\n4. 不能使用`caller`和`callee`\n\n```javascript\n(function restricted(a) {\n    'use strict';\n    console.log(restricted.caller); //TypeError\n    console.log(restricted.arguments); //TypeError\n    console.log(arguments.caller); //TypeError\n    console.log(arguments.callee); //TypeError\n})(1);\n```\n\n## 其他小的特性\n\n### 1. Date.prototype.toISOString\n\n转换成 `YYYY-MM-DDTHH:mm:ss.sssZ` 这种格式\n\n### 2. Date.now()\n\n和 `new Date().getTime()` 一样。\n\n### 3. String.prototype.trim\n\n和`$.trim`，`_.trim`一样。\n\n### 4. 把字符串当做数组一样访问\n\n```javascript\n'foobar'[1] === 'o'; // true\n```\n\n### 5. parseInt 忽略前置 0\n\n```\nparseInt('012'); // 12，在ES3中，因为前置0而按照八进制解析成10\nparseInt('0X12'); // 18，仍然因为前置0X而按照十六进制解析成18\n```\n\n## 思考题\n\n1. 以下这种情况是为什么？\n\n```\nvar array = [];\nconsole.log( array.length ); // 0\nconsole.log( Object.keys(array) ); // []\n```\n\n## 参考\n\n1. [MDN Javascript 参考文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference)\n2. [es5-shim](https://github.com/es-shims/es5-shim)\n3. [Douglas Crockford](https://zh.wikipedia.org/wiki/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%C2%B7%E5%85%8B%E7%BE%85%E5%85%8B%E7%A6%8F%E7%89%B9)\n","slug":"es5","published":1,"date":"2015-09-20T16:00:00.000Z","updated":"2018-12-07T02:44:59.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmak001iw8wkqqedb3em","content":"<p>这是我组织的 ES6 特性分享的预热篇，主要介绍 ES5 的特性。</p>\n<h2 id=\"既是入门，又是回顾\"><a href=\"#既是入门，又是回顾\" class=\"headerlink\" title=\"既是入门，又是回顾\"></a>既是入门，又是回顾</h2><ul>\n<li><p>相信很多人还没有完全在项目中使用</p>\n</li>\n<li><p><code>2011</code>年正式发布的<code>IE9</code>实现了几乎所有<code>ES5</code>的特性</p>\n</li>\n<li><code>ES6</code>，<code>ES7</code>……都已经或将要来了</li>\n</ul>\n<h2 id=\"ES5-中最有用的特性：JSON\"><a href=\"#ES5-中最有用的特性：JSON\" class=\"headerlink\" title=\"ES5 中最有用的特性：JSON\"></a>ES5 中最有用的特性：JSON</h2><h3 id=\"JSON-简介\"><a href=\"#JSON-简介\" class=\"headerlink\" title=\"JSON 简介\"></a>JSON 简介</h3><p><img src=\"https://c2.staticflickr.com/4/3002/3117853012_9b2b508e94_b.jpg\" alt=\"Douglas Crockford\"></p>\n<ol>\n<li>Douglas Crockford 在 2002 年创建，</li>\n<li>JSON JavaScript 对象标记（Notation）</li>\n<li>JavaScript 语言的一个子集</li>\n<li>一种轻量级的数据交换格式</li>\n<li>易于人阅读和编写，同时也易于机器解析和生成。</li>\n</ol>\n<p>更多细节：<a href=\"http://www.ietf.org/rfc/rfc7159.txt\" target=\"_blank\" rel=\"noopener\">RFC7159</a>，<a href=\"http://www.ecma-international.org/publications/standards/Ecma-404.htm\" target=\"_blank\" rel=\"noopener\">ECMA-404</a>，<a href=\"http://json.org/json-zh.html\" target=\"_blank\" rel=\"noopener\">介绍 JSON</a></p>\n<h3 id=\"那段不堪回首的过去\"><a href=\"#那段不堪回首的过去\" class=\"headerlink\" title=\"那段不堪回首的过去\"></a>那段不堪回首的过去</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">eval</span>(<span class=\"string\">'('</span> + response + <span class=\"string\">')'</span>);</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/javascript/json2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(response);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-stringify-value-replacer-space\"><a href=\"#JSON-stringify-value-replacer-space\" class=\"headerlink\" title=\"JSON.stringify(value[, replacer [, space]])\"></a>JSON.stringify(value[, replacer [, space]])</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"string\">'x'</span>, <span class=\"attr\">b</span>: &#123; <span class=\"attr\">c</span>: <span class=\"number\">1</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj);</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'number'</span> ? <span class=\"number\">0</span> : value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">//&#123;\"a\":\"x\",\"b\":&#123;\"c\":0&#125;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//美化JSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj, <span class=\"literal\">null</span>, <span class=\"string\">'\\t'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj, <span class=\"literal\">null</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.toJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'something'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">//nothing</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-parse-text-reviver\"><a href=\"#JSON-parse-text-reviver\" class=\"headerlink\" title=\"JSON.parse(text[, reviver])\"></a>JSON.parse(text[, reviver])</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串解析成JSON对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"a\":1,\"b\":&#123;\"c\":1&#125;&#125;'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将字符串解析成JSON对象，并对象中的每个数值加1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"a\":1,\"b\":&#123;\"c\":1&#125;&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'number'</span> ? value + <span class=\"number\">1</span> : value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data)); <span class=\"comment\">//&#123;\"a\":2,\"b\":&#123;\"c\":2&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-用法举例\"><a href=\"#JSON-用法举例\" class=\"headerlink\" title=\"JSON 用法举例\"></a>JSON 用法举例</h3><ol>\n<li>解析 JSON 格式的 AJAX 响应</li>\n<li>localStorage，sessionStorage 只能存储字符串</li>\n<li>PHP 使用 SpiderMonkey 引擎创建 JS 上下并输入数据</li>\n</ol>\n<h3 id=\"JSON-的替代协议-Protocol-Buffers\"><a href=\"#JSON-的替代协议-Protocol-Buffers\" class=\"headerlink\" title=\"JSON 的替代协议 Protocol Buffers\"></a>JSON 的替代协议 Protocol Buffers</h3><p><a href=\"https://developers.google.com/protocol-buffers/\" target=\"_blank\" rel=\"noopener\">Protocol Buffers</a>，<a href=\"https://github.com/google/protobuf\" target=\"_blank\" rel=\"noopener\">Github</a><br><img src=\"../../../../images/protocol-buffers.png\" alt=\"Protocol Buffers 截屏\"></p>\n<h3 id=\"JSON-的替代协议-MessagePack\"><a href=\"#JSON-的替代协议-MessagePack\" class=\"headerlink\" title=\"JSON 的替代协议 MessagePack\"></a>JSON 的替代协议 MessagePack</h3><p><a href=\"http://msgpack.org/\" target=\"_blank\" rel=\"noopener\">MessagePack</a><br><img src=\"../../../../images/message-pack.png\" alt=\"MessagePack 截屏\"></p>\n<h2 id=\"ES5-中最强大的特性：Object-扩展\"><a href=\"#ES5-中最强大的特性：Object-扩展\" class=\"headerlink\" title=\"ES5 中最强大的特性：Object 扩展\"></a>ES5 中最强大的特性：Object 扩展</h2><p>以下是 ES5 对 Object 对象的所有扩展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.defineProperty</span><br><span class=\"line\">Object.defineProperties</span><br><span class=\"line\">Object.create</span><br><span class=\"line\">Object.getPrototypeOf</span><br><span class=\"line\">Object.keys</span><br><span class=\"line\">Object.seal</span><br><span class=\"line\">Object.freeze</span><br><span class=\"line\">Object.preventExtensions</span><br><span class=\"line\">Object.isSealed</span><br><span class=\"line\">Object.isFrozen</span><br><span class=\"line\">Object.isExtensible</span><br><span class=\"line\">Object.getOwnPropertyDescriptor</span><br><span class=\"line\">Object.getOwnPropertyNames</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty-obj-prop-descriptor\"><a href=\"#Object-defineProperty-obj-prop-descriptor\" class=\"headerlink\" title=\"Object.defineProperty(obj, prop, descriptor)\"></a>Object.defineProperty(obj, prop, descriptor)</h3><p>直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'val'</span>, <span class=\"comment\">//默认 undefined</span></span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span>, <span class=\"comment\">//默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改</span></span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>, <span class=\"comment\">//默认 false，属性是否可以枚举</span></span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>, <span class=\"comment\">//默认 false，能够使用赋值运算符改变属性值</span></span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = newValue;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//以上代码仅为示例，get/set 不能和 value，writable同时出现。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty-数据描述符-configurable\"><a href=\"#Object-defineProperty-数据描述符-configurable\" class=\"headerlink\" title=\"Object.defineProperty 数据描述符 configurable\"></a>Object.defineProperty 数据描述符 configurable</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'val'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改</span></span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123; <span class=\"attr\">value</span>: <span class=\"string\">'changed'</span>, <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">//changed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123;</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e);</span><br><span class=\"line\">&#125; <span class=\"comment\">//TypeError: Cannot redefine property: key(…)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.key;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">//changed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty-数据描述符-enumerable\"><a href=\"#Object-defineProperty-数据描述符-enumerable\" class=\"headerlink\" title=\"Object.defineProperty 数据描述符 enumerable\"></a>Object.defineProperty 数据描述符 enumerable</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'val'</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>, <span class=\"comment\">// 默认 false，属性是否可以枚举</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.propertyIsEnumerable(<span class=\"string\">'key'</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj)); <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k); <span class=\"comment\">//什么也不会打印</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-Object-defineProperty-调试\"><a href=\"#使用-Object-defineProperty-调试\" class=\"headerlink\" title=\"使用 Object.defineProperty 调试\"></a>使用 Object.defineProperty 调试</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function debugObject(obj, key)&#123;</span><br><span class=\"line\">    //将相应值保存起来</span><br><span class=\"line\">    var value = obj.key;</span><br><span class=\"line\">    //重新定义该属性</span><br><span class=\"line\">    Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">            get: function()&#123;</span><br><span class=\"line\">                return value;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            set: function(val)&#123;</span><br><span class=\"line\">                debugger;</span><br><span class=\"line\">                value = val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES7 草案中，还有一个方法<code>Object.observe(ob, callback)</code>可以更加方便地监听对象变化。</p>\n<h3 id=\"Object-defineProperties-obj-props\"><a href=\"#Object-defineProperties-obj-props\" class=\"headerlink\" title=\"Object.defineProperties(obj, props)\"></a>Object.defineProperties(obj, props)</h3><p>添加或修改 1+个属性，并返回该对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(&#123;</span><br><span class=\"line\">    key1: &#123;</span><br><span class=\"line\">        writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    key2: &#123;</span><br><span class=\"line\">        enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-create-prototype-descriptors\"><a href=\"#Object-create-prototype-descriptors\" class=\"headerlink\" title=\"Object.create(prototype, descriptors)\"></a>Object.create(prototype, descriptors)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Man = &#123;</span><br><span class=\"line\">    race: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'race'</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> peter = <span class=\"built_in\">Object</span>.create(Man, &#123;</span><br><span class=\"line\">    firstName: &#123; <span class=\"attr\">value</span>: <span class=\"string\">'Xiaoming'</span> &#125;,</span><br><span class=\"line\">    lastName: &#123; <span class=\"attr\">value</span>: <span class=\"string\">'Li'</span> &#125;,</span><br><span class=\"line\">    fullName: &#123;</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(peter.fullName); <span class=\"comment\">// Xiaoming Li</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-create-prototype-descriptors-1\"><a href=\"#Object-create-prototype-descriptors-1\" class=\"headerlink\" title=\"Object.create(prototype, descriptors)\"></a>Object.create(prototype, descriptors)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Object</span>.keys(obj) ); <span class=\"comment\">//[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"keyword\">typeof</span> obj ); <span class=\"comment\">//object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Object</span>.prototype.toString.call(obj) ); <span class=\"comment\">//[object Object]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj instanseof <span class=\"built_in\">Object</span> ); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-getOwnPropertyDescriptor-obj-prop-获取属性描述符\"><a href=\"#Object-getOwnPropertyDescriptor-obj-prop-获取属性描述符\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptor(obj, prop) 获取属性描述符\"></a>Object.getOwnPropertyDescriptor(obj, prop) 获取属性描述符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'b'</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">//value: 2,</span></span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'a'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'b'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(descriptor);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-getOwnPropertyNames-obj-获取所有自有属性名\"><a href=\"#Object-getOwnPropertyNames-obj-获取所有自有属性名\" class=\"headerlink\" title=\"Object.getOwnPropertyNames(obj) 获取所有自有属性名\"></a>Object.getOwnPropertyNames(obj) 获取所有自有属性名</h3><p>获取所有自有属性名，包含可枚举以及不可枚举的，但是不包含原型链上的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> prototype = &#123; <span class=\"attr\">a</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(prototype, &#123;</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">        value: <span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    c: &#123;</span><br><span class=\"line\">        value: <span class=\"number\">2</span>,</span><br><span class=\"line\">        enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(obj)); <span class=\"comment\">// [\"b\", \"c\"]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-freeze-obj-冻结一个对象\"><a href=\"#Object-freeze-obj-冻结一个对象\" class=\"headerlink\" title=\"Object.freeze(obj) 冻结一个对象\"></a>Object.freeze(obj) 冻结一个对象</h3><p>冻结一个对象，意味着该对象的属性不能增删改，属性的各个特性也不能改。<br>而<code>Object.isFrozen(obj)</code>可以用来判断一个对象有没有冻结。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">key</span>: <span class=\"string\">'val'</span>, <span class=\"attr\">key1</span>: &#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.freeze(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.isFrozen(obj)); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.key2 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key2); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.key;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// val</span></span><br><span class=\"line\">obj.key = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// val</span></span><br><span class=\"line\">obj.key1.a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key1.a); <span class=\"comment\">// 2 ------冻结仅仅冻结一层</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Uncaught TypeError: Cannot redefine property: key</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"怎样完全冻结一个对象\"><a href=\"#怎样完全冻结一个对象\" class=\"headerlink\" title=\"怎样完全冻结一个对象\"></a>怎样完全冻结一个对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepFreeze</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = obj[key];</span><br><span class=\"line\">        <span class=\"comment\">//忽略原型链上的属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!obj.hasOwnProperty(key)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">//忽略不是对象的属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val !== <span class=\"string\">'object'</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">//忽略已经冻结的属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.isFrozen(val)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">//递归地冻结对象属性</span></span><br><span class=\"line\">        deepFreeze(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-seal-obj-密封一个对象\"><a href=\"#Object-seal-obj-密封一个对象\" class=\"headerlink\" title=\"Object.seal(obj) 密封一个对象\"></a>Object.seal(obj) 密封一个对象</h3><p>密封，比冻结宽松一点，仅仅能修改属性的值。<br>而<code>Object.isSealed(obj)</code>可以用来判断一个对象有没有密封。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">key</span>: <span class=\"string\">'val'</span>, <span class=\"attr\">key1</span>: &#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.seal(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.isSealed(obj)); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.key2 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key2); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.key;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// val</span></span><br><span class=\"line\">obj.key = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// 1----跟冻结唯一不同的地方</span></span><br><span class=\"line\">obj.key1.a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key1.a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Uncaught TypeError: Cannot redefine property: key</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-preventExtensions-obj-不能添加新属性\"><a href=\"#Object-preventExtensions-obj-不能添加新属性\" class=\"headerlink\" title=\"Object.preventExtensions(obj) 不能添加新属性\"></a>Object.preventExtensions(obj) 不能添加新属性</h3><p><code>Object.isExtensible</code>用来检查一个对象能不能添加新属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">key</span>: <span class=\"string\">'val'</span>, <span class=\"attr\">key1</span>: &#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.isExtensible(obj)); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.key2 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key2); <span class=\"comment\">// undefined，不能添加新属性</span></span><br><span class=\"line\">obj.key = <span class=\"string\">'value'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// value，能够修改已有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj)); <span class=\"comment\">// [\"key1\"]，能够修改属性特性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.key;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// undefined，能够删除已有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.key1.a = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key1.a); <span class=\"comment\">// a，不影响给扩展已有属性</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-getPrototypeOf-obj\"><a href=\"#Object-getPrototypeOf-obj\" class=\"headerlink\" title=\"Object.getPrototypeOf(obj)\"></a>Object.getPrototypeOf(obj)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> prototype = (Car.prototype = &#123;&#125;);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"keyword\">new</span> Car()) === prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> prototype = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> car = <span class=\"built_in\">Object</span>.create(prototype);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(car) === prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Array-扩展\"><a href=\"#Array-扩展\" class=\"headerlink\" title=\"Array 扩展\"></a>Array 扩展</h2><p><code>Array.isArray(obj)</code> 判断一个对象是不是数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(array); <span class=\"comment\">//true，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj) === <span class=\"string\">'[object Array]'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-实例扩展\"><a href=\"#Array-实例扩展\" class=\"headerlink\" title=\"Array 实例扩展\"></a>Array 实例扩展</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">array.indexOf(<span class=\"number\">2</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">array.lastIndexOf(<span class=\"number\">2</span>); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"保留字作为属性名\"><a href=\"#保留字作为属性名\" class=\"headerlink\" title=\"保留字作为属性名\"></a>保留字作为属性名</h2><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"keyword\">var</span>: <span class=\"string\">'s'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.if);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.var);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.switch);</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-get-set-进行属性初始化\"><a href=\"#使用-get-set-进行属性初始化\" class=\"headerlink\" title=\"使用 get/set 进行属性初始化\"></a>使用 get/set 进行属性初始化</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">        firstName: &apos;&apos;,</span><br><span class=\"line\">        lastName: &apos;&apos;,</span><br><span class=\"line\">        get fullName()&#123;</span><br><span class=\"line\">            return (this.firstName + &apos; &apos; + this.lastName).trim();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set fullName(fullName)&#123;</span><br><span class=\"line\">            if(!fullName) return;</span><br><span class=\"line\">            var index = fullName.indexOf(&apos; &apos;);</span><br><span class=\"line\">            this.firstName = fullName.substring(0, index);</span><br><span class=\"line\">            this.lastName  = fullName.substring(index+1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log( obj.fullName );  // 空字符串</span><br><span class=\"line\">obj.fullName = &apos;San Zhang&apos;;</span><br><span class=\"line\">console.log( obj.firstName ); // San</span><br><span class=\"line\">console.log( obj.lastName );  // Zhang</span><br><span class=\"line\">console.log( obj.fullName );  // San Zhang</span><br></pre></td></tr></table></figure>\n<h2 id=\"全局-undefined-对象\"><a href=\"#全局-undefined-对象\" class=\"headerlink\" title=\"全局 undefined 对象\"></a>全局 undefined 对象</h2><p>以前，undefined 对象是这样产生的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> undef;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> undef === <span class=\"string\">'undefined'</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> undef = <span class=\"number\">1</span>;</span><br><span class=\"line\">undef = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> undef === <span class=\"string\">'undefined'</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//jQuery 1.8.3源码片段</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">window, undefined</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> === <span class=\"string\">'undefined'</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</span><br></pre></td></tr></table></figure>\n<p>在 ES5 中有了不可变的全局的<code>undefined</code>对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">undefined</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"literal\">undefined</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.undefined = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.undefined); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"Function-实例扩展\"><a href=\"#Function-实例扩展\" class=\"headerlink\" title=\"Function 实例扩展\"></a>Function 实例扩展</h2><h3 id=\"Function-prototype-bind\"><a href=\"#Function-prototype-bind\" class=\"headerlink\" title=\"Function.prototype.bind\"></a>Function.prototype.bind</h3><p><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a.bind(&#123; <span class=\"attr\">key</span>: <span class=\"string\">'a'</span> &#125;, <span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// function bound a() &#123; [native code] &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.bind(<span class=\"string\">'ab'</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)(); <span class=\"comment\">//String &#123;0: \"a\", 1: \"b\", length: 2, [[PrimitiveValue]]: \"ab\"&#125; [1, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.bind(&#123; <span class=\"attr\">key</span>: <span class=\"string\">'a'</span> &#125;, <span class=\"number\">1</span>, <span class=\"number\">2</span>).bind(&#123; <span class=\"attr\">key</span>: <span class=\"string\">'b'</span> &#125;, <span class=\"number\">3</span>, <span class=\"number\">4</span>)(); <span class=\"comment\">// &#123;key: 'a'&#125;, [1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Curry（柯里化）\"><a href=\"#Curry（柯里化）\" class=\"headerlink\" title=\"Curry（柯里化）\"></a>Curry（柯里化）</h3><p>预先设定函数的前面若干个实参，生成一个接受剩余实参的新函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice,</span><br><span class=\"line\">        args = slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.apply(<span class=\"literal\">null</span>, args.concat(slice.apply(<span class=\"built_in\">arguments</span>)));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"柯里化案例\"><a href=\"#柯里化案例\" class=\"headerlink\" title=\"柯里化案例\"></a>柯里化案例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">model.groups = _.filter(model.groups, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">g</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g.id !== group.id;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">model.groups = _.sortBy(model.groups, <span class=\"string\">'updateTime'</span>);</span><br><span class=\"line\">model.groups = _.map(model.groups, <span class=\"string\">'name'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// _.prototype 上的方法都是 _ 上相应方法的柯里化</span></span><br><span class=\"line\">model.groups = _.chain(groups)</span><br><span class=\"line\">    .filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">g</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> g.id !== group.id;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .sortBy(<span class=\"string\">'updateTime'</span>)</span><br><span class=\"line\">    .map(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">    .value();</span><br></pre></td></tr></table></figure>\n<h3 id=\"curry-amp-curryRight\"><a href=\"#curry-amp-curryRight\" class=\"headerlink\" title=\"_.curry &amp; _.curryRight\"></a>_.curry &amp; _.curryRight</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> abc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a, b, c];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> curried = _.curry(abc);</span><br><span class=\"line\"></span><br><span class=\"line\">curried(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>); <span class=\"comment\">//[1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">curried(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>); <span class=\"comment\">//[1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">curried(_, <span class=\"number\">2</span>)(_, <span class=\"number\">3</span>)(<span class=\"number\">1</span>); <span class=\"comment\">//[1,2,3]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>把<strong>整段代码</strong>或<strong>某个函数</strong>放在严格操作的环境中运行，严格环境有诸多限制：</p>\n<ol>\n<li>将失误转成异常</li>\n<li>简化变量的使用</li>\n<li>让 eval 和 arguments 变的简单</li>\n<li>“安全的” JavaScript</li>\n<li>为未来的 ECMAScript 版本铺平道路</li>\n</ol>\n<h2 id=\"严格模式：将失误转成异常\"><a href=\"#严格模式：将失误转成异常\" class=\"headerlink\" title=\"严格模式：将失误转成异常\"></a>严格模式：将失误转成异常</h2><ol>\n<li>意外地创建全局变量</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    variable = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;)(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"comment\">//解决方法1：明确指定我要创建全局变量</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.variable = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">//解决方法2：事先定义好全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> variable;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    variable = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>不再静默失败，而是抛出异常</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fixed = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(fixed);</span><br><span class=\"line\">fixed.attr = <span class=\"string\">'value'</span>; <span class=\"comment\">// SyntaxError</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>形参命名不能重复</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, a</span>)</span>&#123;<span class=\"string\">'use strict'</span>; &#125;)(); <span class=\"comment\">//SyntaxError</span></span><br></pre></td></tr></table></figure>\n<p>注意：严格模式下，ES5 中定义变量时，字段名也不能重复，但是 ES6 又允许了。</p>\n<ol start=\"4\">\n<li>严格模式禁止八进制数字语法</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//FireFox: SyntaxError, Chrome/IE10: SyntaxError</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"string\">'use strict'</span>;  <span class=\"built_in\">console</span>.log(<span class=\"number\">010</span>); &#125;)();</span><br><span class=\"line\"><span class=\"comment\">//FireFox: SyntaxError, Chrome/IE10: 19</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"string\">'use strict'</span>;  <span class=\"built_in\">console</span>.log(<span class=\"number\">019</span>); &#125;)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"严格模式：简化变量的使用\"><a href=\"#严格模式：简化变量的使用\" class=\"headerlink\" title=\"严格模式：简化变量的使用\"></a>严格模式：简化变量的使用</h2><ol>\n<li>禁用<code>with</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = <span class=\"string\">'attr'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">key</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">with</span>(obj)&#123; <span class=\"comment\">//SyntaxError</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><code>eval</code>不再为上层作用域引入新变量</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"built_in\">eval</span>(<span class=\"string\">'var x = 2; x'</span>); <span class=\"comment\">//== eval('\"use strict\"; var x = 2; x')</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x, y); <span class=\"comment\">// 1, 2 在正常模式下，返回2, 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"严格模式：简化变量的使用-1\"><a href=\"#严格模式：简化变量的使用-1\" class=\"headerlink\" title=\"严格模式：简化变量的使用\"></a>严格模式：简化变量的使用</h2><ol start=\"3\">\n<li><code>call</code> &amp; <code>apply</code>对<code>this</code>的修改规则简化</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printThis</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printThis.call(<span class=\"number\">2</span>); <span class=\"comment\">// 2 ，不再包装成对象类型</span></span><br><span class=\"line\">    printThis.call(<span class=\"literal\">null</span>); <span class=\"comment\">// null，不再自动替换成window对象</span></span><br><span class=\"line\">    printThis.call(); <span class=\"comment\">// undefined，不再自动替换成window对象</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>不能使用<code>caller</code>和<code>callee</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">restricted</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(restricted.caller); <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(restricted.arguments); <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>.caller); <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>.callee); <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">&#125;)(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他小的特性\"><a href=\"#其他小的特性\" class=\"headerlink\" title=\"其他小的特性\"></a>其他小的特性</h2><h3 id=\"1-Date-prototype-toISOString\"><a href=\"#1-Date-prototype-toISOString\" class=\"headerlink\" title=\"1. Date.prototype.toISOString\"></a>1. Date.prototype.toISOString</h3><p>转换成 <code>YYYY-MM-DDTHH:mm:ss.sssZ</code> 这种格式</p>\n<h3 id=\"2-Date-now\"><a href=\"#2-Date-now\" class=\"headerlink\" title=\"2. Date.now()\"></a>2. Date.now()</h3><p>和 <code>new Date().getTime()</code> 一样。</p>\n<h3 id=\"3-String-prototype-trim\"><a href=\"#3-String-prototype-trim\" class=\"headerlink\" title=\"3. String.prototype.trim\"></a>3. String.prototype.trim</h3><p>和<code>$.trim</code>，<code>_.trim</code>一样。</p>\n<h3 id=\"4-把字符串当做数组一样访问\"><a href=\"#4-把字符串当做数组一样访问\" class=\"headerlink\" title=\"4. 把字符串当做数组一样访问\"></a>4. 把字符串当做数组一样访问</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'foobar'</span>[<span class=\"number\">1</span>] === <span class=\"string\">'o'</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-parseInt-忽略前置-0\"><a href=\"#5-parseInt-忽略前置-0\" class=\"headerlink\" title=\"5. parseInt 忽略前置 0\"></a>5. parseInt 忽略前置 0</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;012&apos;); // 12，在ES3中，因为前置0而按照八进制解析成10</span><br><span class=\"line\">parseInt(&apos;0X12&apos;); // 18，仍然因为前置0X而按照十六进制解析成18</span><br></pre></td></tr></table></figure>\n<h2 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h2><ol>\n<li>以下这种情况是为什么？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var array = [];</span><br><span class=\"line\">console.log( array.length ); // 0</span><br><span class=\"line\">console.log( Object.keys(array) ); // []</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference\" target=\"_blank\" rel=\"noopener\">MDN Javascript 参考文档</a></li>\n<li><a href=\"https://github.com/es-shims/es5-shim\" target=\"_blank\" rel=\"noopener\">es5-shim</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%C2%B7%E5%85%8B%E7%BE%85%E5%85%8B%E7%A6%8F%E7%89%B9\" target=\"_blank\" rel=\"noopener\">Douglas Crockford</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>这是我组织的 ES6 特性分享的预热篇，主要介绍 ES5 的特性。</p>\n<h2 id=\"既是入门，又是回顾\"><a href=\"#既是入门，又是回顾\" class=\"headerlink\" title=\"既是入门，又是回顾\"></a>既是入门，又是回顾</h2><ul>\n<li><p>相信很多人还没有完全在项目中使用</p>\n</li>\n<li><p><code>2011</code>年正式发布的<code>IE9</code>实现了几乎所有<code>ES5</code>的特性</p>\n</li>\n<li><code>ES6</code>，<code>ES7</code>……都已经或将要来了</li>\n</ul>\n<h2 id=\"ES5-中最有用的特性：JSON\"><a href=\"#ES5-中最有用的特性：JSON\" class=\"headerlink\" title=\"ES5 中最有用的特性：JSON\"></a>ES5 中最有用的特性：JSON</h2><h3 id=\"JSON-简介\"><a href=\"#JSON-简介\" class=\"headerlink\" title=\"JSON 简介\"></a>JSON 简介</h3><p><img src=\"https://c2.staticflickr.com/4/3002/3117853012_9b2b508e94_b.jpg\" alt=\"Douglas Crockford\"></p>\n<ol>\n<li>Douglas Crockford 在 2002 年创建，</li>\n<li>JSON JavaScript 对象标记（Notation）</li>\n<li>JavaScript 语言的一个子集</li>\n<li>一种轻量级的数据交换格式</li>\n<li>易于人阅读和编写，同时也易于机器解析和生成。</li>\n</ol>\n<p>更多细节：<a href=\"http://www.ietf.org/rfc/rfc7159.txt\" target=\"_blank\" rel=\"noopener\">RFC7159</a>，<a href=\"http://www.ecma-international.org/publications/standards/Ecma-404.htm\" target=\"_blank\" rel=\"noopener\">ECMA-404</a>，<a href=\"http://json.org/json-zh.html\" target=\"_blank\" rel=\"noopener\">介绍 JSON</a></p>\n<h3 id=\"那段不堪回首的过去\"><a href=\"#那段不堪回首的过去\" class=\"headerlink\" title=\"那段不堪回首的过去\"></a>那段不堪回首的过去</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">eval</span>(<span class=\"string\">'('</span> + response + <span class=\"string\">')'</span>);</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"/javascript/json2.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(response);</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-stringify-value-replacer-space\"><a href=\"#JSON-stringify-value-replacer-space\" class=\"headerlink\" title=\"JSON.stringify(value[, replacer [, space]])\"></a>JSON.stringify(value[, replacer [, space]])</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"string\">'x'</span>, <span class=\"attr\">b</span>: &#123; <span class=\"attr\">c</span>: <span class=\"number\">1</span> &#125; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj);</span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'number'</span> ? <span class=\"number\">0</span> : value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">//&#123;\"a\":\"x\",\"b\":&#123;\"c\":0&#125;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//美化JSON</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj, <span class=\"literal\">null</span>, <span class=\"string\">'\\t'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj, <span class=\"literal\">null</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.toJSON = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'something'</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"built_in\">JSON</span>.stringify(obj);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(string); <span class=\"comment\">//nothing</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-parse-text-reviver\"><a href=\"#JSON-parse-text-reviver\" class=\"headerlink\" title=\"JSON.parse(text[, reviver])\"></a>JSON.parse(text[, reviver])</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将字符串解析成JSON对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"a\":1,\"b\":&#123;\"c\":1&#125;&#125;'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将字符串解析成JSON对象，并对象中的每个数值加1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = <span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"a\":1,\"b\":&#123;\"c\":1&#125;&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> value === <span class=\"string\">'number'</span> ? value + <span class=\"number\">1</span> : value;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data)); <span class=\"comment\">//&#123;\"a\":2,\"b\":&#123;\"c\":2&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-用法举例\"><a href=\"#JSON-用法举例\" class=\"headerlink\" title=\"JSON 用法举例\"></a>JSON 用法举例</h3><ol>\n<li>解析 JSON 格式的 AJAX 响应</li>\n<li>localStorage，sessionStorage 只能存储字符串</li>\n<li>PHP 使用 SpiderMonkey 引擎创建 JS 上下并输入数据</li>\n</ol>\n<h3 id=\"JSON-的替代协议-Protocol-Buffers\"><a href=\"#JSON-的替代协议-Protocol-Buffers\" class=\"headerlink\" title=\"JSON 的替代协议 Protocol Buffers\"></a>JSON 的替代协议 Protocol Buffers</h3><p><a href=\"https://developers.google.com/protocol-buffers/\" target=\"_blank\" rel=\"noopener\">Protocol Buffers</a>，<a href=\"https://github.com/google/protobuf\" target=\"_blank\" rel=\"noopener\">Github</a><br><img src=\"../../../../images/protocol-buffers.png\" alt=\"Protocol Buffers 截屏\"></p>\n<h3 id=\"JSON-的替代协议-MessagePack\"><a href=\"#JSON-的替代协议-MessagePack\" class=\"headerlink\" title=\"JSON 的替代协议 MessagePack\"></a>JSON 的替代协议 MessagePack</h3><p><a href=\"http://msgpack.org/\" target=\"_blank\" rel=\"noopener\">MessagePack</a><br><img src=\"../../../../images/message-pack.png\" alt=\"MessagePack 截屏\"></p>\n<h2 id=\"ES5-中最强大的特性：Object-扩展\"><a href=\"#ES5-中最强大的特性：Object-扩展\" class=\"headerlink\" title=\"ES5 中最强大的特性：Object 扩展\"></a>ES5 中最强大的特性：Object 扩展</h2><p>以下是 ES5 对 Object 对象的所有扩展</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object.defineProperty</span><br><span class=\"line\">Object.defineProperties</span><br><span class=\"line\">Object.create</span><br><span class=\"line\">Object.getPrototypeOf</span><br><span class=\"line\">Object.keys</span><br><span class=\"line\">Object.seal</span><br><span class=\"line\">Object.freeze</span><br><span class=\"line\">Object.preventExtensions</span><br><span class=\"line\">Object.isSealed</span><br><span class=\"line\">Object.isFrozen</span><br><span class=\"line\">Object.isExtensible</span><br><span class=\"line\">Object.getOwnPropertyDescriptor</span><br><span class=\"line\">Object.getOwnPropertyNames</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty-obj-prop-descriptor\"><a href=\"#Object-defineProperty-obj-prop-descriptor\" class=\"headerlink\" title=\"Object.defineProperty(obj, prop, descriptor)\"></a>Object.defineProperty(obj, prop, descriptor)</h3><p>直接在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'val'</span>, <span class=\"comment\">//默认 undefined</span></span><br><span class=\"line\">    configurable: <span class=\"literal\">false</span>, <span class=\"comment\">//默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改</span></span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>, <span class=\"comment\">//默认 false，属性是否可以枚举</span></span><br><span class=\"line\">    writable: <span class=\"literal\">false</span>, <span class=\"comment\">//默认 false，能够使用赋值运算符改变属性值</span></span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = newValue;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//以上代码仅为示例，get/set 不能和 value，writable同时出现。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty-数据描述符-configurable\"><a href=\"#Object-defineProperty-数据描述符-configurable\" class=\"headerlink\" title=\"Object.defineProperty 数据描述符 configurable\"></a>Object.defineProperty 数据描述符 configurable</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'val'</span>,</span><br><span class=\"line\">    <span class=\"comment\">// 默认 false，属性是否可以删除，除 writable 之外其他特性能够被修改</span></span><br><span class=\"line\">    configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123; <span class=\"attr\">value</span>: <span class=\"string\">'changed'</span>, <span class=\"attr\">configurable</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">//changed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123;</span><br><span class=\"line\">        configurable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e);</span><br><span class=\"line\">&#125; <span class=\"comment\">//TypeError: Cannot redefine property: key(…)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.key;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">//changed</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-defineProperty-数据描述符-enumerable\"><a href=\"#Object-defineProperty-数据描述符-enumerable\" class=\"headerlink\" title=\"Object.defineProperty 数据描述符 enumerable\"></a>Object.defineProperty 数据描述符 enumerable</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123;</span><br><span class=\"line\">    value: <span class=\"string\">'val'</span>,</span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>, <span class=\"comment\">// 默认 false，属性是否可以枚举</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.propertyIsEnumerable(<span class=\"string\">'key'</span>)); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj)); <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(k); <span class=\"comment\">//什么也不会打印</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-Object-defineProperty-调试\"><a href=\"#使用-Object-defineProperty-调试\" class=\"headerlink\" title=\"使用 Object.defineProperty 调试\"></a>使用 Object.defineProperty 调试</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function debugObject(obj, key)&#123;</span><br><span class=\"line\">    //将相应值保存起来</span><br><span class=\"line\">    var value = obj.key;</span><br><span class=\"line\">    //重新定义该属性</span><br><span class=\"line\">    Object.defineProperty(obj, key, &#123;</span><br><span class=\"line\">            get: function()&#123;</span><br><span class=\"line\">                return value;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            set: function(val)&#123;</span><br><span class=\"line\">                debugger;</span><br><span class=\"line\">                value = val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES7 草案中，还有一个方法<code>Object.observe(ob, callback)</code>可以更加方便地监听对象变化。</p>\n<h3 id=\"Object-defineProperties-obj-props\"><a href=\"#Object-defineProperties-obj-props\" class=\"headerlink\" title=\"Object.defineProperties(obj, props)\"></a>Object.defineProperties(obj, props)</h3><p>添加或修改 1+个属性，并返回该对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperties(&#123;</span><br><span class=\"line\">    key1: &#123;</span><br><span class=\"line\">        writable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    key2: &#123;</span><br><span class=\"line\">        enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-create-prototype-descriptors\"><a href=\"#Object-create-prototype-descriptors\" class=\"headerlink\" title=\"Object.create(prototype, descriptors)\"></a>Object.create(prototype, descriptors)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Man = &#123;</span><br><span class=\"line\">    race: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'race'</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> peter = <span class=\"built_in\">Object</span>.create(Man, &#123;</span><br><span class=\"line\">    firstName: &#123; <span class=\"attr\">value</span>: <span class=\"string\">'Xiaoming'</span> &#125;,</span><br><span class=\"line\">    lastName: &#123; <span class=\"attr\">value</span>: <span class=\"string\">'Li'</span> &#125;,</span><br><span class=\"line\">    fullName: &#123;</span><br><span class=\"line\">        get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(peter.fullName); <span class=\"comment\">// Xiaoming Li</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-create-prototype-descriptors-1\"><a href=\"#Object-create-prototype-descriptors-1\" class=\"headerlink\" title=\"Object.create(prototype, descriptors)\"></a>Object.create(prototype, descriptors)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Object</span>.keys(obj) ); <span class=\"comment\">//[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"keyword\">typeof</span> obj ); <span class=\"comment\">//object</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Object</span>.prototype.toString.call(obj) ); <span class=\"comment\">//[object Object]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( obj instanseof <span class=\"built_in\">Object</span> ); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-getOwnPropertyDescriptor-obj-prop-获取属性描述符\"><a href=\"#Object-getOwnPropertyDescriptor-obj-prop-获取属性描述符\" class=\"headerlink\" title=\"Object.getOwnPropertyDescriptor(obj, prop) 获取属性描述符\"></a>Object.getOwnPropertyDescriptor(obj, prop) 获取属性描述符</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'b'</span>, &#123;</span><br><span class=\"line\">    <span class=\"comment\">//value: 2,</span></span><br><span class=\"line\">    enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'a'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'b'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(descriptor);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-getOwnPropertyNames-obj-获取所有自有属性名\"><a href=\"#Object-getOwnPropertyNames-obj-获取所有自有属性名\" class=\"headerlink\" title=\"Object.getOwnPropertyNames(obj) 获取所有自有属性名\"></a>Object.getOwnPropertyNames(obj) 获取所有自有属性名</h3><p>获取所有自有属性名，包含可枚举以及不可枚举的，但是不包含原型链上的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> prototype = &#123; <span class=\"attr\">a</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"built_in\">Object</span>.create(prototype, &#123;</span><br><span class=\"line\">    b: &#123;</span><br><span class=\"line\">        value: <span class=\"number\">1</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    c: &#123;</span><br><span class=\"line\">        value: <span class=\"number\">2</span>,</span><br><span class=\"line\">        enumerable: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyNames(obj)); <span class=\"comment\">// [\"b\", \"c\"]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-freeze-obj-冻结一个对象\"><a href=\"#Object-freeze-obj-冻结一个对象\" class=\"headerlink\" title=\"Object.freeze(obj) 冻结一个对象\"></a>Object.freeze(obj) 冻结一个对象</h3><p>冻结一个对象，意味着该对象的属性不能增删改，属性的各个特性也不能改。<br>而<code>Object.isFrozen(obj)</code>可以用来判断一个对象有没有冻结。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">key</span>: <span class=\"string\">'val'</span>, <span class=\"attr\">key1</span>: &#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.freeze(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.isFrozen(obj)); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.key2 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key2); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.key;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// val</span></span><br><span class=\"line\">obj.key = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// val</span></span><br><span class=\"line\">obj.key1.a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key1.a); <span class=\"comment\">// 2 ------冻结仅仅冻结一层</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Uncaught TypeError: Cannot redefine property: key</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"怎样完全冻结一个对象\"><a href=\"#怎样完全冻结一个对象\" class=\"headerlink\" title=\"怎样完全冻结一个对象\"></a>怎样完全冻结一个对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepFreeze</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> val = obj[key];</span><br><span class=\"line\">        <span class=\"comment\">//忽略原型链上的属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!obj.hasOwnProperty(key)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">//忽略不是对象的属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> val !== <span class=\"string\">'object'</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">//忽略已经冻结的属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.isFrozen(val)) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"comment\">//递归地冻结对象属性</span></span><br><span class=\"line\">        deepFreeze(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-seal-obj-密封一个对象\"><a href=\"#Object-seal-obj-密封一个对象\" class=\"headerlink\" title=\"Object.seal(obj) 密封一个对象\"></a>Object.seal(obj) 密封一个对象</h3><p>密封，比冻结宽松一点，仅仅能修改属性的值。<br>而<code>Object.isSealed(obj)</code>可以用来判断一个对象有没有密封。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">key</span>: <span class=\"string\">'val'</span>, <span class=\"attr\">key1</span>: &#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.seal(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.isSealed(obj)); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.key2 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key2); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.key;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// val</span></span><br><span class=\"line\">obj.key = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// 1----跟冻结唯一不同的地方</span></span><br><span class=\"line\">obj.key1.a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key1.a); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Uncaught TypeError: Cannot redefine property: key</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-preventExtensions-obj-不能添加新属性\"><a href=\"#Object-preventExtensions-obj-不能添加新属性\" class=\"headerlink\" title=\"Object.preventExtensions(obj) 不能添加新属性\"></a>Object.preventExtensions(obj) 不能添加新属性</h3><p><code>Object.isExtensible</code>用来检查一个对象能不能添加新属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">key</span>: <span class=\"string\">'val'</span>, <span class=\"attr\">key1</span>: &#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.isExtensible(obj)); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.key2 = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key2); <span class=\"comment\">// undefined，不能添加新属性</span></span><br><span class=\"line\">obj.key = <span class=\"string\">'value'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// value，能够修改已有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'key'</span>, &#123; <span class=\"attr\">enumerable</span>: <span class=\"literal\">false</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(obj)); <span class=\"comment\">// [\"key1\"]，能够修改属性特性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.key;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key); <span class=\"comment\">// undefined，能够删除已有属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.key1.a = <span class=\"string\">'a'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.key1.a); <span class=\"comment\">// a，不影响给扩展已有属性</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-getPrototypeOf-obj\"><a href=\"#Object-getPrototypeOf-obj\" class=\"headerlink\" title=\"Object.getPrototypeOf(obj)\"></a>Object.getPrototypeOf(obj)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Car</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> prototype = (Car.prototype = &#123;&#125;);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(<span class=\"keyword\">new</span> Car()) === prototype; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> prototype = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> car = <span class=\"built_in\">Object</span>.create(prototype);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.getPrototypeOf(car) === prototype; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Array-扩展\"><a href=\"#Array-扩展\" class=\"headerlink\" title=\"Array 扩展\"></a>Array 扩展</h2><p><code>Array.isArray(obj)</code> 判断一个对象是不是数组</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.isArray(array); <span class=\"comment\">//true，</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isArray</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj) === <span class=\"string\">'[object Array]'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-实例扩展\"><a href=\"#Array-实例扩展\" class=\"headerlink\" title=\"Array 实例扩展\"></a>Array 实例扩展</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">array.indexOf(<span class=\"number\">2</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\">array.lastIndexOf(<span class=\"number\">2</span>); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"保留字作为属性名\"><a href=\"#保留字作为属性名\" class=\"headerlink\" title=\"保留字作为属性名\"></a>保留字作为属性名</h2><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"keyword\">var</span>: <span class=\"string\">'s'</span>,</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.if);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.var);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.switch);</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-get-set-进行属性初始化\"><a href=\"#使用-get-set-进行属性初始化\" class=\"headerlink\" title=\"使用 get/set 进行属性初始化\"></a>使用 get/set 进行属性初始化</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">        firstName: &apos;&apos;,</span><br><span class=\"line\">        lastName: &apos;&apos;,</span><br><span class=\"line\">        get fullName()&#123;</span><br><span class=\"line\">            return (this.firstName + &apos; &apos; + this.lastName).trim();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set fullName(fullName)&#123;</span><br><span class=\"line\">            if(!fullName) return;</span><br><span class=\"line\">            var index = fullName.indexOf(&apos; &apos;);</span><br><span class=\"line\">            this.firstName = fullName.substring(0, index);</span><br><span class=\"line\">            this.lastName  = fullName.substring(index+1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log( obj.fullName );  // 空字符串</span><br><span class=\"line\">obj.fullName = &apos;San Zhang&apos;;</span><br><span class=\"line\">console.log( obj.firstName ); // San</span><br><span class=\"line\">console.log( obj.lastName );  // Zhang</span><br><span class=\"line\">console.log( obj.fullName );  // San Zhang</span><br></pre></td></tr></table></figure>\n<h2 id=\"全局-undefined-对象\"><a href=\"#全局-undefined-对象\" class=\"headerlink\" title=\"全局 undefined 对象\"></a>全局 undefined 对象</h2><p>以前，undefined 对象是这样产生的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> undef;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> undef === <span class=\"string\">'undefined'</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> undef = <span class=\"number\">1</span>;</span><br><span class=\"line\">undef = <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> undef === <span class=\"string\">'undefined'</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//jQuery 1.8.3源码片段</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">window, undefined</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> === <span class=\"string\">'undefined'</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">&#125;)(<span class=\"built_in\">window</span>);</span><br></pre></td></tr></table></figure>\n<p>在 ES5 中有了不可变的全局的<code>undefined</code>对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"literal\">undefined</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">undefined</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"literal\">undefined</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.undefined = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.undefined); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"Function-实例扩展\"><a href=\"#Function-实例扩展\" class=\"headerlink\" title=\"Function 实例扩展\"></a>Function 实例扩展</h2><h3 id=\"Function-prototype-bind\"><a href=\"#Function-prototype-bind\" class=\"headerlink\" title=\"Function.prototype.bind\"></a>Function.prototype.bind</h3><p><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a.bind(&#123; <span class=\"attr\">key</span>: <span class=\"string\">'a'</span> &#125;, <span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// function bound a() &#123; [native code] &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.bind(<span class=\"string\">'ab'</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)(); <span class=\"comment\">//String &#123;0: \"a\", 1: \"b\", length: 2, [[PrimitiveValue]]: \"ab\"&#125; [1, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.bind(&#123; <span class=\"attr\">key</span>: <span class=\"string\">'a'</span> &#125;, <span class=\"number\">1</span>, <span class=\"number\">2</span>).bind(&#123; <span class=\"attr\">key</span>: <span class=\"string\">'b'</span> &#125;, <span class=\"number\">3</span>, <span class=\"number\">4</span>)(); <span class=\"comment\">// &#123;key: 'a'&#125;, [1,2,3,4]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Curry（柯里化）\"><a href=\"#Curry（柯里化）\" class=\"headerlink\" title=\"Curry（柯里化）\"></a>Curry（柯里化）</h3><p>预先设定函数的前面若干个实参，生成一个接受剩余实参的新函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> slice = <span class=\"built_in\">Array</span>.prototype.slice,</span><br><span class=\"line\">        args = slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.apply(<span class=\"literal\">null</span>, args.concat(slice.apply(<span class=\"built_in\">arguments</span>)));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"柯里化案例\"><a href=\"#柯里化案例\" class=\"headerlink\" title=\"柯里化案例\"></a>柯里化案例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">model.groups = _.filter(model.groups, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">g</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> g.id !== group.id;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">model.groups = _.sortBy(model.groups, <span class=\"string\">'updateTime'</span>);</span><br><span class=\"line\">model.groups = _.map(model.groups, <span class=\"string\">'name'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// _.prototype 上的方法都是 _ 上相应方法的柯里化</span></span><br><span class=\"line\">model.groups = _.chain(groups)</span><br><span class=\"line\">    .filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">g</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> g.id !== group.id;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .sortBy(<span class=\"string\">'updateTime'</span>)</span><br><span class=\"line\">    .map(<span class=\"string\">'name'</span>)</span><br><span class=\"line\">    .value();</span><br></pre></td></tr></table></figure>\n<h3 id=\"curry-amp-curryRight\"><a href=\"#curry-amp-curryRight\" class=\"headerlink\" title=\"_.curry &amp; _.curryRight\"></a>_.curry &amp; _.curryRight</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> abc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [a, b, c];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> curried = _.curry(abc);</span><br><span class=\"line\"></span><br><span class=\"line\">curried(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>); <span class=\"comment\">//[1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">curried(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>); <span class=\"comment\">//[1,2,3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">curried(_, <span class=\"number\">2</span>)(_, <span class=\"number\">3</span>)(<span class=\"number\">1</span>); <span class=\"comment\">//[1,2,3]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>把<strong>整段代码</strong>或<strong>某个函数</strong>放在严格操作的环境中运行，严格环境有诸多限制：</p>\n<ol>\n<li>将失误转成异常</li>\n<li>简化变量的使用</li>\n<li>让 eval 和 arguments 变的简单</li>\n<li>“安全的” JavaScript</li>\n<li>为未来的 ECMAScript 版本铺平道路</li>\n</ol>\n<h2 id=\"严格模式：将失误转成异常\"><a href=\"#严格模式：将失误转成异常\" class=\"headerlink\" title=\"严格模式：将失误转成异常\"></a>严格模式：将失误转成异常</h2><ol>\n<li>意外地创建全局变量</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    variable = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;)(); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"><span class=\"comment\">//解决方法1：明确指定我要创建全局变量</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.variable = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">//解决方法2：事先定义好全局变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> variable;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    variable = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>不再静默失败，而是抛出异常</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fixed = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.preventExtensions(fixed);</span><br><span class=\"line\">fixed.attr = <span class=\"string\">'value'</span>; <span class=\"comment\">// SyntaxError</span></span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>形参命名不能重复</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, a</span>)</span>&#123;<span class=\"string\">'use strict'</span>; &#125;)(); <span class=\"comment\">//SyntaxError</span></span><br></pre></td></tr></table></figure>\n<p>注意：严格模式下，ES5 中定义变量时，字段名也不能重复，但是 ES6 又允许了。</p>\n<ol start=\"4\">\n<li>严格模式禁止八进制数字语法</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//FireFox: SyntaxError, Chrome/IE10: SyntaxError</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"string\">'use strict'</span>;  <span class=\"built_in\">console</span>.log(<span class=\"number\">010</span>); &#125;)();</span><br><span class=\"line\"><span class=\"comment\">//FireFox: SyntaxError, Chrome/IE10: 19</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"string\">'use strict'</span>;  <span class=\"built_in\">console</span>.log(<span class=\"number\">019</span>); &#125;)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"严格模式：简化变量的使用\"><a href=\"#严格模式：简化变量的使用\" class=\"headerlink\" title=\"严格模式：简化变量的使用\"></a>严格模式：简化变量的使用</h2><ol>\n<li>禁用<code>with</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = <span class=\"string\">'attr'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">key</span>: <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">with</span>(obj)&#123; <span class=\"comment\">//SyntaxError</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><code>eval</code>不再为上层作用域引入新变量</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"built_in\">eval</span>(<span class=\"string\">'var x = 2; x'</span>); <span class=\"comment\">//== eval('\"use strict\"; var x = 2; x')</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x, y); <span class=\"comment\">// 1, 2 在正常模式下，返回2, 2</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h2 id=\"严格模式：简化变量的使用-1\"><a href=\"#严格模式：简化变量的使用-1\" class=\"headerlink\" title=\"严格模式：简化变量的使用\"></a>严格模式：简化变量的使用</h2><ol start=\"3\">\n<li><code>call</code> &amp; <code>apply</code>对<code>this</code>的修改规则简化</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printThis</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    printThis.call(<span class=\"number\">2</span>); <span class=\"comment\">// 2 ，不再包装成对象类型</span></span><br><span class=\"line\">    printThis.call(<span class=\"literal\">null</span>); <span class=\"comment\">// null，不再自动替换成window对象</span></span><br><span class=\"line\">    printThis.call(); <span class=\"comment\">// undefined，不再自动替换成window对象</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>不能使用<code>caller</code>和<code>callee</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">restricted</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(restricted.caller); <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(restricted.arguments); <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>.caller); <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>.callee); <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">&#125;)(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"其他小的特性\"><a href=\"#其他小的特性\" class=\"headerlink\" title=\"其他小的特性\"></a>其他小的特性</h2><h3 id=\"1-Date-prototype-toISOString\"><a href=\"#1-Date-prototype-toISOString\" class=\"headerlink\" title=\"1. Date.prototype.toISOString\"></a>1. Date.prototype.toISOString</h3><p>转换成 <code>YYYY-MM-DDTHH:mm:ss.sssZ</code> 这种格式</p>\n<h3 id=\"2-Date-now\"><a href=\"#2-Date-now\" class=\"headerlink\" title=\"2. Date.now()\"></a>2. Date.now()</h3><p>和 <code>new Date().getTime()</code> 一样。</p>\n<h3 id=\"3-String-prototype-trim\"><a href=\"#3-String-prototype-trim\" class=\"headerlink\" title=\"3. String.prototype.trim\"></a>3. String.prototype.trim</h3><p>和<code>$.trim</code>，<code>_.trim</code>一样。</p>\n<h3 id=\"4-把字符串当做数组一样访问\"><a href=\"#4-把字符串当做数组一样访问\" class=\"headerlink\" title=\"4. 把字符串当做数组一样访问\"></a>4. 把字符串当做数组一样访问</h3><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'foobar'</span>[<span class=\"number\">1</span>] === <span class=\"string\">'o'</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-parseInt-忽略前置-0\"><a href=\"#5-parseInt-忽略前置-0\" class=\"headerlink\" title=\"5. parseInt 忽略前置 0\"></a>5. parseInt 忽略前置 0</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">parseInt(&apos;012&apos;); // 12，在ES3中，因为前置0而按照八进制解析成10</span><br><span class=\"line\">parseInt(&apos;0X12&apos;); // 18，仍然因为前置0X而按照十六进制解析成18</span><br></pre></td></tr></table></figure>\n<h2 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h2><ol>\n<li>以下这种情况是为什么？</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var array = [];</span><br><span class=\"line\">console.log( array.length ); // 0</span><br><span class=\"line\">console.log( Object.keys(array) ); // []</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference\" target=\"_blank\" rel=\"noopener\">MDN Javascript 参考文档</a></li>\n<li><a href=\"https://github.com/es-shims/es5-shim\" target=\"_blank\" rel=\"noopener\">es5-shim</a></li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%C2%B7%E5%85%8B%E7%BE%85%E5%85%8B%E7%A6%8F%E7%89%B9\" target=\"_blank\" rel=\"noopener\">Douglas Crockford</a></li>\n</ol>\n"},{"title":"Knockout简介","_content":"\n## 1. MVVM 的概念\n\n### 1.1 MVVM 的概念\n\nMVC 模型示意图\n![MVC 模型示意图](http://image.beekka.com/blog/2015/bg2015020105.png)\n\nMVVM 模型示意图\n![MVVM 模型示意图](http://image.beekka.com/blog/2015/bg2015020110.png)\n\n### 1.2 双向绑定的概念\n\n页面中每次状态的变化，一般都伴随着多次 DOM 操作，每次 DOM 操作一般都需要先找到该输入框元素，然后修改其相应属性，即便后来有了`jQuery`这种 DOM 操作神器，仍然非常繁琐。随着前端逻辑的日益复杂，前端越来越难以维护。此时双向绑定应运而生了。\n\n双向绑定，简单地说，就是模型（数据）和 DOM 自动保持同步，模型变化了，会自动更新 DOM，用户操作了 DOM，会自动更新更新模型，并且触发相应事件。这样一来，我们只需要更新模型，以及监听模型变化就可以了，不再像以前一边更新模型，一边进行 DOM 操作了。\n\n## 2. Knockout 的简介\n\n[Knockout](http://knockoutjs.com/)是一个可以轻松实现双向绑定的库。它有以下特性：\n\n### 2.1 模型和 DOM 双向绑定\n\n这点不需要多作说明，这就是 Knockout 最大的意义所在。\n\n### 2.2. 声明式绑定\n\n使用简明易读的自定义属性`data-bind`将模型字段关联到 DOM 元素上。比如以下代码就将输入框和模型中的 name 关联起来。\n\n```html\n<input type=\"text\" data-bind=\"value:name\" />\n```\n\n### 2.3 依赖跟踪\n\n对于通过组合或转换而来的数据，保持其依赖链。请看如下例子。\n\n```js\nfunction ViewModel() {\n    this.firstName = ko.observable('');\n    this.lastName = ko.observable('');\n    //声明 fullName 是由 firstName 和 lastName计算出来的\n    //当 firstName 和 lastName 其一发生变化时，fullName都会自动重新计算\n    this.fullName = ko.computed(function() {\n        return this.firstName() + ' ' + this.lastName();\n    }, this);\n}\n```\n\n### 2.4 模板\n\n    也不用多解释，与模型关联的DOM就是一个模板。\n\n### 2.5 其他一些特点\n\n    轻量（库，不是框架，侵入性低，很容和其他框架和库一起使用），全浏览器支持（包括IE6），没有依赖，免费（这是必须的）。\n\n## 3. 简单入门\n\n### 3.1 Bindings\n\n```\n-dom\n    |-visible---------------elem.style.display\n    |-text------------------elem.innerText\n    |-html------------------elem.innerHTML\n    |-css-------------------elem.className\n    |-style-----------------elem.style\n    |-attr------------------elem.setAttribute\n-flow\n    |-foreach\n    |-if/ifnot\n    |-with\n    |-component-------------自定义组件\n-form\n    |-click\n    |-submit\n    |-event-----------------用法：event:{keydown:onKeyDown}\n    |-enable/disable--------elem.disabled\n    |-value-----------------elem.value\n    |-textInput-------------elem.value(输入框值变化，model立即更新)\n    |-hasFocus--------------elem.focus()\n    |-checked---------------elem.checked\n    |-options---------------select的选项\n    |-selectedOptions-------select的选中选项\n    |-uniqueName------------如果:input 没有 name，则生成唯一的name。\n```\n\n### 3.2 官网链接\n\n官网示例[链接](http://knockoutjs.com/examples/)。\n系统自带绑定[链接](http://knockoutjs.com/documentation/introduction.html)\n\n## 4. 高级进阶\n\n### 4.1 创建自定义绑定\n\n使用方法：\n\n```html\n<textarea data-bind=\"textInput:query\"></textarea> <button data-bind=\"preview:query\"></button>\n```\n\n创建方法：\n\n```js\nko.bindingHandlers.preview = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        var query = ko.utils.unwrapObservable(valueAccessor());\n        //做一些初始化工作，比如事件绑定。\n    },\n    update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        //这一行如果不加的话，query发生变化时，该方法不会被调用。\n        var query = ko.utils.unwrapObservable(valueAccessor());\n        //当query发生变化时，要做什么处理。\n    },\n};\n```\n\n详细参考：[knockout-preview.js](http://code.patsnap.com/js/zhihuiya-static/blob/master/javascript/libs/knockout/knockout-preview.js)\n\n### 4.2 创建自定义组件\n\n使用方法：\n\n```html\n<!-- ko component:{name:\"ko-dropmenu\",params:{name:\"agl-search-order\",items:sorts}}\n--><!-- /ko -->\n```\n\n创建方法：\n\n```js\nko.components.register('ko-dropmenu', {\n    viewModel: function(params){\n        this.name = ko.observable(params.name);\n    }，\n    template: '<div data-bind=\"attr:{name:name}\"></div>'\n```\n\n详细参考：[knockout-dropmenu.js](http://code.patsnap.com/js/zhihuiya-static/blob/master/javascript/libs/knockout/knockout-dropmenu.js)\n\n### 4.3 computed 和 pureComputed\n\n`computed`和`pureComputed`均表示该字段是由其他一个或多个字段转化而来，其区别在于`pureComputed`会做一些优化，比如当前字段并没有显示在页面上时，该字段并不会被计算，当该字段显示时，才开始计算。\n\n## 5. 最佳实践\n\n### 5.1 `label>radio/checkbox`\n\n```html\n<div data-bind=\"visible:status==='show'\">\n    <span data=bind=\"text:name\"></span>\n    <label>\n        <input type=\"radio\" value=\"edit\" data-bind=\"checked:status\">\n        <span>编辑</span>\n    </label>\n</div>\n<div data-bind=\"visible:status==='edit'\">\n    <input type=\"text\" data-bind=\"value:name\">\n    <label>\n        <input type=\"radio\" value=\"show\" data-bind=\"checked:status\">\n        <span>保存</span>\n    </label>\n</div>\n```\n\n### 5.2 模型数据合理分块\n\n当模型数据变化了以后，跟这些数据相关的 DOM 都会重新渲染，所以模型数据需要尽可能做到动静分离。\n以收藏夹页面专利列表的详情模式为例，选中一个收藏夹，首先获取该收藏夹第一页的 50 条专利并渲染，然后再获取这 50 条专利的缩略图和 PDF 地址并渲染，用户可以选择全部选中和全部反选，也可以选择部分，然后标记为已读或未读。\n如果将缩略图和 PDF 地址，是否选中，是否已读等字段作为专利数据的一部分，那么必然将造成多次专利列表的重新渲染。\n一种可行的做法如下：\n\n```js\nthis.patents = ko.observableArray([]);\n\nthis.selected = ko.observableArray([]);\nthis.isAllSelected = ko.pureComputed({\n    read: function() {},\n    write: function() {},\n    owner: this,\n});\n\nthis.readMap = ko.observable({});\nthis.thumbMap = ko.observable({});\nthis.pdfMap = ko.observable({});\n```\n\n### 5.3 全选\n\n```html\n<input type=\"checkbox\" data-bind=\"checked:isAllSelected\" />\n\n<ul data-bind=\"foreach:patents\">\n    <li><input type=\"checkbox\" data-bind=\"value:$data.PN,checked:$parent.selected\" /></li>\n</ul>\n```\n\n```js\nthis.selected = ko.observableArray([]);\nthis.isAllSelected = ko.pureComputed({\n    read: function() {\n        return this.selected().length === this.patents().length;\n    },\n    write: function(checked) {\n        var selected = null;\n        //如果全部选中\n        if (checked) {\n            selected = _.map(this.patents(), 'PN');\n        }\n        //如果全部反选\n        else {\n            selected = [];\n        }\n        this.selected(selected);\n    },\n    owner: this,\n});\n```\n\n### 5.4 ViewModel 的重复利用\n\n如果两个 ViewModel 都需要拥有一些相同的数据，我们当然可以通过`pubsub`事件模型来同步，但是这样可能导致 ViewModel 中导出都是同步逻辑，他们没有任何业务价值，并且影响后来维护者理解这段代码。有什么方法解决这个问题吗？答案是肯定的，请看一下代码。\n\n```js\nvar userViewModel = {\n    user: ko.observable({});\n};\nvar model1 = {\n    user: userViewModel\n}\nvar model2 = {\n    user: userViewModel\n}\n```\n\n在以上这段代码中，`model1`和`model2`中拥有同一份`user`数据，自然是自动同步的。\n\n## 6. 踩过的坑\n\n### 6.1 声明绑定时忘记带括号\n\n如果直接绑定字段，才可以省略括号，如果是表达式，则必须带括号，这点初学者很容易犯错，建议所有的绑定都带括号。\n\n```js\nthis.index = ko.observable(0);\n```\n\n```html\n<!-- 正确，绑定单个字段可以不带括号 -->\n<span data-bind=\"text:index\"></span>\n<!-- 正确，绑定单个字段带括号也是对的 -->\n<span data-bind=\"text:index()\"></span>\n<!-- 错误，绑定表达式时必须带括号 -->\n<span data-bind=\"text:'NO.:' + index\"></span>\n<!-- 正确，绑定表达式时必须带括号 -->\n<span data-bind=\"text:'NO.:' + index()\"></span>\n```\n\n### 6.2 Class 属性的绑定\n\nClass 绑定方法有两种：\ncss\n\n```html\n<div data-bind=\"css:{disabled:status()==='disabled'}\"></div>\n```\n\nclass\n\n```html\n<div data-bind=\"attr:{'class':status}\"></div>\n```\n\n假设 ViewModel 中 status 的值为 'disabled'，则以上两种绑定都会给元素添加一个`disabled`类名。\n使用后者时需要注意`class`一定要加上引号，否则在 IE8 中报错。\n\n### 6.3 jQuery.fn.data 的缓存\n\n在`jQuery`中，`jQuery.fn.data`方法是有缓存的，如果要获取正确的结果，必须通过`jQuery.fn.data`进行设置`data`属性，而不使用原生方法`HTMLElement.prototype.getAttribute`。\n\n```html\n<!-- 分页器中的页面跳转链接 -->\n<span data-bind=\"click:goToPage,attr:{'data-page':page()-1}\">上一页</span>\n```\n\n```js\nthis.page = ko.observable(0);\nthis.goToPage = function(model, e) {\n    //错误，因为缓存问题，导致第二次获取页面时出错。\n    var page = $(e.target).data('page');\n    //正确\n    var page = e.target.getAttribute('data-page');\n};\n```\n\n### 6.4 坑爹的性能问题\n\n![是否停止运行此脚本图片](http://my.csdn.net/uploads/201207/17/1342531216_2338.jpg)\n\nKnockout 的模板是基于 DOM 的，遇到循环就会通过原生的 clone 方法复制出若干个 DOM 片段，这个方法性能很差，当复制的 DOM 节点数达到一定程度，就会变得很慢，尤其在 IE8 中，收藏夹中渲染专利列表时就遇到了这种问题，在 IE8 甚至出现了“是否停止运行此脚本对话框”。\n由于该问题是在测试阶段发现的，没有时间进行大的修改。但是 IE8 中的对话框又是不能接受的，所以改为首次渲染前 25 条（如果有的话）专利，异步等 100 毫秒之后再渲染后 25 条（如果有的话）专利。这样，所有专利渲染出来的时间虽然延长了一点，但是保证了不会弹出让人费解的对话框，并且对用户体验基本没有更坏的影响。\n\n## 7. 参考链接\n\n1. [Knockout 官网](http://knockoutjs.com/index.html)\n1. [MVC，MVP 和 MVVM 的图示](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)\n","source":"_posts/2015-09-06-knockout.md","raw":"---\ntitle: Knockout简介\n---\n\n## 1. MVVM 的概念\n\n### 1.1 MVVM 的概念\n\nMVC 模型示意图\n![MVC 模型示意图](http://image.beekka.com/blog/2015/bg2015020105.png)\n\nMVVM 模型示意图\n![MVVM 模型示意图](http://image.beekka.com/blog/2015/bg2015020110.png)\n\n### 1.2 双向绑定的概念\n\n页面中每次状态的变化，一般都伴随着多次 DOM 操作，每次 DOM 操作一般都需要先找到该输入框元素，然后修改其相应属性，即便后来有了`jQuery`这种 DOM 操作神器，仍然非常繁琐。随着前端逻辑的日益复杂，前端越来越难以维护。此时双向绑定应运而生了。\n\n双向绑定，简单地说，就是模型（数据）和 DOM 自动保持同步，模型变化了，会自动更新 DOM，用户操作了 DOM，会自动更新更新模型，并且触发相应事件。这样一来，我们只需要更新模型，以及监听模型变化就可以了，不再像以前一边更新模型，一边进行 DOM 操作了。\n\n## 2. Knockout 的简介\n\n[Knockout](http://knockoutjs.com/)是一个可以轻松实现双向绑定的库。它有以下特性：\n\n### 2.1 模型和 DOM 双向绑定\n\n这点不需要多作说明，这就是 Knockout 最大的意义所在。\n\n### 2.2. 声明式绑定\n\n使用简明易读的自定义属性`data-bind`将模型字段关联到 DOM 元素上。比如以下代码就将输入框和模型中的 name 关联起来。\n\n```html\n<input type=\"text\" data-bind=\"value:name\" />\n```\n\n### 2.3 依赖跟踪\n\n对于通过组合或转换而来的数据，保持其依赖链。请看如下例子。\n\n```js\nfunction ViewModel() {\n    this.firstName = ko.observable('');\n    this.lastName = ko.observable('');\n    //声明 fullName 是由 firstName 和 lastName计算出来的\n    //当 firstName 和 lastName 其一发生变化时，fullName都会自动重新计算\n    this.fullName = ko.computed(function() {\n        return this.firstName() + ' ' + this.lastName();\n    }, this);\n}\n```\n\n### 2.4 模板\n\n    也不用多解释，与模型关联的DOM就是一个模板。\n\n### 2.5 其他一些特点\n\n    轻量（库，不是框架，侵入性低，很容和其他框架和库一起使用），全浏览器支持（包括IE6），没有依赖，免费（这是必须的）。\n\n## 3. 简单入门\n\n### 3.1 Bindings\n\n```\n-dom\n    |-visible---------------elem.style.display\n    |-text------------------elem.innerText\n    |-html------------------elem.innerHTML\n    |-css-------------------elem.className\n    |-style-----------------elem.style\n    |-attr------------------elem.setAttribute\n-flow\n    |-foreach\n    |-if/ifnot\n    |-with\n    |-component-------------自定义组件\n-form\n    |-click\n    |-submit\n    |-event-----------------用法：event:{keydown:onKeyDown}\n    |-enable/disable--------elem.disabled\n    |-value-----------------elem.value\n    |-textInput-------------elem.value(输入框值变化，model立即更新)\n    |-hasFocus--------------elem.focus()\n    |-checked---------------elem.checked\n    |-options---------------select的选项\n    |-selectedOptions-------select的选中选项\n    |-uniqueName------------如果:input 没有 name，则生成唯一的name。\n```\n\n### 3.2 官网链接\n\n官网示例[链接](http://knockoutjs.com/examples/)。\n系统自带绑定[链接](http://knockoutjs.com/documentation/introduction.html)\n\n## 4. 高级进阶\n\n### 4.1 创建自定义绑定\n\n使用方法：\n\n```html\n<textarea data-bind=\"textInput:query\"></textarea> <button data-bind=\"preview:query\"></button>\n```\n\n创建方法：\n\n```js\nko.bindingHandlers.preview = {\n    init: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        var query = ko.utils.unwrapObservable(valueAccessor());\n        //做一些初始化工作，比如事件绑定。\n    },\n    update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {\n        //这一行如果不加的话，query发生变化时，该方法不会被调用。\n        var query = ko.utils.unwrapObservable(valueAccessor());\n        //当query发生变化时，要做什么处理。\n    },\n};\n```\n\n详细参考：[knockout-preview.js](http://code.patsnap.com/js/zhihuiya-static/blob/master/javascript/libs/knockout/knockout-preview.js)\n\n### 4.2 创建自定义组件\n\n使用方法：\n\n```html\n<!-- ko component:{name:\"ko-dropmenu\",params:{name:\"agl-search-order\",items:sorts}}\n--><!-- /ko -->\n```\n\n创建方法：\n\n```js\nko.components.register('ko-dropmenu', {\n    viewModel: function(params){\n        this.name = ko.observable(params.name);\n    }，\n    template: '<div data-bind=\"attr:{name:name}\"></div>'\n```\n\n详细参考：[knockout-dropmenu.js](http://code.patsnap.com/js/zhihuiya-static/blob/master/javascript/libs/knockout/knockout-dropmenu.js)\n\n### 4.3 computed 和 pureComputed\n\n`computed`和`pureComputed`均表示该字段是由其他一个或多个字段转化而来，其区别在于`pureComputed`会做一些优化，比如当前字段并没有显示在页面上时，该字段并不会被计算，当该字段显示时，才开始计算。\n\n## 5. 最佳实践\n\n### 5.1 `label>radio/checkbox`\n\n```html\n<div data-bind=\"visible:status==='show'\">\n    <span data=bind=\"text:name\"></span>\n    <label>\n        <input type=\"radio\" value=\"edit\" data-bind=\"checked:status\">\n        <span>编辑</span>\n    </label>\n</div>\n<div data-bind=\"visible:status==='edit'\">\n    <input type=\"text\" data-bind=\"value:name\">\n    <label>\n        <input type=\"radio\" value=\"show\" data-bind=\"checked:status\">\n        <span>保存</span>\n    </label>\n</div>\n```\n\n### 5.2 模型数据合理分块\n\n当模型数据变化了以后，跟这些数据相关的 DOM 都会重新渲染，所以模型数据需要尽可能做到动静分离。\n以收藏夹页面专利列表的详情模式为例，选中一个收藏夹，首先获取该收藏夹第一页的 50 条专利并渲染，然后再获取这 50 条专利的缩略图和 PDF 地址并渲染，用户可以选择全部选中和全部反选，也可以选择部分，然后标记为已读或未读。\n如果将缩略图和 PDF 地址，是否选中，是否已读等字段作为专利数据的一部分，那么必然将造成多次专利列表的重新渲染。\n一种可行的做法如下：\n\n```js\nthis.patents = ko.observableArray([]);\n\nthis.selected = ko.observableArray([]);\nthis.isAllSelected = ko.pureComputed({\n    read: function() {},\n    write: function() {},\n    owner: this,\n});\n\nthis.readMap = ko.observable({});\nthis.thumbMap = ko.observable({});\nthis.pdfMap = ko.observable({});\n```\n\n### 5.3 全选\n\n```html\n<input type=\"checkbox\" data-bind=\"checked:isAllSelected\" />\n\n<ul data-bind=\"foreach:patents\">\n    <li><input type=\"checkbox\" data-bind=\"value:$data.PN,checked:$parent.selected\" /></li>\n</ul>\n```\n\n```js\nthis.selected = ko.observableArray([]);\nthis.isAllSelected = ko.pureComputed({\n    read: function() {\n        return this.selected().length === this.patents().length;\n    },\n    write: function(checked) {\n        var selected = null;\n        //如果全部选中\n        if (checked) {\n            selected = _.map(this.patents(), 'PN');\n        }\n        //如果全部反选\n        else {\n            selected = [];\n        }\n        this.selected(selected);\n    },\n    owner: this,\n});\n```\n\n### 5.4 ViewModel 的重复利用\n\n如果两个 ViewModel 都需要拥有一些相同的数据，我们当然可以通过`pubsub`事件模型来同步，但是这样可能导致 ViewModel 中导出都是同步逻辑，他们没有任何业务价值，并且影响后来维护者理解这段代码。有什么方法解决这个问题吗？答案是肯定的，请看一下代码。\n\n```js\nvar userViewModel = {\n    user: ko.observable({});\n};\nvar model1 = {\n    user: userViewModel\n}\nvar model2 = {\n    user: userViewModel\n}\n```\n\n在以上这段代码中，`model1`和`model2`中拥有同一份`user`数据，自然是自动同步的。\n\n## 6. 踩过的坑\n\n### 6.1 声明绑定时忘记带括号\n\n如果直接绑定字段，才可以省略括号，如果是表达式，则必须带括号，这点初学者很容易犯错，建议所有的绑定都带括号。\n\n```js\nthis.index = ko.observable(0);\n```\n\n```html\n<!-- 正确，绑定单个字段可以不带括号 -->\n<span data-bind=\"text:index\"></span>\n<!-- 正确，绑定单个字段带括号也是对的 -->\n<span data-bind=\"text:index()\"></span>\n<!-- 错误，绑定表达式时必须带括号 -->\n<span data-bind=\"text:'NO.:' + index\"></span>\n<!-- 正确，绑定表达式时必须带括号 -->\n<span data-bind=\"text:'NO.:' + index()\"></span>\n```\n\n### 6.2 Class 属性的绑定\n\nClass 绑定方法有两种：\ncss\n\n```html\n<div data-bind=\"css:{disabled:status()==='disabled'}\"></div>\n```\n\nclass\n\n```html\n<div data-bind=\"attr:{'class':status}\"></div>\n```\n\n假设 ViewModel 中 status 的值为 'disabled'，则以上两种绑定都会给元素添加一个`disabled`类名。\n使用后者时需要注意`class`一定要加上引号，否则在 IE8 中报错。\n\n### 6.3 jQuery.fn.data 的缓存\n\n在`jQuery`中，`jQuery.fn.data`方法是有缓存的，如果要获取正确的结果，必须通过`jQuery.fn.data`进行设置`data`属性，而不使用原生方法`HTMLElement.prototype.getAttribute`。\n\n```html\n<!-- 分页器中的页面跳转链接 -->\n<span data-bind=\"click:goToPage,attr:{'data-page':page()-1}\">上一页</span>\n```\n\n```js\nthis.page = ko.observable(0);\nthis.goToPage = function(model, e) {\n    //错误，因为缓存问题，导致第二次获取页面时出错。\n    var page = $(e.target).data('page');\n    //正确\n    var page = e.target.getAttribute('data-page');\n};\n```\n\n### 6.4 坑爹的性能问题\n\n![是否停止运行此脚本图片](http://my.csdn.net/uploads/201207/17/1342531216_2338.jpg)\n\nKnockout 的模板是基于 DOM 的，遇到循环就会通过原生的 clone 方法复制出若干个 DOM 片段，这个方法性能很差，当复制的 DOM 节点数达到一定程度，就会变得很慢，尤其在 IE8 中，收藏夹中渲染专利列表时就遇到了这种问题，在 IE8 甚至出现了“是否停止运行此脚本对话框”。\n由于该问题是在测试阶段发现的，没有时间进行大的修改。但是 IE8 中的对话框又是不能接受的，所以改为首次渲染前 25 条（如果有的话）专利，异步等 100 毫秒之后再渲染后 25 条（如果有的话）专利。这样，所有专利渲染出来的时间虽然延长了一点，但是保证了不会弹出让人费解的对话框，并且对用户体验基本没有更坏的影响。\n\n## 7. 参考链接\n\n1. [Knockout 官网](http://knockoutjs.com/index.html)\n1. [MVC，MVP 和 MVVM 的图示](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)\n","slug":"knockout","published":1,"date":"2015-09-05T16:00:00.000Z","updated":"2018-12-07T02:46:53.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmal001jw8wkksvhduoo","content":"<h2 id=\"1-MVVM-的概念\"><a href=\"#1-MVVM-的概念\" class=\"headerlink\" title=\"1. MVVM 的概念\"></a>1. MVVM 的概念</h2><h3 id=\"1-1-MVVM-的概念\"><a href=\"#1-1-MVVM-的概念\" class=\"headerlink\" title=\"1.1 MVVM 的概念\"></a>1.1 MVVM 的概念</h3><p>MVC 模型示意图<br><img src=\"http://image.beekka.com/blog/2015/bg2015020105.png\" alt=\"MVC 模型示意图\"></p>\n<p>MVVM 模型示意图<br><img src=\"http://image.beekka.com/blog/2015/bg2015020110.png\" alt=\"MVVM 模型示意图\"></p>\n<h3 id=\"1-2-双向绑定的概念\"><a href=\"#1-2-双向绑定的概念\" class=\"headerlink\" title=\"1.2 双向绑定的概念\"></a>1.2 双向绑定的概念</h3><p>页面中每次状态的变化，一般都伴随着多次 DOM 操作，每次 DOM 操作一般都需要先找到该输入框元素，然后修改其相应属性，即便后来有了<code>jQuery</code>这种 DOM 操作神器，仍然非常繁琐。随着前端逻辑的日益复杂，前端越来越难以维护。此时双向绑定应运而生了。</p>\n<p>双向绑定，简单地说，就是模型（数据）和 DOM 自动保持同步，模型变化了，会自动更新 DOM，用户操作了 DOM，会自动更新更新模型，并且触发相应事件。这样一来，我们只需要更新模型，以及监听模型变化就可以了，不再像以前一边更新模型，一边进行 DOM 操作了。</p>\n<h2 id=\"2-Knockout-的简介\"><a href=\"#2-Knockout-的简介\" class=\"headerlink\" title=\"2. Knockout 的简介\"></a>2. Knockout 的简介</h2><p><a href=\"http://knockoutjs.com/\" target=\"_blank\" rel=\"noopener\">Knockout</a>是一个可以轻松实现双向绑定的库。它有以下特性：</p>\n<h3 id=\"2-1-模型和-DOM-双向绑定\"><a href=\"#2-1-模型和-DOM-双向绑定\" class=\"headerlink\" title=\"2.1 模型和 DOM 双向绑定\"></a>2.1 模型和 DOM 双向绑定</h3><p>这点不需要多作说明，这就是 Knockout 最大的意义所在。</p>\n<h3 id=\"2-2-声明式绑定\"><a href=\"#2-2-声明式绑定\" class=\"headerlink\" title=\"2.2. 声明式绑定\"></a>2.2. 声明式绑定</h3><p>使用简明易读的自定义属性<code>data-bind</code>将模型字段关联到 DOM 元素上。比如以下代码就将输入框和模型中的 name 关联起来。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"value:name\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-依赖跟踪\"><a href=\"#2-3-依赖跟踪\" class=\"headerlink\" title=\"2.3 依赖跟踪\"></a>2.3 依赖跟踪</h3><p>对于通过组合或转换而来的数据，保持其依赖链。请看如下例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ViewModel</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstName = ko.observable(<span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastName = ko.observable(<span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"comment\">//声明 fullName 是由 firstName 和 lastName计算出来的</span></span><br><span class=\"line\">    <span class=\"comment\">//当 firstName 和 lastName 其一发生变化时，fullName都会自动重新计算</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fullName = ko.computed(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName() + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName();</span><br><span class=\"line\">    &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-模板\"><a href=\"#2-4-模板\" class=\"headerlink\" title=\"2.4 模板\"></a>2.4 模板</h3><pre><code>也不用多解释，与模型关联的DOM就是一个模板。\n</code></pre><h3 id=\"2-5-其他一些特点\"><a href=\"#2-5-其他一些特点\" class=\"headerlink\" title=\"2.5 其他一些特点\"></a>2.5 其他一些特点</h3><pre><code>轻量（库，不是框架，侵入性低，很容和其他框架和库一起使用），全浏览器支持（包括IE6），没有依赖，免费（这是必须的）。\n</code></pre><h2 id=\"3-简单入门\"><a href=\"#3-简单入门\" class=\"headerlink\" title=\"3. 简单入门\"></a>3. 简单入门</h2><h3 id=\"3-1-Bindings\"><a href=\"#3-1-Bindings\" class=\"headerlink\" title=\"3.1 Bindings\"></a>3.1 Bindings</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-dom</span><br><span class=\"line\">    |-visible---------------elem.style.display</span><br><span class=\"line\">    |-text------------------elem.innerText</span><br><span class=\"line\">    |-html------------------elem.innerHTML</span><br><span class=\"line\">    |-css-------------------elem.className</span><br><span class=\"line\">    |-style-----------------elem.style</span><br><span class=\"line\">    |-attr------------------elem.setAttribute</span><br><span class=\"line\">-flow</span><br><span class=\"line\">    |-foreach</span><br><span class=\"line\">    |-if/ifnot</span><br><span class=\"line\">    |-with</span><br><span class=\"line\">    |-component-------------自定义组件</span><br><span class=\"line\">-form</span><br><span class=\"line\">    |-click</span><br><span class=\"line\">    |-submit</span><br><span class=\"line\">    |-event-----------------用法：event:&#123;keydown:onKeyDown&#125;</span><br><span class=\"line\">    |-enable/disable--------elem.disabled</span><br><span class=\"line\">    |-value-----------------elem.value</span><br><span class=\"line\">    |-textInput-------------elem.value(输入框值变化，model立即更新)</span><br><span class=\"line\">    |-hasFocus--------------elem.focus()</span><br><span class=\"line\">    |-checked---------------elem.checked</span><br><span class=\"line\">    |-options---------------select的选项</span><br><span class=\"line\">    |-selectedOptions-------select的选中选项</span><br><span class=\"line\">    |-uniqueName------------如果:input 没有 name，则生成唯一的name。</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-官网链接\"><a href=\"#3-2-官网链接\" class=\"headerlink\" title=\"3.2 官网链接\"></a>3.2 官网链接</h3><p>官网示例<a href=\"http://knockoutjs.com/examples/\" target=\"_blank\" rel=\"noopener\">链接</a>。<br>系统自带绑定<a href=\"http://knockoutjs.com/documentation/introduction.html\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"4-高级进阶\"><a href=\"#4-高级进阶\" class=\"headerlink\" title=\"4. 高级进阶\"></a>4. 高级进阶</h2><h3 id=\"4-1-创建自定义绑定\"><a href=\"#4-1-创建自定义绑定\" class=\"headerlink\" title=\"4.1 创建自定义绑定\"></a>4.1 创建自定义绑定</h3><p>使用方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"textInput:query\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"preview:query\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>创建方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ko.bindingHandlers.preview = &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, valueAccessor, allBindings, viewModel, bindingContext</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> query = ko.utils.unwrapObservable(valueAccessor());</span><br><span class=\"line\">        <span class=\"comment\">//做一些初始化工作，比如事件绑定。</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    update: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, valueAccessor, allBindings, viewModel, bindingContext</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这一行如果不加的话，query发生变化时，该方法不会被调用。</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> query = ko.utils.unwrapObservable(valueAccessor());</span><br><span class=\"line\">        <span class=\"comment\">//当query发生变化时，要做什么处理。</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>详细参考：<a href=\"http://code.patsnap.com/js/zhihuiya-static/blob/master/javascript/libs/knockout/knockout-preview.js\" target=\"_blank\" rel=\"noopener\">knockout-preview.js</a></p>\n<h3 id=\"4-2-创建自定义组件\"><a href=\"#4-2-创建自定义组件\" class=\"headerlink\" title=\"4.2 创建自定义组件\"></a>4.2 创建自定义组件</h3><p>使用方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ko component:&#123;name:\"ko-dropmenu\",params:&#123;name:\"agl-search-order\",items:sorts&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span><span class=\"comment\">&lt;!-- /ko --&gt;</span></span><br></pre></td></tr></table></figure>\n<p>创建方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ko.components.register(<span class=\"string\">'ko-dropmenu'</span>, &#123;</span><br><span class=\"line\">    viewModel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">params</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = ko.observable(params.name);</span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    template: <span class=\"string\">'&lt;div data-bind=\"attr:&#123;name:name&#125;\"&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>\n<p>详细参考：<a href=\"http://code.patsnap.com/js/zhihuiya-static/blob/master/javascript/libs/knockout/knockout-dropmenu.js\" target=\"_blank\" rel=\"noopener\">knockout-dropmenu.js</a></p>\n<h3 id=\"4-3-computed-和-pureComputed\"><a href=\"#4-3-computed-和-pureComputed\" class=\"headerlink\" title=\"4.3 computed 和 pureComputed\"></a>4.3 computed 和 pureComputed</h3><p><code>computed</code>和<code>pureComputed</code>均表示该字段是由其他一个或多个字段转化而来，其区别在于<code>pureComputed</code>会做一些优化，比如当前字段并没有显示在页面上时，该字段并不会被计算，当该字段显示时，才开始计算。</p>\n<h2 id=\"5-最佳实践\"><a href=\"#5-最佳实践\" class=\"headerlink\" title=\"5. 最佳实践\"></a>5. 最佳实践</h2><h3 id=\"5-1-label-gt-radio-checkbox\"><a href=\"#5-1-label-gt-radio-checkbox\" class=\"headerlink\" title=\"5.1 label&gt;radio/checkbox\"></a>5.1 <code>label&gt;radio/checkbox</code></h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"visible:status==='show'\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data</span>=<span class=\"string\">bind</span>=<span class=\"string\">\"text:name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"edit\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"checked:status\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>编辑<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"visible:status==='edit'\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"value:name\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"show\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"checked:status\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>保存<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-模型数据合理分块\"><a href=\"#5-2-模型数据合理分块\" class=\"headerlink\" title=\"5.2 模型数据合理分块\"></a>5.2 模型数据合理分块</h3><p>当模型数据变化了以后，跟这些数据相关的 DOM 都会重新渲染，所以模型数据需要尽可能做到动静分离。<br>以收藏夹页面专利列表的详情模式为例，选中一个收藏夹，首先获取该收藏夹第一页的 50 条专利并渲染，然后再获取这 50 条专利的缩略图和 PDF 地址并渲染，用户可以选择全部选中和全部反选，也可以选择部分，然后标记为已读或未读。<br>如果将缩略图和 PDF 地址，是否选中，是否已读等字段作为专利数据的一部分，那么必然将造成多次专利列表的重新渲染。<br>一种可行的做法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.patents = ko.observableArray([]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.selected = ko.observableArray([]);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.isAllSelected = ko.pureComputed(&#123;</span><br><span class=\"line\">    read: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    write: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    owner: <span class=\"keyword\">this</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.readMap = ko.observable(&#123;&#125;);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.thumbMap = ko.observable(&#123;&#125;);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.pdfMap = ko.observable(&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-3-全选\"><a href=\"#5-3-全选\" class=\"headerlink\" title=\"5.3 全选\"></a>5.3 全选</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"checked:isAllSelected\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"foreach:patents\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"value:$data.PN,checked:$parent.selected\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.selected = ko.observableArray([]);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.isAllSelected = ko.pureComputed(&#123;</span><br><span class=\"line\">    read: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.selected().length === <span class=\"keyword\">this</span>.patents().length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    write: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">checked</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> selected = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果全部选中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checked) &#123;</span><br><span class=\"line\">            selected = _.map(<span class=\"keyword\">this</span>.patents(), <span class=\"string\">'PN'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果全部反选</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            selected = [];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.selected(selected);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    owner: <span class=\"keyword\">this</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-4-ViewModel-的重复利用\"><a href=\"#5-4-ViewModel-的重复利用\" class=\"headerlink\" title=\"5.4 ViewModel 的重复利用\"></a>5.4 ViewModel 的重复利用</h3><p>如果两个 ViewModel 都需要拥有一些相同的数据，我们当然可以通过<code>pubsub</code>事件模型来同步，但是这样可能导致 ViewModel 中导出都是同步逻辑，他们没有任何业务价值，并且影响后来维护者理解这段代码。有什么方法解决这个问题吗？答案是肯定的，请看一下代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userViewModel = &#123;</span><br><span class=\"line\">    user: ko.observable(&#123;&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> model1 = &#123;</span><br><span class=\"line\">    user: userViewModel</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> model2 = &#123;</span><br><span class=\"line\">    user: userViewModel</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在以上这段代码中，<code>model1</code>和<code>model2</code>中拥有同一份<code>user</code>数据，自然是自动同步的。</p>\n<h2 id=\"6-踩过的坑\"><a href=\"#6-踩过的坑\" class=\"headerlink\" title=\"6. 踩过的坑\"></a>6. 踩过的坑</h2><h3 id=\"6-1-声明绑定时忘记带括号\"><a href=\"#6-1-声明绑定时忘记带括号\" class=\"headerlink\" title=\"6.1 声明绑定时忘记带括号\"></a>6.1 声明绑定时忘记带括号</h3><p>如果直接绑定字段，才可以省略括号，如果是表达式，则必须带括号，这点初学者很容易犯错，建议所有的绑定都带括号。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.index = ko.observable(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 正确，绑定单个字段可以不带括号 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"text:index\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 正确，绑定单个字段带括号也是对的 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"text:index()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 错误，绑定表达式时必须带括号 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"text:'NO.:' + index\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 正确，绑定表达式时必须带括号 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"text:'NO.:' + index()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-Class-属性的绑定\"><a href=\"#6-2-Class-属性的绑定\" class=\"headerlink\" title=\"6.2 Class 属性的绑定\"></a>6.2 Class 属性的绑定</h3><p>Class 绑定方法有两种：<br>css</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"css:&#123;disabled:status()==='disabled'&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>class</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"attr:&#123;'class':status&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>假设 ViewModel 中 status 的值为 ‘disabled’，则以上两种绑定都会给元素添加一个<code>disabled</code>类名。<br>使用后者时需要注意<code>class</code>一定要加上引号，否则在 IE8 中报错。</p>\n<h3 id=\"6-3-jQuery-fn-data-的缓存\"><a href=\"#6-3-jQuery-fn-data-的缓存\" class=\"headerlink\" title=\"6.3 jQuery.fn.data 的缓存\"></a>6.3 jQuery.fn.data 的缓存</h3><p>在<code>jQuery</code>中，<code>jQuery.fn.data</code>方法是有缓存的，如果要获取正确的结果，必须通过<code>jQuery.fn.data</code>进行设置<code>data</code>属性，而不使用原生方法<code>HTMLElement.prototype.getAttribute</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 分页器中的页面跳转链接 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"click:goToPage,attr:&#123;'data-page':page()-1&#125;\"</span>&gt;</span>上一页<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.page = ko.observable(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.goToPage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model, e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//错误，因为缓存问题，导致第二次获取页面时出错。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> page = $(e.target).data(<span class=\"string\">'page'</span>);</span><br><span class=\"line\">    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> page = e.target.getAttribute(<span class=\"string\">'data-page'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-4-坑爹的性能问题\"><a href=\"#6-4-坑爹的性能问题\" class=\"headerlink\" title=\"6.4 坑爹的性能问题\"></a>6.4 坑爹的性能问题</h3><p><img src=\"http://my.csdn.net/uploads/201207/17/1342531216_2338.jpg\" alt=\"是否停止运行此脚本图片\"></p>\n<p>Knockout 的模板是基于 DOM 的，遇到循环就会通过原生的 clone 方法复制出若干个 DOM 片段，这个方法性能很差，当复制的 DOM 节点数达到一定程度，就会变得很慢，尤其在 IE8 中，收藏夹中渲染专利列表时就遇到了这种问题，在 IE8 甚至出现了“是否停止运行此脚本对话框”。<br>由于该问题是在测试阶段发现的，没有时间进行大的修改。但是 IE8 中的对话框又是不能接受的，所以改为首次渲染前 25 条（如果有的话）专利，异步等 100 毫秒之后再渲染后 25 条（如果有的话）专利。这样，所有专利渲染出来的时间虽然延长了一点，但是保证了不会弹出让人费解的对话框，并且对用户体验基本没有更坏的影响。</p>\n<h2 id=\"7-参考链接\"><a href=\"#7-参考链接\" class=\"headerlink\" title=\"7. 参考链接\"></a>7. 参考链接</h2><ol>\n<li><a href=\"http://knockoutjs.com/index.html\" target=\"_blank\" rel=\"noopener\">Knockout 官网</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\" target=\"_blank\" rel=\"noopener\">MVC，MVP 和 MVVM 的图示</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-MVVM-的概念\"><a href=\"#1-MVVM-的概念\" class=\"headerlink\" title=\"1. MVVM 的概念\"></a>1. MVVM 的概念</h2><h3 id=\"1-1-MVVM-的概念\"><a href=\"#1-1-MVVM-的概念\" class=\"headerlink\" title=\"1.1 MVVM 的概念\"></a>1.1 MVVM 的概念</h3><p>MVC 模型示意图<br><img src=\"http://image.beekka.com/blog/2015/bg2015020105.png\" alt=\"MVC 模型示意图\"></p>\n<p>MVVM 模型示意图<br><img src=\"http://image.beekka.com/blog/2015/bg2015020110.png\" alt=\"MVVM 模型示意图\"></p>\n<h3 id=\"1-2-双向绑定的概念\"><a href=\"#1-2-双向绑定的概念\" class=\"headerlink\" title=\"1.2 双向绑定的概念\"></a>1.2 双向绑定的概念</h3><p>页面中每次状态的变化，一般都伴随着多次 DOM 操作，每次 DOM 操作一般都需要先找到该输入框元素，然后修改其相应属性，即便后来有了<code>jQuery</code>这种 DOM 操作神器，仍然非常繁琐。随着前端逻辑的日益复杂，前端越来越难以维护。此时双向绑定应运而生了。</p>\n<p>双向绑定，简单地说，就是模型（数据）和 DOM 自动保持同步，模型变化了，会自动更新 DOM，用户操作了 DOM，会自动更新更新模型，并且触发相应事件。这样一来，我们只需要更新模型，以及监听模型变化就可以了，不再像以前一边更新模型，一边进行 DOM 操作了。</p>\n<h2 id=\"2-Knockout-的简介\"><a href=\"#2-Knockout-的简介\" class=\"headerlink\" title=\"2. Knockout 的简介\"></a>2. Knockout 的简介</h2><p><a href=\"http://knockoutjs.com/\" target=\"_blank\" rel=\"noopener\">Knockout</a>是一个可以轻松实现双向绑定的库。它有以下特性：</p>\n<h3 id=\"2-1-模型和-DOM-双向绑定\"><a href=\"#2-1-模型和-DOM-双向绑定\" class=\"headerlink\" title=\"2.1 模型和 DOM 双向绑定\"></a>2.1 模型和 DOM 双向绑定</h3><p>这点不需要多作说明，这就是 Knockout 最大的意义所在。</p>\n<h3 id=\"2-2-声明式绑定\"><a href=\"#2-2-声明式绑定\" class=\"headerlink\" title=\"2.2. 声明式绑定\"></a>2.2. 声明式绑定</h3><p>使用简明易读的自定义属性<code>data-bind</code>将模型字段关联到 DOM 元素上。比如以下代码就将输入框和模型中的 name 关联起来。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"value:name\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-依赖跟踪\"><a href=\"#2-3-依赖跟踪\" class=\"headerlink\" title=\"2.3 依赖跟踪\"></a>2.3 依赖跟踪</h3><p>对于通过组合或转换而来的数据，保持其依赖链。请看如下例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ViewModel</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstName = ko.observable(<span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.lastName = ko.observable(<span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"comment\">//声明 fullName 是由 firstName 和 lastName计算出来的</span></span><br><span class=\"line\">    <span class=\"comment\">//当 firstName 和 lastName 其一发生变化时，fullName都会自动重新计算</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fullName = ko.computed(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstName() + <span class=\"string\">' '</span> + <span class=\"keyword\">this</span>.lastName();</span><br><span class=\"line\">    &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-模板\"><a href=\"#2-4-模板\" class=\"headerlink\" title=\"2.4 模板\"></a>2.4 模板</h3><pre><code>也不用多解释，与模型关联的DOM就是一个模板。\n</code></pre><h3 id=\"2-5-其他一些特点\"><a href=\"#2-5-其他一些特点\" class=\"headerlink\" title=\"2.5 其他一些特点\"></a>2.5 其他一些特点</h3><pre><code>轻量（库，不是框架，侵入性低，很容和其他框架和库一起使用），全浏览器支持（包括IE6），没有依赖，免费（这是必须的）。\n</code></pre><h2 id=\"3-简单入门\"><a href=\"#3-简单入门\" class=\"headerlink\" title=\"3. 简单入门\"></a>3. 简单入门</h2><h3 id=\"3-1-Bindings\"><a href=\"#3-1-Bindings\" class=\"headerlink\" title=\"3.1 Bindings\"></a>3.1 Bindings</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-dom</span><br><span class=\"line\">    |-visible---------------elem.style.display</span><br><span class=\"line\">    |-text------------------elem.innerText</span><br><span class=\"line\">    |-html------------------elem.innerHTML</span><br><span class=\"line\">    |-css-------------------elem.className</span><br><span class=\"line\">    |-style-----------------elem.style</span><br><span class=\"line\">    |-attr------------------elem.setAttribute</span><br><span class=\"line\">-flow</span><br><span class=\"line\">    |-foreach</span><br><span class=\"line\">    |-if/ifnot</span><br><span class=\"line\">    |-with</span><br><span class=\"line\">    |-component-------------自定义组件</span><br><span class=\"line\">-form</span><br><span class=\"line\">    |-click</span><br><span class=\"line\">    |-submit</span><br><span class=\"line\">    |-event-----------------用法：event:&#123;keydown:onKeyDown&#125;</span><br><span class=\"line\">    |-enable/disable--------elem.disabled</span><br><span class=\"line\">    |-value-----------------elem.value</span><br><span class=\"line\">    |-textInput-------------elem.value(输入框值变化，model立即更新)</span><br><span class=\"line\">    |-hasFocus--------------elem.focus()</span><br><span class=\"line\">    |-checked---------------elem.checked</span><br><span class=\"line\">    |-options---------------select的选项</span><br><span class=\"line\">    |-selectedOptions-------select的选中选项</span><br><span class=\"line\">    |-uniqueName------------如果:input 没有 name，则生成唯一的name。</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-官网链接\"><a href=\"#3-2-官网链接\" class=\"headerlink\" title=\"3.2 官网链接\"></a>3.2 官网链接</h3><p>官网示例<a href=\"http://knockoutjs.com/examples/\" target=\"_blank\" rel=\"noopener\">链接</a>。<br>系统自带绑定<a href=\"http://knockoutjs.com/documentation/introduction.html\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"4-高级进阶\"><a href=\"#4-高级进阶\" class=\"headerlink\" title=\"4. 高级进阶\"></a>4. 高级进阶</h2><h3 id=\"4-1-创建自定义绑定\"><a href=\"#4-1-创建自定义绑定\" class=\"headerlink\" title=\"4.1 创建自定义绑定\"></a>4.1 创建自定义绑定</h3><p>使用方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">textarea</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"textInput:query\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"preview:query\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>创建方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ko.bindingHandlers.preview = &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, valueAccessor, allBindings, viewModel, bindingContext</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> query = ko.utils.unwrapObservable(valueAccessor());</span><br><span class=\"line\">        <span class=\"comment\">//做一些初始化工作，比如事件绑定。</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    update: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element, valueAccessor, allBindings, viewModel, bindingContext</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//这一行如果不加的话，query发生变化时，该方法不会被调用。</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> query = ko.utils.unwrapObservable(valueAccessor());</span><br><span class=\"line\">        <span class=\"comment\">//当query发生变化时，要做什么处理。</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>详细参考：<a href=\"http://code.patsnap.com/js/zhihuiya-static/blob/master/javascript/libs/knockout/knockout-preview.js\" target=\"_blank\" rel=\"noopener\">knockout-preview.js</a></p>\n<h3 id=\"4-2-创建自定义组件\"><a href=\"#4-2-创建自定义组件\" class=\"headerlink\" title=\"4.2 创建自定义组件\"></a>4.2 创建自定义组件</h3><p>使用方法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- ko component:&#123;name:\"ko-dropmenu\",params:&#123;name:\"agl-search-order\",items:sorts&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span><span class=\"comment\">&lt;!-- /ko --&gt;</span></span><br></pre></td></tr></table></figure>\n<p>创建方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ko.components.register(<span class=\"string\">'ko-dropmenu'</span>, &#123;</span><br><span class=\"line\">    viewModel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">params</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = ko.observable(params.name);</span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    template: <span class=\"string\">'&lt;div data-bind=\"attr:&#123;name:name&#125;\"&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>\n<p>详细参考：<a href=\"http://code.patsnap.com/js/zhihuiya-static/blob/master/javascript/libs/knockout/knockout-dropmenu.js\" target=\"_blank\" rel=\"noopener\">knockout-dropmenu.js</a></p>\n<h3 id=\"4-3-computed-和-pureComputed\"><a href=\"#4-3-computed-和-pureComputed\" class=\"headerlink\" title=\"4.3 computed 和 pureComputed\"></a>4.3 computed 和 pureComputed</h3><p><code>computed</code>和<code>pureComputed</code>均表示该字段是由其他一个或多个字段转化而来，其区别在于<code>pureComputed</code>会做一些优化，比如当前字段并没有显示在页面上时，该字段并不会被计算，当该字段显示时，才开始计算。</p>\n<h2 id=\"5-最佳实践\"><a href=\"#5-最佳实践\" class=\"headerlink\" title=\"5. 最佳实践\"></a>5. 最佳实践</h2><h3 id=\"5-1-label-gt-radio-checkbox\"><a href=\"#5-1-label-gt-radio-checkbox\" class=\"headerlink\" title=\"5.1 label&gt;radio/checkbox\"></a>5.1 <code>label&gt;radio/checkbox</code></h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"visible:status==='show'\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data</span>=<span class=\"string\">bind</span>=<span class=\"string\">\"text:name\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"edit\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"checked:status\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>编辑<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"visible:status==='edit'\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"value:name\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"show\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"checked:status\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>保存<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-2-模型数据合理分块\"><a href=\"#5-2-模型数据合理分块\" class=\"headerlink\" title=\"5.2 模型数据合理分块\"></a>5.2 模型数据合理分块</h3><p>当模型数据变化了以后，跟这些数据相关的 DOM 都会重新渲染，所以模型数据需要尽可能做到动静分离。<br>以收藏夹页面专利列表的详情模式为例，选中一个收藏夹，首先获取该收藏夹第一页的 50 条专利并渲染，然后再获取这 50 条专利的缩略图和 PDF 地址并渲染，用户可以选择全部选中和全部反选，也可以选择部分，然后标记为已读或未读。<br>如果将缩略图和 PDF 地址，是否选中，是否已读等字段作为专利数据的一部分，那么必然将造成多次专利列表的重新渲染。<br>一种可行的做法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.patents = ko.observableArray([]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.selected = ko.observableArray([]);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.isAllSelected = ko.pureComputed(&#123;</span><br><span class=\"line\">    read: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    write: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    owner: <span class=\"keyword\">this</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">this</span>.readMap = ko.observable(&#123;&#125;);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.thumbMap = ko.observable(&#123;&#125;);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.pdfMap = ko.observable(&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-3-全选\"><a href=\"#5-3-全选\" class=\"headerlink\" title=\"5.3 全选\"></a>5.3 全选</h3><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"checked:isAllSelected\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"foreach:patents\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"value:$data.PN,checked:$parent.selected\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.selected = ko.observableArray([]);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.isAllSelected = ko.pureComputed(&#123;</span><br><span class=\"line\">    read: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.selected().length === <span class=\"keyword\">this</span>.patents().length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    write: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">checked</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> selected = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果全部选中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (checked) &#123;</span><br><span class=\"line\">            selected = _.map(<span class=\"keyword\">this</span>.patents(), <span class=\"string\">'PN'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果全部反选</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            selected = [];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.selected(selected);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    owner: <span class=\"keyword\">this</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-4-ViewModel-的重复利用\"><a href=\"#5-4-ViewModel-的重复利用\" class=\"headerlink\" title=\"5.4 ViewModel 的重复利用\"></a>5.4 ViewModel 的重复利用</h3><p>如果两个 ViewModel 都需要拥有一些相同的数据，我们当然可以通过<code>pubsub</code>事件模型来同步，但是这样可能导致 ViewModel 中导出都是同步逻辑，他们没有任何业务价值，并且影响后来维护者理解这段代码。有什么方法解决这个问题吗？答案是肯定的，请看一下代码。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userViewModel = &#123;</span><br><span class=\"line\">    user: ko.observable(&#123;&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> model1 = &#123;</span><br><span class=\"line\">    user: userViewModel</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> model2 = &#123;</span><br><span class=\"line\">    user: userViewModel</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在以上这段代码中，<code>model1</code>和<code>model2</code>中拥有同一份<code>user</code>数据，自然是自动同步的。</p>\n<h2 id=\"6-踩过的坑\"><a href=\"#6-踩过的坑\" class=\"headerlink\" title=\"6. 踩过的坑\"></a>6. 踩过的坑</h2><h3 id=\"6-1-声明绑定时忘记带括号\"><a href=\"#6-1-声明绑定时忘记带括号\" class=\"headerlink\" title=\"6.1 声明绑定时忘记带括号\"></a>6.1 声明绑定时忘记带括号</h3><p>如果直接绑定字段，才可以省略括号，如果是表达式，则必须带括号，这点初学者很容易犯错，建议所有的绑定都带括号。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.index = ko.observable(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 正确，绑定单个字段可以不带括号 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"text:index\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 正确，绑定单个字段带括号也是对的 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"text:index()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 错误，绑定表达式时必须带括号 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"text:'NO.:' + index\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 正确，绑定表达式时必须带括号 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"text:'NO.:' + index()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-Class-属性的绑定\"><a href=\"#6-2-Class-属性的绑定\" class=\"headerlink\" title=\"6.2 Class 属性的绑定\"></a>6.2 Class 属性的绑定</h3><p>Class 绑定方法有两种：<br>css</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"css:&#123;disabled:status()==='disabled'&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>class</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"attr:&#123;'class':status&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>假设 ViewModel 中 status 的值为 ‘disabled’，则以上两种绑定都会给元素添加一个<code>disabled</code>类名。<br>使用后者时需要注意<code>class</code>一定要加上引号，否则在 IE8 中报错。</p>\n<h3 id=\"6-3-jQuery-fn-data-的缓存\"><a href=\"#6-3-jQuery-fn-data-的缓存\" class=\"headerlink\" title=\"6.3 jQuery.fn.data 的缓存\"></a>6.3 jQuery.fn.data 的缓存</h3><p>在<code>jQuery</code>中，<code>jQuery.fn.data</code>方法是有缓存的，如果要获取正确的结果，必须通过<code>jQuery.fn.data</code>进行设置<code>data</code>属性，而不使用原生方法<code>HTMLElement.prototype.getAttribute</code>。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 分页器中的页面跳转链接 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-bind</span>=<span class=\"string\">\"click:goToPage,attr:&#123;'data-page':page()-1&#125;\"</span>&gt;</span>上一页<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.page = ko.observable(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">this</span>.goToPage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">model, e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//错误，因为缓存问题，导致第二次获取页面时出错。</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> page = $(e.target).data(<span class=\"string\">'page'</span>);</span><br><span class=\"line\">    <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> page = e.target.getAttribute(<span class=\"string\">'data-page'</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-4-坑爹的性能问题\"><a href=\"#6-4-坑爹的性能问题\" class=\"headerlink\" title=\"6.4 坑爹的性能问题\"></a>6.4 坑爹的性能问题</h3><p><img src=\"http://my.csdn.net/uploads/201207/17/1342531216_2338.jpg\" alt=\"是否停止运行此脚本图片\"></p>\n<p>Knockout 的模板是基于 DOM 的，遇到循环就会通过原生的 clone 方法复制出若干个 DOM 片段，这个方法性能很差，当复制的 DOM 节点数达到一定程度，就会变得很慢，尤其在 IE8 中，收藏夹中渲染专利列表时就遇到了这种问题，在 IE8 甚至出现了“是否停止运行此脚本对话框”。<br>由于该问题是在测试阶段发现的，没有时间进行大的修改。但是 IE8 中的对话框又是不能接受的，所以改为首次渲染前 25 条（如果有的话）专利，异步等 100 毫秒之后再渲染后 25 条（如果有的话）专利。这样，所有专利渲染出来的时间虽然延长了一点，但是保证了不会弹出让人费解的对话框，并且对用户体验基本没有更坏的影响。</p>\n<h2 id=\"7-参考链接\"><a href=\"#7-参考链接\" class=\"headerlink\" title=\"7. 参考链接\"></a>7. 参考链接</h2><ol>\n<li><a href=\"http://knockoutjs.com/index.html\" target=\"_blank\" rel=\"noopener\">Knockout 官网</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html\" target=\"_blank\" rel=\"noopener\">MVC，MVP 和 MVVM 的图示</a></li>\n</ol>\n"},{"title":"Chrome 开发者工具 - 设备模式","_content":"\n使用 Chrome 开发者工具的设备模式可以大大减低开发移动优先响应式网站的难度，下面我们开始学习如何使用它模拟各种设备以及开发完全响应式的网站。\n\n**概述**\n\n-   使用设备模式的屏幕模拟器测试网站的响应式特性\n-   自动保存设置，方便你以后继续使用。\n-   设备模式不能代替真实设备，请熟知它的局限性。\n\n## 1 打开设备模式\n\n![device-mode-initial-view.png-101.8kB][1]\n通过切换“设备模式”按钮或者使用快捷键`Command+Shift+M (Mac)`或`Ctrl+Shift+M (Windows, Linux)`\n\n## 2 `viewport`控制器\n\n![device-mode.png-30.8kB][2]\n`viewport`控制器共有两种模式：\n**完全响应式**：自由地改变`viewport`尺寸。\n**特定的设备**：模拟设备`viewport`尺寸和设备特性。\n\n### 2.1 完全响应式\n\n我们推荐你将完全响应式模式作为你的默认模式，在开发过程中，使用它频繁调整`viewport`的尺寸来实现一个完全的响应式设计来适配未知或未来的设备类型。\n你可以拖拽调整大小的手柄或单击菜单栏中值进行细粒度的控制。\n也可以直接选择`Mobile S - 320px`, `Mobile M - 375px`, `Mobile L - 425px`, `Tablet - 768px`, `Laptop - 1024px`, `Laptop L - 1440px`, `4K - 2560px`。\n\n### 2.2 特定的设备\n\n在开发即将结束时，通过使用特定设备模式，可以查看你的网站在特定设备上被渲染成什么模样，比如特定的`iPhone`或`Nexus`。\n\n**内置设备集**\n设备下拉框中已经内置了一组目前最流行的设备，选择了某个设备之后，Chrome 开发者工具就会模拟该设备并模拟网站在该设备上会如何渲染。\n\n-   模拟用户代理（User Agent）\n-   模拟设备分辨率以及 DPI（设备像素比）\n-   模拟触摸事件（如果设备支持的话）\n-   模拟滚动条和`viewport`\n-   对于没有定义`viewport`的页面自动调整文字大小\n\n![select-device.png-19.6kB][3]\n\n**添加自定义设备**\n如果遇到极端情况，需要兼容特殊设备，你也可以添加自定义设备。点击设备列表下面的`Edit ...`选项即可打开以下窗口，你可以勾选更多设备和添加自定义设备。\n![custom-device.png-90.6kB][4]\n\n**设备状态和方向**\n![change-orientation.png-6.8kB][5]\n当模拟特定设备时，设备模式工具栏会出现一个额外的功能，用来切换设备方向横向（landscape）或纵向（portrait）。\n对于某些机型，不仅能切换设备方向，还能模拟特定设备状态。比如对于`Nexus 5X`还可以模拟以下状态：\n\n-   默认的浏览器界面\n-   带有地址栏\n-   键盘处于打开状态\n\n![change-device-state.png-13.5kB][6]\n\n**缩放到合适尺寸**\n有时候你需要测试一个比你浏览器窗口分辨率还大的设备，这时候“缩放”这个选项就非常有用了。适合浏览器窗口（Fit to Window）会自动设置缩放级别以最大程度低利用浏览器空间，而特定的缩放比例可以用来测试 DPI 对图像显示效果的影响等是很有帮助的。\n\n**可选控制项**\n通过单击设备工具栏右侧三个点可以启用和修改可选控制项，目前选项包括：\n\n-   是否显示设备边框\n-   是否显示媒体查询\n-   是否显示刻度尺\n-   设置设备像素比\n-   设置设备类型（移动/桌面，是否支持触摸）\n-   模拟网络状况\n-   截屏\n\n![show-media-queries.png-139.6kB][7]\n\n**显示设备外框**\n只有当你选择了某些设备（比如 iPhone 6）之后才能启用该特性，启用以后你将能够看到页面被放在设备外壳里面。\n![www.google.com-(iPhone 6).png-34.9kB][8]\n\n**显示媒体查询**\n[媒体查询](https://developers.google.com/web/fundamentals/design-and-ui/responsive/fundamentals/use-media-queries)是响应式设计的重要组成部分，通过点击`Show media queries`可以看到媒体查询查看器，该工具会检测你样式中的媒体查询，并在顶部标尺中将其显示成彩色条。\n![media-query-inspector-ruler.png-6.9kB][9]\n\n-   蓝色代表最大宽度`max-width`\n-   绿色代表宽度区间`min-width ~ max-width`\n-   黄色代表最小宽度`min-width`\n\n单击媒体查询条可以调整`viewport`大小来查看样式。\n右击媒体查询条可以在源码中查看该媒体查询的定义。\n![reveal-source-code.png-77.8kB][10]\n\n**显示刻度尺**\n![rule.png-48.2kB][11]\n\n**显示设备像素比**\n如果你想通过非视网膜屏设备模拟视网膜屏设备，或者反过来，那么这个功能就是为你准备的。设备像素比就是逻辑像素和物理像素的比例。视网膜屏设备比如`Nexus 6P`比一般设备的像素密度更高，这会影响视觉内容的清晰度和大小。\n下面这些 Web 上的案例会受到设备像素比的影响：\n\n-   CSS 媒体查询：\n    `@media (-webkit-min-device-pixel-ratio: 2) { ... }`\n-   CSS[`image-set`](http://dev.w3.org/csswg/css-images/# image-set-notation)\n-   `img`的[`srcset`](https://developers.google.com/web/fundamentals/design-and-ui/media/images/images-in-markup)属性\n-   `window.devicePixelRatio`属性\n\n在真正的视网膜屏上，低 DPI（每英寸点数）资源看起来像素化，而高 DPI 的资源看起来很清晰，为了能够在标准的显示器上模拟这中效果，可以将 DPR 设置成 2 并缩放视窗，一个 2X 资源看起来仍然清晰，而 1X 的资源看起来就会像素化。\n\n**设备类型**\n单击`Add device type`，设备工具栏将会出现一个选项“Mobile”，共有以下几个可选值：`Mobile`，`Mobile(not touch)`，`Desktop`，`Desktop(touch)`，修改这项设置将会影响`viewport`，是否模拟触摸事件，用户代理字符串。因此如果你想为左面浏览器创建一个响应式网站并且向测试鼠标悬浮效果，请使用完全响应式模式并将设备类型切换到`Desktop`。\n提示：你还可以在`Network conditions`修改用户代理。\n\n**模拟网络状况**\n单击`Add network throttling`，设备工具栏将会出现一个选项`No throttling`，通过这个选项可以模拟不同网络下页面加载效果。\n![network.throttling.png-71.5kB][12]\n\n## 3 模拟传感器：地理定位和重力感应\n\n大多数台式机都没有 GPS 芯片和重力传感器，因而很难测试，但是 Chrome 开发者工具提供了传感器模拟器使得测试更加容易。\n\n打开方法：\n\n1. 打开开发者工具主菜单\n2. 点击`Customize and control DevTools`- `More tools` - `Sensors`菜单项\n   ![navigate-to-sensors.png-17.9kB][13]\n\n### 3.1 模拟地理定位\n\n移动设备一般使用 GPS 芯片进行定位，在传感器面板中，你可以使用[地理定位 API](http://www.w3.org/TR/geolocation-API/)模拟位置。你可以使用预置的几个城市或手动输入经度纬度，甚至还可以模拟定位失败的情况，这里有一个地理定位 API 的[例子](https://jsfiddle.net/lichangwei/mc0ep3u9/)，可以实验一下。\n![geolocation.png-32.4kB][14]\n\n### 3.2 模拟重力感应（加速度）\n\n![orientation.png-16kB][15]\n在浏览器中打开以下链接实验以下吧。[重力感应代码示例](https://www.ikdoeict.be/apps/leercentrum/courses/ws1-cws-course-materials/demos/06_html5_js/orientation.html)，切换方位看看页面如何变化。\n\n## 4 参考资料\n\n1. [Chrome 开发者工具官方介绍](https://developers.google.com/web/tools/chrome-devtools/)，以上大部分内容来自该文档，部分甚至仅仅做了翻译，强烈推荐大家经常到该网站看看。\n\n[1]: http://static.zybuluo.com/lichangwei/uzwqzy5zn084re2j58aebu2c/device-mode-initial-view.png\n[2]: http://static.zybuluo.com/lichangwei/8u1ihmm4azuhwi4ssb9krruu/device-mode.png\n[3]: http://static.zybuluo.com/lichangwei/e3qyenwnwnyqg3z93k6kcylk/select-device.png\n[4]: http://static.zybuluo.com/lichangwei/1vho3slc17ql6366sjfafxpd/custom-device.png\n[5]: http://static.zybuluo.com/lichangwei/80mo0w30u799t46y9mgv8kvj/change-orientation.png\n[6]: http://static.zybuluo.com/lichangwei/xjk6aez20cl4mvf0fdijci9u/change-device-state.png\n[7]: http://static.zybuluo.com/lichangwei/krz2ci9gli2120g2g2afbrfi/show-media-queries.png\n[8]: http://static.zybuluo.com/lichangwei/akjj90o538yceskczug4lwkr/www.google.com-%28iPhone%206%29.png\n[9]: http://static.zybuluo.com/lichangwei/am40nh3xrcat33n5itno5y3h/media-query-inspector-ruler.png\n[10]: http://static.zybuluo.com/lichangwei/mdadktsfta7e8v5mdgaxcwwi/reveal-source-code.png\n[11]: http://static.zybuluo.com/lichangwei/q12f21enmo6laq9nqhi3mmju/rule.png\n[12]: http://static.zybuluo.com/lichangwei/g9qo71cb23v5g0omwp7hlm7r/network.throttling.png\n[13]: http://static.zybuluo.com/lichangwei/37dklb3tf2etn9t0miuyet6i/navigate-to-sensors.png\n[14]: http://static.zybuluo.com/lichangwei/4p8rz2bqkqfi2no661kz26et/geolocation.png\n[15]: http://static.zybuluo.com/lichangwei/qoclusfnvrctjib2ih1ilfo9/orientation.png\n","source":"_posts/2017-03-03-chrome-developer-tool-device-mode.md","raw":"---\ntitle: Chrome 开发者工具 - 设备模式\n---\n\n使用 Chrome 开发者工具的设备模式可以大大减低开发移动优先响应式网站的难度，下面我们开始学习如何使用它模拟各种设备以及开发完全响应式的网站。\n\n**概述**\n\n-   使用设备模式的屏幕模拟器测试网站的响应式特性\n-   自动保存设置，方便你以后继续使用。\n-   设备模式不能代替真实设备，请熟知它的局限性。\n\n## 1 打开设备模式\n\n![device-mode-initial-view.png-101.8kB][1]\n通过切换“设备模式”按钮或者使用快捷键`Command+Shift+M (Mac)`或`Ctrl+Shift+M (Windows, Linux)`\n\n## 2 `viewport`控制器\n\n![device-mode.png-30.8kB][2]\n`viewport`控制器共有两种模式：\n**完全响应式**：自由地改变`viewport`尺寸。\n**特定的设备**：模拟设备`viewport`尺寸和设备特性。\n\n### 2.1 完全响应式\n\n我们推荐你将完全响应式模式作为你的默认模式，在开发过程中，使用它频繁调整`viewport`的尺寸来实现一个完全的响应式设计来适配未知或未来的设备类型。\n你可以拖拽调整大小的手柄或单击菜单栏中值进行细粒度的控制。\n也可以直接选择`Mobile S - 320px`, `Mobile M - 375px`, `Mobile L - 425px`, `Tablet - 768px`, `Laptop - 1024px`, `Laptop L - 1440px`, `4K - 2560px`。\n\n### 2.2 特定的设备\n\n在开发即将结束时，通过使用特定设备模式，可以查看你的网站在特定设备上被渲染成什么模样，比如特定的`iPhone`或`Nexus`。\n\n**内置设备集**\n设备下拉框中已经内置了一组目前最流行的设备，选择了某个设备之后，Chrome 开发者工具就会模拟该设备并模拟网站在该设备上会如何渲染。\n\n-   模拟用户代理（User Agent）\n-   模拟设备分辨率以及 DPI（设备像素比）\n-   模拟触摸事件（如果设备支持的话）\n-   模拟滚动条和`viewport`\n-   对于没有定义`viewport`的页面自动调整文字大小\n\n![select-device.png-19.6kB][3]\n\n**添加自定义设备**\n如果遇到极端情况，需要兼容特殊设备，你也可以添加自定义设备。点击设备列表下面的`Edit ...`选项即可打开以下窗口，你可以勾选更多设备和添加自定义设备。\n![custom-device.png-90.6kB][4]\n\n**设备状态和方向**\n![change-orientation.png-6.8kB][5]\n当模拟特定设备时，设备模式工具栏会出现一个额外的功能，用来切换设备方向横向（landscape）或纵向（portrait）。\n对于某些机型，不仅能切换设备方向，还能模拟特定设备状态。比如对于`Nexus 5X`还可以模拟以下状态：\n\n-   默认的浏览器界面\n-   带有地址栏\n-   键盘处于打开状态\n\n![change-device-state.png-13.5kB][6]\n\n**缩放到合适尺寸**\n有时候你需要测试一个比你浏览器窗口分辨率还大的设备，这时候“缩放”这个选项就非常有用了。适合浏览器窗口（Fit to Window）会自动设置缩放级别以最大程度低利用浏览器空间，而特定的缩放比例可以用来测试 DPI 对图像显示效果的影响等是很有帮助的。\n\n**可选控制项**\n通过单击设备工具栏右侧三个点可以启用和修改可选控制项，目前选项包括：\n\n-   是否显示设备边框\n-   是否显示媒体查询\n-   是否显示刻度尺\n-   设置设备像素比\n-   设置设备类型（移动/桌面，是否支持触摸）\n-   模拟网络状况\n-   截屏\n\n![show-media-queries.png-139.6kB][7]\n\n**显示设备外框**\n只有当你选择了某些设备（比如 iPhone 6）之后才能启用该特性，启用以后你将能够看到页面被放在设备外壳里面。\n![www.google.com-(iPhone 6).png-34.9kB][8]\n\n**显示媒体查询**\n[媒体查询](https://developers.google.com/web/fundamentals/design-and-ui/responsive/fundamentals/use-media-queries)是响应式设计的重要组成部分，通过点击`Show media queries`可以看到媒体查询查看器，该工具会检测你样式中的媒体查询，并在顶部标尺中将其显示成彩色条。\n![media-query-inspector-ruler.png-6.9kB][9]\n\n-   蓝色代表最大宽度`max-width`\n-   绿色代表宽度区间`min-width ~ max-width`\n-   黄色代表最小宽度`min-width`\n\n单击媒体查询条可以调整`viewport`大小来查看样式。\n右击媒体查询条可以在源码中查看该媒体查询的定义。\n![reveal-source-code.png-77.8kB][10]\n\n**显示刻度尺**\n![rule.png-48.2kB][11]\n\n**显示设备像素比**\n如果你想通过非视网膜屏设备模拟视网膜屏设备，或者反过来，那么这个功能就是为你准备的。设备像素比就是逻辑像素和物理像素的比例。视网膜屏设备比如`Nexus 6P`比一般设备的像素密度更高，这会影响视觉内容的清晰度和大小。\n下面这些 Web 上的案例会受到设备像素比的影响：\n\n-   CSS 媒体查询：\n    `@media (-webkit-min-device-pixel-ratio: 2) { ... }`\n-   CSS[`image-set`](http://dev.w3.org/csswg/css-images/# image-set-notation)\n-   `img`的[`srcset`](https://developers.google.com/web/fundamentals/design-and-ui/media/images/images-in-markup)属性\n-   `window.devicePixelRatio`属性\n\n在真正的视网膜屏上，低 DPI（每英寸点数）资源看起来像素化，而高 DPI 的资源看起来很清晰，为了能够在标准的显示器上模拟这中效果，可以将 DPR 设置成 2 并缩放视窗，一个 2X 资源看起来仍然清晰，而 1X 的资源看起来就会像素化。\n\n**设备类型**\n单击`Add device type`，设备工具栏将会出现一个选项“Mobile”，共有以下几个可选值：`Mobile`，`Mobile(not touch)`，`Desktop`，`Desktop(touch)`，修改这项设置将会影响`viewport`，是否模拟触摸事件，用户代理字符串。因此如果你想为左面浏览器创建一个响应式网站并且向测试鼠标悬浮效果，请使用完全响应式模式并将设备类型切换到`Desktop`。\n提示：你还可以在`Network conditions`修改用户代理。\n\n**模拟网络状况**\n单击`Add network throttling`，设备工具栏将会出现一个选项`No throttling`，通过这个选项可以模拟不同网络下页面加载效果。\n![network.throttling.png-71.5kB][12]\n\n## 3 模拟传感器：地理定位和重力感应\n\n大多数台式机都没有 GPS 芯片和重力传感器，因而很难测试，但是 Chrome 开发者工具提供了传感器模拟器使得测试更加容易。\n\n打开方法：\n\n1. 打开开发者工具主菜单\n2. 点击`Customize and control DevTools`- `More tools` - `Sensors`菜单项\n   ![navigate-to-sensors.png-17.9kB][13]\n\n### 3.1 模拟地理定位\n\n移动设备一般使用 GPS 芯片进行定位，在传感器面板中，你可以使用[地理定位 API](http://www.w3.org/TR/geolocation-API/)模拟位置。你可以使用预置的几个城市或手动输入经度纬度，甚至还可以模拟定位失败的情况，这里有一个地理定位 API 的[例子](https://jsfiddle.net/lichangwei/mc0ep3u9/)，可以实验一下。\n![geolocation.png-32.4kB][14]\n\n### 3.2 模拟重力感应（加速度）\n\n![orientation.png-16kB][15]\n在浏览器中打开以下链接实验以下吧。[重力感应代码示例](https://www.ikdoeict.be/apps/leercentrum/courses/ws1-cws-course-materials/demos/06_html5_js/orientation.html)，切换方位看看页面如何变化。\n\n## 4 参考资料\n\n1. [Chrome 开发者工具官方介绍](https://developers.google.com/web/tools/chrome-devtools/)，以上大部分内容来自该文档，部分甚至仅仅做了翻译，强烈推荐大家经常到该网站看看。\n\n[1]: http://static.zybuluo.com/lichangwei/uzwqzy5zn084re2j58aebu2c/device-mode-initial-view.png\n[2]: http://static.zybuluo.com/lichangwei/8u1ihmm4azuhwi4ssb9krruu/device-mode.png\n[3]: http://static.zybuluo.com/lichangwei/e3qyenwnwnyqg3z93k6kcylk/select-device.png\n[4]: http://static.zybuluo.com/lichangwei/1vho3slc17ql6366sjfafxpd/custom-device.png\n[5]: http://static.zybuluo.com/lichangwei/80mo0w30u799t46y9mgv8kvj/change-orientation.png\n[6]: http://static.zybuluo.com/lichangwei/xjk6aez20cl4mvf0fdijci9u/change-device-state.png\n[7]: http://static.zybuluo.com/lichangwei/krz2ci9gli2120g2g2afbrfi/show-media-queries.png\n[8]: http://static.zybuluo.com/lichangwei/akjj90o538yceskczug4lwkr/www.google.com-%28iPhone%206%29.png\n[9]: http://static.zybuluo.com/lichangwei/am40nh3xrcat33n5itno5y3h/media-query-inspector-ruler.png\n[10]: http://static.zybuluo.com/lichangwei/mdadktsfta7e8v5mdgaxcwwi/reveal-source-code.png\n[11]: http://static.zybuluo.com/lichangwei/q12f21enmo6laq9nqhi3mmju/rule.png\n[12]: http://static.zybuluo.com/lichangwei/g9qo71cb23v5g0omwp7hlm7r/network.throttling.png\n[13]: http://static.zybuluo.com/lichangwei/37dklb3tf2etn9t0miuyet6i/navigate-to-sensors.png\n[14]: http://static.zybuluo.com/lichangwei/4p8rz2bqkqfi2no661kz26et/geolocation.png\n[15]: http://static.zybuluo.com/lichangwei/qoclusfnvrctjib2ih1ilfo9/orientation.png\n","slug":"chrome-developer-tool-device-mode","published":1,"date":"2017-03-02T16:00:00.000Z","updated":"2018-12-07T02:40:36.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmam001kw8wkj4al38fo","content":"<p>使用 Chrome 开发者工具的设备模式可以大大减低开发移动优先响应式网站的难度，下面我们开始学习如何使用它模拟各种设备以及开发完全响应式的网站。</p>\n<p><strong>概述</strong></p>\n<ul>\n<li>使用设备模式的屏幕模拟器测试网站的响应式特性</li>\n<li>自动保存设置，方便你以后继续使用。</li>\n<li>设备模式不能代替真实设备，请熟知它的局限性。</li>\n</ul>\n<h2 id=\"1-打开设备模式\"><a href=\"#1-打开设备模式\" class=\"headerlink\" title=\"1 打开设备模式\"></a>1 打开设备模式</h2><p><img src=\"http://static.zybuluo.com/lichangwei/uzwqzy5zn084re2j58aebu2c/device-mode-initial-view.png\" alt=\"device-mode-initial-view.png-101.8kB\"><br>通过切换“设备模式”按钮或者使用快捷键<code>Command+Shift+M (Mac)</code>或<code>Ctrl+Shift+M (Windows, Linux)</code></p>\n<h2 id=\"2-viewport控制器\"><a href=\"#2-viewport控制器\" class=\"headerlink\" title=\"2 viewport控制器\"></a>2 <code>viewport</code>控制器</h2><p><img src=\"http://static.zybuluo.com/lichangwei/8u1ihmm4azuhwi4ssb9krruu/device-mode.png\" alt=\"device-mode.png-30.8kB\"><br><code>viewport</code>控制器共有两种模式：<br><strong>完全响应式</strong>：自由地改变<code>viewport</code>尺寸。<br><strong>特定的设备</strong>：模拟设备<code>viewport</code>尺寸和设备特性。</p>\n<h3 id=\"2-1-完全响应式\"><a href=\"#2-1-完全响应式\" class=\"headerlink\" title=\"2.1 完全响应式\"></a>2.1 完全响应式</h3><p>我们推荐你将完全响应式模式作为你的默认模式，在开发过程中，使用它频繁调整<code>viewport</code>的尺寸来实现一个完全的响应式设计来适配未知或未来的设备类型。<br>你可以拖拽调整大小的手柄或单击菜单栏中值进行细粒度的控制。<br>也可以直接选择<code>Mobile S - 320px</code>, <code>Mobile M - 375px</code>, <code>Mobile L - 425px</code>, <code>Tablet - 768px</code>, <code>Laptop - 1024px</code>, <code>Laptop L - 1440px</code>, <code>4K - 2560px</code>。</p>\n<h3 id=\"2-2-特定的设备\"><a href=\"#2-2-特定的设备\" class=\"headerlink\" title=\"2.2 特定的设备\"></a>2.2 特定的设备</h3><p>在开发即将结束时，通过使用特定设备模式，可以查看你的网站在特定设备上被渲染成什么模样，比如特定的<code>iPhone</code>或<code>Nexus</code>。</p>\n<p><strong>内置设备集</strong><br>设备下拉框中已经内置了一组目前最流行的设备，选择了某个设备之后，Chrome 开发者工具就会模拟该设备并模拟网站在该设备上会如何渲染。</p>\n<ul>\n<li>模拟用户代理（User Agent）</li>\n<li>模拟设备分辨率以及 DPI（设备像素比）</li>\n<li>模拟触摸事件（如果设备支持的话）</li>\n<li>模拟滚动条和<code>viewport</code></li>\n<li>对于没有定义<code>viewport</code>的页面自动调整文字大小</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/lichangwei/e3qyenwnwnyqg3z93k6kcylk/select-device.png\" alt=\"select-device.png-19.6kB\"></p>\n<p><strong>添加自定义设备</strong><br>如果遇到极端情况，需要兼容特殊设备，你也可以添加自定义设备。点击设备列表下面的<code>Edit ...</code>选项即可打开以下窗口，你可以勾选更多设备和添加自定义设备。<br><img src=\"http://static.zybuluo.com/lichangwei/1vho3slc17ql6366sjfafxpd/custom-device.png\" alt=\"custom-device.png-90.6kB\"></p>\n<p><strong>设备状态和方向</strong><br><img src=\"http://static.zybuluo.com/lichangwei/80mo0w30u799t46y9mgv8kvj/change-orientation.png\" alt=\"change-orientation.png-6.8kB\"><br>当模拟特定设备时，设备模式工具栏会出现一个额外的功能，用来切换设备方向横向（landscape）或纵向（portrait）。<br>对于某些机型，不仅能切换设备方向，还能模拟特定设备状态。比如对于<code>Nexus 5X</code>还可以模拟以下状态：</p>\n<ul>\n<li>默认的浏览器界面</li>\n<li>带有地址栏</li>\n<li>键盘处于打开状态</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/lichangwei/xjk6aez20cl4mvf0fdijci9u/change-device-state.png\" alt=\"change-device-state.png-13.5kB\"></p>\n<p><strong>缩放到合适尺寸</strong><br>有时候你需要测试一个比你浏览器窗口分辨率还大的设备，这时候“缩放”这个选项就非常有用了。适合浏览器窗口（Fit to Window）会自动设置缩放级别以最大程度低利用浏览器空间，而特定的缩放比例可以用来测试 DPI 对图像显示效果的影响等是很有帮助的。</p>\n<p><strong>可选控制项</strong><br>通过单击设备工具栏右侧三个点可以启用和修改可选控制项，目前选项包括：</p>\n<ul>\n<li>是否显示设备边框</li>\n<li>是否显示媒体查询</li>\n<li>是否显示刻度尺</li>\n<li>设置设备像素比</li>\n<li>设置设备类型（移动/桌面，是否支持触摸）</li>\n<li>模拟网络状况</li>\n<li>截屏</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/lichangwei/krz2ci9gli2120g2g2afbrfi/show-media-queries.png\" alt=\"show-media-queries.png-139.6kB\"></p>\n<p><strong>显示设备外框</strong><br>只有当你选择了某些设备（比如 iPhone 6）之后才能启用该特性，启用以后你将能够看到页面被放在设备外壳里面。<br><img src=\"http://static.zybuluo.com/lichangwei/akjj90o538yceskczug4lwkr/www.google.com-%28iPhone%206%29.png\" alt=\"www.google.com-(iPhone 6).png-34.9kB\"></p>\n<p><strong>显示媒体查询</strong><br><a href=\"https://developers.google.com/web/fundamentals/design-and-ui/responsive/fundamentals/use-media-queries\" target=\"_blank\" rel=\"noopener\">媒体查询</a>是响应式设计的重要组成部分，通过点击<code>Show media queries</code>可以看到媒体查询查看器，该工具会检测你样式中的媒体查询，并在顶部标尺中将其显示成彩色条。<br><img src=\"http://static.zybuluo.com/lichangwei/am40nh3xrcat33n5itno5y3h/media-query-inspector-ruler.png\" alt=\"media-query-inspector-ruler.png-6.9kB\"></p>\n<ul>\n<li>蓝色代表最大宽度<code>max-width</code></li>\n<li>绿色代表宽度区间<code>min-width ~ max-width</code></li>\n<li>黄色代表最小宽度<code>min-width</code></li>\n</ul>\n<p>单击媒体查询条可以调整<code>viewport</code>大小来查看样式。<br>右击媒体查询条可以在源码中查看该媒体查询的定义。<br><img src=\"http://static.zybuluo.com/lichangwei/mdadktsfta7e8v5mdgaxcwwi/reveal-source-code.png\" alt=\"reveal-source-code.png-77.8kB\"></p>\n<p><strong>显示刻度尺</strong><br><img src=\"http://static.zybuluo.com/lichangwei/q12f21enmo6laq9nqhi3mmju/rule.png\" alt=\"rule.png-48.2kB\"></p>\n<p><strong>显示设备像素比</strong><br>如果你想通过非视网膜屏设备模拟视网膜屏设备，或者反过来，那么这个功能就是为你准备的。设备像素比就是逻辑像素和物理像素的比例。视网膜屏设备比如<code>Nexus 6P</code>比一般设备的像素密度更高，这会影响视觉内容的清晰度和大小。<br>下面这些 Web 上的案例会受到设备像素比的影响：</p>\n<ul>\n<li>CSS 媒体查询：<br><code>@media (-webkit-min-device-pixel-ratio: 2) { ... }</code></li>\n<li>CSS<a href=\"http://dev.w3.org/csswg/css-images/# image-set-notation\" target=\"_blank\" rel=\"noopener\"><code>image-set</code></a></li>\n<li><code>img</code>的<a href=\"https://developers.google.com/web/fundamentals/design-and-ui/media/images/images-in-markup\" target=\"_blank\" rel=\"noopener\"><code>srcset</code></a>属性</li>\n<li><code>window.devicePixelRatio</code>属性</li>\n</ul>\n<p>在真正的视网膜屏上，低 DPI（每英寸点数）资源看起来像素化，而高 DPI 的资源看起来很清晰，为了能够在标准的显示器上模拟这中效果，可以将 DPR 设置成 2 并缩放视窗，一个 2X 资源看起来仍然清晰，而 1X 的资源看起来就会像素化。</p>\n<p><strong>设备类型</strong><br>单击<code>Add device type</code>，设备工具栏将会出现一个选项“Mobile”，共有以下几个可选值：<code>Mobile</code>，<code>Mobile(not touch)</code>，<code>Desktop</code>，<code>Desktop(touch)</code>，修改这项设置将会影响<code>viewport</code>，是否模拟触摸事件，用户代理字符串。因此如果你想为左面浏览器创建一个响应式网站并且向测试鼠标悬浮效果，请使用完全响应式模式并将设备类型切换到<code>Desktop</code>。<br>提示：你还可以在<code>Network conditions</code>修改用户代理。</p>\n<p><strong>模拟网络状况</strong><br>单击<code>Add network throttling</code>，设备工具栏将会出现一个选项<code>No throttling</code>，通过这个选项可以模拟不同网络下页面加载效果。<br><img src=\"http://static.zybuluo.com/lichangwei/g9qo71cb23v5g0omwp7hlm7r/network.throttling.png\" alt=\"network.throttling.png-71.5kB\"></p>\n<h2 id=\"3-模拟传感器：地理定位和重力感应\"><a href=\"#3-模拟传感器：地理定位和重力感应\" class=\"headerlink\" title=\"3 模拟传感器：地理定位和重力感应\"></a>3 模拟传感器：地理定位和重力感应</h2><p>大多数台式机都没有 GPS 芯片和重力传感器，因而很难测试，但是 Chrome 开发者工具提供了传感器模拟器使得测试更加容易。</p>\n<p>打开方法：</p>\n<ol>\n<li>打开开发者工具主菜单</li>\n<li>点击<code>Customize and control DevTools</code>- <code>More tools</code> - <code>Sensors</code>菜单项<br><img src=\"http://static.zybuluo.com/lichangwei/37dklb3tf2etn9t0miuyet6i/navigate-to-sensors.png\" alt=\"navigate-to-sensors.png-17.9kB\"></li>\n</ol>\n<h3 id=\"3-1-模拟地理定位\"><a href=\"#3-1-模拟地理定位\" class=\"headerlink\" title=\"3.1 模拟地理定位\"></a>3.1 模拟地理定位</h3><p>移动设备一般使用 GPS 芯片进行定位，在传感器面板中，你可以使用<a href=\"http://www.w3.org/TR/geolocation-API/\" target=\"_blank\" rel=\"noopener\">地理定位 API</a>模拟位置。你可以使用预置的几个城市或手动输入经度纬度，甚至还可以模拟定位失败的情况，这里有一个地理定位 API 的<a href=\"https://jsfiddle.net/lichangwei/mc0ep3u9/\" target=\"_blank\" rel=\"noopener\">例子</a>，可以实验一下。<br><img src=\"http://static.zybuluo.com/lichangwei/4p8rz2bqkqfi2no661kz26et/geolocation.png\" alt=\"geolocation.png-32.4kB\"></p>\n<h3 id=\"3-2-模拟重力感应（加速度）\"><a href=\"#3-2-模拟重力感应（加速度）\" class=\"headerlink\" title=\"3.2 模拟重力感应（加速度）\"></a>3.2 模拟重力感应（加速度）</h3><p><img src=\"http://static.zybuluo.com/lichangwei/qoclusfnvrctjib2ih1ilfo9/orientation.png\" alt=\"orientation.png-16kB\"><br>在浏览器中打开以下链接实验以下吧。<a href=\"https://www.ikdoeict.be/apps/leercentrum/courses/ws1-cws-course-materials/demos/06_html5_js/orientation.html\" target=\"_blank\" rel=\"noopener\">重力感应代码示例</a>，切换方位看看页面如何变化。</p>\n<h2 id=\"4-参考资料\"><a href=\"#4-参考资料\" class=\"headerlink\" title=\"4 参考资料\"></a>4 参考资料</h2><ol>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/\" target=\"_blank\" rel=\"noopener\">Chrome 开发者工具官方介绍</a>，以上大部分内容来自该文档，部分甚至仅仅做了翻译，强烈推荐大家经常到该网站看看。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>使用 Chrome 开发者工具的设备模式可以大大减低开发移动优先响应式网站的难度，下面我们开始学习如何使用它模拟各种设备以及开发完全响应式的网站。</p>\n<p><strong>概述</strong></p>\n<ul>\n<li>使用设备模式的屏幕模拟器测试网站的响应式特性</li>\n<li>自动保存设置，方便你以后继续使用。</li>\n<li>设备模式不能代替真实设备，请熟知它的局限性。</li>\n</ul>\n<h2 id=\"1-打开设备模式\"><a href=\"#1-打开设备模式\" class=\"headerlink\" title=\"1 打开设备模式\"></a>1 打开设备模式</h2><p><img src=\"http://static.zybuluo.com/lichangwei/uzwqzy5zn084re2j58aebu2c/device-mode-initial-view.png\" alt=\"device-mode-initial-view.png-101.8kB\"><br>通过切换“设备模式”按钮或者使用快捷键<code>Command+Shift+M (Mac)</code>或<code>Ctrl+Shift+M (Windows, Linux)</code></p>\n<h2 id=\"2-viewport控制器\"><a href=\"#2-viewport控制器\" class=\"headerlink\" title=\"2 viewport控制器\"></a>2 <code>viewport</code>控制器</h2><p><img src=\"http://static.zybuluo.com/lichangwei/8u1ihmm4azuhwi4ssb9krruu/device-mode.png\" alt=\"device-mode.png-30.8kB\"><br><code>viewport</code>控制器共有两种模式：<br><strong>完全响应式</strong>：自由地改变<code>viewport</code>尺寸。<br><strong>特定的设备</strong>：模拟设备<code>viewport</code>尺寸和设备特性。</p>\n<h3 id=\"2-1-完全响应式\"><a href=\"#2-1-完全响应式\" class=\"headerlink\" title=\"2.1 完全响应式\"></a>2.1 完全响应式</h3><p>我们推荐你将完全响应式模式作为你的默认模式，在开发过程中，使用它频繁调整<code>viewport</code>的尺寸来实现一个完全的响应式设计来适配未知或未来的设备类型。<br>你可以拖拽调整大小的手柄或单击菜单栏中值进行细粒度的控制。<br>也可以直接选择<code>Mobile S - 320px</code>, <code>Mobile M - 375px</code>, <code>Mobile L - 425px</code>, <code>Tablet - 768px</code>, <code>Laptop - 1024px</code>, <code>Laptop L - 1440px</code>, <code>4K - 2560px</code>。</p>\n<h3 id=\"2-2-特定的设备\"><a href=\"#2-2-特定的设备\" class=\"headerlink\" title=\"2.2 特定的设备\"></a>2.2 特定的设备</h3><p>在开发即将结束时，通过使用特定设备模式，可以查看你的网站在特定设备上被渲染成什么模样，比如特定的<code>iPhone</code>或<code>Nexus</code>。</p>\n<p><strong>内置设备集</strong><br>设备下拉框中已经内置了一组目前最流行的设备，选择了某个设备之后，Chrome 开发者工具就会模拟该设备并模拟网站在该设备上会如何渲染。</p>\n<ul>\n<li>模拟用户代理（User Agent）</li>\n<li>模拟设备分辨率以及 DPI（设备像素比）</li>\n<li>模拟触摸事件（如果设备支持的话）</li>\n<li>模拟滚动条和<code>viewport</code></li>\n<li>对于没有定义<code>viewport</code>的页面自动调整文字大小</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/lichangwei/e3qyenwnwnyqg3z93k6kcylk/select-device.png\" alt=\"select-device.png-19.6kB\"></p>\n<p><strong>添加自定义设备</strong><br>如果遇到极端情况，需要兼容特殊设备，你也可以添加自定义设备。点击设备列表下面的<code>Edit ...</code>选项即可打开以下窗口，你可以勾选更多设备和添加自定义设备。<br><img src=\"http://static.zybuluo.com/lichangwei/1vho3slc17ql6366sjfafxpd/custom-device.png\" alt=\"custom-device.png-90.6kB\"></p>\n<p><strong>设备状态和方向</strong><br><img src=\"http://static.zybuluo.com/lichangwei/80mo0w30u799t46y9mgv8kvj/change-orientation.png\" alt=\"change-orientation.png-6.8kB\"><br>当模拟特定设备时，设备模式工具栏会出现一个额外的功能，用来切换设备方向横向（landscape）或纵向（portrait）。<br>对于某些机型，不仅能切换设备方向，还能模拟特定设备状态。比如对于<code>Nexus 5X</code>还可以模拟以下状态：</p>\n<ul>\n<li>默认的浏览器界面</li>\n<li>带有地址栏</li>\n<li>键盘处于打开状态</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/lichangwei/xjk6aez20cl4mvf0fdijci9u/change-device-state.png\" alt=\"change-device-state.png-13.5kB\"></p>\n<p><strong>缩放到合适尺寸</strong><br>有时候你需要测试一个比你浏览器窗口分辨率还大的设备，这时候“缩放”这个选项就非常有用了。适合浏览器窗口（Fit to Window）会自动设置缩放级别以最大程度低利用浏览器空间，而特定的缩放比例可以用来测试 DPI 对图像显示效果的影响等是很有帮助的。</p>\n<p><strong>可选控制项</strong><br>通过单击设备工具栏右侧三个点可以启用和修改可选控制项，目前选项包括：</p>\n<ul>\n<li>是否显示设备边框</li>\n<li>是否显示媒体查询</li>\n<li>是否显示刻度尺</li>\n<li>设置设备像素比</li>\n<li>设置设备类型（移动/桌面，是否支持触摸）</li>\n<li>模拟网络状况</li>\n<li>截屏</li>\n</ul>\n<p><img src=\"http://static.zybuluo.com/lichangwei/krz2ci9gli2120g2g2afbrfi/show-media-queries.png\" alt=\"show-media-queries.png-139.6kB\"></p>\n<p><strong>显示设备外框</strong><br>只有当你选择了某些设备（比如 iPhone 6）之后才能启用该特性，启用以后你将能够看到页面被放在设备外壳里面。<br><img src=\"http://static.zybuluo.com/lichangwei/akjj90o538yceskczug4lwkr/www.google.com-%28iPhone%206%29.png\" alt=\"www.google.com-(iPhone 6).png-34.9kB\"></p>\n<p><strong>显示媒体查询</strong><br><a href=\"https://developers.google.com/web/fundamentals/design-and-ui/responsive/fundamentals/use-media-queries\" target=\"_blank\" rel=\"noopener\">媒体查询</a>是响应式设计的重要组成部分，通过点击<code>Show media queries</code>可以看到媒体查询查看器，该工具会检测你样式中的媒体查询，并在顶部标尺中将其显示成彩色条。<br><img src=\"http://static.zybuluo.com/lichangwei/am40nh3xrcat33n5itno5y3h/media-query-inspector-ruler.png\" alt=\"media-query-inspector-ruler.png-6.9kB\"></p>\n<ul>\n<li>蓝色代表最大宽度<code>max-width</code></li>\n<li>绿色代表宽度区间<code>min-width ~ max-width</code></li>\n<li>黄色代表最小宽度<code>min-width</code></li>\n</ul>\n<p>单击媒体查询条可以调整<code>viewport</code>大小来查看样式。<br>右击媒体查询条可以在源码中查看该媒体查询的定义。<br><img src=\"http://static.zybuluo.com/lichangwei/mdadktsfta7e8v5mdgaxcwwi/reveal-source-code.png\" alt=\"reveal-source-code.png-77.8kB\"></p>\n<p><strong>显示刻度尺</strong><br><img src=\"http://static.zybuluo.com/lichangwei/q12f21enmo6laq9nqhi3mmju/rule.png\" alt=\"rule.png-48.2kB\"></p>\n<p><strong>显示设备像素比</strong><br>如果你想通过非视网膜屏设备模拟视网膜屏设备，或者反过来，那么这个功能就是为你准备的。设备像素比就是逻辑像素和物理像素的比例。视网膜屏设备比如<code>Nexus 6P</code>比一般设备的像素密度更高，这会影响视觉内容的清晰度和大小。<br>下面这些 Web 上的案例会受到设备像素比的影响：</p>\n<ul>\n<li>CSS 媒体查询：<br><code>@media (-webkit-min-device-pixel-ratio: 2) { ... }</code></li>\n<li>CSS<a href=\"http://dev.w3.org/csswg/css-images/# image-set-notation\" target=\"_blank\" rel=\"noopener\"><code>image-set</code></a></li>\n<li><code>img</code>的<a href=\"https://developers.google.com/web/fundamentals/design-and-ui/media/images/images-in-markup\" target=\"_blank\" rel=\"noopener\"><code>srcset</code></a>属性</li>\n<li><code>window.devicePixelRatio</code>属性</li>\n</ul>\n<p>在真正的视网膜屏上，低 DPI（每英寸点数）资源看起来像素化，而高 DPI 的资源看起来很清晰，为了能够在标准的显示器上模拟这中效果，可以将 DPR 设置成 2 并缩放视窗，一个 2X 资源看起来仍然清晰，而 1X 的资源看起来就会像素化。</p>\n<p><strong>设备类型</strong><br>单击<code>Add device type</code>，设备工具栏将会出现一个选项“Mobile”，共有以下几个可选值：<code>Mobile</code>，<code>Mobile(not touch)</code>，<code>Desktop</code>，<code>Desktop(touch)</code>，修改这项设置将会影响<code>viewport</code>，是否模拟触摸事件，用户代理字符串。因此如果你想为左面浏览器创建一个响应式网站并且向测试鼠标悬浮效果，请使用完全响应式模式并将设备类型切换到<code>Desktop</code>。<br>提示：你还可以在<code>Network conditions</code>修改用户代理。</p>\n<p><strong>模拟网络状况</strong><br>单击<code>Add network throttling</code>，设备工具栏将会出现一个选项<code>No throttling</code>，通过这个选项可以模拟不同网络下页面加载效果。<br><img src=\"http://static.zybuluo.com/lichangwei/g9qo71cb23v5g0omwp7hlm7r/network.throttling.png\" alt=\"network.throttling.png-71.5kB\"></p>\n<h2 id=\"3-模拟传感器：地理定位和重力感应\"><a href=\"#3-模拟传感器：地理定位和重力感应\" class=\"headerlink\" title=\"3 模拟传感器：地理定位和重力感应\"></a>3 模拟传感器：地理定位和重力感应</h2><p>大多数台式机都没有 GPS 芯片和重力传感器，因而很难测试，但是 Chrome 开发者工具提供了传感器模拟器使得测试更加容易。</p>\n<p>打开方法：</p>\n<ol>\n<li>打开开发者工具主菜单</li>\n<li>点击<code>Customize and control DevTools</code>- <code>More tools</code> - <code>Sensors</code>菜单项<br><img src=\"http://static.zybuluo.com/lichangwei/37dklb3tf2etn9t0miuyet6i/navigate-to-sensors.png\" alt=\"navigate-to-sensors.png-17.9kB\"></li>\n</ol>\n<h3 id=\"3-1-模拟地理定位\"><a href=\"#3-1-模拟地理定位\" class=\"headerlink\" title=\"3.1 模拟地理定位\"></a>3.1 模拟地理定位</h3><p>移动设备一般使用 GPS 芯片进行定位，在传感器面板中，你可以使用<a href=\"http://www.w3.org/TR/geolocation-API/\" target=\"_blank\" rel=\"noopener\">地理定位 API</a>模拟位置。你可以使用预置的几个城市或手动输入经度纬度，甚至还可以模拟定位失败的情况，这里有一个地理定位 API 的<a href=\"https://jsfiddle.net/lichangwei/mc0ep3u9/\" target=\"_blank\" rel=\"noopener\">例子</a>，可以实验一下。<br><img src=\"http://static.zybuluo.com/lichangwei/4p8rz2bqkqfi2no661kz26et/geolocation.png\" alt=\"geolocation.png-32.4kB\"></p>\n<h3 id=\"3-2-模拟重力感应（加速度）\"><a href=\"#3-2-模拟重力感应（加速度）\" class=\"headerlink\" title=\"3.2 模拟重力感应（加速度）\"></a>3.2 模拟重力感应（加速度）</h3><p><img src=\"http://static.zybuluo.com/lichangwei/qoclusfnvrctjib2ih1ilfo9/orientation.png\" alt=\"orientation.png-16kB\"><br>在浏览器中打开以下链接实验以下吧。<a href=\"https://www.ikdoeict.be/apps/leercentrum/courses/ws1-cws-course-materials/demos/06_html5_js/orientation.html\" target=\"_blank\" rel=\"noopener\">重力感应代码示例</a>，切换方位看看页面如何变化。</p>\n<h2 id=\"4-参考资料\"><a href=\"#4-参考资料\" class=\"headerlink\" title=\"4 参考资料\"></a>4 参考资料</h2><ol>\n<li><a href=\"https://developers.google.com/web/tools/chrome-devtools/\" target=\"_blank\" rel=\"noopener\">Chrome 开发者工具官方介绍</a>，以上大部分内容来自该文档，部分甚至仅仅做了翻译，强烈推荐大家经常到该网站看看。</li>\n</ol>\n"},{"title":"【翻译】React模式","_content":"\n[原文链接](http://reactpatterns.com/)\n\n## 1. 无状态函数（Stateless function）\n\n无状态函数是一种创建高度可复用组件的牛逼闪闪的方法，它自己不管理状态，他只是函数。\n\n```jsx\nconst Greeting = () => <div>Hi there!</div>;\n```\n\n可以传递`props`和`context`。\n\n```jsx\nconst Greeting = (props, context) => <div style={{ color: context.color }}>Hi {props.name}!</div>;\n```\n\n也可以定义局部变量。\n\n```jsx\nconst Greeting = (props, context) => {\n    const style = {\n        fontWeight: 'bold',\n        color: context.color,\n    };\n    return <div style={style}>{props.name}</div>;\n};\n```\n\n当然也可以不定义局部变量，改为函数。\n\n```jsx\nconst getStyle = context => ({\n    fontWeight: 'bold',\n    color: context.color,\n});\n\nconst Greeting = (props, context) => <div style={getStyle(context)}>{props.name}</div>;\n```\n\n无状态函数也可以拥有`defaultProps`，`propTypes`和`contextTypes`。\n\n```jsx\nGreeting.propTypes = {\n    name: PropTypes.string.isRequired,\n};\nGreeting.defaultProps = {\n    name: 'Guest',\n};\nGreeting.contextTypes = {\n    color: PropTypes.string,\n};\n```\n\n## 2. JSX 展开属性（JSX Spread Attributes）\n\n展开属性是 JSX 的一个特性，一种语法糖，用来将一个对象的所有属性作为 JSX 的属性传递。\n以下两个例子是等价的\n\n```jsx\n// props written as attributes\n<main className=\"main\" role=\"main\">\n    {children}\n</main>\n```\n\n```jsx\n// props \"spread\" from object\n<main {...{ className: 'main', role: 'main', children }} />\n```\n\n用它可以方便地将属性转发给底层组件。\n\n```jsx\nconst FancyDiv = props => <div className=\"fancy\" {...props} />;\n```\n\n这时我给可以`FancyDiv`组件添加他关心和他不关心的属性。\n\n```jsx\n<FancyDiv data-id=\"my-fancy-div\">So Fancy</FancyDiv>\n\n// output: <div className=\"fancy\" data-id=\"my-fancy-div\">So Fancy</div>\n```\n\n注意属性顺序很重要，如果外部传入`className`属性，那么`FancyDiv`定义的`className`将会被覆盖。\n\n```jsx\n<FancyDiv className=\"my-fancy-div\" />\n\n// output: <div className=\"my-fancy-div\"></div>\n```\n\n也可以让`FancyDiv`定义的`className`永远生效，只需要将它放在展开属性（{...props}）后面。\n\n```jsx\n// my `className` clobbers your `className`\nconst FancyDiv = props => <div {...props} className=\"fancy\" />;\n```\n\n你应该优雅地处理这类情形，这种情况下我会合并使用者定义的`className`和组件自身的`className`。\n\n```jsx\nconst FancyDiv = ({ className, ...props }) => <div className={['fancy', className].join(' ')} {...props} />;\n```\n\n## 3. 参数解构（Destructuring Arguments）\n\n参数解构是 ES2015 的特性，它能够很好的配合无状态函数的参数。\n以下两个例子是等价的。\n\n```jsx\nconst Greeting = props => <div>Hi {props.name}!</div>;\n\nconst Greeting = ({ name }) => <div>Hi {name}!</div>;\n```\n\n[剩余参数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)（[中文链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)）语法可以将剩余的参数手机到一个新对象中。\n\n```jsx\nconst Greeting = ({ name, ...props }) => <div>Hi {name}!</div>;\n```\n\n反过来，这个新对象可以通过展开属性将属性转发给底层组件。\n\n```jsx\nconst Greeting = ({ name, ...props }) => <div {...props}>Hi {name}!</div>;\n```\n\n应该避免将非 DOM 属性转发给原生组件，通过解构可以创建一个不包含高阶组件特有属性的新对象，因此解构可以让这个工作更加简单。\n\n## 4. 条件渲染（Conditional Rendering）\n\n组件定义内部是不能使用 if/else 条件语句的，但是可以使用[条件表达式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)。\n\nif\n\n```jsx\n{\n    condition && <span>Rendered when `truthy`</span>;\n}\n```\n\nelse\n\n```jsx\n{\n    condition || <span>Rendered when `falsey`</span>;\n}\n```\n\nif-else (tidy one-liners)\n\n```jsx\n{\n    condition ? <span>Rendered when `truthy`</span> : <span>Rendered when `falsey`</span>;\n}\n```\n\nif-else (big blocks)\n\n```jsx\n{\n    condition ? <span>Rendered when `truthy`</span> : <span>Rendered when `falsey`</span>;\n}\n```\n\n## 5. Children 类型（Children types）\n\nReact 中 children 有好几种类型，常见的有数组和字符串。\n\n字符串\n\n```jsx\n<div>Hello World!</div>\n```\n\narray\n\n```jsx\n<div>{['Hello ', <span>World</span>, '!']}</div>\n```\n\nchildren 也可以是函数，但是必须和父组件协作才能用。\n\nfunction\n\n```jsx\n<div>\n  {() => { return \"hello world!\"}()}\n</div>\n```\n\n## 6. 数组类型的 children（Array as children）\n\n数组类型的 children 是非常常见的，列表就是这么渲染出来的。使用`map`函数就可以创建 React 元素数组。\n\n```jsx\n<ul>\n    {['first', 'second'].map(item => (\n        <li>{item}</li>\n    ))}\n</ul>\n```\n\n和下面这个数组字面量方式等价\n\n```jsx\n<ul>{[<li>first</li>, <li>second</li>]}</ul>\n```\n\n为了更加简洁，可以结合解构，JSX 展开属性，其他组件一起使用。\n\n```jsx\n<ul>\n    {arrayOfMessageObjects.map(({ id, ...message }) => (\n        <Message key={id} {...message} />\n    ))}\n</ul>\n```\n\n## 7. 函数类型的 children（Function as children）\n\n函数类型的 children 不是天然有用的。\n\n```jsx\n<div>{() => { return \"hello world!\"}()}</div>\n```\n\n这种技术通常被称为渲染回调，可以给组件创作带来更多空间和便利。比如[ReactMotion](https://github.com/chenglou/react-motion)使用这种高能技术以后，渲染逻辑可以由使用者提供，而不是被类库写死。更多细节，请参考下一章渲染回调。\n\n## 8. 渲染回调（Render callback）\n\n下面这个组件使用了渲染回调技术，它没什么用，但它是一个很好的开端。\n\n```jsx\nconst Width = ({ children }) => children(500);\n```\n\n该组件将 children 当做函数来调用，并传递了一个数字类型值为 500 的参数。\n\n下面我们将使用该组件，并给它传递一个函数类型的 children.\n\n```jsx\n<Width>{width => <div>window is {width}</div>}</Width>\n```\n\n我们将得到以下结果。\n\n```html\n<div>window is 500</div>\n```\n\n有了这些设置，我们可以根据宽度来决定渲染什么。\n\n```jsx\n<Width>{width => (width > 600 ? <div>min-width requirement met!</div> : null)}</Width>\n```\n\n如果这个逻辑会被多次使用，我们可以创建一个新组件来封装可重用逻辑。\n\n```jsx\nconst MinWidth = ({ width: minWidth, children }) => <Width>{width => (width > minWidth ? children : null)}</Width>;\n```\n\n很明显这对于一个有着固定宽度的组件没有什么意义，但对一个监听浏览器窗口宽度的组件就有意义了，以下是示例代码。\n\n```jsx\nclass WindowWidth extends React.Component {\n    constructor() {\n        super();\n        this.state = { width: 0 };\n    }\n\n    componentDidMount() {\n        this.setState({ width: window.innerWidth });\n        window.addEventListener('resize', ({ target }) => {\n            this.setState({ width: target.innerWidth });\n        });\n    }\n\n    render() {\n        return this.props.children(this.state.width);\n    }\n}\n```\n\n很多开发者更喜欢高阶组件完成类似功能，这是个人偏好问题。\n\n## 9. Children 值传（Children pass-through）\n\n有时候你可能会创建一个组件，只用来处理上下文并且直接渲染其 children.\n\n```jsx\nclass SomeContextProvider extends React.Component {\n    getChildContext() {\n        return { some: 'context' };\n    }\n\n    render() {\n        // how best do we return `children`?\n    }\n}\n```\n\n现在你需要作出决定，将`children`包裹在一个`<div />`中，还是直接返回`children`。第一种做法多了一层标签（可能导致样式失效），第二种做法将会导致一个错误。\n\n```jsx\n// option 1: extra div\nreturn <div>{children}</div>;\n\n// option 2: unhelpful errors\nreturn children;\n```\n\n最好的做法是将`children`看做一个不透明的数据类型，`React`提供了`React.Children`来合理的处理`children`。\n\n```jsx\nreturn React.Children.only(this.props.children);\n```\n\n## 10. 组件代理（Proxy component）\n\n（我不确定这个名字是否有意义）\n按钮（Button）在网页应用中随处可见，每一个按钮都必须有一个`type`属性并设成`button`。\n\n```jsx\n<button type=\"button\">\n```\n\n书写次数多了，也就容易导致错误，我们可以创建一个高阶组件代理该低阶组件。\n\n```jsx\nconst Button = props =>\n  <button type=\"button\" {...props}>\n```\n\n这时我们可以使用`Button`代替`button`，确保`type`属性总被正确使用。\n\n```jsx\n<Button />\n// <button type=\"button\"><button>\n\n<Button className=\"CTA\">Send Money</Button>\n// <button type=\"button\" class=\"CTA\">Send Money</button>\n```\n\n## 11. 使用样式（Style component）\n\n这是一种使用样式的组件代理。\n假设我们通过使用`class`将一个`button`装饰成主要（primary）按钮。\n\n```jsx\n<button type=\"button\" className=\"btn btn-primary\">\n```\n\n我们可以通过两个单一职责组件达到此目的。\n\n```jsx\nconst PrimaryBtn = props => <Btn {...props} primary />;\n\nconst Btn = ({ className, primary, ...props }) => (\n    <button type=\"button\" className={classnames('btn', primary && 'btn-primary', className)} {...props} />\n);\n```\n\n便于理解，请看下面的图示。\n\n```\nPrimaryBtn()\n  ↳ Btn({primary: true})\n    ↳ Button({className: \"btn btn-primary\"}, type: \"button\"})\n      ↳ '<button type=\"button\" class=\"btn btn-primary\"></button>'\n```\n\n通过这些组件，以下代码是等价的。\n\n```jsx\n<PrimaryBtn />\n<Btn primary />\n<button type=\"button\" className=\"btn btn-primary\" />\n```\n\n对于样式维护来说真是一大福音，它将样式问题封装在单一组件中。\n\n## 12. 事件切换（Event switch）\n\n在写事件回调时通过采用`handle{EventName}`规则。\n\n```jsx\nhandleClick(e) { /* do something */ }\n```\n\n对于一个需要处理多种事件事件的组件来说，这些函数名显得非常啰嗦。函数名中也不会带有更多信息，因为他们一般直接调用其他`action`或`function`。\n\n```jsx\nhandleClick() { require(\"./actions/doStuff\")(/* action stuff */) }\nhandleMouseEnter() { this.setState({ hovered: true }) }\nhandleMouseLeave() { this.setState({ hovered: false }) }\n```\n\n下面只给组件写一个事件处理函数，并通过`event.type`区分。\n\n```jsx\nhandleEvent({type}) {\n  switch(type) {\n    case \"click\":\n      return require(\"./actions/doStuff\")(/* action dates */)\n    case \"mouseenter\":\n      return this.setState({ hovered: true })\n    case \"mouseleave\":\n      return this.setState({ hovered: false })\n    default:\n      return console.warn(`No case for event type \"${type}\"`)\n  }\n}\n```\n\n或者，对于简单组件，你可以通过胖箭头函数方式直接调用`action`或`function`。\n\n```jsx\n<div onClick={() => someImportedAction({ action: 'DO_STUFF' })} />\n```\n\n不要担心性能问题，知道性能问题爆发。一定不要过早进行性能优化。\n\n## 13. 布局组件（Layout component）\n\n布局组件会产生一些静态 DOM 元素，他们可能不会有任何改变，即使改变了也不会很频繁。\n下面是一个并排显示两个子组件的组件。\n\n```jsx\n<HorizontalSplit leftSide={<SomeSmartComponent />} rightSide={<AnotherSmartComponent />} />\n```\n\n我们可以尽量去优化这个组件。\n虽然`HorizontalSplit`是两个组件的父组件，但是它绝不是这两个组件的所有者。我们可以让它永不更新，不影响组件的生命周期。\n\n```jsx\nclass HorizontalSplit extends React.Component {\n    shouldComponentUpdate() {\n        return false;\n    }\n\n    render() {\n        <FlexContainer>\n            <div>{this.props.leftSide}</div>\n            <div>{this.props.rightSide}</div>\n        </FlexContainer>;\n    }\n}\n```\n\n## 14. 容器组件（Container component）\n\n> “容器负责获取数据并渲染其子组件，这就够了”\n> —Jason Bonta\n> 假设我们已经有了可复用的`CommentList`组件。\n\n```jsx\nconst CommentList = ({ comments }) => (\n    <ul>\n        {comments.map(comment => (\n            <li>\n                {comment.body}-{comment.author}\n            </li>\n        ))}\n    </ul>\n);\n```\n\n接下来我们可以创建一个新组件负责获取数据并渲染无状态的`CommentList`组件。\n\n```jsx\nclass CommentListContainer extends React.Component {\n  constructor() {\n    super()\n    this.state = { comments: [] }\n  }\n\n  componentDidMount() {\n    $.ajax({\n      url: \"/my-comments.json\",\n      dataType: 'json',\n      success: comments =>\n        this.setState({comments: comments});\n    })\n  }\n\n  render() {\n    return <CommentList comments={this.state.comments} />\n  }\n}\n```\n\n我们可以给不同的应用上下文创建不同的容器组件。\n\n## 14. 高阶组件（Higher-order component）\n\n[高阶函数](https://en.wikipedia.org/wiki/Higher-order_function)是一个接受函数类型的参数或返回一个新函数的函数。那么什么是高阶组件呢？\n如果你已经开始使用容器组件，它们都是包裹在一个函数中的通用容器。\n下面我们从一个无状态的`Greeting`组件开始。\n\n```jsx\nconst Greeting = ({ name }) => {\n    if (!name) {\n        return <div>Connecting...</div>;\n    }\n\n    return <div>Hi {name}!</div>;\n};\n```\n\n如果`Greeting`组件接到`props.name`，它就回去渲染这个数据，否则他会说正在连接。现在我们创建一个高阶组件。\n\n```jsx\nconst Connect = ComposedComponent =>\n    class extends React.Component {\n        constructor() {\n            super();\n            this.state = { name: '' };\n        }\n\n        componentDidMount() {\n            // this would fetch or connect to a store\n            this.setState({ name: 'Michael' });\n        }\n\n        render() {\n            return <ComposedComponent {...this.props} name={this.state.name} />;\n        }\n    };\n```\n\n它就是一个函数，返回一个渲染作为参数传递进去的组件的新组件。\n最后，我们需要用`Connect`组件将`Greeting`组件包裹起来，如下：\n\n```jsx\nconst ConnectedMyComponent = Connect(Greeting);\n```\n\n高阶组件是一个功能很强的模式，可以用来获取数据并给其他无状态组件提供数据。\n\n## 15. 状态提升（State hoisting）\n\n无状态组件并不持有状态，正如它名称暗示的那样。\n\nEvents are changes in state. Their data needs to be passed to stateful container components parents.\n\nThis is called “state hoisting”. It’s accomplished by passing a callback from a container component to a child component.\n\n```jsx\nclass NameContainer extends React.Component {\n    render() {\n        return <Name onChange={newName => alert(newName)} />;\n    }\n}\n\nconst Name = ({ onChange }) => <input onChange={e => onChange(e.target.value)} />;\n```\n\n`Name`组件从`NameContainer`组件中获得`onChange`回调并在事件中调用。\n上面的`alert`只是简单演示并不修改状态，下面的代码将会修改`NameContainer`组件的状态。\n\n```jsx\nclass NameContainer extends React.Component {\n    constructor() {\n        super();\n        this.state = { name: '' };\n    }\n\n    render() {\n        return <Name onChange={newName => this.setState({ name: newName })} />;\n    }\n}\n```\n\n通过回调，状态被提升到维护局部状态的容器组件中。这给无状态函数一个清晰的边界和最大限度的可重用性。\n\n这个模式并不局限于无状态函数，因为无状态函数没有生命周期事件，该模式同样适用于无状态组件。\n\n受控的 input 就是一个使用了状态提升的重要模式。\n\n## 16. 受控的 input（Controlled input）\n\n直接讨论受控的 input 比较困难，我们先从不受控的 input 谈起。\n\n```jsx\n<input type=\"text\" />\n```\n\n当你在浏览器中输入框中输入时，你会看到输入框的值发生变化，这很正常。\n\n受控的 input 禁用 DOM 突变，它的值只能被组件修改，不能被 DOM 修改。\n\n```jsx\n<input type=\"text\" value=\"This won't change. Try it.\" />\n```\n\n上面的输入框有着固定值没有什么意义，下面输入框的值将会从`state`中获取。\n\n```jsx\nclass ControlledNameInput extends React.Component {\n    constructor() {\n        super();\n        this.state = { name: '' };\n    }\n\n    render() {\n        return <input type=\"text\" value={this.state.name} />;\n    }\n}\n```\n\n接着，修改输入框的值就是修改组件状态。\n\n```jsx\nreturn <input value={this.state.name} onChange={e => this.setState(e.target.value)} />;\n```\n\n这就是受控的 input，只有当组件的状态改变了才能改变 DOM，对于创建一致的 UI，有着非常大的作用。\n","source":"_posts/2017-05-04-react-patterns.md","raw":"---\ntitle: 【翻译】React模式\n---\n\n[原文链接](http://reactpatterns.com/)\n\n## 1. 无状态函数（Stateless function）\n\n无状态函数是一种创建高度可复用组件的牛逼闪闪的方法，它自己不管理状态，他只是函数。\n\n```jsx\nconst Greeting = () => <div>Hi there!</div>;\n```\n\n可以传递`props`和`context`。\n\n```jsx\nconst Greeting = (props, context) => <div style={{ color: context.color }}>Hi {props.name}!</div>;\n```\n\n也可以定义局部变量。\n\n```jsx\nconst Greeting = (props, context) => {\n    const style = {\n        fontWeight: 'bold',\n        color: context.color,\n    };\n    return <div style={style}>{props.name}</div>;\n};\n```\n\n当然也可以不定义局部变量，改为函数。\n\n```jsx\nconst getStyle = context => ({\n    fontWeight: 'bold',\n    color: context.color,\n});\n\nconst Greeting = (props, context) => <div style={getStyle(context)}>{props.name}</div>;\n```\n\n无状态函数也可以拥有`defaultProps`，`propTypes`和`contextTypes`。\n\n```jsx\nGreeting.propTypes = {\n    name: PropTypes.string.isRequired,\n};\nGreeting.defaultProps = {\n    name: 'Guest',\n};\nGreeting.contextTypes = {\n    color: PropTypes.string,\n};\n```\n\n## 2. JSX 展开属性（JSX Spread Attributes）\n\n展开属性是 JSX 的一个特性，一种语法糖，用来将一个对象的所有属性作为 JSX 的属性传递。\n以下两个例子是等价的\n\n```jsx\n// props written as attributes\n<main className=\"main\" role=\"main\">\n    {children}\n</main>\n```\n\n```jsx\n// props \"spread\" from object\n<main {...{ className: 'main', role: 'main', children }} />\n```\n\n用它可以方便地将属性转发给底层组件。\n\n```jsx\nconst FancyDiv = props => <div className=\"fancy\" {...props} />;\n```\n\n这时我给可以`FancyDiv`组件添加他关心和他不关心的属性。\n\n```jsx\n<FancyDiv data-id=\"my-fancy-div\">So Fancy</FancyDiv>\n\n// output: <div className=\"fancy\" data-id=\"my-fancy-div\">So Fancy</div>\n```\n\n注意属性顺序很重要，如果外部传入`className`属性，那么`FancyDiv`定义的`className`将会被覆盖。\n\n```jsx\n<FancyDiv className=\"my-fancy-div\" />\n\n// output: <div className=\"my-fancy-div\"></div>\n```\n\n也可以让`FancyDiv`定义的`className`永远生效，只需要将它放在展开属性（{...props}）后面。\n\n```jsx\n// my `className` clobbers your `className`\nconst FancyDiv = props => <div {...props} className=\"fancy\" />;\n```\n\n你应该优雅地处理这类情形，这种情况下我会合并使用者定义的`className`和组件自身的`className`。\n\n```jsx\nconst FancyDiv = ({ className, ...props }) => <div className={['fancy', className].join(' ')} {...props} />;\n```\n\n## 3. 参数解构（Destructuring Arguments）\n\n参数解构是 ES2015 的特性，它能够很好的配合无状态函数的参数。\n以下两个例子是等价的。\n\n```jsx\nconst Greeting = props => <div>Hi {props.name}!</div>;\n\nconst Greeting = ({ name }) => <div>Hi {name}!</div>;\n```\n\n[剩余参数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)（[中文链接](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)）语法可以将剩余的参数手机到一个新对象中。\n\n```jsx\nconst Greeting = ({ name, ...props }) => <div>Hi {name}!</div>;\n```\n\n反过来，这个新对象可以通过展开属性将属性转发给底层组件。\n\n```jsx\nconst Greeting = ({ name, ...props }) => <div {...props}>Hi {name}!</div>;\n```\n\n应该避免将非 DOM 属性转发给原生组件，通过解构可以创建一个不包含高阶组件特有属性的新对象，因此解构可以让这个工作更加简单。\n\n## 4. 条件渲染（Conditional Rendering）\n\n组件定义内部是不能使用 if/else 条件语句的，但是可以使用[条件表达式](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)。\n\nif\n\n```jsx\n{\n    condition && <span>Rendered when `truthy`</span>;\n}\n```\n\nelse\n\n```jsx\n{\n    condition || <span>Rendered when `falsey`</span>;\n}\n```\n\nif-else (tidy one-liners)\n\n```jsx\n{\n    condition ? <span>Rendered when `truthy`</span> : <span>Rendered when `falsey`</span>;\n}\n```\n\nif-else (big blocks)\n\n```jsx\n{\n    condition ? <span>Rendered when `truthy`</span> : <span>Rendered when `falsey`</span>;\n}\n```\n\n## 5. Children 类型（Children types）\n\nReact 中 children 有好几种类型，常见的有数组和字符串。\n\n字符串\n\n```jsx\n<div>Hello World!</div>\n```\n\narray\n\n```jsx\n<div>{['Hello ', <span>World</span>, '!']}</div>\n```\n\nchildren 也可以是函数，但是必须和父组件协作才能用。\n\nfunction\n\n```jsx\n<div>\n  {() => { return \"hello world!\"}()}\n</div>\n```\n\n## 6. 数组类型的 children（Array as children）\n\n数组类型的 children 是非常常见的，列表就是这么渲染出来的。使用`map`函数就可以创建 React 元素数组。\n\n```jsx\n<ul>\n    {['first', 'second'].map(item => (\n        <li>{item}</li>\n    ))}\n</ul>\n```\n\n和下面这个数组字面量方式等价\n\n```jsx\n<ul>{[<li>first</li>, <li>second</li>]}</ul>\n```\n\n为了更加简洁，可以结合解构，JSX 展开属性，其他组件一起使用。\n\n```jsx\n<ul>\n    {arrayOfMessageObjects.map(({ id, ...message }) => (\n        <Message key={id} {...message} />\n    ))}\n</ul>\n```\n\n## 7. 函数类型的 children（Function as children）\n\n函数类型的 children 不是天然有用的。\n\n```jsx\n<div>{() => { return \"hello world!\"}()}</div>\n```\n\n这种技术通常被称为渲染回调，可以给组件创作带来更多空间和便利。比如[ReactMotion](https://github.com/chenglou/react-motion)使用这种高能技术以后，渲染逻辑可以由使用者提供，而不是被类库写死。更多细节，请参考下一章渲染回调。\n\n## 8. 渲染回调（Render callback）\n\n下面这个组件使用了渲染回调技术，它没什么用，但它是一个很好的开端。\n\n```jsx\nconst Width = ({ children }) => children(500);\n```\n\n该组件将 children 当做函数来调用，并传递了一个数字类型值为 500 的参数。\n\n下面我们将使用该组件，并给它传递一个函数类型的 children.\n\n```jsx\n<Width>{width => <div>window is {width}</div>}</Width>\n```\n\n我们将得到以下结果。\n\n```html\n<div>window is 500</div>\n```\n\n有了这些设置，我们可以根据宽度来决定渲染什么。\n\n```jsx\n<Width>{width => (width > 600 ? <div>min-width requirement met!</div> : null)}</Width>\n```\n\n如果这个逻辑会被多次使用，我们可以创建一个新组件来封装可重用逻辑。\n\n```jsx\nconst MinWidth = ({ width: minWidth, children }) => <Width>{width => (width > minWidth ? children : null)}</Width>;\n```\n\n很明显这对于一个有着固定宽度的组件没有什么意义，但对一个监听浏览器窗口宽度的组件就有意义了，以下是示例代码。\n\n```jsx\nclass WindowWidth extends React.Component {\n    constructor() {\n        super();\n        this.state = { width: 0 };\n    }\n\n    componentDidMount() {\n        this.setState({ width: window.innerWidth });\n        window.addEventListener('resize', ({ target }) => {\n            this.setState({ width: target.innerWidth });\n        });\n    }\n\n    render() {\n        return this.props.children(this.state.width);\n    }\n}\n```\n\n很多开发者更喜欢高阶组件完成类似功能，这是个人偏好问题。\n\n## 9. Children 值传（Children pass-through）\n\n有时候你可能会创建一个组件，只用来处理上下文并且直接渲染其 children.\n\n```jsx\nclass SomeContextProvider extends React.Component {\n    getChildContext() {\n        return { some: 'context' };\n    }\n\n    render() {\n        // how best do we return `children`?\n    }\n}\n```\n\n现在你需要作出决定，将`children`包裹在一个`<div />`中，还是直接返回`children`。第一种做法多了一层标签（可能导致样式失效），第二种做法将会导致一个错误。\n\n```jsx\n// option 1: extra div\nreturn <div>{children}</div>;\n\n// option 2: unhelpful errors\nreturn children;\n```\n\n最好的做法是将`children`看做一个不透明的数据类型，`React`提供了`React.Children`来合理的处理`children`。\n\n```jsx\nreturn React.Children.only(this.props.children);\n```\n\n## 10. 组件代理（Proxy component）\n\n（我不确定这个名字是否有意义）\n按钮（Button）在网页应用中随处可见，每一个按钮都必须有一个`type`属性并设成`button`。\n\n```jsx\n<button type=\"button\">\n```\n\n书写次数多了，也就容易导致错误，我们可以创建一个高阶组件代理该低阶组件。\n\n```jsx\nconst Button = props =>\n  <button type=\"button\" {...props}>\n```\n\n这时我们可以使用`Button`代替`button`，确保`type`属性总被正确使用。\n\n```jsx\n<Button />\n// <button type=\"button\"><button>\n\n<Button className=\"CTA\">Send Money</Button>\n// <button type=\"button\" class=\"CTA\">Send Money</button>\n```\n\n## 11. 使用样式（Style component）\n\n这是一种使用样式的组件代理。\n假设我们通过使用`class`将一个`button`装饰成主要（primary）按钮。\n\n```jsx\n<button type=\"button\" className=\"btn btn-primary\">\n```\n\n我们可以通过两个单一职责组件达到此目的。\n\n```jsx\nconst PrimaryBtn = props => <Btn {...props} primary />;\n\nconst Btn = ({ className, primary, ...props }) => (\n    <button type=\"button\" className={classnames('btn', primary && 'btn-primary', className)} {...props} />\n);\n```\n\n便于理解，请看下面的图示。\n\n```\nPrimaryBtn()\n  ↳ Btn({primary: true})\n    ↳ Button({className: \"btn btn-primary\"}, type: \"button\"})\n      ↳ '<button type=\"button\" class=\"btn btn-primary\"></button>'\n```\n\n通过这些组件，以下代码是等价的。\n\n```jsx\n<PrimaryBtn />\n<Btn primary />\n<button type=\"button\" className=\"btn btn-primary\" />\n```\n\n对于样式维护来说真是一大福音，它将样式问题封装在单一组件中。\n\n## 12. 事件切换（Event switch）\n\n在写事件回调时通过采用`handle{EventName}`规则。\n\n```jsx\nhandleClick(e) { /* do something */ }\n```\n\n对于一个需要处理多种事件事件的组件来说，这些函数名显得非常啰嗦。函数名中也不会带有更多信息，因为他们一般直接调用其他`action`或`function`。\n\n```jsx\nhandleClick() { require(\"./actions/doStuff\")(/* action stuff */) }\nhandleMouseEnter() { this.setState({ hovered: true }) }\nhandleMouseLeave() { this.setState({ hovered: false }) }\n```\n\n下面只给组件写一个事件处理函数，并通过`event.type`区分。\n\n```jsx\nhandleEvent({type}) {\n  switch(type) {\n    case \"click\":\n      return require(\"./actions/doStuff\")(/* action dates */)\n    case \"mouseenter\":\n      return this.setState({ hovered: true })\n    case \"mouseleave\":\n      return this.setState({ hovered: false })\n    default:\n      return console.warn(`No case for event type \"${type}\"`)\n  }\n}\n```\n\n或者，对于简单组件，你可以通过胖箭头函数方式直接调用`action`或`function`。\n\n```jsx\n<div onClick={() => someImportedAction({ action: 'DO_STUFF' })} />\n```\n\n不要担心性能问题，知道性能问题爆发。一定不要过早进行性能优化。\n\n## 13. 布局组件（Layout component）\n\n布局组件会产生一些静态 DOM 元素，他们可能不会有任何改变，即使改变了也不会很频繁。\n下面是一个并排显示两个子组件的组件。\n\n```jsx\n<HorizontalSplit leftSide={<SomeSmartComponent />} rightSide={<AnotherSmartComponent />} />\n```\n\n我们可以尽量去优化这个组件。\n虽然`HorizontalSplit`是两个组件的父组件，但是它绝不是这两个组件的所有者。我们可以让它永不更新，不影响组件的生命周期。\n\n```jsx\nclass HorizontalSplit extends React.Component {\n    shouldComponentUpdate() {\n        return false;\n    }\n\n    render() {\n        <FlexContainer>\n            <div>{this.props.leftSide}</div>\n            <div>{this.props.rightSide}</div>\n        </FlexContainer>;\n    }\n}\n```\n\n## 14. 容器组件（Container component）\n\n> “容器负责获取数据并渲染其子组件，这就够了”\n> —Jason Bonta\n> 假设我们已经有了可复用的`CommentList`组件。\n\n```jsx\nconst CommentList = ({ comments }) => (\n    <ul>\n        {comments.map(comment => (\n            <li>\n                {comment.body}-{comment.author}\n            </li>\n        ))}\n    </ul>\n);\n```\n\n接下来我们可以创建一个新组件负责获取数据并渲染无状态的`CommentList`组件。\n\n```jsx\nclass CommentListContainer extends React.Component {\n  constructor() {\n    super()\n    this.state = { comments: [] }\n  }\n\n  componentDidMount() {\n    $.ajax({\n      url: \"/my-comments.json\",\n      dataType: 'json',\n      success: comments =>\n        this.setState({comments: comments});\n    })\n  }\n\n  render() {\n    return <CommentList comments={this.state.comments} />\n  }\n}\n```\n\n我们可以给不同的应用上下文创建不同的容器组件。\n\n## 14. 高阶组件（Higher-order component）\n\n[高阶函数](https://en.wikipedia.org/wiki/Higher-order_function)是一个接受函数类型的参数或返回一个新函数的函数。那么什么是高阶组件呢？\n如果你已经开始使用容器组件，它们都是包裹在一个函数中的通用容器。\n下面我们从一个无状态的`Greeting`组件开始。\n\n```jsx\nconst Greeting = ({ name }) => {\n    if (!name) {\n        return <div>Connecting...</div>;\n    }\n\n    return <div>Hi {name}!</div>;\n};\n```\n\n如果`Greeting`组件接到`props.name`，它就回去渲染这个数据，否则他会说正在连接。现在我们创建一个高阶组件。\n\n```jsx\nconst Connect = ComposedComponent =>\n    class extends React.Component {\n        constructor() {\n            super();\n            this.state = { name: '' };\n        }\n\n        componentDidMount() {\n            // this would fetch or connect to a store\n            this.setState({ name: 'Michael' });\n        }\n\n        render() {\n            return <ComposedComponent {...this.props} name={this.state.name} />;\n        }\n    };\n```\n\n它就是一个函数，返回一个渲染作为参数传递进去的组件的新组件。\n最后，我们需要用`Connect`组件将`Greeting`组件包裹起来，如下：\n\n```jsx\nconst ConnectedMyComponent = Connect(Greeting);\n```\n\n高阶组件是一个功能很强的模式，可以用来获取数据并给其他无状态组件提供数据。\n\n## 15. 状态提升（State hoisting）\n\n无状态组件并不持有状态，正如它名称暗示的那样。\n\nEvents are changes in state. Their data needs to be passed to stateful container components parents.\n\nThis is called “state hoisting”. It’s accomplished by passing a callback from a container component to a child component.\n\n```jsx\nclass NameContainer extends React.Component {\n    render() {\n        return <Name onChange={newName => alert(newName)} />;\n    }\n}\n\nconst Name = ({ onChange }) => <input onChange={e => onChange(e.target.value)} />;\n```\n\n`Name`组件从`NameContainer`组件中获得`onChange`回调并在事件中调用。\n上面的`alert`只是简单演示并不修改状态，下面的代码将会修改`NameContainer`组件的状态。\n\n```jsx\nclass NameContainer extends React.Component {\n    constructor() {\n        super();\n        this.state = { name: '' };\n    }\n\n    render() {\n        return <Name onChange={newName => this.setState({ name: newName })} />;\n    }\n}\n```\n\n通过回调，状态被提升到维护局部状态的容器组件中。这给无状态函数一个清晰的边界和最大限度的可重用性。\n\n这个模式并不局限于无状态函数，因为无状态函数没有生命周期事件，该模式同样适用于无状态组件。\n\n受控的 input 就是一个使用了状态提升的重要模式。\n\n## 16. 受控的 input（Controlled input）\n\n直接讨论受控的 input 比较困难，我们先从不受控的 input 谈起。\n\n```jsx\n<input type=\"text\" />\n```\n\n当你在浏览器中输入框中输入时，你会看到输入框的值发生变化，这很正常。\n\n受控的 input 禁用 DOM 突变，它的值只能被组件修改，不能被 DOM 修改。\n\n```jsx\n<input type=\"text\" value=\"This won't change. Try it.\" />\n```\n\n上面的输入框有着固定值没有什么意义，下面输入框的值将会从`state`中获取。\n\n```jsx\nclass ControlledNameInput extends React.Component {\n    constructor() {\n        super();\n        this.state = { name: '' };\n    }\n\n    render() {\n        return <input type=\"text\" value={this.state.name} />;\n    }\n}\n```\n\n接着，修改输入框的值就是修改组件状态。\n\n```jsx\nreturn <input value={this.state.name} onChange={e => this.setState(e.target.value)} />;\n```\n\n这就是受控的 input，只有当组件的状态改变了才能改变 DOM，对于创建一致的 UI，有着非常大的作用。\n","slug":"react-patterns","published":1,"date":"2017-05-03T16:00:00.000Z","updated":"2018-12-07T02:40:07.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmav001lw8wksmer3twx","content":"<p><a href=\"http://reactpatterns.com/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"1-无状态函数（Stateless-function）\"><a href=\"#1-无状态函数（Stateless-function）\" class=\"headerlink\" title=\"1. 无状态函数（Stateless function）\"></a>1. 无状态函数（Stateless function）</h2><p>无状态函数是一种创建高度可复用组件的牛逼闪闪的方法，它自己不管理状态，他只是函数。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &lt;div&gt;Hi there!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p>可以传递<code>props</code>和<code>context</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">props, context</span>) =&gt;</span> &lt;div style=&#123;&#123; <span class=\"attr\">color</span>: context.color &#125;&#125;&gt;Hi &#123;props.name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p>也可以定义局部变量。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">props, context</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> style = &#123;</span><br><span class=\"line\">        fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">        color: context.color,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;style&#125;</span>&gt;</span>&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当然也可以不定义局部变量，改为函数。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getStyle = <span class=\"function\"><span class=\"params\">context</span> =&gt;</span> (&#123;</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">    color: context.color,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">props, context</span>) =&gt;</span> &lt;div style=&#123;getStyle(context)&#125;&gt;&#123;props.name&#125;&lt;<span class=\"regexp\">/div&gt;;</span></span><br></pre></td></tr></table></figure>\n<p>无状态函数也可以拥有<code>defaultProps</code>，<code>propTypes</code>和<code>contextTypes</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">Greeting.propTypes = &#123;</span><br><span class=\"line\">    name: PropTypes.string.isRequired,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Greeting.defaultProps = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Guest'</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Greeting.contextTypes = &#123;</span><br><span class=\"line\">    color: PropTypes.string,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-JSX-展开属性（JSX-Spread-Attributes）\"><a href=\"#2-JSX-展开属性（JSX-Spread-Attributes）\" class=\"headerlink\" title=\"2. JSX 展开属性（JSX Spread Attributes）\"></a>2. JSX 展开属性（JSX Spread Attributes）</h2><p>展开属性是 JSX 的一个特性，一种语法糖，用来将一个对象的所有属性作为 JSX 的属性传递。<br>以下两个例子是等价的</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// props written as attributes</span></span><br><span class=\"line\">&lt;main className=<span class=\"string\">\"main\"</span> role=<span class=\"string\">\"main\"</span>&gt;</span><br><span class=\"line\">    &#123;children&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/main&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// props \"spread\" from object</span></span><br><span class=\"line\">&lt;main &#123;...&#123; <span class=\"attr\">className</span>: <span class=\"string\">'main'</span>, <span class=\"attr\">role</span>: <span class=\"string\">'main'</span>, children &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>用它可以方便地将属性转发给底层组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> FancyDiv = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;div className=<span class=\"string\">\"fancy\"</span> &#123;...props&#125; /&gt;;</span><br></pre></td></tr></table></figure>\n<p>这时我给可以<code>FancyDiv</code>组件添加他关心和他不关心的属性。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;FancyDiv data-id=<span class=\"string\">\"my-fancy-div\"</span>&gt;So Fancy&lt;<span class=\"regexp\">/FancyDiv&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ output: &lt;div className=\"fancy\" data-id=\"my-fancy-div\"&gt;So Fancy&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>注意属性顺序很重要，如果外部传入<code>className</code>属性，那么<code>FancyDiv</code>定义的<code>className</code>将会被覆盖。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;FancyDiv className=<span class=\"string\">\"my-fancy-div\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: &lt;div className=\"my-fancy-div\"&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>\n<p>也可以让<code>FancyDiv</code>定义的<code>className</code>永远生效，只需要将它放在展开属性（{…props}）后面。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// my `className` clobbers your `className`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FancyDiv = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;div &#123;...props&#125; className=<span class=\"string\">\"fancy\"</span> /&gt;;</span><br></pre></td></tr></table></figure>\n<p>你应该优雅地处理这类情形，这种情况下我会合并使用者定义的<code>className</code>和组件自身的<code>className</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> FancyDiv = <span class=\"function\">(<span class=\"params\">&#123; className, ...props &#125;</span>) =&gt;</span> &lt;div className=&#123;[<span class=\"string\">'fancy'</span>, className].join(<span class=\"string\">' '</span>)&#125; &#123;...props&#125; /&gt;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-参数解构（Destructuring-Arguments）\"><a href=\"#3-参数解构（Destructuring-Arguments）\" class=\"headerlink\" title=\"3. 参数解构（Destructuring Arguments）\"></a>3. 参数解构（Destructuring Arguments）</h2><p>参数解构是 ES2015 的特性，它能够很好的配合无状态函数的参数。<br>以下两个例子是等价的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;div&gt;Hi &#123;props.name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">&#123; name &#125;</span>) =&gt;</span> &lt;div&gt;Hi &#123;name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\" target=\"_blank\" rel=\"noopener\">剩余参数</a>（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters\" target=\"_blank\" rel=\"noopener\">中文链接</a>）语法可以将剩余的参数手机到一个新对象中。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">&#123; name, ...props &#125;</span>) =&gt;</span> &lt;div&gt;Hi &#123;name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p>反过来，这个新对象可以通过展开属性将属性转发给底层组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">&#123; name, ...props &#125;</span>) =&gt;</span> &lt;div &#123;...props&#125;&gt;Hi &#123;name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p>应该避免将非 DOM 属性转发给原生组件，通过解构可以创建一个不包含高阶组件特有属性的新对象，因此解构可以让这个工作更加简单。</p>\n<h2 id=\"4-条件渲染（Conditional-Rendering）\"><a href=\"#4-条件渲染（Conditional-Rendering）\" class=\"headerlink\" title=\"4. 条件渲染（Conditional Rendering）\"></a>4. 条件渲染（Conditional Rendering）</h2><p>组件定义内部是不能使用 if/else 条件语句的，但是可以使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\" target=\"_blank\" rel=\"noopener\">条件表达式</a>。</p>\n<p>if</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    condition &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `truthy`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>else</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    condition || <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `falsey`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>if-else (tidy one-liners)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    condition ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `truthy`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span> : <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `falsey`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>if-else (big blocks)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    condition ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `truthy`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span> : <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `falsey`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-Children-类型（Children-types）\"><a href=\"#5-Children-类型（Children-types）\" class=\"headerlink\" title=\"5. Children 类型（Children types）\"></a>5. Children 类型（Children types）</h2><p>React 中 children 有好几种类型，常见的有数组和字符串。</p>\n<p>字符串</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;Hello World!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>array</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;[<span class=\"string\">'Hello '</span>, &lt;span&gt;World&lt;<span class=\"regexp\">/span&gt;, '!']&#125;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>children 也可以是函数，但是必须和父组件协作才能用。</p>\n<p>function</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &#123;() =&gt; &#123; <span class=\"keyword\">return</span> <span class=\"string\">\"hello world!\"</span>&#125;()&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-数组类型的-children（Array-as-children）\"><a href=\"#6-数组类型的-children（Array-as-children）\" class=\"headerlink\" title=\"6. 数组类型的 children（Array as children）\"></a>6. 数组类型的 children（Array as children）</h2><p>数组类型的 children 是非常常见的，列表就是这么渲染出来的。使用<code>map</code>函数就可以创建 React 元素数组。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;[<span class=\"string\">'first'</span>, <span class=\"string\">'second'</span>].map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> (</span><br><span class=\"line\">        &lt;li&gt;&#123;item&#125;&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ))&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n<p>和下面这个数组字面量方式等价</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;&#123;[<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>first<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span>, &lt;li&gt;second&lt;<span class=\"regexp\">/li&gt;]&#125;&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n<p>为了更加简洁，可以结合解构，JSX 展开属性，其他组件一起使用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;arrayOfMessageObjects.map(<span class=\"function\">(<span class=\"params\">&#123; id, ...message &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">        &lt;Message key=&#123;id&#125; &#123;...message&#125; /&gt;</span><br><span class=\"line\">    ))&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/ul&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-函数类型的-children（Function-as-children）\"><a href=\"#7-函数类型的-children（Function-as-children）\" class=\"headerlink\" title=\"7. 函数类型的 children（Function as children）\"></a>7. 函数类型的 children（Function as children）</h2><p>函数类型的 children 不是天然有用的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;() =&gt; &#123; <span class=\"keyword\">return</span> <span class=\"string\">\"hello world!\"</span>&#125;()&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这种技术通常被称为渲染回调，可以给组件创作带来更多空间和便利。比如<a href=\"https://github.com/chenglou/react-motion\" target=\"_blank\" rel=\"noopener\">ReactMotion</a>使用这种高能技术以后，渲染逻辑可以由使用者提供，而不是被类库写死。更多细节，请参考下一章渲染回调。</p>\n<h2 id=\"8-渲染回调（Render-callback）\"><a href=\"#8-渲染回调（Render-callback）\" class=\"headerlink\" title=\"8. 渲染回调（Render callback）\"></a>8. 渲染回调（Render callback）</h2><p>下面这个组件使用了渲染回调技术，它没什么用，但它是一个很好的开端。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Width = <span class=\"function\">(<span class=\"params\">&#123; children &#125;</span>) =&gt;</span> children(<span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n<p>该组件将 children 当做函数来调用，并传递了一个数字类型值为 500 的参数。</p>\n<p>下面我们将使用该组件，并给它传递一个函数类型的 children.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Width&gt;&#123;width =&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>window is &#123;width&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>&#125;&lt;<span class=\"regexp\">/Width&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们将得到以下结果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>window is 500<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>有了这些设置，我们可以根据宽度来决定渲染什么。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Width&gt;&#123;width =&gt; (width &gt; <span class=\"number\">600</span> ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>min-width requirement met!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> : <span class=\"literal\">null</span>)&#125;&lt;<span class=\"regexp\">/Width&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果这个逻辑会被多次使用，我们可以创建一个新组件来封装可重用逻辑。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MinWidth = <span class=\"function\">(<span class=\"params\">&#123; width: minWidth, children &#125;</span>) =&gt;</span> &lt;Width&gt;&#123;width =&gt; (width &gt; minWidth ? children : <span class=\"literal\">null</span>)&#125;&lt;<span class=\"regexp\">/Width&gt;;</span></span><br></pre></td></tr></table></figure>\n<p>很明显这对于一个有着固定宽度的组件没有什么意义，但对一个监听浏览器窗口宽度的组件就有意义了，以下是示例代码。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowWidth</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">width</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">width</span>: <span class=\"built_in\">window</span>.innerWidth &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>, (&#123; target &#125;) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">width</span>: target.innerWidth &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.width);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很多开发者更喜欢高阶组件完成类似功能，这是个人偏好问题。</p>\n<h2 id=\"9-Children-值传（Children-pass-through）\"><a href=\"#9-Children-值传（Children-pass-through）\" class=\"headerlink\" title=\"9. Children 值传（Children pass-through）\"></a>9. Children 值传（Children pass-through）</h2><p>有时候你可能会创建一个组件，只用来处理上下文并且直接渲染其 children.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeContextProvider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getChildContext() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"attr\">some</span>: <span class=\"string\">'context'</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// how best do we return `children`?</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在你需要作出决定，将<code>children</code>包裹在一个<code>&lt;div /&gt;</code>中，还是直接返回<code>children</code>。第一种做法多了一层标签（可能导致样式失效），第二种做法将会导致一个错误。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// option 1: extra div</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// option 2: unhelpful errors</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> children;</span><br></pre></td></tr></table></figure>\n<p>最好的做法是将<code>children</code>看做一个不透明的数据类型，<code>React</code>提供了<code>React.Children</code>来合理的处理<code>children</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> React.Children.only(<span class=\"keyword\">this</span>.props.children);</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-组件代理（Proxy-component）\"><a href=\"#10-组件代理（Proxy-component）\" class=\"headerlink\" title=\"10. 组件代理（Proxy component）\"></a>10. 组件代理（Proxy component）</h2><p>（我不确定这个名字是否有意义）<br>按钮（Button）在网页应用中随处可见，每一个按钮都必须有一个<code>type</code>属性并设成<code>button</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button type=<span class=\"string\">\"button\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>书写次数多了，也就容易导致错误，我们可以创建一个高阶组件代理该低阶组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Button = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span></span><br><span class=\"line\">  &lt;button type=<span class=\"string\">\"button\"</span> &#123;...props&#125;&gt;</span><br></pre></td></tr></table></figure>\n<p>这时我们可以使用<code>Button</code>代替<code>button</code>，确保<code>type</code>属性总被正确使用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button /&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;button type=\"button\"&gt;&lt;button&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Button className=<span class=\"string\">\"CTA\"</span>&gt;Send Money&lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ &lt;button type=\"button\" class=\"CTA\"&gt;Send Money&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-使用样式（Style-component）\"><a href=\"#11-使用样式（Style-component）\" class=\"headerlink\" title=\"11. 使用样式（Style component）\"></a>11. 使用样式（Style component）</h2><p>这是一种使用样式的组件代理。<br>假设我们通过使用<code>class</code>将一个<code>button</code>装饰成主要（primary）按钮。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button type=<span class=\"string\">\"button\"</span> className=<span class=\"string\">\"btn btn-primary\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过两个单一职责组件达到此目的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PrimaryBtn = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;Btn &#123;...props&#125; primary /&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Btn = <span class=\"function\">(<span class=\"params\">&#123; className, primary, ...props &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">    &lt;button type=<span class=\"string\">\"button\"</span> className=&#123;classnames(<span class=\"string\">'btn'</span>, primary &amp;&amp; <span class=\"string\">'btn-primary'</span>, className)&#125; &#123;...props&#125; /&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>便于理解，请看下面的图示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PrimaryBtn()</span><br><span class=\"line\">  ↳ Btn(&#123;primary: true&#125;)</span><br><span class=\"line\">    ↳ Button(&#123;className: &quot;btn btn-primary&quot;&#125;, type: &quot;button&quot;&#125;)</span><br><span class=\"line\">      ↳ &apos;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;/button&gt;&apos;</span><br></pre></td></tr></table></figure>\n<p>通过这些组件，以下代码是等价的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;PrimaryBtn /&gt;</span><br><span class=\"line\">&lt;Btn primary /&gt;</span><br><span class=\"line\">&lt;button type=<span class=\"string\">\"button\"</span> className=<span class=\"string\">\"btn btn-primary\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>对于样式维护来说真是一大福音，它将样式问题封装在单一组件中。</p>\n<h2 id=\"12-事件切换（Event-switch）\"><a href=\"#12-事件切换（Event-switch）\" class=\"headerlink\" title=\"12. 事件切换（Event switch）\"></a>12. 事件切换（Event switch）</h2><p>在写事件回调时通过采用<code>handle{EventName}</code>规则。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">handleClick(e) &#123; <span class=\"comment\">/* do something */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>对于一个需要处理多种事件事件的组件来说，这些函数名显得非常啰嗦。函数名中也不会带有更多信息，因为他们一般直接调用其他<code>action</code>或<code>function</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">handleClick() &#123; <span class=\"built_in\">require</span>(<span class=\"string\">\"./actions/doStuff\"</span>)(<span class=\"comment\">/* action stuff */</span>) &#125;</span><br><span class=\"line\">handleMouseEnter() &#123; <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">hovered</span>: <span class=\"literal\">true</span> &#125;) &#125;</span><br><span class=\"line\">handleMouseLeave() &#123; <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">hovered</span>: <span class=\"literal\">false</span> &#125;) &#125;</span><br></pre></td></tr></table></figure>\n<p>下面只给组件写一个事件处理函数，并通过<code>event.type</code>区分。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">handleEvent(&#123;type&#125;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"click\"</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">require</span>(<span class=\"string\">\"./actions/doStuff\"</span>)(<span class=\"comment\">/* action dates */</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"mouseenter\"</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">hovered</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"mouseleave\"</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">hovered</span>: <span class=\"literal\">false</span> &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.warn(<span class=\"string\">`No case for event type \"<span class=\"subst\">$&#123;type&#125;</span>\"`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者，对于简单组件，你可以通过胖箭头函数方式直接调用<code>action</code>或<code>function</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;() =&gt; someImportedAction(&#123; <span class=\"attr\">action</span>: <span class=\"string\">'DO_STUFF'</span> &#125;)&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>不要担心性能问题，知道性能问题爆发。一定不要过早进行性能优化。</p>\n<h2 id=\"13-布局组件（Layout-component）\"><a href=\"#13-布局组件（Layout-component）\" class=\"headerlink\" title=\"13. 布局组件（Layout component）\"></a>13. 布局组件（Layout component）</h2><p>布局组件会产生一些静态 DOM 元素，他们可能不会有任何改变，即使改变了也不会很频繁。<br>下面是一个并排显示两个子组件的组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;HorizontalSplit leftSide=&#123;&lt;SomeSmartComponent /&gt;&#125; rightSide=&#123;&lt;AnotherSmartComponent /&gt;&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>我们可以尽量去优化这个组件。<br>虽然<code>HorizontalSplit</code>是两个组件的父组件，但是它绝不是这两个组件的所有者。我们可以让它永不更新，不影响组件的生命周期。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HorizontalSplit</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    shouldComponentUpdate() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        &lt;FlexContainer&gt;</span><br><span class=\"line\">            &lt;div&gt;&#123;<span class=\"keyword\">this</span>.props.leftSide&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div&gt;&#123;this.props.rightSide&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/FlexContainer&gt;;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"14-容器组件（Container-component）\"><a href=\"#14-容器组件（Container-component）\" class=\"headerlink\" title=\"14. 容器组件（Container component）\"></a>14. 容器组件（Container component）</h2><blockquote>\n<p>“容器负责获取数据并渲染其子组件，这就够了”<br>—Jason Bonta<br>假设我们已经有了可复用的<code>CommentList</code>组件。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CommentList = <span class=\"function\">(<span class=\"params\">&#123; comments &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &#123;comments.map(<span class=\"function\"><span class=\"params\">comment</span> =&gt;</span> (</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">                &#123;comment.body&#125;-&#123;comment.author&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        ))&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/u</span>l&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>接下来我们可以创建一个新组件负责获取数据并渲染无状态的<code>CommentList</code>组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommentListContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">comments</span>: [] &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">      url: <span class=\"string\">\"/my-comments.json\"</span>,</span><br><span class=\"line\">      dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">      success: <span class=\"function\"><span class=\"params\">comments</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">comments</span>: comments&#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">CommentList</span> <span class=\"attr\">comments</span>=<span class=\"string\">&#123;this.state.comments&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们可以给不同的应用上下文创建不同的容器组件。</p>\n<h2 id=\"14-高阶组件（Higher-order-component）\"><a href=\"#14-高阶组件（Higher-order-component）\" class=\"headerlink\" title=\"14. 高阶组件（Higher-order component）\"></a>14. 高阶组件（Higher-order component）</h2><p><a href=\"https://en.wikipedia.org/wiki/Higher-order_function\" target=\"_blank\" rel=\"noopener\">高阶函数</a>是一个接受函数类型的参数或返回一个新函数的函数。那么什么是高阶组件呢？<br>如果你已经开始使用容器组件，它们都是包裹在一个函数中的通用容器。<br>下面我们从一个无状态的<code>Greeting</code>组件开始。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Connecting...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hi &#123;name&#125;!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果<code>Greeting</code>组件接到<code>props.name</code>，它就回去渲染这个数据，否则他会说正在连接。现在我们创建一个高阶组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Connect = <span class=\"function\"><span class=\"params\">ComposedComponent</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">name</span>: <span class=\"string\">''</span> &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentDidMount() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// this would fetch or connect to a store</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Michael'</span> &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ComposedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; <span class=\"attr\">name</span>=<span class=\"string\">&#123;this.state.name&#125;</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;;</span></span><br></pre></td></tr></table></figure>\n<p>它就是一个函数，返回一个渲染作为参数传递进去的组件的新组件。<br>最后，我们需要用<code>Connect</code>组件将<code>Greeting</code>组件包裹起来，如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ConnectedMyComponent = Connect(Greeting);</span><br></pre></td></tr></table></figure>\n<p>高阶组件是一个功能很强的模式，可以用来获取数据并给其他无状态组件提供数据。</p>\n<h2 id=\"15-状态提升（State-hoisting）\"><a href=\"#15-状态提升（State-hoisting）\" class=\"headerlink\" title=\"15. 状态提升（State hoisting）\"></a>15. 状态提升（State hoisting）</h2><p>无状态组件并不持有状态，正如它名称暗示的那样。</p>\n<p>Events are changes in state. Their data needs to be passed to stateful container components parents.</p>\n<p>This is called “state hoisting”. It’s accomplished by passing a callback from a container component to a child component.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Name</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;newName</span> =&gt;</span> alert(newName)&#125; /&gt;;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\">const Name = (&#123; onChange &#125;) =&gt; &lt;input onChange=&#123;e =&gt; onChange(e.target.value)&#125; /&gt;;</span><br></pre></td></tr></table></figure>\n<p><code>Name</code>组件从<code>NameContainer</code>组件中获得<code>onChange</code>回调并在事件中调用。<br>上面的<code>alert</code>只是简单演示并不修改状态，下面的代码将会修改<code>NameContainer</code>组件的状态。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">name</span>: <span class=\"string\">''</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Name</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;newName</span> =&gt;</span> this.setState(&#123; name: newName &#125;)&#125; /&gt;;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>通过回调，状态被提升到维护局部状态的容器组件中。这给无状态函数一个清晰的边界和最大限度的可重用性。</p>\n<p>这个模式并不局限于无状态函数，因为无状态函数没有生命周期事件，该模式同样适用于无状态组件。</p>\n<p>受控的 input 就是一个使用了状态提升的重要模式。</p>\n<h2 id=\"16-受控的-input（Controlled-input）\"><a href=\"#16-受控的-input（Controlled-input）\" class=\"headerlink\" title=\"16. 受控的 input（Controlled input）\"></a>16. 受控的 input（Controlled input）</h2><p>直接讨论受控的 input 比较困难，我们先从不受控的 input 谈起。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">\"text\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>当你在浏览器中输入框中输入时，你会看到输入框的值发生变化，这很正常。</p>\n<p>受控的 input 禁用 DOM 突变，它的值只能被组件修改，不能被 DOM 修改。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">\"text\"</span> value=<span class=\"string\">\"This won't change. Try it.\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的输入框有着固定值没有什么意义，下面输入框的值将会从<code>state</code>中获取。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ControlledNameInput</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">name</span>: <span class=\"string\">''</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.name&#125;</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>接着，修改输入框的值就是修改组件状态。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.name&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span> =&gt;</span> this.setState(e.target.value)&#125; /&gt;;</span></span><br></pre></td></tr></table></figure>\n<p>这就是受控的 input，只有当组件的状态改变了才能改变 DOM，对于创建一致的 UI，有着非常大的作用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://reactpatterns.com/\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<h2 id=\"1-无状态函数（Stateless-function）\"><a href=\"#1-无状态函数（Stateless-function）\" class=\"headerlink\" title=\"1. 无状态函数（Stateless function）\"></a>1. 无状态函数（Stateless function）</h2><p>无状态函数是一种创建高度可复用组件的牛逼闪闪的方法，它自己不管理状态，他只是函数。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &lt;div&gt;Hi there!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p>可以传递<code>props</code>和<code>context</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">props, context</span>) =&gt;</span> &lt;div style=&#123;&#123; <span class=\"attr\">color</span>: context.color &#125;&#125;&gt;Hi &#123;props.name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p>也可以定义局部变量。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">props, context</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> style = &#123;</span><br><span class=\"line\">        fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">        color: context.color,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;style&#125;</span>&gt;</span>&#123;props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当然也可以不定义局部变量，改为函数。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getStyle = <span class=\"function\"><span class=\"params\">context</span> =&gt;</span> (&#123;</span><br><span class=\"line\">    fontWeight: <span class=\"string\">'bold'</span>,</span><br><span class=\"line\">    color: context.color,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">props, context</span>) =&gt;</span> &lt;div style=&#123;getStyle(context)&#125;&gt;&#123;props.name&#125;&lt;<span class=\"regexp\">/div&gt;;</span></span><br></pre></td></tr></table></figure>\n<p>无状态函数也可以拥有<code>defaultProps</code>，<code>propTypes</code>和<code>contextTypes</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">Greeting.propTypes = &#123;</span><br><span class=\"line\">    name: PropTypes.string.isRequired,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Greeting.defaultProps = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Guest'</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Greeting.contextTypes = &#123;</span><br><span class=\"line\">    color: PropTypes.string,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-JSX-展开属性（JSX-Spread-Attributes）\"><a href=\"#2-JSX-展开属性（JSX-Spread-Attributes）\" class=\"headerlink\" title=\"2. JSX 展开属性（JSX Spread Attributes）\"></a>2. JSX 展开属性（JSX Spread Attributes）</h2><p>展开属性是 JSX 的一个特性，一种语法糖，用来将一个对象的所有属性作为 JSX 的属性传递。<br>以下两个例子是等价的</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// props written as attributes</span></span><br><span class=\"line\">&lt;main className=<span class=\"string\">\"main\"</span> role=<span class=\"string\">\"main\"</span>&gt;</span><br><span class=\"line\">    &#123;children&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/main&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// props \"spread\" from object</span></span><br><span class=\"line\">&lt;main &#123;...&#123; <span class=\"attr\">className</span>: <span class=\"string\">'main'</span>, <span class=\"attr\">role</span>: <span class=\"string\">'main'</span>, children &#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>用它可以方便地将属性转发给底层组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> FancyDiv = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;div className=<span class=\"string\">\"fancy\"</span> &#123;...props&#125; /&gt;;</span><br></pre></td></tr></table></figure>\n<p>这时我给可以<code>FancyDiv</code>组件添加他关心和他不关心的属性。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;FancyDiv data-id=<span class=\"string\">\"my-fancy-div\"</span>&gt;So Fancy&lt;<span class=\"regexp\">/FancyDiv&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ output: &lt;div className=\"fancy\" data-id=\"my-fancy-div\"&gt;So Fancy&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>注意属性顺序很重要，如果外部传入<code>className</code>属性，那么<code>FancyDiv</code>定义的<code>className</code>将会被覆盖。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;FancyDiv className=<span class=\"string\">\"my-fancy-div\"</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// output: &lt;div className=\"my-fancy-div\"&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure>\n<p>也可以让<code>FancyDiv</code>定义的<code>className</code>永远生效，只需要将它放在展开属性（{…props}）后面。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// my `className` clobbers your `className`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FancyDiv = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;div &#123;...props&#125; className=<span class=\"string\">\"fancy\"</span> /&gt;;</span><br></pre></td></tr></table></figure>\n<p>你应该优雅地处理这类情形，这种情况下我会合并使用者定义的<code>className</code>和组件自身的<code>className</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> FancyDiv = <span class=\"function\">(<span class=\"params\">&#123; className, ...props &#125;</span>) =&gt;</span> &lt;div className=&#123;[<span class=\"string\">'fancy'</span>, className].join(<span class=\"string\">' '</span>)&#125; &#123;...props&#125; /&gt;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-参数解构（Destructuring-Arguments）\"><a href=\"#3-参数解构（Destructuring-Arguments）\" class=\"headerlink\" title=\"3. 参数解构（Destructuring Arguments）\"></a>3. 参数解构（Destructuring Arguments）</h2><p>参数解构是 ES2015 的特性，它能够很好的配合无状态函数的参数。<br>以下两个例子是等价的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;div&gt;Hi &#123;props.name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">&#123; name &#125;</span>) =&gt;</span> &lt;div&gt;Hi &#123;name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\" target=\"_blank\" rel=\"noopener\">剩余参数</a>（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters\" target=\"_blank\" rel=\"noopener\">中文链接</a>）语法可以将剩余的参数手机到一个新对象中。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">&#123; name, ...props &#125;</span>) =&gt;</span> &lt;div&gt;Hi &#123;name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p>反过来，这个新对象可以通过展开属性将属性转发给底层组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">&#123; name, ...props &#125;</span>) =&gt;</span> &lt;div &#123;...props&#125;&gt;Hi &#123;name&#125;!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>\n<p>应该避免将非 DOM 属性转发给原生组件，通过解构可以创建一个不包含高阶组件特有属性的新对象，因此解构可以让这个工作更加简单。</p>\n<h2 id=\"4-条件渲染（Conditional-Rendering）\"><a href=\"#4-条件渲染（Conditional-Rendering）\" class=\"headerlink\" title=\"4. 条件渲染（Conditional Rendering）\"></a>4. 条件渲染（Conditional Rendering）</h2><p>组件定义内部是不能使用 if/else 条件语句的，但是可以使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator\" target=\"_blank\" rel=\"noopener\">条件表达式</a>。</p>\n<p>if</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    condition &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `truthy`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>else</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    condition || <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `falsey`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>if-else (tidy one-liners)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    condition ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `truthy`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span> : <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `falsey`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>if-else (big blocks)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    condition ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `truthy`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span> : <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>Rendered when `falsey`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-Children-类型（Children-types）\"><a href=\"#5-Children-类型（Children-types）\" class=\"headerlink\" title=\"5. Children 类型（Children types）\"></a>5. Children 类型（Children types）</h2><p>React 中 children 有好几种类型，常见的有数组和字符串。</p>\n<p>字符串</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;Hello World!<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>array</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;[<span class=\"string\">'Hello '</span>, &lt;span&gt;World&lt;<span class=\"regexp\">/span&gt;, '!']&#125;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>children 也可以是函数，但是必须和父组件协作才能用。</p>\n<p>function</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &#123;() =&gt; &#123; <span class=\"keyword\">return</span> <span class=\"string\">\"hello world!\"</span>&#125;()&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-数组类型的-children（Array-as-children）\"><a href=\"#6-数组类型的-children（Array-as-children）\" class=\"headerlink\" title=\"6. 数组类型的 children（Array as children）\"></a>6. 数组类型的 children（Array as children）</h2><p>数组类型的 children 是非常常见的，列表就是这么渲染出来的。使用<code>map</code>函数就可以创建 React 元素数组。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;[<span class=\"string\">'first'</span>, <span class=\"string\">'second'</span>].map(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> (</span><br><span class=\"line\">        &lt;li&gt;&#123;item&#125;&lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    ))&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n<p>和下面这个数组字面量方式等价</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;&#123;[<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>first<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span>, &lt;li&gt;second&lt;<span class=\"regexp\">/li&gt;]&#125;&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>\n<p>为了更加简洁，可以结合解构，JSX 展开属性，其他组件一起使用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    &#123;arrayOfMessageObjects.map(<span class=\"function\">(<span class=\"params\">&#123; id, ...message &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">        &lt;Message key=&#123;id&#125; &#123;...message&#125; /&gt;</span><br><span class=\"line\">    ))&#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/ul&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-函数类型的-children（Function-as-children）\"><a href=\"#7-函数类型的-children（Function-as-children）\" class=\"headerlink\" title=\"7. 函数类型的 children（Function as children）\"></a>7. 函数类型的 children（Function as children）</h2><p>函数类型的 children 不是天然有用的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;() =&gt; &#123; <span class=\"keyword\">return</span> <span class=\"string\">\"hello world!\"</span>&#125;()&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这种技术通常被称为渲染回调，可以给组件创作带来更多空间和便利。比如<a href=\"https://github.com/chenglou/react-motion\" target=\"_blank\" rel=\"noopener\">ReactMotion</a>使用这种高能技术以后，渲染逻辑可以由使用者提供，而不是被类库写死。更多细节，请参考下一章渲染回调。</p>\n<h2 id=\"8-渲染回调（Render-callback）\"><a href=\"#8-渲染回调（Render-callback）\" class=\"headerlink\" title=\"8. 渲染回调（Render callback）\"></a>8. 渲染回调（Render callback）</h2><p>下面这个组件使用了渲染回调技术，它没什么用，但它是一个很好的开端。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Width = <span class=\"function\">(<span class=\"params\">&#123; children &#125;</span>) =&gt;</span> children(<span class=\"number\">500</span>);</span><br></pre></td></tr></table></figure>\n<p>该组件将 children 当做函数来调用，并传递了一个数字类型值为 500 的参数。</p>\n<p>下面我们将使用该组件，并给它传递一个函数类型的 children.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Width&gt;&#123;width =&gt; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>window is &#123;width&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>&#125;&lt;<span class=\"regexp\">/Width&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们将得到以下结果。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>window is 500<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>有了这些设置，我们可以根据宽度来决定渲染什么。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Width&gt;&#123;width =&gt; (width &gt; <span class=\"number\">600</span> ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>min-width requirement met!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span> : <span class=\"literal\">null</span>)&#125;&lt;<span class=\"regexp\">/Width&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果这个逻辑会被多次使用，我们可以创建一个新组件来封装可重用逻辑。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MinWidth = <span class=\"function\">(<span class=\"params\">&#123; width: minWidth, children &#125;</span>) =&gt;</span> &lt;Width&gt;&#123;width =&gt; (width &gt; minWidth ? children : <span class=\"literal\">null</span>)&#125;&lt;<span class=\"regexp\">/Width&gt;;</span></span><br></pre></td></tr></table></figure>\n<p>很明显这对于一个有着固定宽度的组件没有什么意义，但对一个监听浏览器窗口宽度的组件就有意义了，以下是示例代码。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WindowWidth</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">width</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">width</span>: <span class=\"built_in\">window</span>.innerWidth &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'resize'</span>, (&#123; target &#125;) =&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">width</span>: target.innerWidth &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.props.children(<span class=\"keyword\">this</span>.state.width);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很多开发者更喜欢高阶组件完成类似功能，这是个人偏好问题。</p>\n<h2 id=\"9-Children-值传（Children-pass-through）\"><a href=\"#9-Children-值传（Children-pass-through）\" class=\"headerlink\" title=\"9. Children 值传（Children pass-through）\"></a>9. Children 值传（Children pass-through）</h2><p>有时候你可能会创建一个组件，只用来处理上下文并且直接渲染其 children.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeContextProvider</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    getChildContext() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123; <span class=\"attr\">some</span>: <span class=\"string\">'context'</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// how best do we return `children`?</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在你需要作出决定，将<code>children</code>包裹在一个<code>&lt;div /&gt;</code>中，还是直接返回<code>children</code>。第一种做法多了一层标签（可能导致样式失效），第二种做法将会导致一个错误。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// option 1: extra div</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;children&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// option 2: unhelpful errors</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> children;</span><br></pre></td></tr></table></figure>\n<p>最好的做法是将<code>children</code>看做一个不透明的数据类型，<code>React</code>提供了<code>React.Children</code>来合理的处理<code>children</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> React.Children.only(<span class=\"keyword\">this</span>.props.children);</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-组件代理（Proxy-component）\"><a href=\"#10-组件代理（Proxy-component）\" class=\"headerlink\" title=\"10. 组件代理（Proxy component）\"></a>10. 组件代理（Proxy component）</h2><p>（我不确定这个名字是否有意义）<br>按钮（Button）在网页应用中随处可见，每一个按钮都必须有一个<code>type</code>属性并设成<code>button</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button type=<span class=\"string\">\"button\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>书写次数多了，也就容易导致错误，我们可以创建一个高阶组件代理该低阶组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Button = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span></span><br><span class=\"line\">  &lt;button type=<span class=\"string\">\"button\"</span> &#123;...props&#125;&gt;</span><br></pre></td></tr></table></figure>\n<p>这时我们可以使用<code>Button</code>代替<code>button</code>，确保<code>type</code>属性总被正确使用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Button /&gt;</span><br><span class=\"line\"><span class=\"comment\">// &lt;button type=\"button\"&gt;&lt;button&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Button className=<span class=\"string\">\"CTA\"</span>&gt;Send Money&lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ &lt;button type=\"button\" class=\"CTA\"&gt;Send Money&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-使用样式（Style-component）\"><a href=\"#11-使用样式（Style-component）\" class=\"headerlink\" title=\"11. 使用样式（Style component）\"></a>11. 使用样式（Style component）</h2><p>这是一种使用样式的组件代理。<br>假设我们通过使用<code>class</code>将一个<code>button</code>装饰成主要（primary）按钮。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;button type=<span class=\"string\">\"button\"</span> className=<span class=\"string\">\"btn btn-primary\"</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>我们可以通过两个单一职责组件达到此目的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> PrimaryBtn = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> &lt;Btn &#123;...props&#125; primary /&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Btn = <span class=\"function\">(<span class=\"params\">&#123; className, primary, ...props &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">    &lt;button type=<span class=\"string\">\"button\"</span> className=&#123;classnames(<span class=\"string\">'btn'</span>, primary &amp;&amp; <span class=\"string\">'btn-primary'</span>, className)&#125; &#123;...props&#125; /&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>便于理解，请看下面的图示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">PrimaryBtn()</span><br><span class=\"line\">  ↳ Btn(&#123;primary: true&#125;)</span><br><span class=\"line\">    ↳ Button(&#123;className: &quot;btn btn-primary&quot;&#125;, type: &quot;button&quot;&#125;)</span><br><span class=\"line\">      ↳ &apos;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;&lt;/button&gt;&apos;</span><br></pre></td></tr></table></figure>\n<p>通过这些组件，以下代码是等价的。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;PrimaryBtn /&gt;</span><br><span class=\"line\">&lt;Btn primary /&gt;</span><br><span class=\"line\">&lt;button type=<span class=\"string\">\"button\"</span> className=<span class=\"string\">\"btn btn-primary\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>对于样式维护来说真是一大福音，它将样式问题封装在单一组件中。</p>\n<h2 id=\"12-事件切换（Event-switch）\"><a href=\"#12-事件切换（Event-switch）\" class=\"headerlink\" title=\"12. 事件切换（Event switch）\"></a>12. 事件切换（Event switch）</h2><p>在写事件回调时通过采用<code>handle{EventName}</code>规则。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">handleClick(e) &#123; <span class=\"comment\">/* do something */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>对于一个需要处理多种事件事件的组件来说，这些函数名显得非常啰嗦。函数名中也不会带有更多信息，因为他们一般直接调用其他<code>action</code>或<code>function</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">handleClick() &#123; <span class=\"built_in\">require</span>(<span class=\"string\">\"./actions/doStuff\"</span>)(<span class=\"comment\">/* action stuff */</span>) &#125;</span><br><span class=\"line\">handleMouseEnter() &#123; <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">hovered</span>: <span class=\"literal\">true</span> &#125;) &#125;</span><br><span class=\"line\">handleMouseLeave() &#123; <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">hovered</span>: <span class=\"literal\">false</span> &#125;) &#125;</span><br></pre></td></tr></table></figure>\n<p>下面只给组件写一个事件处理函数，并通过<code>event.type</code>区分。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">handleEvent(&#123;type&#125;) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"click\"</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">require</span>(<span class=\"string\">\"./actions/doStuff\"</span>)(<span class=\"comment\">/* action dates */</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"mouseenter\"</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">hovered</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"mouseleave\"</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">hovered</span>: <span class=\"literal\">false</span> &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">console</span>.warn(<span class=\"string\">`No case for event type \"<span class=\"subst\">$&#123;type&#125;</span>\"`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>或者，对于简单组件，你可以通过胖箭头函数方式直接调用<code>action</code>或<code>function</code>。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div onClick=&#123;() =&gt; someImportedAction(&#123; <span class=\"attr\">action</span>: <span class=\"string\">'DO_STUFF'</span> &#125;)&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>不要担心性能问题，知道性能问题爆发。一定不要过早进行性能优化。</p>\n<h2 id=\"13-布局组件（Layout-component）\"><a href=\"#13-布局组件（Layout-component）\" class=\"headerlink\" title=\"13. 布局组件（Layout component）\"></a>13. 布局组件（Layout component）</h2><p>布局组件会产生一些静态 DOM 元素，他们可能不会有任何改变，即使改变了也不会很频繁。<br>下面是一个并排显示两个子组件的组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;HorizontalSplit leftSide=&#123;&lt;SomeSmartComponent /&gt;&#125; rightSide=&#123;&lt;AnotherSmartComponent /&gt;&#125; /&gt;</span><br></pre></td></tr></table></figure>\n<p>我们可以尽量去优化这个组件。<br>虽然<code>HorizontalSplit</code>是两个组件的父组件，但是它绝不是这两个组件的所有者。我们可以让它永不更新，不影响组件的生命周期。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HorizontalSplit</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    shouldComponentUpdate() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        &lt;FlexContainer&gt;</span><br><span class=\"line\">            &lt;div&gt;&#123;<span class=\"keyword\">this</span>.props.leftSide&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            &lt;div&gt;&#123;this.props.rightSide&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">        &lt;<span class=\"regexp\">/FlexContainer&gt;;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"14-容器组件（Container-component）\"><a href=\"#14-容器组件（Container-component）\" class=\"headerlink\" title=\"14. 容器组件（Container component）\"></a>14. 容器组件（Container component）</h2><blockquote>\n<p>“容器负责获取数据并渲染其子组件，这就够了”<br>—Jason Bonta<br>假设我们已经有了可复用的<code>CommentList</code>组件。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> CommentList = <span class=\"function\">(<span class=\"params\">&#123; comments &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &#123;comments.map(<span class=\"function\"><span class=\"params\">comment</span> =&gt;</span> (</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">                &#123;comment.body&#125;-&#123;comment.author&#125;</span><br><span class=\"line\">            &lt;<span class=\"regexp\">/li&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        ))&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/u</span>l&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>接下来我们可以创建一个新组件负责获取数据并渲染无状态的<code>CommentList</code>组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommentListContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">comments</span>: [] &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    $.ajax(&#123;</span><br><span class=\"line\">      url: <span class=\"string\">\"/my-comments.json\"</span>,</span><br><span class=\"line\">      dataType: <span class=\"string\">'json'</span>,</span><br><span class=\"line\">      success: <span class=\"function\"><span class=\"params\">comments</span> =&gt;</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;<span class=\"attr\">comments</span>: comments&#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">CommentList</span> <span class=\"attr\">comments</span>=<span class=\"string\">&#123;this.state.comments&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>我们可以给不同的应用上下文创建不同的容器组件。</p>\n<h2 id=\"14-高阶组件（Higher-order-component）\"><a href=\"#14-高阶组件（Higher-order-component）\" class=\"headerlink\" title=\"14. 高阶组件（Higher-order component）\"></a>14. 高阶组件（Higher-order component）</h2><p><a href=\"https://en.wikipedia.org/wiki/Higher-order_function\" target=\"_blank\" rel=\"noopener\">高阶函数</a>是一个接受函数类型的参数或返回一个新函数的函数。那么什么是高阶组件呢？<br>如果你已经开始使用容器组件，它们都是包裹在一个函数中的通用容器。<br>下面我们从一个无状态的<code>Greeting</code>组件开始。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Greeting = <span class=\"function\">(<span class=\"params\">&#123; name &#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Connecting...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Hi &#123;name&#125;!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>如果<code>Greeting</code>组件接到<code>props.name</code>，它就回去渲染这个数据，否则他会说正在连接。现在我们创建一个高阶组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Connect = <span class=\"function\"><span class=\"params\">ComposedComponent</span> =&gt;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>();</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">name</span>: <span class=\"string\">''</span> &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        componentDidMount() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// this would fetch or connect to a store</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'Michael'</span> &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ComposedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; <span class=\"attr\">name</span>=<span class=\"string\">&#123;this.state.name&#125;</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">        &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;;</span></span><br></pre></td></tr></table></figure>\n<p>它就是一个函数，返回一个渲染作为参数传递进去的组件的新组件。<br>最后，我们需要用<code>Connect</code>组件将<code>Greeting</code>组件包裹起来，如下：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ConnectedMyComponent = Connect(Greeting);</span><br></pre></td></tr></table></figure>\n<p>高阶组件是一个功能很强的模式，可以用来获取数据并给其他无状态组件提供数据。</p>\n<h2 id=\"15-状态提升（State-hoisting）\"><a href=\"#15-状态提升（State-hoisting）\" class=\"headerlink\" title=\"15. 状态提升（State hoisting）\"></a>15. 状态提升（State hoisting）</h2><p>无状态组件并不持有状态，正如它名称暗示的那样。</p>\n<p>Events are changes in state. Their data needs to be passed to stateful container components parents.</p>\n<p>This is called “state hoisting”. It’s accomplished by passing a callback from a container component to a child component.</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Name</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;newName</span> =&gt;</span> alert(newName)&#125; /&gt;;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\">const Name = (&#123; onChange &#125;) =&gt; &lt;input onChange=&#123;e =&gt; onChange(e.target.value)&#125; /&gt;;</span><br></pre></td></tr></table></figure>\n<p><code>Name</code>组件从<code>NameContainer</code>组件中获得<code>onChange</code>回调并在事件中调用。<br>上面的<code>alert</code>只是简单演示并不修改状态，下面的代码将会修改<code>NameContainer</code>组件的状态。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameContainer</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">name</span>: <span class=\"string\">''</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Name</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;newName</span> =&gt;</span> this.setState(&#123; name: newName &#125;)&#125; /&gt;;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>通过回调，状态被提升到维护局部状态的容器组件中。这给无状态函数一个清晰的边界和最大限度的可重用性。</p>\n<p>这个模式并不局限于无状态函数，因为无状态函数没有生命周期事件，该模式同样适用于无状态组件。</p>\n<p>受控的 input 就是一个使用了状态提升的重要模式。</p>\n<h2 id=\"16-受控的-input（Controlled-input）\"><a href=\"#16-受控的-input（Controlled-input）\" class=\"headerlink\" title=\"16. 受控的 input（Controlled input）\"></a>16. 受控的 input（Controlled input）</h2><p>直接讨论受控的 input 比较困难，我们先从不受控的 input 谈起。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">\"text\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>当你在浏览器中输入框中输入时，你会看到输入框的值发生变化，这很正常。</p>\n<p>受控的 input 禁用 DOM 突变，它的值只能被组件修改，不能被 DOM 修改。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=<span class=\"string\">\"text\"</span> value=<span class=\"string\">\"This won't change. Try it.\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>上面的输入框有着固定值没有什么意义，下面输入框的值将会从<code>state</code>中获取。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ControlledNameInput</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">name</span>: <span class=\"string\">''</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.name&#125;</span> /&gt;</span>;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>接着，修改输入框的值就是修改组件状态。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.name&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span> =&gt;</span> this.setState(e.target.value)&#125; /&gt;;</span></span><br></pre></td></tr></table></figure>\n<p>这就是受控的 input，只有当组件的状态改变了才能改变 DOM，对于创建一致的 UI，有着非常大的作用。</p>\n"},{"title":"【Node系列】回调地狱和异步编程","_content":"\n## 回调地狱\n\n`Node`中有大量的异步 IO 操作，被封装成基于回调的函数，遇到复杂的业务逻辑很容易形成多级缩进的代码，在左侧形成一个由空格（或 Tab）组成的三角形，代码变得非常难读，被称为回调地狱。\n![image_1bjrp088i1fepi1o1klpdarjs1m.png-238kB][1]\n\n```js\nconst fs = require('fs');\nconst _ = require('lodash');\n\nfunction compose() {\n    //读取页面模板\n    fs.readFile('sample.template.html', 'utf-8', function(error, template) {\n        if (error) throw error;\n        //读取用户数据\n        fs.readFile('sample.data.user.js', 'utf-8', function(error, user) {\n            if (error) throw error;\n            //读取公司数据\n            fs.readFile('sample.data.company.js', 'utf-8', function(error, company) {\n                if (error) throw error;\n                user = JSON.parse(user);\n                company = JSON.parse(company);\n                //组装页面\n                let data = { user, company };\n                let html = _.template(template)(data);\n                console.log(html);\n            });\n        });\n    });\n}\n\ncompose();\n```\n\n下面我们来看一下，怎么解决回调地狱问题。\n\n## 解决方案\n\n1. 函数拆解并使用第三方异步库\n2. Promise\n3. 生成器函数\n4. 终极大招：async/await\n\n## 函数拆解并使用第三方异步库\n\n```\nconst fs = require('fs');\nconst _ = require('lodash');\nconst async = require('async');\n\nfunction readTemplate(callback){\n\t//读取页面模板\n\tfs.readFile('sample.template.html', 'utf-8', callback);\n}\n\nfunction readUserData(callback){\n\t//读取用户数据\n\tfs.readFile('sample.data.user.js', 'utf-8', callback);\n}\n\nfunction readCompanyData(callback){\n\t//读取公司数据\n\tfs.readFile('sample.data.company.js', 'utf-8', callback);\n}\n\nfunction compose(template, user, company){\n\tuser = JSON.parse(user);\n\tcompany = JSON.parse(company);\n\t//组装页面\n\tlet data = {user, company};\n\tlet html = _.template(template)(data);\n\tconsole.log(html);\n}\n\nasync.series([\n\treadTemplate,\n\treadUserData,\n\treadCompanyData\n], function(error, results){\n\tcompose(results[0], results[1], results[2]);\n});\n```\n\n### 使用第三方库\n\n1. 多个逻辑单元被分成独立的函数。\n2. 每个函数有了有意义的名称，更加易读。\n3. 依赖第三方异步类库解决回调地狱问题。\n\n## Promise\n\n### Promise 简介\n\n![image_1bjrhnves1ocn183b1d3n11thb119.png-17.3kB][3]\n\n### Promise 成为 JavaScript API 的基石\n\n[从 Node 6.X 开始内置 Promise](http://node.green/# ES2015-built-ins-Promise). JavaScript 相关生态中更多的 API 都开始基于 Promise 实现。比如下面的两段代码。\n\nBattery API，提供了有关系统充电级别的信息并提供了通过电池等级或者充电状态的改变提醒用户的事件。 这个可以在设备电量低的时候调整应用的资源使用状态，或者在电池用尽前保存应用中的修改以防数据丢失。\n\n```js\n//获取设备电池相关数据\nnavigator.getBattery().then(function(battery) {\n    console.log(battery);\n    // {\n    // \tcharging: true\n    // \tchargingTime: 0\n    // \tdischargingTime: Infinity\n    // \tlevel: 1\n    // \tonchargingchange: null\n    // \tonchargingtimechange: null\n    // \tondischargingtimechange: null\n    // \tonlevelchange: null\n    // }\n});\n```\n\nFetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合乎逻辑的方式来跨网络异步获取资源\n\n```js\nfetch('flowers.jpg')\n    .then(function(response) {\n        return response.blob();\n    })\n    .then(function(blob) {\n        let objectURL = URL.createObjectURL(blob);\n        document.querySelector('img').src = objectURL;\n    });\n```\n\n### Promise 类方法简介\n\n```js\nPromise.resolve(1);\n//等价于以下代码\nnew Promise(function(resolve, reject) {\n    resolve(1);\n});\n```\n\n```js\nPromise.reject(1);\n//等价于以下代码\nnew Promise(function(resolve, reject) {\n    reject(1);\n});\n```\n\n`Promise.all`：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变成`rejected`，新的 Promise 实例的状态就改变成`rejected`，否则等所有状态改变成`fulfilled`，新的 Promise 实例的状态就改变成`fulfilled`。\n\n`Promise.race`：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变，新的 Promise 实例的状态就改变，新的 Promise 实例的状态就是第一个改变状态的 Promise 实例的状态。\n\n### Promise 实例方法\n\nPromise.prototype.then\nPromise.prototype.catch\n\n### 使用 util.promisify 转成基于 Promise 的函数\n\n```js\nconst { promisify } = require('util');\nconst read = promisify(require('fs').readFile);\n\nread(path, 'utf-8').then(\n    function(txt) {\n        console.log(txt);\n    },\n    function(err) {\n        console.error(err);\n    }\n);\n\nlet date = new Date();\npromisify(setTimeout)(10000).then(function() {\n    console.log(new Date() - date);\n});\n```\n\n### 自定义基于 Promise 的函数\n\n使用`fn[util.promisify.custom]`来定义基于 Promise 的接口。\n\n```\nconst util = require('util');\n\nfunction foo() {\n    return 'abc';\n}\nasync function fooAsync() {\n    return 'abc';\n}\nfoo[util.promisify.custom] = fooAsync;\n\nconsole.log(util.promisify(foo) === fooAsync); // true\n```\n\n### 使用 Promise 解决回调问题\n\n```js\n//使用`util.promisify`转成基于Promise的接口\nconst { promisify } = require('util');\nconst read = promisify(require('fs').readFile);\nconst _ = require('lodash');\n\nfunction usePromise() {\n    var template, user, company;\n    //读取页面模板\n    read('sample.template.html', 'utf-8')\n        .then(t => (template = t))\n        .then(function() {\n            //这里必须return，否则下面的一个 then 不等待 user 数据\n            //读取用户数据\n            return read('sample.data.user.js', 'utf-8').then(u => (user = u));\n        })\n        .then(() => {\n            //读取公司数据\n            return read('sample.data.company.js', 'utf-8').then(c => (company = c));\n        })\n        .then(() => {\n            console.log(template, user, company);\n        });\n}\n//使用Promise.all\nfunction usePromiseAll() {\n    Promise.all([\n        read('sample.template.html', 'utf-8'),\n        read('sample.data.user.js', 'utf-8'),\n        read('sample.data.company.js', 'utf-8'),\n    ]).then(([template, user, company]) => {\n        compose(\n            template,\n            user,\n            company\n        );\n    });\n}\n//组装页面\nfunction compose(template, user, company) {\n    let data = {\n        user: JSON.parse(user),\n        company: JSON.parse(company),\n    };\n    let html = _.template(template)(data);\n    console.log(html);\n}\n\nusePromise();\nusePromiseAll();\n```\n\n## 通过生成器函数\n\n生成器函数是一个状态机，封装了多个内部状态。还是一个遍历器生成函数，返回遍历器对象，可以依次遍历生成器函数内部的每一个状态。\n\n### 生成器函数执行器\n\n[co](https://github.com/tj/co)是一个基于生成器函数的流程控制工作，可用于 Node.js 和浏览器。它可以通过 Promise 让你的非阻塞代码以一种漂亮的方式呈现。\n\n```js\nlet print = val => console.log(val);\n\nco(function*() {\n    return yield Promise.resolve(true);\n}).then(print);\n```\n\n```js\nvar fn = co.wrap(function*(val) {\n    return yield Promise.resolve(val);\n});\n\nfn(true).then(print);\n```\n\n### 使用生成器函数解决回调地狱问题\n\n```js\n//使用`util.promisify`转成基于Promise的接口\nconst { promisify } = require('util');\nconst read = promisify(require('fs').readFile);\nconst _ = require('lodash');\nconst co = require('co');\n\n//组装页面\nfunction compose(template, user, company) {\n    let data = {\n        user: JSON.parse(user),\n        company: JSON.parse(company),\n    };\n    let html = _.template(template)(data);\n    console.log(html);\n}\n\nlet useGenerator = co.wrap(function*() {\n    let template = yield read('sample.template.html', 'utf-8');\n    let user = yield read('sample.data.user.js', 'utf-8');\n    let company = yield read('sample.data.company.js', 'utf-8');\n    compose(\n        template,\n        user,\n        company\n    );\n});\n\nuseGenerator();\n```\n\n## 终极大招：async/await\n\n### 生成器函数和 async 函数比较\n\n使用生成器函数\n\n```js\nconst { promisify } = require('util');\nlet read = promisify(require('fs').readFile);\n\nvar fn = function*() {\n    var f1 = yield read('/etc/fstab');\n    var f2 = yield read('/etc/shells');\n    console.log(f1.toString());\n    console.log(f2.toString());\n};\nrequire('co')(fn);\n```\n\n使用`async`函数\n\n```js\nvar fn = async function() {\n    var f1 = await read('/etc/fstab');\n    var f2 = await read('/etc/shells');\n    console.log(f1.toString());\n    console.log(f2.toString());\n};\n```\n\n`async`函数和生成器函数非常相似，基本上就是`*`换成`async`，`yield`换成了`await`。\n\n### async 函数的优点\n\n1. 内置了执行器\n   生成器函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。\n2. 更好的语义\n   async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。\n3. 更广的适用性。\n   co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n4. 返回值是 Promise。\n   async 函数的返回值是 Promise 对象，这比生成器函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。\n\n进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。\n\n### 使用 async 函数解决回调地狱问题\n\n```js\nconst { promisify } = require('util');\nconst read = promisify(require('fs').readFile);\nconst _ = require('lodash');\n\n//组装页面\nfunction compose(template, user, company) {\n    let data = {\n        user: JSON.parse(user),\n        company: JSON.parse(company),\n    };\n    let html = _.template(template)(data);\n    console.log(html);\n}\n\nlet useAsync = async function() {\n    let template = await read('sample.template.html', 'utf-8');\n    let user = await read('sample.data.user.js', 'utf-8');\n    let company = await read('sample.data.company.js', 'utf-8');\n    compose(\n        template,\n        user,\n        company\n    );\n};\n\nuseAsync();\n```\n\n## 总结\n\n1. 回调地狱问题可以通过第三方异步类库，Promise，生成器函数和 async 函数等方式解决。\n2. Promise 是 ECMAScript 中异步 API 的基石，需要重点掌握。\n3. async 函数解决异步问题更加优雅，推荐在 Node 中使用。\n\n## 参考资料\n\n1. [Node.js 8: util.promisify()](http://2ality.com/2017/05/util-promisify.html)\n2. [ECMAScript 6 入门](http://es6.ruanyifeng.com/) 阮一峰\n3. [co](https://github.com/tj/co) 生成器函数执行器\n\n[1]: http://static.zybuluo.com/lichangwei/4dcltssgjnp2b2293nei6a3g/image_1bjrp088i1fepi1o1klpdarjs1m.png\n[2]: http://static.zybuluo.com/lichangwei/7dr9ts0gz0jpae4gd7d6dbrm/image_1bjrp2s8f3nf2np1k8p1u1f1vh513.png\n[3]: http://static.zybuluo.com/lichangwei/9rx1tdnqg4dk942otjej824b/image_1bjrhnves1ocn183b1d3n11thb119.png\n","source":"_posts/2017-06-30-callback-hell-and-async-program.md","raw":"---\ntitle: 【Node系列】回调地狱和异步编程\n---\n\n## 回调地狱\n\n`Node`中有大量的异步 IO 操作，被封装成基于回调的函数，遇到复杂的业务逻辑很容易形成多级缩进的代码，在左侧形成一个由空格（或 Tab）组成的三角形，代码变得非常难读，被称为回调地狱。\n![image_1bjrp088i1fepi1o1klpdarjs1m.png-238kB][1]\n\n```js\nconst fs = require('fs');\nconst _ = require('lodash');\n\nfunction compose() {\n    //读取页面模板\n    fs.readFile('sample.template.html', 'utf-8', function(error, template) {\n        if (error) throw error;\n        //读取用户数据\n        fs.readFile('sample.data.user.js', 'utf-8', function(error, user) {\n            if (error) throw error;\n            //读取公司数据\n            fs.readFile('sample.data.company.js', 'utf-8', function(error, company) {\n                if (error) throw error;\n                user = JSON.parse(user);\n                company = JSON.parse(company);\n                //组装页面\n                let data = { user, company };\n                let html = _.template(template)(data);\n                console.log(html);\n            });\n        });\n    });\n}\n\ncompose();\n```\n\n下面我们来看一下，怎么解决回调地狱问题。\n\n## 解决方案\n\n1. 函数拆解并使用第三方异步库\n2. Promise\n3. 生成器函数\n4. 终极大招：async/await\n\n## 函数拆解并使用第三方异步库\n\n```\nconst fs = require('fs');\nconst _ = require('lodash');\nconst async = require('async');\n\nfunction readTemplate(callback){\n\t//读取页面模板\n\tfs.readFile('sample.template.html', 'utf-8', callback);\n}\n\nfunction readUserData(callback){\n\t//读取用户数据\n\tfs.readFile('sample.data.user.js', 'utf-8', callback);\n}\n\nfunction readCompanyData(callback){\n\t//读取公司数据\n\tfs.readFile('sample.data.company.js', 'utf-8', callback);\n}\n\nfunction compose(template, user, company){\n\tuser = JSON.parse(user);\n\tcompany = JSON.parse(company);\n\t//组装页面\n\tlet data = {user, company};\n\tlet html = _.template(template)(data);\n\tconsole.log(html);\n}\n\nasync.series([\n\treadTemplate,\n\treadUserData,\n\treadCompanyData\n], function(error, results){\n\tcompose(results[0], results[1], results[2]);\n});\n```\n\n### 使用第三方库\n\n1. 多个逻辑单元被分成独立的函数。\n2. 每个函数有了有意义的名称，更加易读。\n3. 依赖第三方异步类库解决回调地狱问题。\n\n## Promise\n\n### Promise 简介\n\n![image_1bjrhnves1ocn183b1d3n11thb119.png-17.3kB][3]\n\n### Promise 成为 JavaScript API 的基石\n\n[从 Node 6.X 开始内置 Promise](http://node.green/# ES2015-built-ins-Promise). JavaScript 相关生态中更多的 API 都开始基于 Promise 实现。比如下面的两段代码。\n\nBattery API，提供了有关系统充电级别的信息并提供了通过电池等级或者充电状态的改变提醒用户的事件。 这个可以在设备电量低的时候调整应用的资源使用状态，或者在电池用尽前保存应用中的修改以防数据丢失。\n\n```js\n//获取设备电池相关数据\nnavigator.getBattery().then(function(battery) {\n    console.log(battery);\n    // {\n    // \tcharging: true\n    // \tchargingTime: 0\n    // \tdischargingTime: Infinity\n    // \tlevel: 1\n    // \tonchargingchange: null\n    // \tonchargingtimechange: null\n    // \tondischargingtimechange: null\n    // \tonlevelchange: null\n    // }\n});\n```\n\nFetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合乎逻辑的方式来跨网络异步获取资源\n\n```js\nfetch('flowers.jpg')\n    .then(function(response) {\n        return response.blob();\n    })\n    .then(function(blob) {\n        let objectURL = URL.createObjectURL(blob);\n        document.querySelector('img').src = objectURL;\n    });\n```\n\n### Promise 类方法简介\n\n```js\nPromise.resolve(1);\n//等价于以下代码\nnew Promise(function(resolve, reject) {\n    resolve(1);\n});\n```\n\n```js\nPromise.reject(1);\n//等价于以下代码\nnew Promise(function(resolve, reject) {\n    reject(1);\n});\n```\n\n`Promise.all`：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变成`rejected`，新的 Promise 实例的状态就改变成`rejected`，否则等所有状态改变成`fulfilled`，新的 Promise 实例的状态就改变成`fulfilled`。\n\n`Promise.race`：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变，新的 Promise 实例的状态就改变，新的 Promise 实例的状态就是第一个改变状态的 Promise 实例的状态。\n\n### Promise 实例方法\n\nPromise.prototype.then\nPromise.prototype.catch\n\n### 使用 util.promisify 转成基于 Promise 的函数\n\n```js\nconst { promisify } = require('util');\nconst read = promisify(require('fs').readFile);\n\nread(path, 'utf-8').then(\n    function(txt) {\n        console.log(txt);\n    },\n    function(err) {\n        console.error(err);\n    }\n);\n\nlet date = new Date();\npromisify(setTimeout)(10000).then(function() {\n    console.log(new Date() - date);\n});\n```\n\n### 自定义基于 Promise 的函数\n\n使用`fn[util.promisify.custom]`来定义基于 Promise 的接口。\n\n```\nconst util = require('util');\n\nfunction foo() {\n    return 'abc';\n}\nasync function fooAsync() {\n    return 'abc';\n}\nfoo[util.promisify.custom] = fooAsync;\n\nconsole.log(util.promisify(foo) === fooAsync); // true\n```\n\n### 使用 Promise 解决回调问题\n\n```js\n//使用`util.promisify`转成基于Promise的接口\nconst { promisify } = require('util');\nconst read = promisify(require('fs').readFile);\nconst _ = require('lodash');\n\nfunction usePromise() {\n    var template, user, company;\n    //读取页面模板\n    read('sample.template.html', 'utf-8')\n        .then(t => (template = t))\n        .then(function() {\n            //这里必须return，否则下面的一个 then 不等待 user 数据\n            //读取用户数据\n            return read('sample.data.user.js', 'utf-8').then(u => (user = u));\n        })\n        .then(() => {\n            //读取公司数据\n            return read('sample.data.company.js', 'utf-8').then(c => (company = c));\n        })\n        .then(() => {\n            console.log(template, user, company);\n        });\n}\n//使用Promise.all\nfunction usePromiseAll() {\n    Promise.all([\n        read('sample.template.html', 'utf-8'),\n        read('sample.data.user.js', 'utf-8'),\n        read('sample.data.company.js', 'utf-8'),\n    ]).then(([template, user, company]) => {\n        compose(\n            template,\n            user,\n            company\n        );\n    });\n}\n//组装页面\nfunction compose(template, user, company) {\n    let data = {\n        user: JSON.parse(user),\n        company: JSON.parse(company),\n    };\n    let html = _.template(template)(data);\n    console.log(html);\n}\n\nusePromise();\nusePromiseAll();\n```\n\n## 通过生成器函数\n\n生成器函数是一个状态机，封装了多个内部状态。还是一个遍历器生成函数，返回遍历器对象，可以依次遍历生成器函数内部的每一个状态。\n\n### 生成器函数执行器\n\n[co](https://github.com/tj/co)是一个基于生成器函数的流程控制工作，可用于 Node.js 和浏览器。它可以通过 Promise 让你的非阻塞代码以一种漂亮的方式呈现。\n\n```js\nlet print = val => console.log(val);\n\nco(function*() {\n    return yield Promise.resolve(true);\n}).then(print);\n```\n\n```js\nvar fn = co.wrap(function*(val) {\n    return yield Promise.resolve(val);\n});\n\nfn(true).then(print);\n```\n\n### 使用生成器函数解决回调地狱问题\n\n```js\n//使用`util.promisify`转成基于Promise的接口\nconst { promisify } = require('util');\nconst read = promisify(require('fs').readFile);\nconst _ = require('lodash');\nconst co = require('co');\n\n//组装页面\nfunction compose(template, user, company) {\n    let data = {\n        user: JSON.parse(user),\n        company: JSON.parse(company),\n    };\n    let html = _.template(template)(data);\n    console.log(html);\n}\n\nlet useGenerator = co.wrap(function*() {\n    let template = yield read('sample.template.html', 'utf-8');\n    let user = yield read('sample.data.user.js', 'utf-8');\n    let company = yield read('sample.data.company.js', 'utf-8');\n    compose(\n        template,\n        user,\n        company\n    );\n});\n\nuseGenerator();\n```\n\n## 终极大招：async/await\n\n### 生成器函数和 async 函数比较\n\n使用生成器函数\n\n```js\nconst { promisify } = require('util');\nlet read = promisify(require('fs').readFile);\n\nvar fn = function*() {\n    var f1 = yield read('/etc/fstab');\n    var f2 = yield read('/etc/shells');\n    console.log(f1.toString());\n    console.log(f2.toString());\n};\nrequire('co')(fn);\n```\n\n使用`async`函数\n\n```js\nvar fn = async function() {\n    var f1 = await read('/etc/fstab');\n    var f2 = await read('/etc/shells');\n    console.log(f1.toString());\n    console.log(f2.toString());\n};\n```\n\n`async`函数和生成器函数非常相似，基本上就是`*`换成`async`，`yield`换成了`await`。\n\n### async 函数的优点\n\n1. 内置了执行器\n   生成器函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。\n2. 更好的语义\n   async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。\n3. 更广的适用性。\n   co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n4. 返回值是 Promise。\n   async 函数的返回值是 Promise 对象，这比生成器函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。\n\n进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。\n\n### 使用 async 函数解决回调地狱问题\n\n```js\nconst { promisify } = require('util');\nconst read = promisify(require('fs').readFile);\nconst _ = require('lodash');\n\n//组装页面\nfunction compose(template, user, company) {\n    let data = {\n        user: JSON.parse(user),\n        company: JSON.parse(company),\n    };\n    let html = _.template(template)(data);\n    console.log(html);\n}\n\nlet useAsync = async function() {\n    let template = await read('sample.template.html', 'utf-8');\n    let user = await read('sample.data.user.js', 'utf-8');\n    let company = await read('sample.data.company.js', 'utf-8');\n    compose(\n        template,\n        user,\n        company\n    );\n};\n\nuseAsync();\n```\n\n## 总结\n\n1. 回调地狱问题可以通过第三方异步类库，Promise，生成器函数和 async 函数等方式解决。\n2. Promise 是 ECMAScript 中异步 API 的基石，需要重点掌握。\n3. async 函数解决异步问题更加优雅，推荐在 Node 中使用。\n\n## 参考资料\n\n1. [Node.js 8: util.promisify()](http://2ality.com/2017/05/util-promisify.html)\n2. [ECMAScript 6 入门](http://es6.ruanyifeng.com/) 阮一峰\n3. [co](https://github.com/tj/co) 生成器函数执行器\n\n[1]: http://static.zybuluo.com/lichangwei/4dcltssgjnp2b2293nei6a3g/image_1bjrp088i1fepi1o1klpdarjs1m.png\n[2]: http://static.zybuluo.com/lichangwei/7dr9ts0gz0jpae4gd7d6dbrm/image_1bjrp2s8f3nf2np1k8p1u1f1vh513.png\n[3]: http://static.zybuluo.com/lichangwei/9rx1tdnqg4dk942otjej824b/image_1bjrhnves1ocn183b1d3n11thb119.png\n","slug":"callback-hell-and-async-program","published":1,"date":"2017-06-29T16:00:00.000Z","updated":"2018-12-07T02:39:21.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmax001mw8wkg7i5j2y3","content":"<h2 id=\"回调地狱\"><a href=\"#回调地狱\" class=\"headerlink\" title=\"回调地狱\"></a>回调地狱</h2><p><code>Node</code>中有大量的异步 IO 操作，被封装成基于回调的函数，遇到复杂的业务逻辑很容易形成多级缩进的代码，在左侧形成一个由空格（或 Tab）组成的三角形，代码变得非常难读，被称为回调地狱。<br><img src=\"http://static.zybuluo.com/lichangwei/4dcltssgjnp2b2293nei6a3g/image_1bjrp088i1fepi1o1klpdarjs1m.png\" alt=\"image_1bjrp088i1fepi1o1klpdarjs1m.png-238kB\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//读取页面模板</span></span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, template</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">        <span class=\"comment\">//读取用户数据</span></span><br><span class=\"line\">        fs.readFile(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, user</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">            <span class=\"comment\">//读取公司数据</span></span><br><span class=\"line\">            fs.readFile(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, company</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">                user = <span class=\"built_in\">JSON</span>.parse(user);</span><br><span class=\"line\">                company = <span class=\"built_in\">JSON</span>.parse(company);</span><br><span class=\"line\">                <span class=\"comment\">//组装页面</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> data = &#123; user, company &#125;;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> html = _.template(template)(data);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(html);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">compose();</span><br></pre></td></tr></table></figure>\n<p>下面我们来看一下，怎么解决回调地狱问题。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li>函数拆解并使用第三方异步库</li>\n<li>Promise</li>\n<li>生成器函数</li>\n<li>终极大招：async/await</li>\n</ol>\n<h2 id=\"函数拆解并使用第三方异步库\"><a href=\"#函数拆解并使用第三方异步库\" class=\"headerlink\" title=\"函数拆解并使用第三方异步库\"></a>函数拆解并使用第三方异步库</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const _ = require(&apos;lodash&apos;);</span><br><span class=\"line\">const async = require(&apos;async&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function readTemplate(callback)&#123;</span><br><span class=\"line\">\t//读取页面模板</span><br><span class=\"line\">\tfs.readFile(&apos;sample.template.html&apos;, &apos;utf-8&apos;, callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function readUserData(callback)&#123;</span><br><span class=\"line\">\t//读取用户数据</span><br><span class=\"line\">\tfs.readFile(&apos;sample.data.user.js&apos;, &apos;utf-8&apos;, callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function readCompanyData(callback)&#123;</span><br><span class=\"line\">\t//读取公司数据</span><br><span class=\"line\">\tfs.readFile(&apos;sample.data.company.js&apos;, &apos;utf-8&apos;, callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function compose(template, user, company)&#123;</span><br><span class=\"line\">\tuser = JSON.parse(user);</span><br><span class=\"line\">\tcompany = JSON.parse(company);</span><br><span class=\"line\">\t//组装页面</span><br><span class=\"line\">\tlet data = &#123;user, company&#125;;</span><br><span class=\"line\">\tlet html = _.template(template)(data);</span><br><span class=\"line\">\tconsole.log(html);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">async.series([</span><br><span class=\"line\">\treadTemplate,</span><br><span class=\"line\">\treadUserData,</span><br><span class=\"line\">\treadCompanyData</span><br><span class=\"line\">], function(error, results)&#123;</span><br><span class=\"line\">\tcompose(results[0], results[1], results[2]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用第三方库\"><a href=\"#使用第三方库\" class=\"headerlink\" title=\"使用第三方库\"></a>使用第三方库</h3><ol>\n<li>多个逻辑单元被分成独立的函数。</li>\n<li>每个函数有了有意义的名称，更加易读。</li>\n<li>依赖第三方异步类库解决回调地狱问题。</li>\n</ol>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><h3 id=\"Promise-简介\"><a href=\"#Promise-简介\" class=\"headerlink\" title=\"Promise 简介\"></a>Promise 简介</h3><p><img src=\"http://static.zybuluo.com/lichangwei/9rx1tdnqg4dk942otjej824b/image_1bjrhnves1ocn183b1d3n11thb119.png\" alt=\"image_1bjrhnves1ocn183b1d3n11thb119.png-17.3kB\"></p>\n<h3 id=\"Promise-成为-JavaScript-API-的基石\"><a href=\"#Promise-成为-JavaScript-API-的基石\" class=\"headerlink\" title=\"Promise 成为 JavaScript API 的基石\"></a>Promise 成为 JavaScript API 的基石</h3><p><a href=\"http://node.green/# ES2015-built-ins-Promise\" target=\"_blank\" rel=\"noopener\">从 Node 6.X 开始内置 Promise</a>. JavaScript 相关生态中更多的 API 都开始基于 Promise 实现。比如下面的两段代码。</p>\n<p>Battery API，提供了有关系统充电级别的信息并提供了通过电池等级或者充电状态的改变提醒用户的事件。 这个可以在设备电量低的时候调整应用的资源使用状态，或者在电池用尽前保存应用中的修改以防数据丢失。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取设备电池相关数据</span></span><br><span class=\"line\">navigator.getBattery().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">battery</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(battery);</span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// \tcharging: true</span></span><br><span class=\"line\">    <span class=\"comment\">// \tchargingTime: 0</span></span><br><span class=\"line\">    <span class=\"comment\">// \tdischargingTime: Infinity</span></span><br><span class=\"line\">    <span class=\"comment\">// \tlevel: 1</span></span><br><span class=\"line\">    <span class=\"comment\">// \tonchargingchange: null</span></span><br><span class=\"line\">    <span class=\"comment\">// \tonchargingtimechange: null</span></span><br><span class=\"line\">    <span class=\"comment\">// \tondischargingtimechange: null</span></span><br><span class=\"line\">    <span class=\"comment\">// \tonlevelchange: null</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合乎逻辑的方式来跨网络异步获取资源</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'flowers.jpg'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response.blob();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">blob</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'img'</span>).src = objectURL;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-类方法简介\"><a href=\"#Promise-类方法简介\" class=\"headerlink\" title=\"Promise 类方法简介\"></a>Promise 类方法简介</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">//等价于以下代码</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">//等价于以下代码</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    reject(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>Promise.all</code>：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变成<code>rejected</code>，新的 Promise 实例的状态就改变成<code>rejected</code>，否则等所有状态改变成<code>fulfilled</code>，新的 Promise 实例的状态就改变成<code>fulfilled</code>。</p>\n<p><code>Promise.race</code>：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变，新的 Promise 实例的状态就改变，新的 Promise 实例的状态就是第一个改变状态的 Promise 实例的状态。</p>\n<h3 id=\"Promise-实例方法\"><a href=\"#Promise-实例方法\" class=\"headerlink\" title=\"Promise 实例方法\"></a>Promise 实例方法</h3><p>Promise.prototype.then<br>Promise.prototype.catch</p>\n<h3 id=\"使用-util-promisify-转成基于-Promise-的函数\"><a href=\"#使用-util-promisify-转成基于-Promise-的函数\" class=\"headerlink\" title=\"使用 util.promisify 转成基于 Promise 的函数\"></a>使用 util.promisify 转成基于 Promise 的函数</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"></span><br><span class=\"line\">read(path, <span class=\"string\">'utf-8'</span>).then(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">txt</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(txt);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">promisify(setTimeout)(<span class=\"number\">10000</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - date);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义基于-Promise-的函数\"><a href=\"#自定义基于-Promise-的函数\" class=\"headerlink\" title=\"自定义基于 Promise 的函数\"></a>自定义基于 Promise 的函数</h3><p>使用<code>fn[util.promisify.custom]</code>来定义基于 Promise 的接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const util = require(&apos;util&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    return &apos;abc&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function fooAsync() &#123;</span><br><span class=\"line\">    return &apos;abc&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo[util.promisify.custom] = fooAsync;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(util.promisify(foo) === fooAsync); // true</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-Promise-解决回调问题\"><a href=\"#使用-Promise-解决回调问题\" class=\"headerlink\" title=\"使用 Promise 解决回调问题\"></a>使用 Promise 解决回调问题</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用`util.promisify`转成基于Promise的接口</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usePromise</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> template, user, company;</span><br><span class=\"line\">    <span class=\"comment\">//读取页面模板</span></span><br><span class=\"line\">    read(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> (template = t))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//这里必须return，否则下面的一个 then 不等待 user 数据</span></span><br><span class=\"line\">            <span class=\"comment\">//读取用户数据</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> read(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>).then(<span class=\"function\"><span class=\"params\">u</span> =&gt;</span> (user = u));</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//读取公司数据</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> read(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>).then(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> (company = c));</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(template, user, company);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用Promise.all</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usePromiseAll</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.all([</span><br><span class=\"line\">        read(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>),</span><br><span class=\"line\">        read(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>),</span><br><span class=\"line\">        read(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>),</span><br><span class=\"line\">    ]).then(<span class=\"function\">(<span class=\"params\">[template, user, company]</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        compose(</span><br><span class=\"line\">            template,</span><br><span class=\"line\">            user,</span><br><span class=\"line\">            company</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//组装页面</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">template, user, company</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">        user: <span class=\"built_in\">JSON</span>.parse(user),</span><br><span class=\"line\">        company: <span class=\"built_in\">JSON</span>.parse(company),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = _.template(template)(data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(html);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">usePromise();</span><br><span class=\"line\">usePromiseAll();</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过生成器函数\"><a href=\"#通过生成器函数\" class=\"headerlink\" title=\"通过生成器函数\"></a>通过生成器函数</h2><p>生成器函数是一个状态机，封装了多个内部状态。还是一个遍历器生成函数，返回遍历器对象，可以依次遍历生成器函数内部的每一个状态。</p>\n<h3 id=\"生成器函数执行器\"><a href=\"#生成器函数执行器\" class=\"headerlink\" title=\"生成器函数执行器\"></a>生成器函数执行器</h3><p><a href=\"https://github.com/tj/co\" target=\"_blank\" rel=\"noopener\">co</a>是一个基于生成器函数的流程控制工作，可用于 Node.js 和浏览器。它可以通过 Promise 让你的非阻塞代码以一种漂亮的方式呈现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> print = <span class=\"function\"><span class=\"params\">val</span> =&gt;</span> <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\"></span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;).then(print);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = co.wrap(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.resolve(val);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"literal\">true</span>).then(print);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用生成器函数解决回调地狱问题\"><a href=\"#使用生成器函数解决回调地狱问题\" class=\"headerlink\" title=\"使用生成器函数解决回调地狱问题\"></a>使用生成器函数解决回调地狱问题</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用`util.promisify`转成基于Promise的接口</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">'co'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//组装页面</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">template, user, company</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">        user: <span class=\"built_in\">JSON</span>.parse(user),</span><br><span class=\"line\">        company: <span class=\"built_in\">JSON</span>.parse(company),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = _.template(template)(data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(html);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> useGenerator = co.wrap(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> template = <span class=\"keyword\">yield</span> read(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user = <span class=\"keyword\">yield</span> read(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> company = <span class=\"keyword\">yield</span> read(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    compose(</span><br><span class=\"line\">        template,</span><br><span class=\"line\">        user,</span><br><span class=\"line\">        company</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">useGenerator();</span><br></pre></td></tr></table></figure>\n<h2 id=\"终极大招：async-await\"><a href=\"#终极大招：async-await\" class=\"headerlink\" title=\"终极大招：async/await\"></a>终极大招：async/await</h2><h3 id=\"生成器函数和-async-函数比较\"><a href=\"#生成器函数和-async-函数比较\" class=\"headerlink\" title=\"生成器函数和 async 函数比较\"></a>生成器函数和 async 函数比较</h3><p>使用生成器函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">yield</span> read(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">yield</span> read(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'co'</span>)(fn);</span><br></pre></td></tr></table></figure>\n<p>使用<code>async</code>函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">await</span> read(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">await</span> read(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>async</code>函数和生成器函数非常相似，基本上就是<code>*</code>换成<code>async</code>，<code>yield</code>换成了<code>await</code>。</p>\n<h3 id=\"async-函数的优点\"><a href=\"#async-函数的优点\" class=\"headerlink\" title=\"async 函数的优点\"></a>async 函数的优点</h3><ol>\n<li>内置了执行器<br>生成器函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>\n<li>更好的语义<br>async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>\n<li>更广的适用性。<br>co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>\n<li>返回值是 Promise。<br>async 函数的返回值是 Promise 对象，这比生成器函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。</li>\n</ol>\n<p>进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。</p>\n<h3 id=\"使用-async-函数解决回调地狱问题\"><a href=\"#使用-async-函数解决回调地狱问题\" class=\"headerlink\" title=\"使用 async 函数解决回调地狱问题\"></a>使用 async 函数解决回调地狱问题</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//组装页面</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">template, user, company</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">        user: <span class=\"built_in\">JSON</span>.parse(user),</span><br><span class=\"line\">        company: <span class=\"built_in\">JSON</span>.parse(company),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = _.template(template)(data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(html);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> useAsync = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> template = <span class=\"keyword\">await</span> read(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user = <span class=\"keyword\">await</span> read(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> company = <span class=\"keyword\">await</span> read(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    compose(</span><br><span class=\"line\">        template,</span><br><span class=\"line\">        user,</span><br><span class=\"line\">        company</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">useAsync();</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>回调地狱问题可以通过第三方异步类库，Promise，生成器函数和 async 函数等方式解决。</li>\n<li>Promise 是 ECMAScript 中异步 API 的基石，需要重点掌握。</li>\n<li>async 函数解决异步问题更加优雅，推荐在 Node 中使用。</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://2ality.com/2017/05/util-promisify.html\" target=\"_blank\" rel=\"noopener\">Node.js 8: util.promisify()</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a> 阮一峰</li>\n<li><a href=\"https://github.com/tj/co\" target=\"_blank\" rel=\"noopener\">co</a> 生成器函数执行器</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"回调地狱\"><a href=\"#回调地狱\" class=\"headerlink\" title=\"回调地狱\"></a>回调地狱</h2><p><code>Node</code>中有大量的异步 IO 操作，被封装成基于回调的函数，遇到复杂的业务逻辑很容易形成多级缩进的代码，在左侧形成一个由空格（或 Tab）组成的三角形，代码变得非常难读，被称为回调地狱。<br><img src=\"http://static.zybuluo.com/lichangwei/4dcltssgjnp2b2293nei6a3g/image_1bjrp088i1fepi1o1klpdarjs1m.png\" alt=\"image_1bjrp088i1fepi1o1klpdarjs1m.png-238kB\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//读取页面模板</span></span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, template</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">        <span class=\"comment\">//读取用户数据</span></span><br><span class=\"line\">        fs.readFile(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, user</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">            <span class=\"comment\">//读取公司数据</span></span><br><span class=\"line\">            fs.readFile(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, company</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (error) <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">                user = <span class=\"built_in\">JSON</span>.parse(user);</span><br><span class=\"line\">                company = <span class=\"built_in\">JSON</span>.parse(company);</span><br><span class=\"line\">                <span class=\"comment\">//组装页面</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> data = &#123; user, company &#125;;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> html = _.template(template)(data);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(html);</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">compose();</span><br></pre></td></tr></table></figure>\n<p>下面我们来看一下，怎么解决回调地狱问题。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><ol>\n<li>函数拆解并使用第三方异步库</li>\n<li>Promise</li>\n<li>生成器函数</li>\n<li>终极大招：async/await</li>\n</ol>\n<h2 id=\"函数拆解并使用第三方异步库\"><a href=\"#函数拆解并使用第三方异步库\" class=\"headerlink\" title=\"函数拆解并使用第三方异步库\"></a>函数拆解并使用第三方异步库</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const _ = require(&apos;lodash&apos;);</span><br><span class=\"line\">const async = require(&apos;async&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function readTemplate(callback)&#123;</span><br><span class=\"line\">\t//读取页面模板</span><br><span class=\"line\">\tfs.readFile(&apos;sample.template.html&apos;, &apos;utf-8&apos;, callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function readUserData(callback)&#123;</span><br><span class=\"line\">\t//读取用户数据</span><br><span class=\"line\">\tfs.readFile(&apos;sample.data.user.js&apos;, &apos;utf-8&apos;, callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function readCompanyData(callback)&#123;</span><br><span class=\"line\">\t//读取公司数据</span><br><span class=\"line\">\tfs.readFile(&apos;sample.data.company.js&apos;, &apos;utf-8&apos;, callback);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function compose(template, user, company)&#123;</span><br><span class=\"line\">\tuser = JSON.parse(user);</span><br><span class=\"line\">\tcompany = JSON.parse(company);</span><br><span class=\"line\">\t//组装页面</span><br><span class=\"line\">\tlet data = &#123;user, company&#125;;</span><br><span class=\"line\">\tlet html = _.template(template)(data);</span><br><span class=\"line\">\tconsole.log(html);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">async.series([</span><br><span class=\"line\">\treadTemplate,</span><br><span class=\"line\">\treadUserData,</span><br><span class=\"line\">\treadCompanyData</span><br><span class=\"line\">], function(error, results)&#123;</span><br><span class=\"line\">\tcompose(results[0], results[1], results[2]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用第三方库\"><a href=\"#使用第三方库\" class=\"headerlink\" title=\"使用第三方库\"></a>使用第三方库</h3><ol>\n<li>多个逻辑单元被分成独立的函数。</li>\n<li>每个函数有了有意义的名称，更加易读。</li>\n<li>依赖第三方异步类库解决回调地狱问题。</li>\n</ol>\n<h2 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h2><h3 id=\"Promise-简介\"><a href=\"#Promise-简介\" class=\"headerlink\" title=\"Promise 简介\"></a>Promise 简介</h3><p><img src=\"http://static.zybuluo.com/lichangwei/9rx1tdnqg4dk942otjej824b/image_1bjrhnves1ocn183b1d3n11thb119.png\" alt=\"image_1bjrhnves1ocn183b1d3n11thb119.png-17.3kB\"></p>\n<h3 id=\"Promise-成为-JavaScript-API-的基石\"><a href=\"#Promise-成为-JavaScript-API-的基石\" class=\"headerlink\" title=\"Promise 成为 JavaScript API 的基石\"></a>Promise 成为 JavaScript API 的基石</h3><p><a href=\"http://node.green/# ES2015-built-ins-Promise\" target=\"_blank\" rel=\"noopener\">从 Node 6.X 开始内置 Promise</a>. JavaScript 相关生态中更多的 API 都开始基于 Promise 实现。比如下面的两段代码。</p>\n<p>Battery API，提供了有关系统充电级别的信息并提供了通过电池等级或者充电状态的改变提醒用户的事件。 这个可以在设备电量低的时候调整应用的资源使用状态，或者在电池用尽前保存应用中的修改以防数据丢失。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取设备电池相关数据</span></span><br><span class=\"line\">navigator.getBattery().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">battery</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(battery);</span><br><span class=\"line\">    <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// \tcharging: true</span></span><br><span class=\"line\">    <span class=\"comment\">// \tchargingTime: 0</span></span><br><span class=\"line\">    <span class=\"comment\">// \tdischargingTime: Infinity</span></span><br><span class=\"line\">    <span class=\"comment\">// \tlevel: 1</span></span><br><span class=\"line\">    <span class=\"comment\">// \tonchargingchange: null</span></span><br><span class=\"line\">    <span class=\"comment\">// \tonchargingtimechange: null</span></span><br><span class=\"line\">    <span class=\"comment\">// \tondischargingtimechange: null</span></span><br><span class=\"line\">    <span class=\"comment\">// \tonlevelchange: null</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合乎逻辑的方式来跨网络异步获取资源</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'flowers.jpg'</span>)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response.blob();</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">blob</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> objectURL = URL.createObjectURL(blob);</span><br><span class=\"line\">        <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'img'</span>).src = objectURL;</span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-类方法简介\"><a href=\"#Promise-类方法简介\" class=\"headerlink\" title=\"Promise 类方法简介\"></a>Promise 类方法简介</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">//等价于以下代码</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.reject(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">//等价于以下代码</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    reject(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>Promise.all</code>：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变成<code>rejected</code>，新的 Promise 实例的状态就改变成<code>rejected</code>，否则等所有状态改变成<code>fulfilled</code>，新的 Promise 实例的状态就改变成<code>fulfilled</code>。</p>\n<p><code>Promise.race</code>：将多个 Promise 实例，包装成一个新的 Promise 实例。有一个 Promise 对象状态改变，新的 Promise 实例的状态就改变，新的 Promise 实例的状态就是第一个改变状态的 Promise 实例的状态。</p>\n<h3 id=\"Promise-实例方法\"><a href=\"#Promise-实例方法\" class=\"headerlink\" title=\"Promise 实例方法\"></a>Promise 实例方法</h3><p>Promise.prototype.then<br>Promise.prototype.catch</p>\n<h3 id=\"使用-util-promisify-转成基于-Promise-的函数\"><a href=\"#使用-util-promisify-转成基于-Promise-的函数\" class=\"headerlink\" title=\"使用 util.promisify 转成基于 Promise 的函数\"></a>使用 util.promisify 转成基于 Promise 的函数</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"></span><br><span class=\"line\">read(path, <span class=\"string\">'utf-8'</span>).then(</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">txt</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(txt);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.error(err);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">promisify(setTimeout)(<span class=\"number\">10000</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>() - date);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义基于-Promise-的函数\"><a href=\"#自定义基于-Promise-的函数\" class=\"headerlink\" title=\"自定义基于 Promise 的函数\"></a>自定义基于 Promise 的函数</h3><p>使用<code>fn[util.promisify.custom]</code>来定义基于 Promise 的接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const util = require(&apos;util&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    return &apos;abc&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function fooAsync() &#123;</span><br><span class=\"line\">    return &apos;abc&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo[util.promisify.custom] = fooAsync;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(util.promisify(foo) === fooAsync); // true</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用-Promise-解决回调问题\"><a href=\"#使用-Promise-解决回调问题\" class=\"headerlink\" title=\"使用 Promise 解决回调问题\"></a>使用 Promise 解决回调问题</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用`util.promisify`转成基于Promise的接口</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usePromise</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> template, user, company;</span><br><span class=\"line\">    <span class=\"comment\">//读取页面模板</span></span><br><span class=\"line\">    read(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> (template = t))</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//这里必须return，否则下面的一个 then 不等待 user 数据</span></span><br><span class=\"line\">            <span class=\"comment\">//读取用户数据</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> read(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>).then(<span class=\"function\"><span class=\"params\">u</span> =&gt;</span> (user = u));</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//读取公司数据</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> read(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>).then(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> (company = c));</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(template, user, company);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用Promise.all</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usePromiseAll</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Promise</span>.all([</span><br><span class=\"line\">        read(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>),</span><br><span class=\"line\">        read(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>),</span><br><span class=\"line\">        read(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>),</span><br><span class=\"line\">    ]).then(<span class=\"function\">(<span class=\"params\">[template, user, company]</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        compose(</span><br><span class=\"line\">            template,</span><br><span class=\"line\">            user,</span><br><span class=\"line\">            company</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//组装页面</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">template, user, company</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">        user: <span class=\"built_in\">JSON</span>.parse(user),</span><br><span class=\"line\">        company: <span class=\"built_in\">JSON</span>.parse(company),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = _.template(template)(data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(html);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">usePromise();</span><br><span class=\"line\">usePromiseAll();</span><br></pre></td></tr></table></figure>\n<h2 id=\"通过生成器函数\"><a href=\"#通过生成器函数\" class=\"headerlink\" title=\"通过生成器函数\"></a>通过生成器函数</h2><p>生成器函数是一个状态机，封装了多个内部状态。还是一个遍历器生成函数，返回遍历器对象，可以依次遍历生成器函数内部的每一个状态。</p>\n<h3 id=\"生成器函数执行器\"><a href=\"#生成器函数执行器\" class=\"headerlink\" title=\"生成器函数执行器\"></a>生成器函数执行器</h3><p><a href=\"https://github.com/tj/co\" target=\"_blank\" rel=\"noopener\">co</a>是一个基于生成器函数的流程控制工作，可用于 Node.js 和浏览器。它可以通过 Promise 让你的非阻塞代码以一种漂亮的方式呈现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> print = <span class=\"function\"><span class=\"params\">val</span> =&gt;</span> <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\"></span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;).then(print);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = co.wrap(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\">val</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">yield</span> <span class=\"built_in\">Promise</span>.resolve(val);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">fn(<span class=\"literal\">true</span>).then(print);</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用生成器函数解决回调地狱问题\"><a href=\"#使用生成器函数解决回调地狱问题\" class=\"headerlink\" title=\"使用生成器函数解决回调地狱问题\"></a>使用生成器函数解决回调地狱问题</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用`util.promisify`转成基于Promise的接口</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">'co'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//组装页面</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">template, user, company</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">        user: <span class=\"built_in\">JSON</span>.parse(user),</span><br><span class=\"line\">        company: <span class=\"built_in\">JSON</span>.parse(company),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = _.template(template)(data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(html);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> useGenerator = co.wrap(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> template = <span class=\"keyword\">yield</span> read(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user = <span class=\"keyword\">yield</span> read(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> company = <span class=\"keyword\">yield</span> read(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    compose(</span><br><span class=\"line\">        template,</span><br><span class=\"line\">        user,</span><br><span class=\"line\">        company</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">useGenerator();</span><br></pre></td></tr></table></figure>\n<h2 id=\"终极大招：async-await\"><a href=\"#终极大招：async-await\" class=\"headerlink\" title=\"终极大招：async/await\"></a>终极大招：async/await</h2><h3 id=\"生成器函数和-async-函数比较\"><a href=\"#生成器函数和-async-函数比较\" class=\"headerlink\" title=\"生成器函数和 async 函数比较\"></a>生成器函数和 async 函数比较</h3><p>使用生成器函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">yield</span> read(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">yield</span> read(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'co'</span>)(fn);</span><br></pre></td></tr></table></figure>\n<p>使用<code>async</code>函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fn = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f1 = <span class=\"keyword\">await</span> read(<span class=\"string\">'/etc/fstab'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f2 = <span class=\"keyword\">await</span> read(<span class=\"string\">'/etc/shells'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>async</code>函数和生成器函数非常相似，基本上就是<code>*</code>换成<code>async</code>，<code>yield</code>换成了<code>await</code>。</p>\n<h3 id=\"async-函数的优点\"><a href=\"#async-函数的优点\" class=\"headerlink\" title=\"async 函数的优点\"></a>async 函数的优点</h3><ol>\n<li>内置了执行器<br>生成器函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li>\n<li>更好的语义<br>async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>\n<li>更广的适用性。<br>co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>\n<li>返回值是 Promise。<br>async 函数的返回值是 Promise 对象，这比生成器函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。</li>\n</ol>\n<p>进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。</p>\n<h3 id=\"使用-async-函数解决回调地狱问题\"><a href=\"#使用-async-函数解决回调地狱问题\" class=\"headerlink\" title=\"使用 async 函数解决回调地狱问题\"></a>使用 async 函数解决回调地狱问题</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; promisify &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">'util'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> read = promisify(<span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>).readFile);</span><br><span class=\"line\"><span class=\"keyword\">const</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">'lodash'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//组装页面</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">template, user, company</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">        user: <span class=\"built_in\">JSON</span>.parse(user),</span><br><span class=\"line\">        company: <span class=\"built_in\">JSON</span>.parse(company),</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = _.template(template)(data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(html);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> useAsync = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> template = <span class=\"keyword\">await</span> read(<span class=\"string\">'sample.template.html'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> user = <span class=\"keyword\">await</span> read(<span class=\"string\">'sample.data.user.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> company = <span class=\"keyword\">await</span> read(<span class=\"string\">'sample.data.company.js'</span>, <span class=\"string\">'utf-8'</span>);</span><br><span class=\"line\">    compose(</span><br><span class=\"line\">        template,</span><br><span class=\"line\">        user,</span><br><span class=\"line\">        company</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">useAsync();</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>回调地狱问题可以通过第三方异步类库，Promise，生成器函数和 async 函数等方式解决。</li>\n<li>Promise 是 ECMAScript 中异步 API 的基石，需要重点掌握。</li>\n<li>async 函数解决异步问题更加优雅，推荐在 Node 中使用。</li>\n</ol>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"http://2ality.com/2017/05/util-promisify.html\" target=\"_blank\" rel=\"noopener\">Node.js 8: util.promisify()</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">ECMAScript 6 入门</a> 阮一峰</li>\n<li><a href=\"https://github.com/tj/co\" target=\"_blank\" rel=\"noopener\">co</a> 生成器函数执行器</li>\n</ol>\n"},{"title":"HTTP缓存头部入门指南","_content":"\n本文结合 CDN 行为，探索 HTTP 缓存头部。如果你正要了解怎么书写缓存头部以适应现代 WEB，或者你很好奇你周围的人都在谈论什么，那么你可以阅读本文。\n\n如果你已经了解了缓存头部的好处，并且想了解更多，那么我推荐你去查看[W3 文档](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)。\n\n#### 缓存头部能做什么？\n\n简单地说，缓存能让你将 Web 资源保存在通往用户浏览器的每一个远程节点。当然浏览器本身也维护着一个私有缓存，它让浏览器不用每次都从服务器获取资源。\n\n配置缓存，对于节省站点流量是非常重要的，一个经济的站点可以减少带宽支出，或者希望保持 Web 专业开发者的声誉，你必须了解缓存的作用以及如何使用。\n\n对于这些资源文件，比如你公司的 logo，站点的 favicon，以及那些核心的各个请求之间通用的 CSS，告诉浏览器将此文件的备份保存一段时间，是非常安全的。如果你的用户是一个后座上的小孩，总是不停的问：“我们到了吗？”，你很可能会告诉他，“没有，20 分钟以后才到，请不要再问了。”\n\n通过减少对服务器请求的数量，你可以处理更多的请求，用户也可以享受更快的浏览体验。一般来讲，像图片，Javascript 脚本，样式表等资源文件都可以大量使用缓存，但是像 dashboard，论坛等动态产生的内容，就很少能使用缓存。如果你关注性能，可以将动态产生的内容和静态的资源文件分离，前者使用 Ajax 获取，后者则可以大量使用缓存。\n\n#### 客户端和 CDN\n\n最初，缓存设置都是针对客户端浏览器的，所以我们应该适当地考虑客户端以及它是如何保存资源的。但是，进来伴随着 CDN 的出现，在网络传输的中间节点上如何做好缓存成为一个重大关切。\n\n> > **什么是 CDN？**  \n> > 如果你不愿意查看 Wiki 的话，我在这里给你一个简单的说明。本质上，CDN 就是一组服务器（注意是一组），它位于用户和站点之间。每一个服务器都会根据你设定的缓存头部缓存你站点的内容。\n\n配置适当的话，CDM 会使用最快的（一般是距离用户最近的）服务器向用户传递内容。另外，CDN 起到站点和用户之间的缓冲的作用。我们最关心的数字是缓存命中率，它描述了 CDN 不需要向服务器请求就可以直接响应的请求的百分比。取决于流量和架构，它可以高达 90%。即使没有这么高，你也会受益良多。注意，低频率的请求会被更多地传给服务器，所以命中率只有和缓存次数和平均负载放在一起时才有意义。如果你配置了缓存，但是缓存头部设置不当，很可能导致\n\n![简单的CDN图](http://www.mobify.com/static/blog/2013/04/CDN_basic_diagram.png)\n这是一个 CDN 网络中的基本的数据流图。你的 Web 服务器提供内容给 CDN 中间服务器，而 CDN 中间服务器分布在全球不同地区。懒一点的话，可以在这里画一片云。\n\nBeyond their intended use for caching, CDNs also have a pleasant side-effect; provided you're dealing with a website, or a particularly well-crafted web application, in the event that your servers experience a momentary outage, your CDN may be able to buffer the experience for your end users, ensuring they never even notice.\n\nThe Basic Headers\n\nSo, you know what a CDN is, and you know you want to configure your response headers to make use of them. Most web servers make it trivial to set response headers, so I'll leave it to you, Google, and the man pages to figure that part out. For now, let’s move onto what headers you should care about.\n\n1. cache-control\n\nIf there were a default super-header for caching behavior, this would be it. Typically you will see a string of settings for this header along the lines of:\n\ncache-control: private, max-age=0, no-cache\nThese settings are called cache response directives, and are as follows:\n\nprivate | public\nEssentially they let intermediary caches know that a given response is specific to the end user and should not be cached. Do not make the mistake of assuming that this in any way provides you with some kind of security or privacy: Keep using SSL for that.\n\nno-cache\nWhen used alone, this guy lets you specify that caches should revalidate this resource every time, typically using the \"etag\" header outlined below. The fun bit comes when you specify a field name after the no-cache directive, which lets caches know that you can cache the response, provided that the named fields are stripped out; cookies would be a good example of why you might want to do this. I should note that older User Agents won't respect this trick, so you shouldn't depend on it too much.\n\nno-store\nThis guy lets you specify that caches should not store this response. I know that may be surprising given the name, but there it is. Actually, if the cache in question is following the rules, it will also ensure that no part of the request is stored either. \"no-store\" was designed with sensitive information requirements in mind, and so is kind of like the G-Man of cache headers.\n\nmax-age\nTraditionally, you would let caches know when an asset is expired by using the aptly-named \"expires\" header, discussed below. However, if you want to be more explicit, you may set a max-age, in seconds, which will override the expires header. Further reasons to use this directive are discussed below under the Caveats section.\n\ns-maxage\nUsing our keen deductive skills, we can see some similarities between this header and the last one. \"s-\" is for shared, as in \"shared cache\", as in CDN. These directives are explicitly for CDNs and other intermediary caches. When present, this directive overrides both the max-age and expires header, and most well behaved CDNs will obey it.\n\nmust-revalidate\nThis one is fun, although not applicable to most of us. For the sake of completeness, and in case your dev-team has some kind of trivia night where free beer is involved, we'll discuss it. Essentially, if your responses include this directive, you are telling the cache that it needs to revalidate a cached asset on any subsequent request, and that it may not, under any circumstance, serve stale content (which is sometimes a desired behaviour). Of course, I say \"under any circumstances\", but what I really mean is that there's a big fat asterisk next to that claim. If your users are under \"severe connectivity constraints\", (perhaps they are browsing from low-earth-orbit), then their user agents may serve stale content, provided they pinky-swear to tell their users that they've done so. Apparently this directive exists because some protocols require it, typically involving transactions.\n\nno-transform\n“Transform into what?”, you’re surely asking. Some proxies will convert image formats and other documents to improve performance. Presumably this was thought to be a feature that you should have to opt out of. If you don’t like the idea of your CDN making automated guesses about how your content should be encoded or formatted, I suggest including this header.\n\nproxy-revalidate\nEssentially the same as the \"must-revalidate\" directive, except it's just for the shared caches. Why didn't they call it \"s-mustrevalidate\"? I'm sure there exists a mailing list somewhere where you could find that debate, but for now, just know that like \"s-maxage\", this directive is designed for intermediary proxies and not user agents. The idea here is that you validate each end-user only once between the proxy and their agent, but each new user should revalidate back to the server. I suspect if your service requires this feature, you probably already know about it.\n\nAs always, you should check out the spec for these settings if you need any clarification.\n\n2. expires\n\nBack in the day, this was the standard way to specify when an asset expired, and is just a basic date-time stamp. It is still fairly useful for older user agents, which crypto webologists assure us still roam in the uncharted territories. On most modern systems, the \"cache-control\" headers \"max-age\" and \"s-maxage\" will take precedence, but it's always good practice to set a matching value here for compatibility. Just make sure you format the date correctly, or it will be evaluated as an expired date:\n\nThu, 01 Dec 1983 20:00:00 GMT\nTry to avoid setting the value to more than one year out as that breaks the specification, (see below for a discussion on cache time settings).\n\n3. etag\n\nShort for \"entity-tag\", the etag is a unique identifier for the resource being requested, typically comprised of the hash of that resource, or a hash of the timestamp the resource was updated. Basically, this lets a client ask smarter questions of the CDNs, like \"give me X if it's different than the etag I already have.\"\n\nThere's a neat trick you can do with etags, which is to make them weak validators. This basically tells the user that although they are not the same, the two resources are functionally equivalent. Support for this feature is considered optional though, so you will want to do some testing with your providers, (discussed below).\n\n4. vary\n\nOh wow. This one is fun. The “vary” header is extremely powerful, but can trip up what would otherwise be a simple caching scheme. IE has had issues handling the \"vary\" header in the past, and at one point, even Chrome was handling this in a funny way. Essentially, \"vary\" lets the caches know which of the headers to use to figure out if they have a valid cache for a request; if a cache were a giant key-value store, adding \"vary\" fields appends those values to the key, thus changing which requests are considered valid matches for what exists in the cache.\n\nYou would commonly set this to something like \"Accept-Encoding\" to make sure your gzip'ed assets get served where appropriate, saving you all that bandwidth you might otherwise waste. Additionally, setting:\n\nvary: User-Agent\nwill put you in the SEO good-books if you happen to be serving different versions of your HTML/CSS depending on the User-Agent of the request. Google will note the header and have the Googlebot crawl your mobile content as well.\n\n5. pragma\n\nAnother beast from the days of yore, the \"pragma\" header does many things, and most of them are honoured by newer implementations. The directive we're most concerned with is:\n\npragma: no-cache\nwhich gets interpreted by newer implementations as:\n\ncache-control: no-cache\nI would not generally recommend worrying about it, but for the sake of completeness, there it is. No new HTTP directives will be defined for \"pragma\" going forward.\n\nSome Caveats\n\nNow that we've gotten some of the standard and expected behaviors out of the way, we should probably mention that not every CDN or User Agent will behave according to the specification, which I'm sure is not news to anyone familiar with browser compatibility issues. For this reason, it is a good idea to test your services before launching a live resource to make sure the behavior you get is what you expected; it will save you money.\n\nAlso, you may have noted that a lot of the headers seem to be either duplicated or overlapping. Some of this is because there are subtle differences between the different methods, and also because the web is shifting over from HTTP/1.0 to HTTP/1.1, which uses the \"cache-control\" much more heavily. Generally it is safe to set both and let the CDNs and User Agents figure out which one they care to listen to.\n\n1. Compression\n\nRemember that \"Accept-Encoding\" example for the \"vary\" header we talked about? That's your new best friend if you intend to serve compressed content, which I hope you do to increase performance and save on bandwidth. CDN providers that get a request with \"gzip\" as an accepted encoding are expected to request the compressed asset from the origin server, or to serve a cached version of that compressed asset. Historically, this has been a sticking point for some CDNs, and for people wishing to use something like S3 to serve their files, although modern CDNs are able to perform the compression operation themselves if need be.\n\nThings to watch out for when the CDN serves compressed assets is that they'll often ensure that both uncompressed (AKA identity) and gzip'ed version are in their cache, regardless of which was requested. There is a time delay as they perform that operation, so any testing you do will have to take that delay into account.\n\n2. SSL\n\nA CDN is basically a Man-In-The-Middle, meaning you need to think about your HTTPS traffic and how it gets back to your server. Many CDNs will pipe a request for https://somesite.com/asset to your servers as http://somesite.com/asset, so if your server logic depended on that being SSL, either reconsider your logic or ask your CDN to redirect to an HTTPS origin URL. Most CDNs are capable of doing so, with varying degrees of flexibility.\n\nBut What about Dynamic Content?\n\nGenerally the rule of thumb for dynamic content, like the HTML files of a WordPress blog, is to set “cache-control: no-cache” and prevent the CDNs or User Agents from storing the asset. For most applications, serving your own dynamic content is probably fine, however if you need to boost performance, read on.\n\nTypical Dynamic Content\nHTTP/1.1 200 OK\nServer: Apache\nX-Rack-Cache: miss\nETag: \"e6811cdbcedf972c5e8105a89f637d39-gzip\"\nStatus: 200\nContent-Type: text/html; charset=utf-8\nExpires: Mon, 29 Apr 2013 21:44:55 GMT\nCache-Control: max-age=0, no-cache, no-store\nPragma: no-cache\nDate: Mon, 29 Apr 2013 21:44:55 GMT\nAn example of a section of a header for dynamic content. Note the missed cache status, and the cache-control directives all set to 0 seconds.\n\nMost dynamic content has a shelf-life and is not nearly as volatile as we assume. Things like \"Active Users\" are probably valid for 10 or 20 seconds, depending on your site. Dashboards that report daily figures could certainly stand to be cached for a few minutes. News feeds could certainly stand to be cached for a while, especially if you remember to set an \"etag\". If your site is seeing lots of load, it may be worth trying out a short cache on your dynamic assets.\n\nAn Analysis of Cache Time\n\nSo what types of cache times should you consider setting? Again, this will require you to consider things like the rate of traffic to your site, how sizeable your assets are, and how large your cache is, (yes, there are space allocations, so don't go over them).\n\nAdditionally, you should consider the main tradeoff: speed and performance vs. control. If you want to update an asset and need the new version to be live immediately, you may run into trouble if you thought a one-year cache time was a good idea, especially if you set that for Users (max-age) and not just CDNs (s-maxage).\n\nThe longest you can set your headers and still be following the specification is one year, or 31536000 seconds, but this is not a very good idea. That's like getting a face tattoo; it stays around forever, barring expensive or painful removal surgery, which accurately describes the annoyances of having to trick caches into refetching an asset through name changes or hoping you remembered to correctly set your etag and that your users and CDNs implemented them correctly. If your servers can't stand to have your CDNs ask once a day if your profile picture has changed you should upgrade your servers.\n\nSane Static Content Headers\nHTTP/1.1 200 OK\nCache-Control: no-transform,public,max-age=300,s-maxage=900\nContent-Type: text/html; charset=UTF-8\nDate: Mon, 29 Apr 2013 16:38:15 GMT\nETag: \"bbea5db7e1785119a7f94fdd504c546e\"\nLast-Modified: Sat, 27 Apr 2013 00:44:54 GMT\nServer: AmazonS3\nVary: Accept-Encoding\nX-Cache: HIT\nA sample of cache settings for a static asset served from S3. Here we see that the cache has been asked to store the asset for 900 seconds rather than the 300 seconds set for User Agents. Also note the \"x-cache: HIT\" header, indicating the CDN served the request.\n\nThere is one exception to the “thou-shalt-not-set-one-year-headers” commandment, or more accurately, there’s a bit of a hack to get around their pitfalls: if you’ve configured your site to generate resource names, you can rename your assets each time you publish a new version. Typically, this will involve an incrementing version number, a date-time stamp, or a hash of the contents, much like an “etag”, being appended to the file name, so that you end up with things like “core.E89A123FFDB...432D687B.css” and the like. It’s not pretty, but really, who cares? Also, this lets you set one-year-headers without worrying about updating your resources.\n\nA handy table best explains the cache time trade-off. Assuming a web asset get 500 requests per minute, then the following Hit Ratios are possible for each cache time:\n\nCache time (minutes) Hit Ratio Request to Origin / Hr\n1 99.8% 60\n5 99.96% 12\n20 99.99% 3\n60 99.997% 1\n86400 99.9998% <1\nThere. It's spelt out. What kind of Hit Ratio do you need? Typically 60 seconds to an hour is an ideal trade-off. For pseudo-dynamic content, you can still use CDNs, just start working in the under-60-seconds range, as appropriate for the request.\n\nTesting Your CDN\n\nSo, onto the testing. Always check that the headers are coming through CDNs the way you expect when setting up new services. Typically a CDN will insert some kind of \"x-\" header to indicate that it hit, missed, or served expired content. What we're looking for is a convenient way to look at this and other headers, and to set them on our requests for testing. There are more than a few tools out there to help, though these are the ones I’ve found most handy.\n\n1. Web Inspector\n\nProbably the most accessible method, simply right-click on a webpage in Chrome, click Inspect Element, navigate to the Network tab, hit refresh, and click on the HTML asset at the top. If it's not selected by default, checkout the Headers tab to see all your request and response headers. Chrome also lets you set the user agent you request with, and gives you the option to not use your local cache, which is handy when you're testing.\n\n2. Charles Proxy et al.\n\nTools like Charles Proxy will let you route traffic through them and manipulate DNS lookups, record headers, and see performance statistics, all in a clean, easy-to-use GUI. These tools are generally more task-specific than the Web Inspector and other browser tools, and generally worth the small licensing fee if you work with web requests in any significant way.\n\n3. cURL\n\nQuick, easy, and highly flexible, cURL lets you make web requests directly from the command line and check out the responding headers. Helpful flags include -A for user agents, -b for cookies, -F for form data, -H for setting headers, and -I to request the header only. Very handy for sanity checks, and extremely powerful.\n\n4. hurl.it\n\nhurl.it is essentially cURL with a prettier interface, and in a web browser. You’re able to set the headers you pass in to the request, as well as view the full header and body response. Although you don’t quite get the robustness of the command line, it’s still very useful for a quick header examination, and is probably the fastest way to get access to headers if you’re in a hurry.\n\n5. Python and Requests\n\nRequests is a great Python package for making web requests, and is useful for quick checks from the REPL, or from slightly more complex scripted checks. Using Requests comes with the added benefit of letting you write a test-suite for your web assets to assert the status of response headers.\n\nNotes from the Field and Parting Thoughts\n\nSo now you’ve made it all the way through our quick guide to cache headers, and you’re eager to get going on setting your own. Excellent. However, now it’s time to put some of this in perspective.\n\nMost web servers, like Apache and Nginx, will do a lot of this work for you. Really, the “cache-control” header is the only one you’re going to have to work with. Web browsers are typically set up to cache aggressively to improve user experience, so often you’ll be fighting to prevent caching rather than ensuring it. Generally this means that you set a “/static” path and configure its caching headers to allow caching up to some reasonable interval like 300 seconds. Next, you would ensure that your root path “/” has “cache-control: no-cache” enabled, or better yet route dynamic content straight to your servers and only have “/static” use your CDN. This is a healthy starting point for most purposes. If your hosting bill is astronomical, or you get to use operations cost savings as beer money, then consider tweaking your settings.\n\nCDNs will often give you the option of breaking protocol and will cache for whatever period you like, regardless of the headers. They also take liberties with the protocols depending on their interpretation of expected behavior, which is why it’s important to test the headers you get out of your CDN and compare them to your servers. Consider the expected behavior outlined here to be a baseline and keep an eye out for variance.\n\nGood luck, and happy caching!\n","source":"_posts/2013-09-28-A-Beginner's-Guide-to-HTTP-Cache-Headers.md","raw":"---\ntitle: HTTP缓存头部入门指南\n---\n\n本文结合 CDN 行为，探索 HTTP 缓存头部。如果你正要了解怎么书写缓存头部以适应现代 WEB，或者你很好奇你周围的人都在谈论什么，那么你可以阅读本文。\n\n如果你已经了解了缓存头部的好处，并且想了解更多，那么我推荐你去查看[W3 文档](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html)。\n\n#### 缓存头部能做什么？\n\n简单地说，缓存能让你将 Web 资源保存在通往用户浏览器的每一个远程节点。当然浏览器本身也维护着一个私有缓存，它让浏览器不用每次都从服务器获取资源。\n\n配置缓存，对于节省站点流量是非常重要的，一个经济的站点可以减少带宽支出，或者希望保持 Web 专业开发者的声誉，你必须了解缓存的作用以及如何使用。\n\n对于这些资源文件，比如你公司的 logo，站点的 favicon，以及那些核心的各个请求之间通用的 CSS，告诉浏览器将此文件的备份保存一段时间，是非常安全的。如果你的用户是一个后座上的小孩，总是不停的问：“我们到了吗？”，你很可能会告诉他，“没有，20 分钟以后才到，请不要再问了。”\n\n通过减少对服务器请求的数量，你可以处理更多的请求，用户也可以享受更快的浏览体验。一般来讲，像图片，Javascript 脚本，样式表等资源文件都可以大量使用缓存，但是像 dashboard，论坛等动态产生的内容，就很少能使用缓存。如果你关注性能，可以将动态产生的内容和静态的资源文件分离，前者使用 Ajax 获取，后者则可以大量使用缓存。\n\n#### 客户端和 CDN\n\n最初，缓存设置都是针对客户端浏览器的，所以我们应该适当地考虑客户端以及它是如何保存资源的。但是，进来伴随着 CDN 的出现，在网络传输的中间节点上如何做好缓存成为一个重大关切。\n\n> > **什么是 CDN？**  \n> > 如果你不愿意查看 Wiki 的话，我在这里给你一个简单的说明。本质上，CDN 就是一组服务器（注意是一组），它位于用户和站点之间。每一个服务器都会根据你设定的缓存头部缓存你站点的内容。\n\n配置适当的话，CDM 会使用最快的（一般是距离用户最近的）服务器向用户传递内容。另外，CDN 起到站点和用户之间的缓冲的作用。我们最关心的数字是缓存命中率，它描述了 CDN 不需要向服务器请求就可以直接响应的请求的百分比。取决于流量和架构，它可以高达 90%。即使没有这么高，你也会受益良多。注意，低频率的请求会被更多地传给服务器，所以命中率只有和缓存次数和平均负载放在一起时才有意义。如果你配置了缓存，但是缓存头部设置不当，很可能导致\n\n![简单的CDN图](http://www.mobify.com/static/blog/2013/04/CDN_basic_diagram.png)\n这是一个 CDN 网络中的基本的数据流图。你的 Web 服务器提供内容给 CDN 中间服务器，而 CDN 中间服务器分布在全球不同地区。懒一点的话，可以在这里画一片云。\n\nBeyond their intended use for caching, CDNs also have a pleasant side-effect; provided you're dealing with a website, or a particularly well-crafted web application, in the event that your servers experience a momentary outage, your CDN may be able to buffer the experience for your end users, ensuring they never even notice.\n\nThe Basic Headers\n\nSo, you know what a CDN is, and you know you want to configure your response headers to make use of them. Most web servers make it trivial to set response headers, so I'll leave it to you, Google, and the man pages to figure that part out. For now, let’s move onto what headers you should care about.\n\n1. cache-control\n\nIf there were a default super-header for caching behavior, this would be it. Typically you will see a string of settings for this header along the lines of:\n\ncache-control: private, max-age=0, no-cache\nThese settings are called cache response directives, and are as follows:\n\nprivate | public\nEssentially they let intermediary caches know that a given response is specific to the end user and should not be cached. Do not make the mistake of assuming that this in any way provides you with some kind of security or privacy: Keep using SSL for that.\n\nno-cache\nWhen used alone, this guy lets you specify that caches should revalidate this resource every time, typically using the \"etag\" header outlined below. The fun bit comes when you specify a field name after the no-cache directive, which lets caches know that you can cache the response, provided that the named fields are stripped out; cookies would be a good example of why you might want to do this. I should note that older User Agents won't respect this trick, so you shouldn't depend on it too much.\n\nno-store\nThis guy lets you specify that caches should not store this response. I know that may be surprising given the name, but there it is. Actually, if the cache in question is following the rules, it will also ensure that no part of the request is stored either. \"no-store\" was designed with sensitive information requirements in mind, and so is kind of like the G-Man of cache headers.\n\nmax-age\nTraditionally, you would let caches know when an asset is expired by using the aptly-named \"expires\" header, discussed below. However, if you want to be more explicit, you may set a max-age, in seconds, which will override the expires header. Further reasons to use this directive are discussed below under the Caveats section.\n\ns-maxage\nUsing our keen deductive skills, we can see some similarities between this header and the last one. \"s-\" is for shared, as in \"shared cache\", as in CDN. These directives are explicitly for CDNs and other intermediary caches. When present, this directive overrides both the max-age and expires header, and most well behaved CDNs will obey it.\n\nmust-revalidate\nThis one is fun, although not applicable to most of us. For the sake of completeness, and in case your dev-team has some kind of trivia night where free beer is involved, we'll discuss it. Essentially, if your responses include this directive, you are telling the cache that it needs to revalidate a cached asset on any subsequent request, and that it may not, under any circumstance, serve stale content (which is sometimes a desired behaviour). Of course, I say \"under any circumstances\", but what I really mean is that there's a big fat asterisk next to that claim. If your users are under \"severe connectivity constraints\", (perhaps they are browsing from low-earth-orbit), then their user agents may serve stale content, provided they pinky-swear to tell their users that they've done so. Apparently this directive exists because some protocols require it, typically involving transactions.\n\nno-transform\n“Transform into what?”, you’re surely asking. Some proxies will convert image formats and other documents to improve performance. Presumably this was thought to be a feature that you should have to opt out of. If you don’t like the idea of your CDN making automated guesses about how your content should be encoded or formatted, I suggest including this header.\n\nproxy-revalidate\nEssentially the same as the \"must-revalidate\" directive, except it's just for the shared caches. Why didn't they call it \"s-mustrevalidate\"? I'm sure there exists a mailing list somewhere where you could find that debate, but for now, just know that like \"s-maxage\", this directive is designed for intermediary proxies and not user agents. The idea here is that you validate each end-user only once between the proxy and their agent, but each new user should revalidate back to the server. I suspect if your service requires this feature, you probably already know about it.\n\nAs always, you should check out the spec for these settings if you need any clarification.\n\n2. expires\n\nBack in the day, this was the standard way to specify when an asset expired, and is just a basic date-time stamp. It is still fairly useful for older user agents, which crypto webologists assure us still roam in the uncharted territories. On most modern systems, the \"cache-control\" headers \"max-age\" and \"s-maxage\" will take precedence, but it's always good practice to set a matching value here for compatibility. Just make sure you format the date correctly, or it will be evaluated as an expired date:\n\nThu, 01 Dec 1983 20:00:00 GMT\nTry to avoid setting the value to more than one year out as that breaks the specification, (see below for a discussion on cache time settings).\n\n3. etag\n\nShort for \"entity-tag\", the etag is a unique identifier for the resource being requested, typically comprised of the hash of that resource, or a hash of the timestamp the resource was updated. Basically, this lets a client ask smarter questions of the CDNs, like \"give me X if it's different than the etag I already have.\"\n\nThere's a neat trick you can do with etags, which is to make them weak validators. This basically tells the user that although they are not the same, the two resources are functionally equivalent. Support for this feature is considered optional though, so you will want to do some testing with your providers, (discussed below).\n\n4. vary\n\nOh wow. This one is fun. The “vary” header is extremely powerful, but can trip up what would otherwise be a simple caching scheme. IE has had issues handling the \"vary\" header in the past, and at one point, even Chrome was handling this in a funny way. Essentially, \"vary\" lets the caches know which of the headers to use to figure out if they have a valid cache for a request; if a cache were a giant key-value store, adding \"vary\" fields appends those values to the key, thus changing which requests are considered valid matches for what exists in the cache.\n\nYou would commonly set this to something like \"Accept-Encoding\" to make sure your gzip'ed assets get served where appropriate, saving you all that bandwidth you might otherwise waste. Additionally, setting:\n\nvary: User-Agent\nwill put you in the SEO good-books if you happen to be serving different versions of your HTML/CSS depending on the User-Agent of the request. Google will note the header and have the Googlebot crawl your mobile content as well.\n\n5. pragma\n\nAnother beast from the days of yore, the \"pragma\" header does many things, and most of them are honoured by newer implementations. The directive we're most concerned with is:\n\npragma: no-cache\nwhich gets interpreted by newer implementations as:\n\ncache-control: no-cache\nI would not generally recommend worrying about it, but for the sake of completeness, there it is. No new HTTP directives will be defined for \"pragma\" going forward.\n\nSome Caveats\n\nNow that we've gotten some of the standard and expected behaviors out of the way, we should probably mention that not every CDN or User Agent will behave according to the specification, which I'm sure is not news to anyone familiar with browser compatibility issues. For this reason, it is a good idea to test your services before launching a live resource to make sure the behavior you get is what you expected; it will save you money.\n\nAlso, you may have noted that a lot of the headers seem to be either duplicated or overlapping. Some of this is because there are subtle differences between the different methods, and also because the web is shifting over from HTTP/1.0 to HTTP/1.1, which uses the \"cache-control\" much more heavily. Generally it is safe to set both and let the CDNs and User Agents figure out which one they care to listen to.\n\n1. Compression\n\nRemember that \"Accept-Encoding\" example for the \"vary\" header we talked about? That's your new best friend if you intend to serve compressed content, which I hope you do to increase performance and save on bandwidth. CDN providers that get a request with \"gzip\" as an accepted encoding are expected to request the compressed asset from the origin server, or to serve a cached version of that compressed asset. Historically, this has been a sticking point for some CDNs, and for people wishing to use something like S3 to serve their files, although modern CDNs are able to perform the compression operation themselves if need be.\n\nThings to watch out for when the CDN serves compressed assets is that they'll often ensure that both uncompressed (AKA identity) and gzip'ed version are in their cache, regardless of which was requested. There is a time delay as they perform that operation, so any testing you do will have to take that delay into account.\n\n2. SSL\n\nA CDN is basically a Man-In-The-Middle, meaning you need to think about your HTTPS traffic and how it gets back to your server. Many CDNs will pipe a request for https://somesite.com/asset to your servers as http://somesite.com/asset, so if your server logic depended on that being SSL, either reconsider your logic or ask your CDN to redirect to an HTTPS origin URL. Most CDNs are capable of doing so, with varying degrees of flexibility.\n\nBut What about Dynamic Content?\n\nGenerally the rule of thumb for dynamic content, like the HTML files of a WordPress blog, is to set “cache-control: no-cache” and prevent the CDNs or User Agents from storing the asset. For most applications, serving your own dynamic content is probably fine, however if you need to boost performance, read on.\n\nTypical Dynamic Content\nHTTP/1.1 200 OK\nServer: Apache\nX-Rack-Cache: miss\nETag: \"e6811cdbcedf972c5e8105a89f637d39-gzip\"\nStatus: 200\nContent-Type: text/html; charset=utf-8\nExpires: Mon, 29 Apr 2013 21:44:55 GMT\nCache-Control: max-age=0, no-cache, no-store\nPragma: no-cache\nDate: Mon, 29 Apr 2013 21:44:55 GMT\nAn example of a section of a header for dynamic content. Note the missed cache status, and the cache-control directives all set to 0 seconds.\n\nMost dynamic content has a shelf-life and is not nearly as volatile as we assume. Things like \"Active Users\" are probably valid for 10 or 20 seconds, depending on your site. Dashboards that report daily figures could certainly stand to be cached for a few minutes. News feeds could certainly stand to be cached for a while, especially if you remember to set an \"etag\". If your site is seeing lots of load, it may be worth trying out a short cache on your dynamic assets.\n\nAn Analysis of Cache Time\n\nSo what types of cache times should you consider setting? Again, this will require you to consider things like the rate of traffic to your site, how sizeable your assets are, and how large your cache is, (yes, there are space allocations, so don't go over them).\n\nAdditionally, you should consider the main tradeoff: speed and performance vs. control. If you want to update an asset and need the new version to be live immediately, you may run into trouble if you thought a one-year cache time was a good idea, especially if you set that for Users (max-age) and not just CDNs (s-maxage).\n\nThe longest you can set your headers and still be following the specification is one year, or 31536000 seconds, but this is not a very good idea. That's like getting a face tattoo; it stays around forever, barring expensive or painful removal surgery, which accurately describes the annoyances of having to trick caches into refetching an asset through name changes or hoping you remembered to correctly set your etag and that your users and CDNs implemented them correctly. If your servers can't stand to have your CDNs ask once a day if your profile picture has changed you should upgrade your servers.\n\nSane Static Content Headers\nHTTP/1.1 200 OK\nCache-Control: no-transform,public,max-age=300,s-maxage=900\nContent-Type: text/html; charset=UTF-8\nDate: Mon, 29 Apr 2013 16:38:15 GMT\nETag: \"bbea5db7e1785119a7f94fdd504c546e\"\nLast-Modified: Sat, 27 Apr 2013 00:44:54 GMT\nServer: AmazonS3\nVary: Accept-Encoding\nX-Cache: HIT\nA sample of cache settings for a static asset served from S3. Here we see that the cache has been asked to store the asset for 900 seconds rather than the 300 seconds set for User Agents. Also note the \"x-cache: HIT\" header, indicating the CDN served the request.\n\nThere is one exception to the “thou-shalt-not-set-one-year-headers” commandment, or more accurately, there’s a bit of a hack to get around their pitfalls: if you’ve configured your site to generate resource names, you can rename your assets each time you publish a new version. Typically, this will involve an incrementing version number, a date-time stamp, or a hash of the contents, much like an “etag”, being appended to the file name, so that you end up with things like “core.E89A123FFDB...432D687B.css” and the like. It’s not pretty, but really, who cares? Also, this lets you set one-year-headers without worrying about updating your resources.\n\nA handy table best explains the cache time trade-off. Assuming a web asset get 500 requests per minute, then the following Hit Ratios are possible for each cache time:\n\nCache time (minutes) Hit Ratio Request to Origin / Hr\n1 99.8% 60\n5 99.96% 12\n20 99.99% 3\n60 99.997% 1\n86400 99.9998% <1\nThere. It's spelt out. What kind of Hit Ratio do you need? Typically 60 seconds to an hour is an ideal trade-off. For pseudo-dynamic content, you can still use CDNs, just start working in the under-60-seconds range, as appropriate for the request.\n\nTesting Your CDN\n\nSo, onto the testing. Always check that the headers are coming through CDNs the way you expect when setting up new services. Typically a CDN will insert some kind of \"x-\" header to indicate that it hit, missed, or served expired content. What we're looking for is a convenient way to look at this and other headers, and to set them on our requests for testing. There are more than a few tools out there to help, though these are the ones I’ve found most handy.\n\n1. Web Inspector\n\nProbably the most accessible method, simply right-click on a webpage in Chrome, click Inspect Element, navigate to the Network tab, hit refresh, and click on the HTML asset at the top. If it's not selected by default, checkout the Headers tab to see all your request and response headers. Chrome also lets you set the user agent you request with, and gives you the option to not use your local cache, which is handy when you're testing.\n\n2. Charles Proxy et al.\n\nTools like Charles Proxy will let you route traffic through them and manipulate DNS lookups, record headers, and see performance statistics, all in a clean, easy-to-use GUI. These tools are generally more task-specific than the Web Inspector and other browser tools, and generally worth the small licensing fee if you work with web requests in any significant way.\n\n3. cURL\n\nQuick, easy, and highly flexible, cURL lets you make web requests directly from the command line and check out the responding headers. Helpful flags include -A for user agents, -b for cookies, -F for form data, -H for setting headers, and -I to request the header only. Very handy for sanity checks, and extremely powerful.\n\n4. hurl.it\n\nhurl.it is essentially cURL with a prettier interface, and in a web browser. You’re able to set the headers you pass in to the request, as well as view the full header and body response. Although you don’t quite get the robustness of the command line, it’s still very useful for a quick header examination, and is probably the fastest way to get access to headers if you’re in a hurry.\n\n5. Python and Requests\n\nRequests is a great Python package for making web requests, and is useful for quick checks from the REPL, or from slightly more complex scripted checks. Using Requests comes with the added benefit of letting you write a test-suite for your web assets to assert the status of response headers.\n\nNotes from the Field and Parting Thoughts\n\nSo now you’ve made it all the way through our quick guide to cache headers, and you’re eager to get going on setting your own. Excellent. However, now it’s time to put some of this in perspective.\n\nMost web servers, like Apache and Nginx, will do a lot of this work for you. Really, the “cache-control” header is the only one you’re going to have to work with. Web browsers are typically set up to cache aggressively to improve user experience, so often you’ll be fighting to prevent caching rather than ensuring it. Generally this means that you set a “/static” path and configure its caching headers to allow caching up to some reasonable interval like 300 seconds. Next, you would ensure that your root path “/” has “cache-control: no-cache” enabled, or better yet route dynamic content straight to your servers and only have “/static” use your CDN. This is a healthy starting point for most purposes. If your hosting bill is astronomical, or you get to use operations cost savings as beer money, then consider tweaking your settings.\n\nCDNs will often give you the option of breaking protocol and will cache for whatever period you like, regardless of the headers. They also take liberties with the protocols depending on their interpretation of expected behavior, which is why it’s important to test the headers you get out of your CDN and compare them to your servers. Consider the expected behavior outlined here to be a baseline and keep an eye out for variance.\n\nGood luck, and happy caching!\n","slug":"A-Beginner's-Guide-to-HTTP-Cache-Headers","published":1,"date":"2013-09-27T16:00:00.000Z","updated":"2018-12-07T02:56:34.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmb2001nw8wkfnnid6bf","content":"<p>本文结合 CDN 行为，探索 HTTP 缓存头部。如果你正要了解怎么书写缓存头部以适应现代 WEB，或者你很好奇你周围的人都在谈论什么，那么你可以阅读本文。</p>\n<p>如果你已经了解了缓存头部的好处，并且想了解更多，那么我推荐你去查看<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\" target=\"_blank\" rel=\"noopener\">W3 文档</a>。</p>\n<h4 id=\"缓存头部能做什么？\"><a href=\"#缓存头部能做什么？\" class=\"headerlink\" title=\"缓存头部能做什么？\"></a>缓存头部能做什么？</h4><p>简单地说，缓存能让你将 Web 资源保存在通往用户浏览器的每一个远程节点。当然浏览器本身也维护着一个私有缓存，它让浏览器不用每次都从服务器获取资源。</p>\n<p>配置缓存，对于节省站点流量是非常重要的，一个经济的站点可以减少带宽支出，或者希望保持 Web 专业开发者的声誉，你必须了解缓存的作用以及如何使用。</p>\n<p>对于这些资源文件，比如你公司的 logo，站点的 favicon，以及那些核心的各个请求之间通用的 CSS，告诉浏览器将此文件的备份保存一段时间，是非常安全的。如果你的用户是一个后座上的小孩，总是不停的问：“我们到了吗？”，你很可能会告诉他，“没有，20 分钟以后才到，请不要再问了。”</p>\n<p>通过减少对服务器请求的数量，你可以处理更多的请求，用户也可以享受更快的浏览体验。一般来讲，像图片，Javascript 脚本，样式表等资源文件都可以大量使用缓存，但是像 dashboard，论坛等动态产生的内容，就很少能使用缓存。如果你关注性能，可以将动态产生的内容和静态的资源文件分离，前者使用 Ajax 获取，后者则可以大量使用缓存。</p>\n<h4 id=\"客户端和-CDN\"><a href=\"#客户端和-CDN\" class=\"headerlink\" title=\"客户端和 CDN\"></a>客户端和 CDN</h4><p>最初，缓存设置都是针对客户端浏览器的，所以我们应该适当地考虑客户端以及它是如何保存资源的。但是，进来伴随着 CDN 的出现，在网络传输的中间节点上如何做好缓存成为一个重大关切。</p>\n<blockquote>\n<blockquote>\n<p><strong>什么是 CDN？</strong><br>如果你不愿意查看 Wiki 的话，我在这里给你一个简单的说明。本质上，CDN 就是一组服务器（注意是一组），它位于用户和站点之间。每一个服务器都会根据你设定的缓存头部缓存你站点的内容。</p>\n</blockquote>\n</blockquote>\n<p>配置适当的话，CDM 会使用最快的（一般是距离用户最近的）服务器向用户传递内容。另外，CDN 起到站点和用户之间的缓冲的作用。我们最关心的数字是缓存命中率，它描述了 CDN 不需要向服务器请求就可以直接响应的请求的百分比。取决于流量和架构，它可以高达 90%。即使没有这么高，你也会受益良多。注意，低频率的请求会被更多地传给服务器，所以命中率只有和缓存次数和平均负载放在一起时才有意义。如果你配置了缓存，但是缓存头部设置不当，很可能导致</p>\n<p><img src=\"http://www.mobify.com/static/blog/2013/04/CDN_basic_diagram.png\" alt=\"简单的CDN图\"><br>这是一个 CDN 网络中的基本的数据流图。你的 Web 服务器提供内容给 CDN 中间服务器，而 CDN 中间服务器分布在全球不同地区。懒一点的话，可以在这里画一片云。</p>\n<p>Beyond their intended use for caching, CDNs also have a pleasant side-effect; provided you’re dealing with a website, or a particularly well-crafted web application, in the event that your servers experience a momentary outage, your CDN may be able to buffer the experience for your end users, ensuring they never even notice.</p>\n<p>The Basic Headers</p>\n<p>So, you know what a CDN is, and you know you want to configure your response headers to make use of them. Most web servers make it trivial to set response headers, so I’ll leave it to you, Google, and the man pages to figure that part out. For now, let’s move onto what headers you should care about.</p>\n<ol>\n<li>cache-control</li>\n</ol>\n<p>If there were a default super-header for caching behavior, this would be it. Typically you will see a string of settings for this header along the lines of:</p>\n<p>cache-control: private, max-age=0, no-cache<br>These settings are called cache response directives, and are as follows:</p>\n<p>private | public<br>Essentially they let intermediary caches know that a given response is specific to the end user and should not be cached. Do not make the mistake of assuming that this in any way provides you with some kind of security or privacy: Keep using SSL for that.</p>\n<p>no-cache<br>When used alone, this guy lets you specify that caches should revalidate this resource every time, typically using the “etag” header outlined below. The fun bit comes when you specify a field name after the no-cache directive, which lets caches know that you can cache the response, provided that the named fields are stripped out; cookies would be a good example of why you might want to do this. I should note that older User Agents won’t respect this trick, so you shouldn’t depend on it too much.</p>\n<p>no-store<br>This guy lets you specify that caches should not store this response. I know that may be surprising given the name, but there it is. Actually, if the cache in question is following the rules, it will also ensure that no part of the request is stored either. “no-store” was designed with sensitive information requirements in mind, and so is kind of like the G-Man of cache headers.</p>\n<p>max-age<br>Traditionally, you would let caches know when an asset is expired by using the aptly-named “expires” header, discussed below. However, if you want to be more explicit, you may set a max-age, in seconds, which will override the expires header. Further reasons to use this directive are discussed below under the Caveats section.</p>\n<p>s-maxage<br>Using our keen deductive skills, we can see some similarities between this header and the last one. “s-“ is for shared, as in “shared cache”, as in CDN. These directives are explicitly for CDNs and other intermediary caches. When present, this directive overrides both the max-age and expires header, and most well behaved CDNs will obey it.</p>\n<p>must-revalidate<br>This one is fun, although not applicable to most of us. For the sake of completeness, and in case your dev-team has some kind of trivia night where free beer is involved, we’ll discuss it. Essentially, if your responses include this directive, you are telling the cache that it needs to revalidate a cached asset on any subsequent request, and that it may not, under any circumstance, serve stale content (which is sometimes a desired behaviour). Of course, I say “under any circumstances”, but what I really mean is that there’s a big fat asterisk next to that claim. If your users are under “severe connectivity constraints”, (perhaps they are browsing from low-earth-orbit), then their user agents may serve stale content, provided they pinky-swear to tell their users that they’ve done so. Apparently this directive exists because some protocols require it, typically involving transactions.</p>\n<p>no-transform<br>“Transform into what?”, you’re surely asking. Some proxies will convert image formats and other documents to improve performance. Presumably this was thought to be a feature that you should have to opt out of. If you don’t like the idea of your CDN making automated guesses about how your content should be encoded or formatted, I suggest including this header.</p>\n<p>proxy-revalidate<br>Essentially the same as the “must-revalidate” directive, except it’s just for the shared caches. Why didn’t they call it “s-mustrevalidate”? I’m sure there exists a mailing list somewhere where you could find that debate, but for now, just know that like “s-maxage”, this directive is designed for intermediary proxies and not user agents. The idea here is that you validate each end-user only once between the proxy and their agent, but each new user should revalidate back to the server. I suspect if your service requires this feature, you probably already know about it.</p>\n<p>As always, you should check out the spec for these settings if you need any clarification.</p>\n<ol start=\"2\">\n<li>expires</li>\n</ol>\n<p>Back in the day, this was the standard way to specify when an asset expired, and is just a basic date-time stamp. It is still fairly useful for older user agents, which crypto webologists assure us still roam in the uncharted territories. On most modern systems, the “cache-control” headers “max-age” and “s-maxage” will take precedence, but it’s always good practice to set a matching value here for compatibility. Just make sure you format the date correctly, or it will be evaluated as an expired date:</p>\n<p>Thu, 01 Dec 1983 20:00:00 GMT<br>Try to avoid setting the value to more than one year out as that breaks the specification, (see below for a discussion on cache time settings).</p>\n<ol start=\"3\">\n<li>etag</li>\n</ol>\n<p>Short for “entity-tag”, the etag is a unique identifier for the resource being requested, typically comprised of the hash of that resource, or a hash of the timestamp the resource was updated. Basically, this lets a client ask smarter questions of the CDNs, like “give me X if it’s different than the etag I already have.”</p>\n<p>There’s a neat trick you can do with etags, which is to make them weak validators. This basically tells the user that although they are not the same, the two resources are functionally equivalent. Support for this feature is considered optional though, so you will want to do some testing with your providers, (discussed below).</p>\n<ol start=\"4\">\n<li>vary</li>\n</ol>\n<p>Oh wow. This one is fun. The “vary” header is extremely powerful, but can trip up what would otherwise be a simple caching scheme. IE has had issues handling the “vary” header in the past, and at one point, even Chrome was handling this in a funny way. Essentially, “vary” lets the caches know which of the headers to use to figure out if they have a valid cache for a request; if a cache were a giant key-value store, adding “vary” fields appends those values to the key, thus changing which requests are considered valid matches for what exists in the cache.</p>\n<p>You would commonly set this to something like “Accept-Encoding” to make sure your gzip’ed assets get served where appropriate, saving you all that bandwidth you might otherwise waste. Additionally, setting:</p>\n<p>vary: User-Agent<br>will put you in the SEO good-books if you happen to be serving different versions of your HTML/CSS depending on the User-Agent of the request. Google will note the header and have the Googlebot crawl your mobile content as well.</p>\n<ol start=\"5\">\n<li>pragma</li>\n</ol>\n<p>Another beast from the days of yore, the “pragma” header does many things, and most of them are honoured by newer implementations. The directive we’re most concerned with is:</p>\n<p>pragma: no-cache<br>which gets interpreted by newer implementations as:</p>\n<p>cache-control: no-cache<br>I would not generally recommend worrying about it, but for the sake of completeness, there it is. No new HTTP directives will be defined for “pragma” going forward.</p>\n<p>Some Caveats</p>\n<p>Now that we’ve gotten some of the standard and expected behaviors out of the way, we should probably mention that not every CDN or User Agent will behave according to the specification, which I’m sure is not news to anyone familiar with browser compatibility issues. For this reason, it is a good idea to test your services before launching a live resource to make sure the behavior you get is what you expected; it will save you money.</p>\n<p>Also, you may have noted that a lot of the headers seem to be either duplicated or overlapping. Some of this is because there are subtle differences between the different methods, and also because the web is shifting over from HTTP/1.0 to HTTP/1.1, which uses the “cache-control” much more heavily. Generally it is safe to set both and let the CDNs and User Agents figure out which one they care to listen to.</p>\n<ol>\n<li>Compression</li>\n</ol>\n<p>Remember that “Accept-Encoding” example for the “vary” header we talked about? That’s your new best friend if you intend to serve compressed content, which I hope you do to increase performance and save on bandwidth. CDN providers that get a request with “gzip” as an accepted encoding are expected to request the compressed asset from the origin server, or to serve a cached version of that compressed asset. Historically, this has been a sticking point for some CDNs, and for people wishing to use something like S3 to serve their files, although modern CDNs are able to perform the compression operation themselves if need be.</p>\n<p>Things to watch out for when the CDN serves compressed assets is that they’ll often ensure that both uncompressed (AKA identity) and gzip’ed version are in their cache, regardless of which was requested. There is a time delay as they perform that operation, so any testing you do will have to take that delay into account.</p>\n<ol start=\"2\">\n<li>SSL</li>\n</ol>\n<p>A CDN is basically a Man-In-The-Middle, meaning you need to think about your HTTPS traffic and how it gets back to your server. Many CDNs will pipe a request for <a href=\"https://somesite.com/asset\" target=\"_blank\" rel=\"noopener\">https://somesite.com/asset</a> to your servers as <a href=\"http://somesite.com/asset\" target=\"_blank\" rel=\"noopener\">http://somesite.com/asset</a>, so if your server logic depended on that being SSL, either reconsider your logic or ask your CDN to redirect to an HTTPS origin URL. Most CDNs are capable of doing so, with varying degrees of flexibility.</p>\n<p>But What about Dynamic Content?</p>\n<p>Generally the rule of thumb for dynamic content, like the HTML files of a WordPress blog, is to set “cache-control: no-cache” and prevent the CDNs or User Agents from storing the asset. For most applications, serving your own dynamic content is probably fine, however if you need to boost performance, read on.</p>\n<p>Typical Dynamic Content<br>HTTP/1.1 200 OK<br>Server: Apache<br>X-Rack-Cache: miss<br>ETag: “e6811cdbcedf972c5e8105a89f637d39-gzip”<br>Status: 200<br>Content-Type: text/html; charset=utf-8<br>Expires: Mon, 29 Apr 2013 21:44:55 GMT<br>Cache-Control: max-age=0, no-cache, no-store<br>Pragma: no-cache<br>Date: Mon, 29 Apr 2013 21:44:55 GMT<br>An example of a section of a header for dynamic content. Note the missed cache status, and the cache-control directives all set to 0 seconds.</p>\n<p>Most dynamic content has a shelf-life and is not nearly as volatile as we assume. Things like “Active Users” are probably valid for 10 or 20 seconds, depending on your site. Dashboards that report daily figures could certainly stand to be cached for a few minutes. News feeds could certainly stand to be cached for a while, especially if you remember to set an “etag”. If your site is seeing lots of load, it may be worth trying out a short cache on your dynamic assets.</p>\n<p>An Analysis of Cache Time</p>\n<p>So what types of cache times should you consider setting? Again, this will require you to consider things like the rate of traffic to your site, how sizeable your assets are, and how large your cache is, (yes, there are space allocations, so don’t go over them).</p>\n<p>Additionally, you should consider the main tradeoff: speed and performance vs. control. If you want to update an asset and need the new version to be live immediately, you may run into trouble if you thought a one-year cache time was a good idea, especially if you set that for Users (max-age) and not just CDNs (s-maxage).</p>\n<p>The longest you can set your headers and still be following the specification is one year, or 31536000 seconds, but this is not a very good idea. That’s like getting a face tattoo; it stays around forever, barring expensive or painful removal surgery, which accurately describes the annoyances of having to trick caches into refetching an asset through name changes or hoping you remembered to correctly set your etag and that your users and CDNs implemented them correctly. If your servers can’t stand to have your CDNs ask once a day if your profile picture has changed you should upgrade your servers.</p>\n<p>Sane Static Content Headers<br>HTTP/1.1 200 OK<br>Cache-Control: no-transform,public,max-age=300,s-maxage=900<br>Content-Type: text/html; charset=UTF-8<br>Date: Mon, 29 Apr 2013 16:38:15 GMT<br>ETag: “bbea5db7e1785119a7f94fdd504c546e”<br>Last-Modified: Sat, 27 Apr 2013 00:44:54 GMT<br>Server: AmazonS3<br>Vary: Accept-Encoding<br>X-Cache: HIT<br>A sample of cache settings for a static asset served from S3. Here we see that the cache has been asked to store the asset for 900 seconds rather than the 300 seconds set for User Agents. Also note the “x-cache: HIT” header, indicating the CDN served the request.</p>\n<p>There is one exception to the “thou-shalt-not-set-one-year-headers” commandment, or more accurately, there’s a bit of a hack to get around their pitfalls: if you’ve configured your site to generate resource names, you can rename your assets each time you publish a new version. Typically, this will involve an incrementing version number, a date-time stamp, or a hash of the contents, much like an “etag”, being appended to the file name, so that you end up with things like “core.E89A123FFDB…432D687B.css” and the like. It’s not pretty, but really, who cares? Also, this lets you set one-year-headers without worrying about updating your resources.</p>\n<p>A handy table best explains the cache time trade-off. Assuming a web asset get 500 requests per minute, then the following Hit Ratios are possible for each cache time:</p>\n<p>Cache time (minutes) Hit Ratio Request to Origin / Hr<br>1 99.8% 60<br>5 99.96% 12<br>20 99.99% 3<br>60 99.997% 1<br>86400 99.9998% &lt;1<br>There. It’s spelt out. What kind of Hit Ratio do you need? Typically 60 seconds to an hour is an ideal trade-off. For pseudo-dynamic content, you can still use CDNs, just start working in the under-60-seconds range, as appropriate for the request.</p>\n<p>Testing Your CDN</p>\n<p>So, onto the testing. Always check that the headers are coming through CDNs the way you expect when setting up new services. Typically a CDN will insert some kind of “x-“ header to indicate that it hit, missed, or served expired content. What we’re looking for is a convenient way to look at this and other headers, and to set them on our requests for testing. There are more than a few tools out there to help, though these are the ones I’ve found most handy.</p>\n<ol>\n<li>Web Inspector</li>\n</ol>\n<p>Probably the most accessible method, simply right-click on a webpage in Chrome, click Inspect Element, navigate to the Network tab, hit refresh, and click on the HTML asset at the top. If it’s not selected by default, checkout the Headers tab to see all your request and response headers. Chrome also lets you set the user agent you request with, and gives you the option to not use your local cache, which is handy when you’re testing.</p>\n<ol start=\"2\">\n<li>Charles Proxy et al.</li>\n</ol>\n<p>Tools like Charles Proxy will let you route traffic through them and manipulate DNS lookups, record headers, and see performance statistics, all in a clean, easy-to-use GUI. These tools are generally more task-specific than the Web Inspector and other browser tools, and generally worth the small licensing fee if you work with web requests in any significant way.</p>\n<ol start=\"3\">\n<li>cURL</li>\n</ol>\n<p>Quick, easy, and highly flexible, cURL lets you make web requests directly from the command line and check out the responding headers. Helpful flags include -A for user agents, -b for cookies, -F for form data, -H for setting headers, and -I to request the header only. Very handy for sanity checks, and extremely powerful.</p>\n<ol start=\"4\">\n<li>hurl.it</li>\n</ol>\n<p>hurl.it is essentially cURL with a prettier interface, and in a web browser. You’re able to set the headers you pass in to the request, as well as view the full header and body response. Although you don’t quite get the robustness of the command line, it’s still very useful for a quick header examination, and is probably the fastest way to get access to headers if you’re in a hurry.</p>\n<ol start=\"5\">\n<li>Python and Requests</li>\n</ol>\n<p>Requests is a great Python package for making web requests, and is useful for quick checks from the REPL, or from slightly more complex scripted checks. Using Requests comes with the added benefit of letting you write a test-suite for your web assets to assert the status of response headers.</p>\n<p>Notes from the Field and Parting Thoughts</p>\n<p>So now you’ve made it all the way through our quick guide to cache headers, and you’re eager to get going on setting your own. Excellent. However, now it’s time to put some of this in perspective.</p>\n<p>Most web servers, like Apache and Nginx, will do a lot of this work for you. Really, the “cache-control” header is the only one you’re going to have to work with. Web browsers are typically set up to cache aggressively to improve user experience, so often you’ll be fighting to prevent caching rather than ensuring it. Generally this means that you set a “/static” path and configure its caching headers to allow caching up to some reasonable interval like 300 seconds. Next, you would ensure that your root path “/” has “cache-control: no-cache” enabled, or better yet route dynamic content straight to your servers and only have “/static” use your CDN. This is a healthy starting point for most purposes. If your hosting bill is astronomical, or you get to use operations cost savings as beer money, then consider tweaking your settings.</p>\n<p>CDNs will often give you the option of breaking protocol and will cache for whatever period you like, regardless of the headers. They also take liberties with the protocols depending on their interpretation of expected behavior, which is why it’s important to test the headers you get out of your CDN and compare them to your servers. Consider the expected behavior outlined here to be a baseline and keep an eye out for variance.</p>\n<p>Good luck, and happy caching!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文结合 CDN 行为，探索 HTTP 缓存头部。如果你正要了解怎么书写缓存头部以适应现代 WEB，或者你很好奇你周围的人都在谈论什么，那么你可以阅读本文。</p>\n<p>如果你已经了解了缓存头部的好处，并且想了解更多，那么我推荐你去查看<a href=\"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html\" target=\"_blank\" rel=\"noopener\">W3 文档</a>。</p>\n<h4 id=\"缓存头部能做什么？\"><a href=\"#缓存头部能做什么？\" class=\"headerlink\" title=\"缓存头部能做什么？\"></a>缓存头部能做什么？</h4><p>简单地说，缓存能让你将 Web 资源保存在通往用户浏览器的每一个远程节点。当然浏览器本身也维护着一个私有缓存，它让浏览器不用每次都从服务器获取资源。</p>\n<p>配置缓存，对于节省站点流量是非常重要的，一个经济的站点可以减少带宽支出，或者希望保持 Web 专业开发者的声誉，你必须了解缓存的作用以及如何使用。</p>\n<p>对于这些资源文件，比如你公司的 logo，站点的 favicon，以及那些核心的各个请求之间通用的 CSS，告诉浏览器将此文件的备份保存一段时间，是非常安全的。如果你的用户是一个后座上的小孩，总是不停的问：“我们到了吗？”，你很可能会告诉他，“没有，20 分钟以后才到，请不要再问了。”</p>\n<p>通过减少对服务器请求的数量，你可以处理更多的请求，用户也可以享受更快的浏览体验。一般来讲，像图片，Javascript 脚本，样式表等资源文件都可以大量使用缓存，但是像 dashboard，论坛等动态产生的内容，就很少能使用缓存。如果你关注性能，可以将动态产生的内容和静态的资源文件分离，前者使用 Ajax 获取，后者则可以大量使用缓存。</p>\n<h4 id=\"客户端和-CDN\"><a href=\"#客户端和-CDN\" class=\"headerlink\" title=\"客户端和 CDN\"></a>客户端和 CDN</h4><p>最初，缓存设置都是针对客户端浏览器的，所以我们应该适当地考虑客户端以及它是如何保存资源的。但是，进来伴随着 CDN 的出现，在网络传输的中间节点上如何做好缓存成为一个重大关切。</p>\n<blockquote>\n<blockquote>\n<p><strong>什么是 CDN？</strong><br>如果你不愿意查看 Wiki 的话，我在这里给你一个简单的说明。本质上，CDN 就是一组服务器（注意是一组），它位于用户和站点之间。每一个服务器都会根据你设定的缓存头部缓存你站点的内容。</p>\n</blockquote>\n</blockquote>\n<p>配置适当的话，CDM 会使用最快的（一般是距离用户最近的）服务器向用户传递内容。另外，CDN 起到站点和用户之间的缓冲的作用。我们最关心的数字是缓存命中率，它描述了 CDN 不需要向服务器请求就可以直接响应的请求的百分比。取决于流量和架构，它可以高达 90%。即使没有这么高，你也会受益良多。注意，低频率的请求会被更多地传给服务器，所以命中率只有和缓存次数和平均负载放在一起时才有意义。如果你配置了缓存，但是缓存头部设置不当，很可能导致</p>\n<p><img src=\"http://www.mobify.com/static/blog/2013/04/CDN_basic_diagram.png\" alt=\"简单的CDN图\"><br>这是一个 CDN 网络中的基本的数据流图。你的 Web 服务器提供内容给 CDN 中间服务器，而 CDN 中间服务器分布在全球不同地区。懒一点的话，可以在这里画一片云。</p>\n<p>Beyond their intended use for caching, CDNs also have a pleasant side-effect; provided you’re dealing with a website, or a particularly well-crafted web application, in the event that your servers experience a momentary outage, your CDN may be able to buffer the experience for your end users, ensuring they never even notice.</p>\n<p>The Basic Headers</p>\n<p>So, you know what a CDN is, and you know you want to configure your response headers to make use of them. Most web servers make it trivial to set response headers, so I’ll leave it to you, Google, and the man pages to figure that part out. For now, let’s move onto what headers you should care about.</p>\n<ol>\n<li>cache-control</li>\n</ol>\n<p>If there were a default super-header for caching behavior, this would be it. Typically you will see a string of settings for this header along the lines of:</p>\n<p>cache-control: private, max-age=0, no-cache<br>These settings are called cache response directives, and are as follows:</p>\n<p>private | public<br>Essentially they let intermediary caches know that a given response is specific to the end user and should not be cached. Do not make the mistake of assuming that this in any way provides you with some kind of security or privacy: Keep using SSL for that.</p>\n<p>no-cache<br>When used alone, this guy lets you specify that caches should revalidate this resource every time, typically using the “etag” header outlined below. The fun bit comes when you specify a field name after the no-cache directive, which lets caches know that you can cache the response, provided that the named fields are stripped out; cookies would be a good example of why you might want to do this. I should note that older User Agents won’t respect this trick, so you shouldn’t depend on it too much.</p>\n<p>no-store<br>This guy lets you specify that caches should not store this response. I know that may be surprising given the name, but there it is. Actually, if the cache in question is following the rules, it will also ensure that no part of the request is stored either. “no-store” was designed with sensitive information requirements in mind, and so is kind of like the G-Man of cache headers.</p>\n<p>max-age<br>Traditionally, you would let caches know when an asset is expired by using the aptly-named “expires” header, discussed below. However, if you want to be more explicit, you may set a max-age, in seconds, which will override the expires header. Further reasons to use this directive are discussed below under the Caveats section.</p>\n<p>s-maxage<br>Using our keen deductive skills, we can see some similarities between this header and the last one. “s-“ is for shared, as in “shared cache”, as in CDN. These directives are explicitly for CDNs and other intermediary caches. When present, this directive overrides both the max-age and expires header, and most well behaved CDNs will obey it.</p>\n<p>must-revalidate<br>This one is fun, although not applicable to most of us. For the sake of completeness, and in case your dev-team has some kind of trivia night where free beer is involved, we’ll discuss it. Essentially, if your responses include this directive, you are telling the cache that it needs to revalidate a cached asset on any subsequent request, and that it may not, under any circumstance, serve stale content (which is sometimes a desired behaviour). Of course, I say “under any circumstances”, but what I really mean is that there’s a big fat asterisk next to that claim. If your users are under “severe connectivity constraints”, (perhaps they are browsing from low-earth-orbit), then their user agents may serve stale content, provided they pinky-swear to tell their users that they’ve done so. Apparently this directive exists because some protocols require it, typically involving transactions.</p>\n<p>no-transform<br>“Transform into what?”, you’re surely asking. Some proxies will convert image formats and other documents to improve performance. Presumably this was thought to be a feature that you should have to opt out of. If you don’t like the idea of your CDN making automated guesses about how your content should be encoded or formatted, I suggest including this header.</p>\n<p>proxy-revalidate<br>Essentially the same as the “must-revalidate” directive, except it’s just for the shared caches. Why didn’t they call it “s-mustrevalidate”? I’m sure there exists a mailing list somewhere where you could find that debate, but for now, just know that like “s-maxage”, this directive is designed for intermediary proxies and not user agents. The idea here is that you validate each end-user only once between the proxy and their agent, but each new user should revalidate back to the server. I suspect if your service requires this feature, you probably already know about it.</p>\n<p>As always, you should check out the spec for these settings if you need any clarification.</p>\n<ol start=\"2\">\n<li>expires</li>\n</ol>\n<p>Back in the day, this was the standard way to specify when an asset expired, and is just a basic date-time stamp. It is still fairly useful for older user agents, which crypto webologists assure us still roam in the uncharted territories. On most modern systems, the “cache-control” headers “max-age” and “s-maxage” will take precedence, but it’s always good practice to set a matching value here for compatibility. Just make sure you format the date correctly, or it will be evaluated as an expired date:</p>\n<p>Thu, 01 Dec 1983 20:00:00 GMT<br>Try to avoid setting the value to more than one year out as that breaks the specification, (see below for a discussion on cache time settings).</p>\n<ol start=\"3\">\n<li>etag</li>\n</ol>\n<p>Short for “entity-tag”, the etag is a unique identifier for the resource being requested, typically comprised of the hash of that resource, or a hash of the timestamp the resource was updated. Basically, this lets a client ask smarter questions of the CDNs, like “give me X if it’s different than the etag I already have.”</p>\n<p>There’s a neat trick you can do with etags, which is to make them weak validators. This basically tells the user that although they are not the same, the two resources are functionally equivalent. Support for this feature is considered optional though, so you will want to do some testing with your providers, (discussed below).</p>\n<ol start=\"4\">\n<li>vary</li>\n</ol>\n<p>Oh wow. This one is fun. The “vary” header is extremely powerful, but can trip up what would otherwise be a simple caching scheme. IE has had issues handling the “vary” header in the past, and at one point, even Chrome was handling this in a funny way. Essentially, “vary” lets the caches know which of the headers to use to figure out if they have a valid cache for a request; if a cache were a giant key-value store, adding “vary” fields appends those values to the key, thus changing which requests are considered valid matches for what exists in the cache.</p>\n<p>You would commonly set this to something like “Accept-Encoding” to make sure your gzip’ed assets get served where appropriate, saving you all that bandwidth you might otherwise waste. Additionally, setting:</p>\n<p>vary: User-Agent<br>will put you in the SEO good-books if you happen to be serving different versions of your HTML/CSS depending on the User-Agent of the request. Google will note the header and have the Googlebot crawl your mobile content as well.</p>\n<ol start=\"5\">\n<li>pragma</li>\n</ol>\n<p>Another beast from the days of yore, the “pragma” header does many things, and most of them are honoured by newer implementations. The directive we’re most concerned with is:</p>\n<p>pragma: no-cache<br>which gets interpreted by newer implementations as:</p>\n<p>cache-control: no-cache<br>I would not generally recommend worrying about it, but for the sake of completeness, there it is. No new HTTP directives will be defined for “pragma” going forward.</p>\n<p>Some Caveats</p>\n<p>Now that we’ve gotten some of the standard and expected behaviors out of the way, we should probably mention that not every CDN or User Agent will behave according to the specification, which I’m sure is not news to anyone familiar with browser compatibility issues. For this reason, it is a good idea to test your services before launching a live resource to make sure the behavior you get is what you expected; it will save you money.</p>\n<p>Also, you may have noted that a lot of the headers seem to be either duplicated or overlapping. Some of this is because there are subtle differences between the different methods, and also because the web is shifting over from HTTP/1.0 to HTTP/1.1, which uses the “cache-control” much more heavily. Generally it is safe to set both and let the CDNs and User Agents figure out which one they care to listen to.</p>\n<ol>\n<li>Compression</li>\n</ol>\n<p>Remember that “Accept-Encoding” example for the “vary” header we talked about? That’s your new best friend if you intend to serve compressed content, which I hope you do to increase performance and save on bandwidth. CDN providers that get a request with “gzip” as an accepted encoding are expected to request the compressed asset from the origin server, or to serve a cached version of that compressed asset. Historically, this has been a sticking point for some CDNs, and for people wishing to use something like S3 to serve their files, although modern CDNs are able to perform the compression operation themselves if need be.</p>\n<p>Things to watch out for when the CDN serves compressed assets is that they’ll often ensure that both uncompressed (AKA identity) and gzip’ed version are in their cache, regardless of which was requested. There is a time delay as they perform that operation, so any testing you do will have to take that delay into account.</p>\n<ol start=\"2\">\n<li>SSL</li>\n</ol>\n<p>A CDN is basically a Man-In-The-Middle, meaning you need to think about your HTTPS traffic and how it gets back to your server. Many CDNs will pipe a request for <a href=\"https://somesite.com/asset\" target=\"_blank\" rel=\"noopener\">https://somesite.com/asset</a> to your servers as <a href=\"http://somesite.com/asset\" target=\"_blank\" rel=\"noopener\">http://somesite.com/asset</a>, so if your server logic depended on that being SSL, either reconsider your logic or ask your CDN to redirect to an HTTPS origin URL. Most CDNs are capable of doing so, with varying degrees of flexibility.</p>\n<p>But What about Dynamic Content?</p>\n<p>Generally the rule of thumb for dynamic content, like the HTML files of a WordPress blog, is to set “cache-control: no-cache” and prevent the CDNs or User Agents from storing the asset. For most applications, serving your own dynamic content is probably fine, however if you need to boost performance, read on.</p>\n<p>Typical Dynamic Content<br>HTTP/1.1 200 OK<br>Server: Apache<br>X-Rack-Cache: miss<br>ETag: “e6811cdbcedf972c5e8105a89f637d39-gzip”<br>Status: 200<br>Content-Type: text/html; charset=utf-8<br>Expires: Mon, 29 Apr 2013 21:44:55 GMT<br>Cache-Control: max-age=0, no-cache, no-store<br>Pragma: no-cache<br>Date: Mon, 29 Apr 2013 21:44:55 GMT<br>An example of a section of a header for dynamic content. Note the missed cache status, and the cache-control directives all set to 0 seconds.</p>\n<p>Most dynamic content has a shelf-life and is not nearly as volatile as we assume. Things like “Active Users” are probably valid for 10 or 20 seconds, depending on your site. Dashboards that report daily figures could certainly stand to be cached for a few minutes. News feeds could certainly stand to be cached for a while, especially if you remember to set an “etag”. If your site is seeing lots of load, it may be worth trying out a short cache on your dynamic assets.</p>\n<p>An Analysis of Cache Time</p>\n<p>So what types of cache times should you consider setting? Again, this will require you to consider things like the rate of traffic to your site, how sizeable your assets are, and how large your cache is, (yes, there are space allocations, so don’t go over them).</p>\n<p>Additionally, you should consider the main tradeoff: speed and performance vs. control. If you want to update an asset and need the new version to be live immediately, you may run into trouble if you thought a one-year cache time was a good idea, especially if you set that for Users (max-age) and not just CDNs (s-maxage).</p>\n<p>The longest you can set your headers and still be following the specification is one year, or 31536000 seconds, but this is not a very good idea. That’s like getting a face tattoo; it stays around forever, barring expensive or painful removal surgery, which accurately describes the annoyances of having to trick caches into refetching an asset through name changes or hoping you remembered to correctly set your etag and that your users and CDNs implemented them correctly. If your servers can’t stand to have your CDNs ask once a day if your profile picture has changed you should upgrade your servers.</p>\n<p>Sane Static Content Headers<br>HTTP/1.1 200 OK<br>Cache-Control: no-transform,public,max-age=300,s-maxage=900<br>Content-Type: text/html; charset=UTF-8<br>Date: Mon, 29 Apr 2013 16:38:15 GMT<br>ETag: “bbea5db7e1785119a7f94fdd504c546e”<br>Last-Modified: Sat, 27 Apr 2013 00:44:54 GMT<br>Server: AmazonS3<br>Vary: Accept-Encoding<br>X-Cache: HIT<br>A sample of cache settings for a static asset served from S3. Here we see that the cache has been asked to store the asset for 900 seconds rather than the 300 seconds set for User Agents. Also note the “x-cache: HIT” header, indicating the CDN served the request.</p>\n<p>There is one exception to the “thou-shalt-not-set-one-year-headers” commandment, or more accurately, there’s a bit of a hack to get around their pitfalls: if you’ve configured your site to generate resource names, you can rename your assets each time you publish a new version. Typically, this will involve an incrementing version number, a date-time stamp, or a hash of the contents, much like an “etag”, being appended to the file name, so that you end up with things like “core.E89A123FFDB…432D687B.css” and the like. It’s not pretty, but really, who cares? Also, this lets you set one-year-headers without worrying about updating your resources.</p>\n<p>A handy table best explains the cache time trade-off. Assuming a web asset get 500 requests per minute, then the following Hit Ratios are possible for each cache time:</p>\n<p>Cache time (minutes) Hit Ratio Request to Origin / Hr<br>1 99.8% 60<br>5 99.96% 12<br>20 99.99% 3<br>60 99.997% 1<br>86400 99.9998% &lt;1<br>There. It’s spelt out. What kind of Hit Ratio do you need? Typically 60 seconds to an hour is an ideal trade-off. For pseudo-dynamic content, you can still use CDNs, just start working in the under-60-seconds range, as appropriate for the request.</p>\n<p>Testing Your CDN</p>\n<p>So, onto the testing. Always check that the headers are coming through CDNs the way you expect when setting up new services. Typically a CDN will insert some kind of “x-“ header to indicate that it hit, missed, or served expired content. What we’re looking for is a convenient way to look at this and other headers, and to set them on our requests for testing. There are more than a few tools out there to help, though these are the ones I’ve found most handy.</p>\n<ol>\n<li>Web Inspector</li>\n</ol>\n<p>Probably the most accessible method, simply right-click on a webpage in Chrome, click Inspect Element, navigate to the Network tab, hit refresh, and click on the HTML asset at the top. If it’s not selected by default, checkout the Headers tab to see all your request and response headers. Chrome also lets you set the user agent you request with, and gives you the option to not use your local cache, which is handy when you’re testing.</p>\n<ol start=\"2\">\n<li>Charles Proxy et al.</li>\n</ol>\n<p>Tools like Charles Proxy will let you route traffic through them and manipulate DNS lookups, record headers, and see performance statistics, all in a clean, easy-to-use GUI. These tools are generally more task-specific than the Web Inspector and other browser tools, and generally worth the small licensing fee if you work with web requests in any significant way.</p>\n<ol start=\"3\">\n<li>cURL</li>\n</ol>\n<p>Quick, easy, and highly flexible, cURL lets you make web requests directly from the command line and check out the responding headers. Helpful flags include -A for user agents, -b for cookies, -F for form data, -H for setting headers, and -I to request the header only. Very handy for sanity checks, and extremely powerful.</p>\n<ol start=\"4\">\n<li>hurl.it</li>\n</ol>\n<p>hurl.it is essentially cURL with a prettier interface, and in a web browser. You’re able to set the headers you pass in to the request, as well as view the full header and body response. Although you don’t quite get the robustness of the command line, it’s still very useful for a quick header examination, and is probably the fastest way to get access to headers if you’re in a hurry.</p>\n<ol start=\"5\">\n<li>Python and Requests</li>\n</ol>\n<p>Requests is a great Python package for making web requests, and is useful for quick checks from the REPL, or from slightly more complex scripted checks. Using Requests comes with the added benefit of letting you write a test-suite for your web assets to assert the status of response headers.</p>\n<p>Notes from the Field and Parting Thoughts</p>\n<p>So now you’ve made it all the way through our quick guide to cache headers, and you’re eager to get going on setting your own. Excellent. However, now it’s time to put some of this in perspective.</p>\n<p>Most web servers, like Apache and Nginx, will do a lot of this work for you. Really, the “cache-control” header is the only one you’re going to have to work with. Web browsers are typically set up to cache aggressively to improve user experience, so often you’ll be fighting to prevent caching rather than ensuring it. Generally this means that you set a “/static” path and configure its caching headers to allow caching up to some reasonable interval like 300 seconds. Next, you would ensure that your root path “/” has “cache-control: no-cache” enabled, or better yet route dynamic content straight to your servers and only have “/static” use your CDN. This is a healthy starting point for most purposes. If your hosting bill is astronomical, or you get to use operations cost savings as beer money, then consider tweaking your settings.</p>\n<p>CDNs will often give you the option of breaking protocol and will cache for whatever period you like, regardless of the headers. They also take liberties with the protocols depending on their interpretation of expected behavior, which is why it’s important to test the headers you get out of your CDN and compare them to your servers. Consider the expected behavior outlined here to be a baseline and keep an eye out for variance.</p>\n<p>Good luck, and happy caching!</p>\n"},{"title":"Lodash函数以及常见用法","_content":"\n## 1 简介\n\n[Lodash](https://github.com/lodash/lodash)是一款优秀的 JavaScript 工具库，里面包含了大量的工具函数。在 2015 年就成为[被依赖最多的 JavaScript 库](https://www.npmjs.com/browse/depended)，写这篇文档是最新版是 4.17.4，适用于常见浏览器以及 Node.js 等。\n\n这里给出其[英文文档](https://lodash.com/docs)和[中文文档](http://lodash.think2011.net/)的链接。其中中文文档的版本较低，但是区别不大，可以参考帮助理解。\n\n## 2 常见用法\n\n在这部分我们介绍一些 Lodash 的常见的优雅的用法。主要是引起大家的学习兴趣，有更多优雅用法等待大家去发现。\n\n### `_.get`获取一个嵌套很深的字段\n\n```js\n//config 初始化为 null，需要从服务器端获取权限数据\nlet config = null;\najax.get(url, function(data) {\n    // data = {basic: {delete: true}}\n    config = data;\n});\n//使用原生JS获取是否有删除权限\nlet isDeletable = false;\nif (config && config.basic) {\n    isDeletable = config.basic.delete || false;\n}\n//使用lodash获取是否有删除权限\nlet isDeletable = _.get(config, 'basic.delete', false);\n```\n\n对应地，可以通过`_.set({}, 'a.b.c', 1)`创建一个多级嵌套的对象。\n\n### `_.map`获取数组中每个对象的特定字段，并形成一个新的数组\n\n```js\n//使用所有用户的 idCard 字段创建出一个数组\nlet users = [{ idCard: '20160512', name: '张三' }, { idCard: '20160513', name: '李四' }];\n//使用原生JS\nlet idCards = users.map(function(user) {\n    return user.idCard;\n});\n//使用lodash\nlet idCards = _.map(model, 'idCard');\n```\n\n### `_.pick`取出对象的部分字段形成一个新对象\n\n```js\n//在修改密码表单里，用户输入了如下字段并被封装到一个对象中\nlet form = {\n    password: '123456', //密码\n    repeatPassword: '123456', //重复密码\n    code: '5489', //验证码\n};\n\n//这里不直接使用delete删除字段，是因为该 form 对象与 DOM 进行了绑定。\n//其中重复密码只用来在客户端校验，不需要发送给服务器\nlet data = {};\nlet fields = ['password', 'code'];\nfor (var i = 0; i < fields.length; i++) {\n    data[fields[i]] = form[fields[i]];\n}\n\n//使用lodash\nlet data = _.pick(form, 'password', 'code');\n```\n\n对应地，还有`_.omit`方法表示删除部分字段形成一个新对象。\n\n### `_.random`获取一个随机值\n\n```js\n//获取[90, 100)之内的一个随机值\nlet min = 90;\nlet max = 100;\n//使用原生JS\nlet random = Math.floor(Math.random() * (max - min)) + min;\n//使用lodash\nlet random = _.random(min, max);\n```\n\n类似地，`_.sample(['a', 'b', 'c'])`可以从数组中随机取出一个项目。\n\n### `_.clamp`将一个数字修改成区间中的一个值\n\n```js\n//使用原生JS\nfunction applyRange(number) {\n    number = Math.max(number, this.props.min);\n    number = Math.min(number, this.props.max);\n    return number;\n}\n//使用lodash\nlet number = _.clamp(number, min, max);\n```\n\n### `_.once`确保一个函数只会执行一次\n\n```js\n//使用原生JS\nlet inited = false;\nfunction init() {\n    if (inited) return;\n    // init code\n}\n//使用lodash\nlet init = _.once(function() {\n    // init code\n});\n```\n\n### `_.chain`链式操作\n\n链接调用让代码更加整洁；避免了中间变量，避免了错误引用，让代码质量更有保证；`_.chain`还提供了延迟计算特性，在显式或隐式调用`value()`方法之前是不进行任何计算的，通过合并大大降低迭代次数。  \n下面是`lodash`的官方文档中的一个例子。\n\n```js\nvar users = [{ user: 'barney', age: 36 }, { user: 'fred', age: 40 }, { user: 'pebbles', age: 1 }];\n\nvar youngest = _.chain(users)\n    .sortBy('age')\n    .map(function(chr) {\n        return chr.user + ' is ' + chr.age;\n    })\n    .first()\n    .value();\n// → 'pebbles is 1'\n```\n\n## 3 模块\n\nLodash 的工具函数很多，可以分为以下几类：数组（Array），集合（Collection），函数（Function），Lang（Lang），数学（Math），数字（Number），对象（Object），字符串（String），未分类工具函数（Util）。下面将会按类别介绍常见工具函数。\n\n## 4 数组\n\n### 获取子数组\n\n| 函数名                                                    | 简介                                             |\n| --------------------------------------------------------- | ------------------------------------------------ |\n| [slice](https://lodash.com/docs/#slice)                   | 获取元素第 m-n(不包含)个元素                     |\n| [tail](https://lodash.com/docs/#tail)                     | 获取出第一个元素之外的其他元素                   |\n| [initial](https://lodash.com/docs/#initial)               | 获取出最后一个元素之外的其他元素                 |\n| [take](https://lodash.com/docs/#take)                     | 从左侧开始获取任意数量的元素                     |\n| [takeRight](https://lodash.com/docs/#takeRight)           | 从右侧开始获取任意数量的元素                     |\n| [takeWhile](https://lodash.com/docs/#takeWhile)           | 从左侧开始获取任意数量的元素，直到断言返回假值   |\n| [takeRightWhile](https://lodash.com/docs/#takeRightWhile) | 从右侧开始获取任意数量的元素，直到断言返回假值   |\n| [drop](https://lodash.com/docs/#drop)                     | 丢掉前面几个元素，得到剩余元素                   |\n| [dropWhile](https://lodash.com/docs/#dropWhile)           | 丢掉前面几个元素知道迭代器返回假值，得到剩余元素 |\n| [dropRight](https://lodash.com/docs/#dropRight)           | 丢掉后面几个元素，得到剩余元素                   |\n| [dropRightWhile](https://lodash.com/docs/#dropRightWhile) | 丢掉后面几个元素知道迭代器返回假值，得到剩余元素 |\n\n### 数组常见操作\n\n| 操作 | 不修改原数组                                              | 修改原数组                                          |\n| ---- | --------------------------------------------------------- | --------------------------------------------------- |\n| 移除 | [without](https://lodash.com/docs/#without)               | [pull](https://lodash.com/docs/#pull)               |\n| 相减 | [difference](https://lodash.com/docs/#difference)         | [pullAll](https://lodash.com/docs/#pullAll)         |\n| 相减 | [differenceBy](https://lodash.com/docs/#differenceBy)     | [pullAllBy](https://lodash.com/docs/#pullAllBy)     |\n| 相减 | [differenceWith](https://lodash.com/docs/#differenceWith) | [pullAllWith](https://lodash.com/docs/#pullAllWith) |\n| 反转 |                                                           | [reverse](https://lodash.com/docs/#reverse)         |\n| 裁剪 | [at](https://lodash.com/docs/#at)                         | [pullAt](https://lodash.com/docs/#pullAt)           |\n| 过滤 | [filter](https://lodash.com/docs/#filter)                 | [remove](https://lodash.com/docs/#remove)           |\n\n### 数组常见操作变种函数 by, with\n\n有些函数还可以稍微变化一下，接受不同的参数，提供更多灵活性。\n\n| 作用 | 函数名                                                | by                                                        | with                                                                                                                                                                    |\n| ---- | ----------------------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 相减 | [difference](https://lodash.com/docs/#difference)     | [differenceBy](https://lodash.com/docs/#differenceBy)     | [differenceWith](https://lodash.com/docs/#differenceWith)                                                                                                               |\n| 交集 | [intersection](https://lodash.com/docs/#intersection) | [intersectionBy](https://lodash.com/docs/#intersectionBy) | [intersectionWith](https://lodash.com/docs/#intersectionWith)                                                                                                           |\n| 并集 | [union](https://lodash.com/docs/#union)               | [unionBy](https://lodash.com/docs/#unionBy)               | [unionWith](https://lodash.com/docs/#unionWith)                                                                                                                         |\n| 异或 | [xor](https://lodash.com/docs/#xor)                   | [xorBy](https://lodash.com/docs/#xorBy)                   | [xorWith](https://lodash.com/docs/#xorWith)                                                                                                                             |\n| 相减 | [pullAll](https://lodash.com/docs/#pullAll)           | [pullAllBy](https://lodash.com/docs/#pullAllBy)           | [pullAllWith](https://lodash.com/docs/#pullAllWith)，跟[difference](https://lodash.com/docs/#difference)不同的是，[pullAll](https://lodash.com/docs/#pullAll)修改原数组 |\n| 去重 | [uniq](https://lodash.com/docs/#uniq)                 | [uniqBy](https://lodash.com/docs/#uniqBy)                 | [uniqWith](https://lodash.com/docs/#uniqWith)                                                                                                                           |\n| 去重 | [sortedUniq](https://lodash.com/docs/#sortedUniq)     | [sortedUniqBy](https://lodash.com/docs/#sortedUniqBy)     |                                                                                                                                                                         |  |\n\n### 获取数组某个位置上的元素\n\n| 函数名                                | 主要参数-返回值 | 简介                                                                |\n| ------------------------------------- | --------------- | ------------------------------------------------------------------- |\n| [head](https://lodash.com/docs/#head) | 数组=>元素      | 返回数组的第一个元素，和[first](https://lodash.com/docs/#first)相同 |\n| [last](https://lodash.com/docs/#last) | 数组=>元素      | 返回数组的最后一个元素，和[head](https://lodash.com/docs/#head)相反 |\n| [nth](https://lodash.com/docs/#nth)   | 数组=>元素      | 返回数组中某个位置上的元素                                          |\n\n### 检测元素在数组中的索引\n\n| 函数名                                                          | 简介                                                                                |\n| --------------------------------------------------------------- | ----------------------------------------------------------------------------------- |\n| [indexOf](https://lodash.com/docs/#indexOf)                     | 获取元素在数组中的索引                                                              |\n| [sortedIndexOf](https://lodash.com/docs/#sortedIndexOf)         | 和[indexOf](https://lodash.com/docs/#indexOf)功能一致，只是通过二分搜索方法         |\n| [lastIndexOf](https://lodash.com/docs/#lastIndexOf)             | 获取元素在数组中的索引，最后一次出现                                                |\n| [sortedLastIndexOf](https://lodash.com/docs/#sortedLastIndexOf) | 和[lastIndexOf](https://lodash.com/docs/#lastIndexOf)功能一致，只是通过二分搜索方法 |\n| [findIndex](https://lodash.com/docs/#findIndex)                 | 寻找元素位置                                                                        |\n| [findLastIndex](https://lodash.com/docs/#findLastIndex)         | 寻找元素位置，从后往前                                                              |\n\n### 检测元素在插在有序数组的什么位置\n\n| 函数名                                                          | 简介                                                                      |\n| --------------------------------------------------------------- | ------------------------------------------------------------------------- |\n| [sortedIndex](https://lodash.com/docs/#sortedIndex)             | 通过二分搜索判断元素应该插在数组的哪个位置                                |\n| [sortedIndexBy](https://lodash.com/docs/#sortedIndexBy)         | 同上，可以额外提供一个迭代器函数                                          |\n| [sortedLastIndex](https://lodash.com/docs/#sortedLastIndex)     | 和[sortedIndex](https://lodash.com/docs/#sortedIndex)类似，但是从右边开始 |\n| [sortedLastIndexBy](https://lodash.com/docs/#sortedLastIndexBy) | 同上，可以额外提供一个迭代器函数                                          |\n\n### 将数组拍平\n\n| 函数名                                                | 主要参数-返回值    | 简介       |\n| ----------------------------------------------------- | ------------------ | ---------- |\n| [flatten](https://lodash.com/docs/#)                  | 高维数组=>低维数组 | 将数组拍平 |\n| [flattenDeep](https://lodash.com/docs/#flattenDeep)   | 高维数组=>数组     | 将数组拍平 |\n| [flattenDepth](https://lodash.com/docs/#flattenDepth) | 高维数组=>低维数组 | 将数组拍平 |\n\n### Zip\n\n| 函数名                                                  | 主要参数-返回值    | 简介                                                   |\n| ------------------------------------------------------- | ------------------ | ------------------------------------------------------ |\n| [zip](https://lodash.com/docs/#zip)                     | 多个数组=>二维数组 | 可以理解为二维数组的行列互换                           |\n| [zipWith](https://lodash.com/docs/#zipWith)             | 多个数组=>数组     | 同上，但是可以自由处理行列互换后的数组中的每个数组元素 |\n| [zipObject](https://lodash.com/docs/#zipObject)         | 两个数组=>对象     | 把 keys 和 values 数组组成一个新对象                   |\n| [zipObjectDeep](https://lodash.com/docs/#zipObjectDeep) | 两个数组=>对象     | 同上，递归地处理属性名                                 |\n\n### 未分类函数\n\n| 函数名                                          | 主要参数-返回值 | 简介                                                                  |\n| ----------------------------------------------- | --------------- | --------------------------------------------------------------------- |\n| [chunk](https://lodash.com/docs/#chunk)         | 数组=>二维数组  | 分段形成二维数组                                                      |\n| [compact](https://lodash.com/docs/#compact)     | 数组=>数组      | 移除假值                                                              |\n| [concat](https://lodash.com/docs/#concat)       | 多个数组=>数组  | 连接多个数组形成一个数组                                              |\n| [fill](https://lodash.com/docs/#fill)           | 数组=>数组      | 填充数组                                                              |\n| [fromPairs](https://lodash.com/docs/#fromPairs) | 二维数组=>对象  | 将键值数组变成对象。和[toPairs](https://lodash.com/docs/#toPairs)相反 |\n| [join](https://lodash.com/docs/#join)           | 数组=>字符串    | 拼接数组元素成一个字符串                                              |\n\n## 5 集合\n\n为什么区分集合函数和数组函数？\n集合函数不单单适用于数组，还适用于字符串，对象，类数组对象（比如 Arguments，NodeList 等）。字符串是字符的集合，对象是属性值的集合。类数组对象是通过“[鸭子类型](https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B)”工作的，所以如果你传入一个拥有`length`字段并且值为数字的对象，这个对象会被当做一个数组处理。具体请参考[Underscore.js](http://underscorejs.org/#collections)文档。\n\n范例：\n\n```js\nfunction printKeyVal(val, key) {\n    console.log(key, val);\n}\n\n//普通对象\n_.each({ a: 1 }, printKeyVal);\n//打印结果\n// a 1\n\n//拥有值为数字的length字段\n_.each({ a: 1, length: 2 }, printKeyVal);\n//打印结果\n// 0 undefined\n// 1 undefined\n```\n\n下面将分类介绍集合相关函数。\n\n### 遍历\n\n| 函数名                                          | 简介                                                    |\n| ----------------------------------------------- | ------------------------------------------------------- |\n| [each](https://lodash.com/docs/#each)           | 同[forEach](https://lodash.com/docs/#forEach)           |\n| [eachRight](https://lodash.com/docs/#eachRight) | 同[forEachRight](https://lodash.com/docs/#forEachRight) |\n\n### 排序\n\n| 函数名                                      | 简介                                                      |\n| ------------------------------------------- | --------------------------------------------------------- |\n| [sortBy](https://lodash.com/docs/#)         | 排序                                                      |\n| [orderBy](https://lodash.com/docs/#orderBy) | 同[sortBy](https://lodash.com/docs/#)，还可以指定正序倒序 |\n| [shuffle](https://lodash.com/docs/#shuffle) | 返回一个打乱顺序的新数组                                  |\n\n### 过滤\n\n| 函数名                                          | 简介                                       |\n| ----------------------------------------------- | ------------------------------------------ |\n| [filter](https://lodash.com/docs/#filter)       | 创建一个新数组，包含了所有让断言为真的元素 |\n| [reject](https://lodash.com/docs/#reject)       | 创建一个新数组，包含了所有让断言为假的元素 |\n| [partition](https://lodash.com/docs/#partition) | 根据断言真假将一个集合分成两个集合         |\n\n### Map 之后再 flatten\n\n| 函数名                                                | 简介                                                                                           |\n| ----------------------------------------------------- | ---------------------------------------------------------------------------------------------- |\n| [flatMap](https://lodash.com/docs/#flatMap)           | [map](https://lodash.com/docs/#map)之后再[flatten](https://lodash.com/docs/#flatten)           |\n| [flatMapDeep](https://lodash.com/docs/#flatMapDeep)   | [map](https://lodash.com/docs/#map)之后再[flattenDeep](https://lodash.com/docs/#flattenDeep)   |\n| [flatMapDepth](https://lodash.com/docs/#flatMapDepth) | [map](https://lodash.com/docs/#map)之后再[flattenDepth](https://lodash.com/docs/#flattenDepth) |\n\n### 寻找元素\n\n| 函数名                                        | 简介                       |\n| --------------------------------------------- | -------------------------- |\n| [find](https://lodash.com/docs/#find)         | 找到第一个让断言为真的元素 |\n| [findLast](https://lodash.com/docs/#findLast) | 同上，逆序                 |\n\n### 随机取值\n\n| 函数名                                            | 简介                      |\n| ------------------------------------------------- | ------------------------- |\n| [sample](https://lodash.com/docs/#sample)         | 从集合中随机选出一个元素  |\n| [sampleSize](https://lodash.com/docs/#sampleSize) | 从集合中随机选出 n 个元素 |\n\n### 迭代\n\n| 函数名                                              | 简介 |\n| --------------------------------------------------- | ---- |\n| [reduce](https://lodash.com/docs/#reduce)           |      |\n| [reduceRight](https://lodash.com/docs/#reduceRight) | -    |\n\n### 分组计数\n\n| 函数名                                      | 简介                                                                   |\n| ------------------------------------------- | ---------------------------------------------------------------------- |\n| [countBy](https://lodash.com/docs/#countBy) | 返回一个对象，属性名是迭代器的返回值，属性值该返回值出现的次数         |\n| [groupBy](https://lodash.com/docs/#groupBy) | 返回一个对象，属性名是迭代器的返回值，属性值是一个包含了相应元素的数组 |\n\n### 未分类\n\n| 函数名                                          | 简介                                                                                               |\n| ----------------------------------------------- | -------------------------------------------------------------------------------------------------- |\n| [keyBy](https://lodash.com/docs/#keyBy)         | 返回一个对象，属性名是迭代器的返回值，属性值是元素本身                                             |\n| [some](https://lodash.com/docs/#)               | 对于集合中的每个元素，是否至少其一返回真值                                                         |\n| [every](https://lodash.com/docs/#every)         | 对于集合中的每个元素，是否都返回真值                                                               |\n| [includes](https://lodash.com/docs/#includes)   | 判断元素是不是在数组中，判断某个值是不是某个对象的属性值，判断一个字符串是不是包含在另一个字符串中 |\n| [map](https://lodash.com/docs/#map)             | 对集合的数组                                                                                       |\n| [invokeMap](https://lodash.com/docs/#invokeMap) | -                                                                                                  |\n\n## 6 对象\n\n### 仅需要部分字段\n\n| 函数名                                    | 简介                           |\n| ----------------------------------------- | ------------------------------ |\n| [omit](https://lodash.com/docs/#omit)     | 通过忽略某些字段创建一个新对象 |\n| [omitBy](https://lodash.com/docs/#omitBy) |                                |\n| [pick](https://lodash.com/docs/#pick)     | 通过指定某些字段创建一个新对象 |\n| [pickBy](https://lodash.com/docs/#pickBy) | -                              |\n\n### 合并对象\n\n| 函数名                                                | 简介                                                                           |\n| ----------------------------------------------------- | ------------------------------------------------------------------------------ |\n| [assign](https://lodash.com/docs/#assign)             | 合并对象                                                                       |\n| [assignWith](https://lodash.com/docs/#assignWith)     | 有条件地合并对象                                                               |\n| [extend](https://lodash.com/docs/#extend)             | 合并对象，包括原型链上的属性                                                   |\n| [extendWith](https://lodash.com/docs/#extendWith)     | 有条件地合并对象，包括原型链上的属性                                           |\n| [assignIn](https://lodash.com/docs/#assignIn)         | 别名`extend`                                                                   |\n| [assignInWith](https://lodash.com/docs/#assignInWith) | 别名`extendWith`                                                               |\n| [defaults](https://lodash.com/docs/#defaults)         | 合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话       |\n| [defaultsDeep](https://lodash.com/docs/#defaultsDeep) | 递归地合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话 |\n| [merge](https://lodash.com/docs/#merge)               | 递归地合并对象，将后面参数的属性付给第一个参数                                 |\n| [mergeWith](https://lodash.com/docs/#mergeWith)       | 同[merge](https://lodash.com/docs/#merge)，额外接受一个 customizer 参数        |\n\n### 键值列表\n\n| 函数名                                              | 简介                                                         |\n| --------------------------------------------------- | ------------------------------------------------------------ |\n| [keys](https://lodash.com/docs/#keys)               | 创建一个数组，包含对象中所有的属性                           |\n| [keysIn](https://lodash.com/docs/#keysIn)           | 创建一个数组，包含对象中所有的属性（包含原型链上的）         |\n| [functions](https://lodash.com/docs/#functions)     | 创建一个数组，包含对象中所有值为函数的属性                   |\n| [functionsIn](https://lodash.com/docs/#functionsIn) | 创建一个数组，包含对象中所有值为函数的属性（包含原型链上的） |\n| [values](https://lodash.com/docs/#values)           | 创建一个数组，包含对象中所有的属性值                         |\n| [valuesIn](https://lodash.com/docs/#valuesIn)       | 创建一个数组，包含对象中所有的属性值（包含原型链上的）       |\n\n### 赋值取值\n\n| 函数名                                            | 简介                                                                               |\n| ------------------------------------------------- | ---------------------------------------------------------------------------------- |\n| [at](https://lodash.com/docs/#at)                 | 获取对象的一组属性路径的值，肯定不会报错                                           |\n| [get](https://lodash.com/docs/#get)               | 获取对象的某个属性路径的值，肯定不会报错                                           |\n| [result](https://lodash.com/docs/#result)         | 同[get](https://lodash.com/docs/#get)，但是如果属性值是函数的话，自动执行该函数    |\n| [set](https://lodash.com/docs/#set)               | 设置对象的某个属性路径的值                                                         |\n| [setWith](https://lodash.com/docs/#setWith)       | 设置对象的某个属性路径的值，遇到不存在的中间对象，使用数组呢？还是使用对象呢？等等 |\n| [update](https://lodash.com/docs/#update)         | 同[set](https://lodash.com/docs/#set)，只是接受一个函数作为参数                    |\n| [updateWith](https://lodash.com/docs/#updateWith) | 同[setWith](https://lodash.com/docs/#setWith)，只是接受一个函数作为参数            |\n| [unset](https://lodash.com/docs/#unset)           | 删除对象的某个属性路径                                                             |\n| [invoke](https://lodash.com/docs/#invoke)         | 调用对象中某个属性路径上的函数，肯定不会报错                                       |\n\n### 键值数组\n\n| 函数名                                          | 简介                                          |\n| ----------------------------------------------- | --------------------------------------------- |\n| [entries](https://lodash.com/docs/#entries)     | {'a':1}=>[['a',1]]。别名`toPairs`             |\n| [entriesIn](https://lodash.com/docs/#entriesIn) | 同上，但是包含原型链上的属性。别名`toPairsIn` |\n\n### 键值变换\n\n| 函数名                                          | 简介                                                                                  |\n| ----------------------------------------------- | ------------------------------------------------------------------------------------- |\n| [mapKeys](https://lodash.com/docs/#mapKeys)     | 对对象中所有属性名做某种处理之后形成一个新对象                                        |\n| [mapValues](https://lodash.com/docs/#mapValues) | 对对象中所有属性值做某种处理之后形成一个新对象                                        |\n| [invert](https://lodash.com/docs/#invert)       | 将对象中的属性名和属性值互换转成一个新对象                                            |\n| [invertBy](https://lodash.com/docs/#invertBy)   | 同[invert](https://lodash.com/docs/#invert)，但是转换以后的属性值是原属性值组成的数组 |\n\n### 键值遍历\n\n| 函数名                                              | 简介                                     |\n| --------------------------------------------------- | ---------------------------------------- |\n| [forIn](https://lodash.com/docs/#forIn)             | 遍历对象上的所有属性，包含原型链上的。   |\n| [forInRight](https://lodash.com/docs/#forInRight)   | 遍历对象上的所有属性，包含原型链上的。   |\n| [forOwn](https://lodash.com/docs/#forOwn)           | 遍历对象上的所有属性，不包含原型链上的。 |\n| [forOwnRight](https://lodash.com/docs/#forOwnRight) | 遍历对象上的所有属性，不包含原型链上的。 |\n\n### 寻找属性\n\n| 函数名                                              | 简介                                                                                              |\n| --------------------------------------------------- | ------------------------------------------------------------------------------------------------- |\n| [findKey](https://lodash.com/docs/#findKey)         | 同[find](https://lodash.com/docs/#find)类似，但是匹配的是对象的属性值，返回的是对象的属性名       |\n| [findLastKey](https://lodash.com/docs/#findLastKey) | 同[findKey](https://lodash.com/docs/#findKey)类似，但是匹配的是对象的属性值，返回的是对象的属性名 |\n\n### 判断属性是否存在\n\n| 函数名                                  | 简介                                         |\n| --------------------------------------- | -------------------------------------------- |\n| [has](https://lodash.com/docs/#has)     | 判断对象上是否拥有某个属性，不包含原型链上的 |\n| [hasIn](https://lodash.com/docs/#hasIn) | 判断对象上是否拥有某个属性，包含原型链上的   |\n\n### 转换对象或数组\n\n| 函数名                                          | 简介                                                                                                    |\n| ----------------------------------------------- | ------------------------------------------------------------------------------------------------------- |\n| [transform](https://lodash.com/docs/#transform) | 同[reduce](https://lodash.com/docs/#reduce)，但是其迭代器函数返回的是布尔值，如果返回 false，则停止迭代 |\n\n### 创建新对象\n\n| 函数名                                    | 简介                             |\n| ----------------------------------------- | -------------------------------- |\n| [create](https://lodash.com/docs/#create) | 创建一个对象，并指定其原型和属性 |\n\n## 7. 函数\n\n### 修改参数\n\n| 函数名                                        | 简介                                                                                        |\n| --------------------------------------------- | ------------------------------------------------------------------------------------------- |\n| [ary](https://lodash.com/docs/#ary)           | 创建一个包裹函数，只将前 n 个参数传递给原函数。                                             |\n| [unary](https://lodash.com/docs/#unary)       | 创建一个包裹函数，只将第一个参数传递给原函数。                                              |\n| [flip](https://lodash.com/docs/#flip)         | 创建一个包裹函数，将参数逆序之后传递给原函数。                                              |\n| [rearg](https://lodash.com/docs/#rearg)       | 创建一个包裹函数，调整参数顺序之后在传递给原函数                                            |\n| [rest](https://lodash.com/docs/#rest)         | 创建一个包裹函数，将参数合成数组之后传递给原函数                                            |\n| [spread](https://lodash.com/docs/#spread)     | 创建一个包裹函数，将数组参数展开之后传给原函数，跟[rest](https://lodash.com/docs/#rest)相反 |\n| [overArgs](https://lodash.com/docs/#overArgs) | 创建一个包裹函数，将参数做处理之后再传递给原函数。                                          |\n\n### 修改结果\n\n| 函数名                                    | 简介                                   |\n| ----------------------------------------- | -------------------------------------- |\n| [negate](https://lodash.com/docs/#negate) | 创建一个包裹函数，返回原函数结果的非。 |\n\n### 缓存结果\n\n| 函数名                                      | 简介                             |\n| ------------------------------------------- | -------------------------------- |\n| [memoize](https://lodash.com/docs/#memoize) | 创建一个包裹函数，会缓存计算结果 |\n\n### 降频调用\n\n| 函数名                                        | 简介 |\n| --------------------------------------------- | ---- |\n| [debounce](https://lodash.com/docs/#debounce) |      |\n| [throttle](https://lodash.com/docs/#throttle) |      |\n\n### 延迟调用\n\n| 函数名                                  | 简介                                 |\n| --------------------------------------- | ------------------------------------ |\n| [defer](https://lodash.com/docs/#defer) | 类似`setTimeout(fn,0)`，可以指定参数 |\n| [delay](https://lodash.com/docs/#delay) | 类似`setTimeout(fn,x)`，可以指定参数 |\n\n### 延迟调用\n\n| 函数名                                    | 简介                                                          |\n| ----------------------------------------- | ------------------------------------------------------------- |\n| [once](https://lodash.com/docs/#once)     | 创建一个包裹函数，确保原函数只被执行一次。                    |\n| [before](https://lodash.com/docs/#before) | 创建一个包裹函数，确保原函数只被执行 n 次。                   |\n| [after](https://lodash.com/docs/#after)   | 创建一个包裹函数，调用包裹函数时只有 n 次之后才会调用目标函数 |\n\n### 固定参数\n\n| 函数名                                                | 简介                                                                                                                     |\n| ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |\n| [wrap](https://lodash.com/docs/#wrap)                 | 创建一个包裹函数，固定原函数的第一个参数                                                                                 |\n| [partial](https://lodash.com/docs/#partial)           | 创建一个包裹函数，固定原函数若干个参数                                                                                   |\n| [partialRight](https://lodash.com/docs/#partialRight) | 创建一个包裹函数，固定原函数若干个参数                                                                                   |\n| [bind](https://lodash.com/docs/#bind)                 | 创建一个包裹函数，固定原函数若干个参数，并指定 this 对象                                                                 |\n| [bindKey](https://lodash.com/docs/#bindKey)           | 和[bind](https://lodash.com/docs/#bind)功能类似，但是能够处理尚未创建或被重写的函数，有点事件代理的感觉。                |\n| [curry](https://lodash.com/docs/#curry)               | 创建一个包裹函数，可以传入任意数量的参数，如果参数不完整，则返回一个接受余下参数的新函数，否则，调用原函数获得计算结果。 |\n| [curryRight](https://lodash.com/docs/#curryRight)     | 同上，逆序                                                                                                               |\n\n## 8. 字符串\n\n### 书写格式\n\n| 函数名                                          | 简介                           |\n| ----------------------------------------------- | ------------------------------ |\n| [startCase](https://lodash.com/docs/#startCase) | 每个单词首字母大写，多用于标题 |\n| [camelCase](https://lodash.com/docs/#camelCase) | 小驼峰                         |\n| [kebabCase](https://lodash.com/docs/#kebabCase) | 小写连字符                     |\n| [snakeCase](https://lodash.com/docs/#snakeCase) | 小写下划线                     |\n| [upperCase](https://lodash.com/docs/#upperCase) | 大写加空格                     |\n| [lowerCase](https://lodash.com/docs/#lowerCase) | 小写加空格                     |\n\n### 大写小写\n\n| 函数名                                            | 简介                 |\n| ------------------------------------------------- | -------------------- |\n| [capitalize](https://lodash.com/docs/#capitalize) | 首字母大写，其余小写 |\n| [upperFirst](https://lodash.com/docs/#upperFirst) | 首字母大写，其余不变 |\n| [lowerFirst](https://lodash.com/docs/#lowerFirst) | 首字母小写，其余不变 |\n| [toUpper](https://lodash.com/docs/#lowerFirst)    | 大写                 |\n| [toLower](https://lodash.com/docs/#toLower)       | 小写                 |\n\n### 打头结尾\n\n| 函数名                                            | 简介                   |\n| ------------------------------------------------- | ---------------------- |\n| [endsWith](https://lodash.com/docs/#endsWith)     | 是不是以特定字符串结尾 |\n| [startsWith](https://lodash.com/docs/#startsWith) | 是不是以特定字符串打头 |\n\n### 转义\n\n| 函数名                                                | 简介                                                            |\n| ----------------------------------------------------- | --------------------------------------------------------------- |\n| [escape](https://lodash.com/docs/#escape)             | 转义 &<>\"'，与[unescape](https://lodash.com/docs/#unescape)相反 |\n| [escapeRegExp](https://lodash.com/docs/#escapeRegExp) | 转义正则表达式中的特殊字符：^\\$.\\*+?()[]{}\\|                    |\n\n### 补全抹掉\n\n| 函数名                                | 简介                                                                                                                                           |\n| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |\n| [pad](https://lodash.com/docs/#pad)   | 使用某个字符串将特定字符串扩充至指定长度，类似地还有[padStart](https://lodash.com/docs/#padStart)，[padEnd](https://lodash.com/docs/#padEnd)   |\n| [trim](https://lodash.com/docs/#trim) | 去除字符串两边的特殊字符（默认为空格），类似地还有[trimStart](https://lodash.com/docs/#trimStart)，[trimEnd](https://lodash.com/docs/#trimEnd) |\n\n### 未分类\n\n| 函数名                                        | 简介                                 |\n| --------------------------------------------- | ------------------------------------ |\n| [parseInt](https://lodash.com/docs/#parseInt) | 转成整型                             |\n| [repeat](https://lodash.com/docs/#repeat)     | 将某个字符串重复 n 遍                |\n| [replace](https://lodash.com/docs/#replace)   | 替换字符串                           |\n| [split](https://lodash.com/docs/#split)       | 拆分字符串                           |\n| [template](https://lodash.com/docs/#template) | 简单模板引擎                         |\n| [truncate](https://lodash.com/docs/#truncate) | 截断字符串                           |\n| [words](https://lodash.com/docs/#words)       | 将字符串拆分成单词，可以指定拆分模式 |\n| [deburr](https://lodash.com/docs/#deburr)     | 基本拉丁字母                         |\n\n## 9. 数字\n\n| 函数名                                      | 主要参数-返回值 | 简介                                                 |\n| ------------------------------------------- | --------------- | ---------------------------------------------------- |\n| [clamp](https://lodash.com/docs/#clamp)     | 数字=>数字      | 将数字限定在一个范围内                               |\n| [inRange](https://lodash.com/docs/#inRange) | 数字=>布尔      | 判断数字是否在某个区间里                             |\n| [random](https://lodash.com/docs/#random)   | 区间=>数字      | 随机获取一个值，可以通过第三个参数指定是不是返回小数 |\n\n## 10. 数学\n\n### 加减乘除\n\n| 函数名                                        | 主要参数-返回值  | 简介             |\n| --------------------------------------------- | ---------------- | ---------------- |\n| [add](https://lodash.com/docs/#add)           | 两个数字 => 数字 | 返回两个数字的和 |\n| [subtract](https://lodash.com/docs/#subtract) | 两个数字 => 数字 | 返回两个数字的差 |\n| [multiply](https://lodash.com/docs/#multiply) | 两个数字 => 数字 | 返回两个数字的积 |\n| [divide](https://lodash.com/docs/#divide)     | 两个数字 => 数字 | 返回两个数字的商 |\n\n### 和，最大值，最小值，平均值\n\n| 函数名                                | 主要参数-返回值 | 简介                   |\n| ------------------------------------- | --------------- | ---------------------- |\n| [sum](https://lodash.com/docs/#sum)   | 数组 => 数字    | 返回数组中的各数字之和 |\n| [max](https://lodash.com/docs/#max)   | 数组 => 数字    | 返回数组中的最大值     |\n| [min](https://lodash.com/docs/#min)   | 数组 => 数字    | 返回数组中的最小值     |\n| [mean](https://lodash.com/docs/#mean) | 数组 => 数字    | 返回数组中的平均值     |\n\n### 数字精度\n\n| 函数名                                  | 主要参数-返回值 | 简介                       |\n| --------------------------------------- | --------------- | -------------------------- |\n| [ceil](https://lodash.com/docs/#ceil)   | 数字 => 数字    | 向上取整，可以指定精度     |\n| [floor](https://lodash.com/docs/#floor) | 数字 => 数字    | 向下取整，可以指定精度     |\n| [round](https://lodash.com/docs/#round) | 数字 => 数字    | 四舍五入取整，可以指定精度 |\n\n## 11. 语言\n\n### 数值比较\n\n| 函数名                                              | 简介                                       |\n| --------------------------------------------------- | ------------------------------------------ |\n| [eq](https://lodash.com/docs/#eq)                   | 等价于`===`                                |\n| [isEqual](https://lodash.com/docs/#isEqual)         | 深度比较对象是否相等                       |\n| [isEqualWith](https://lodash.com/docs/#isEqualWith) | 深度比较对象是否相等，可以定义相等比较函数 |\n| [gt](https://lodash.com/docs/#gt)                   | 大于                                       |\n| [lt](https://lodash.com/docs/#lt)                   | 小于                                       |\n| [gte](https://lodash.com/docs/#gte)                 | 大于等于                                   |\n| [lte](https://lodash.com/docs/#lte)                 | 小于等于                                   |\n\n### 类型判断\n\n| 函数名                                                          | 简介                                                     |\n| --------------------------------------------------------------- | -------------------------------------------------------- |\n| [isArguments](https://lodash.com/docs/#isArguments)             |                                                          |\n| [isArray](https://lodash.com/docs/#isArray)                     |                                                          |\n| [isArrayBuffer](https://lodash.com/docs/#isArrayBuffer)         |                                                          |\n| [isArrayLike](https://lodash.com/docs/#isArrayLike)             |                                                          |\n| [isArrayLikeObject](https://lodash.com/docs/#isArrayLikeObject) |                                                          |\n| [isBoolean](https://lodash.com/docs/#isBoolean)                 |                                                          |\n| [isBuffer](https://lodash.com/docs/#isBuffer)                   |                                                          |\n| [isDate](https://lodash.com/docs/#isDate)                       |                                                          |\n| [isElement](https://lodash.com/docs/#isElement)                 |                                                          |\n| [isEmpty](https://lodash.com/docs/#isEmpty)                     | 判断是否有可遍历的属性                                   |\n| [isError](https://lodash.com/docs/#isError)                     | 错误                                                     |\n| [isFinite](https://lodash.com/docs/#isFinite)                   | 是否是有限的数字，基于 Number.isFinite                   |\n| [isFunction](https://lodash.com/docs/#isFunction)               |                                                          |\n| [isInteger](https://lodash.com/docs/#isInteger)                 |                                                          |\n| [isLength](https://lodash.com/docs/#isLength)                   |                                                          |\n| [isMap](https://lodash.com/docs/#isMap)                         |                                                          |\n| [isMatch](https://lodash.com/docs/#isMatch)                     |                                                          |\n| [isMatchWith](https://lodash.com/docs/#isMatchWith)             |                                                          |\n| [isNaN](https://lodash.com/docs/#isNaN)                         |                                                          |\n| [isNative](https://lodash.com/docs/#isNative)                   | 原生函数                                                 |\n| [isNil](https://lodash.com/docs/#isNil)                         | 等价于 `_.isNull(val)` &#124;&#124; `_.isUndefined(val)` |\n| [isNull](https://lodash.com/docs/#isNull)                       |                                                          |\n| [isNumber](https://lodash.com/docs/#isNumber)                   |                                                          |\n| [isObject](https://lodash.com/docs/#isObject)                   |                                                          |\n| [isObjectLike](https://lodash.com/docs/#isObjectLike)           |                                                          |\n| [isPlainObject](https://lodash.com/docs/#isPlainObject)         |                                                          |\n| [isRegExp](https://lodash.com/docs/#isRegExp)                   |                                                          |\n| [isSafeInteger](https://lodash.com/docs/#isSafeInteger)         |                                                          |\n| [isSet](https://lodash.com/docs/#)                              | isSet                                                    |\n| [isString](https://lodash.com/docs/#isString)                   |                                                          |\n| [isSymbol](https://lodash.com/docs/#isSymbol)                   |                                                          |\n| [isTypedArray](https://lodash.com/docs/#isTypedArray)           |                                                          |\n| [isUndefined](https://lodash.com/docs/#isUndefined)             |                                                          |\n| [isWeakMap](https://lodash.com/docs/#isWeakMap)                 |                                                          |\n| [isWeakSet](https://lodash.com/docs/#isWeakSet)                 |                                                          |\n\n### 类型转换\n\n| 函数名                                                  | 简介                                                 |\n| ------------------------------------------------------- | ---------------------------------------------------- |\n| [castArray](https://lodash.com/docs/#castArray)         | 强制转给数组                                         |\n| [toArray](https://lodash.com/docs/#toArray)             | 转成数组，对象调用 Object.values，字符串转成字符数组 |\n| [toFinite](https://lodash.com/docs/#toFinite)           |                                                      |\n| [toInteger](https://lodash.com/docs/#toInteger)         |                                                      |\n| [toLength](https://lodash.com/docs/#toLength)           |                                                      |\n| [toNumber](https://lodash.com/docs/#toNumber)           |                                                      |\n| [toPlainObject](https://lodash.com/docs/#toPlainObject) |                                                      |\n| [toSafeInteger](https://lodash.com/docs/#toSafeInteger) |                                                      |\n| [toString](https://lodash.com/docs/#toString)           | 转成字符串，                                         |\n\n### 复制对象\n\n| 函数名                                                  | 简介 |\n| ------------------------------------------------------- | ---- |\n| [clone](https://lodash.com/docs/#clone)                 |      |\n| [cloneDeep](https://lodash.com/docs/#cloneDeep)         |      |\n| [cloneDeepWith](https://lodash.com/docs/#cloneDeepWith) |      |\n| [cloneWith](https://lodash.com/docs/#cloneWith)         |      |\n\n### 检测对象\n\n| 函数名                                            | 简介                               |\n| ------------------------------------------------- | ---------------------------------- |\n| [conformsTo](https://lodash.com/docs/#conformsTo) | 判断一个对象的字段是否满足一些条件 |\n\n## 12. 工具\n\n### 总是返回某个参数的函数\n\n| 函数名                                        | 简介                                  |\n| --------------------------------------------- | ------------------------------------- |\n| [constant](https://lodash.com/docs/#constant) | 创建一个包裹函数，总是返回第一个参数  |\n| [nthArg](https://lodash.com/docs/#nthArg)     | 创建一个包裹函数，总是返回第 n 个参数 |\n\n### 总是返回某个特定值的函数\n\n| 函数名                                            | 简介                      |\n| ------------------------------------------------- | ------------------------- |\n| [noop](https://lodash.com/docs/#noop)             | 总是返回`undefined`的函数 |\n| [stubArray](https://lodash.com/docs/#stubArray)   | 总是返回空数组的函数      |\n| [stubObject](https://lodash.com/docs/#stubObject) | 总是返回空对象的函数      |\n| [stubString](https://lodash.com/docs/#stubString) | 总是返回空字符串的函数    |\n| [stubTrue](https://lodash.com/docs/#stubTrue)     | 总是返回`true`的函数      |\n| [stubFalse](https://lodash.com/docs/#stubFalse)   | 总是返回`false`的函数     |\n| [identity](https://lodash.com/docs/#identity)     | 总是返回第一个参数        |\n\n### 获取对象的属性值或者调用对象的函数\n\n| 函数名                                            | 简介                                                                                                    |\n| ------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |\n| [method](https://lodash.com/docs/#method)         | [\\_.invoke(object, path, [args])](https://lodash.com/docs/#invoke)预设`path`和`args`两个参数            |\n| [methodOf](https://lodash.com/docs/#methodOf)     | [\\_.invoke(object, path, [args])](https://lodash.com/docs/#invoke)预设`object`和`args`两个参数          |\n| [property](https://lodash.com/docs/#property)     | [\\_.get(object, path)](https://lodash.com/docs/#invoke)预设`path参数，不同的是缺少`defaultValue`参数    |\n| [propertyOf](https://lodash.com/docs/#propertyOf) | [\\_.get(object, path)](https://lodash.com/docs/#invoke)预设`object`参数，不同的是缺少`defaultValue`参数 |\n\n### 判断对象是否满足某些条件\n\n| 函数名                                                      | 简介                                                                                                                                                               |\n| ----------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| [conforms](https://lodash.com/docs/#conforms)               | 创建一个包裹函数，判断一个对象的字段是否满足某个函数。`conforms`意思是遵守。                                                                                       |\n| [matches](https://lodash.com/docs/#matches)                 | 创建一个包裹函数，判断一个对象的字段是否等于某个值，使用[isEqual](https://lodash.com/docs/#isEqual)判断是否相等。跟[isMatch](https://lodash.com/docs/#isMatch)类似 |\n| [matchesProperty](https://lodash.com/docs/#matchesProperty) | 创建一个包裹函数，判断一个对象特定字段是否等于某个值，使用[isEqual](https://lodash.com/docs/#isEqual)判断是否相等。                                                |\n\n### 把多个操作合成一个操作\n\n| 函数名                                          | 简介                           |\n| ----------------------------------------------- | ------------------------------ |\n| [flow](https://lodash.com/docs/#flow)           | 把一组函数串起来形成一个新函数 |\n| [flowRight](https://lodash.com/docs/#flowRight) | 同上，倒序                     |\n\n### 批量进行多个操作\n\n| 函数名                                          | 简介                                                           |\n| ----------------------------------------------- | -------------------------------------------------------------- |\n| [over](https://lodash.com/docs/#over)           | 创建一个新函数，并将参数传递给预先指定的一组函数，并返回其结果 |\n| [overEvery](https://lodash.com/docs/#overEvery) | 跟`over`类似，判断是不是所有函数都返回真值                     |\n| [overSome](https://lodash.com/docs/#overSome)   | 跟`over`类似，判断是不是至少一个函数返回真值                   |\n\n### 等差数列\n\n| 函数名                                            | 简介                                                                          |\n| ------------------------------------------------- | ----------------------------------------------------------------------------- |\n| [range](https://lodash.com/docs/#range)           | 生成等差数列，可以指定步长，步长可以是小数，也可以是负数                      |\n| [rangeRight](https://lodash.com/docs/#rangeRight) | 这个基本可以忽略，功能完成可以由[range](https://lodash.com/docs/#range)代替。 |\n\n### 其他未分类\n\n| 函数名                                                | 简介                                                                                                        |\n| ----------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |\n| [attempt](https://lodash.com/docs/#attempt)           | 使用 try-catch 包裹函数，如果出错返回错误对象                                                               |\n| [bindAll](https://lodash.com/docs/#bindAll)           | 将一个对象的多个函数中的 this 固定为该对象                                                                  |\n| [cond](https://lodash.com/docs/#cond)                 | 创建一个拥有复杂 if-else 的函数                                                                             |\n| [defaultTo](https://lodash.com/docs/#defaultTo)       | 如果第一个参数为 NaN,null,undefined，则返回第二个参数，否则返回第一个参数                                   |\n| [iteratee](https://lodash.com/docs/#iteratee)         | 创建一个迭代函数                                                                                            |\n| [noConflict](https://lodash.com/docs/#noConflict)     | 如果`_`被占用，可以使用该方法                                                                               |\n| [runInContext](https://lodash.com/docs/#runInContext) | 创建一个`lodash`镜像对象，可以扩展修改该对象                                                                |\n| [mixin](https://lodash.com/docs/#mixin)               | 给一个对象的原型添加属性或方法，一般配合[runInContext](https://lodash.com/docs/#runInContext)扩展`lodash`。 |\n| [times](https://lodash.com/docs/#times)               | 执行函数 n 次，传入参数为 index                                                                             |\n| [toPath](https://lodash.com/docs/#toPath)             | 'a[0].b.c'=>['a','0','b','c']                                                                               |\n| [uniqueId](https://lodash.com/docs/#uniqueId)         | 生成唯一 ID，可以指定前缀                                                                                   |\n\n## 13. 链式\n\n### 链式调用的好处\n\n省略了中间变量，让代码更加简洁，更加安全。\n链式调用可以优化成惰性求值（延迟计算），让代码更加高效。\n\n### \\_(value)\n\n创建一个经过 lodash 包装过后的对象会启用隐式链，直到调用了不支持链接调用的函数或者主动调用`value`方法解除链式调用。\n作用类似于[chain](https://lodash.com/docs/#chain)\n\n### lodash 包装对象上的特殊函数\n\n| 函数名                                              | 简介                                                                             |\n| --------------------------------------------------- | -------------------------------------------------------------------------------- |\n| [tap](https://lodash.com/docs/#prototype-tap)       | 可以在链式调用中插入普通方法，直接修改中间结果，也可以仅仅是用于调试打印中间结果 |\n| [thru](https://lodash.com/docs/#prototype-thru)     | 同[tap](https://lodash.com/docs/#tap)，但是使用函数的返回值作为中间结果          |\n| [commit](https://lodash.com/docs/#prototype-commit) | 立即执行链式调用中尚未进行的操作                                                 |\n| [next](https://lodash.com/docs/#prototype-next)     | 获得包装对象的下一个值                                                           |\n| [plant](https://lodash.com/docs/#prototype-plant)   | 复制一个链式调用，并传入初始值                                                   |\n| [value](https://lodash.com/docs/#prototype-value)   | 结束链式调用，并计算结果。别名`valueOf`，`toJSON`                                |\n","source":"_posts/2016-09-06-lodash-functions.md","raw":"---\ntitle: Lodash函数以及常见用法\n---\n\n## 1 简介\n\n[Lodash](https://github.com/lodash/lodash)是一款优秀的 JavaScript 工具库，里面包含了大量的工具函数。在 2015 年就成为[被依赖最多的 JavaScript 库](https://www.npmjs.com/browse/depended)，写这篇文档是最新版是 4.17.4，适用于常见浏览器以及 Node.js 等。\n\n这里给出其[英文文档](https://lodash.com/docs)和[中文文档](http://lodash.think2011.net/)的链接。其中中文文档的版本较低，但是区别不大，可以参考帮助理解。\n\n## 2 常见用法\n\n在这部分我们介绍一些 Lodash 的常见的优雅的用法。主要是引起大家的学习兴趣，有更多优雅用法等待大家去发现。\n\n### `_.get`获取一个嵌套很深的字段\n\n```js\n//config 初始化为 null，需要从服务器端获取权限数据\nlet config = null;\najax.get(url, function(data) {\n    // data = {basic: {delete: true}}\n    config = data;\n});\n//使用原生JS获取是否有删除权限\nlet isDeletable = false;\nif (config && config.basic) {\n    isDeletable = config.basic.delete || false;\n}\n//使用lodash获取是否有删除权限\nlet isDeletable = _.get(config, 'basic.delete', false);\n```\n\n对应地，可以通过`_.set({}, 'a.b.c', 1)`创建一个多级嵌套的对象。\n\n### `_.map`获取数组中每个对象的特定字段，并形成一个新的数组\n\n```js\n//使用所有用户的 idCard 字段创建出一个数组\nlet users = [{ idCard: '20160512', name: '张三' }, { idCard: '20160513', name: '李四' }];\n//使用原生JS\nlet idCards = users.map(function(user) {\n    return user.idCard;\n});\n//使用lodash\nlet idCards = _.map(model, 'idCard');\n```\n\n### `_.pick`取出对象的部分字段形成一个新对象\n\n```js\n//在修改密码表单里，用户输入了如下字段并被封装到一个对象中\nlet form = {\n    password: '123456', //密码\n    repeatPassword: '123456', //重复密码\n    code: '5489', //验证码\n};\n\n//这里不直接使用delete删除字段，是因为该 form 对象与 DOM 进行了绑定。\n//其中重复密码只用来在客户端校验，不需要发送给服务器\nlet data = {};\nlet fields = ['password', 'code'];\nfor (var i = 0; i < fields.length; i++) {\n    data[fields[i]] = form[fields[i]];\n}\n\n//使用lodash\nlet data = _.pick(form, 'password', 'code');\n```\n\n对应地，还有`_.omit`方法表示删除部分字段形成一个新对象。\n\n### `_.random`获取一个随机值\n\n```js\n//获取[90, 100)之内的一个随机值\nlet min = 90;\nlet max = 100;\n//使用原生JS\nlet random = Math.floor(Math.random() * (max - min)) + min;\n//使用lodash\nlet random = _.random(min, max);\n```\n\n类似地，`_.sample(['a', 'b', 'c'])`可以从数组中随机取出一个项目。\n\n### `_.clamp`将一个数字修改成区间中的一个值\n\n```js\n//使用原生JS\nfunction applyRange(number) {\n    number = Math.max(number, this.props.min);\n    number = Math.min(number, this.props.max);\n    return number;\n}\n//使用lodash\nlet number = _.clamp(number, min, max);\n```\n\n### `_.once`确保一个函数只会执行一次\n\n```js\n//使用原生JS\nlet inited = false;\nfunction init() {\n    if (inited) return;\n    // init code\n}\n//使用lodash\nlet init = _.once(function() {\n    // init code\n});\n```\n\n### `_.chain`链式操作\n\n链接调用让代码更加整洁；避免了中间变量，避免了错误引用，让代码质量更有保证；`_.chain`还提供了延迟计算特性，在显式或隐式调用`value()`方法之前是不进行任何计算的，通过合并大大降低迭代次数。  \n下面是`lodash`的官方文档中的一个例子。\n\n```js\nvar users = [{ user: 'barney', age: 36 }, { user: 'fred', age: 40 }, { user: 'pebbles', age: 1 }];\n\nvar youngest = _.chain(users)\n    .sortBy('age')\n    .map(function(chr) {\n        return chr.user + ' is ' + chr.age;\n    })\n    .first()\n    .value();\n// → 'pebbles is 1'\n```\n\n## 3 模块\n\nLodash 的工具函数很多，可以分为以下几类：数组（Array），集合（Collection），函数（Function），Lang（Lang），数学（Math），数字（Number），对象（Object），字符串（String），未分类工具函数（Util）。下面将会按类别介绍常见工具函数。\n\n## 4 数组\n\n### 获取子数组\n\n| 函数名                                                    | 简介                                             |\n| --------------------------------------------------------- | ------------------------------------------------ |\n| [slice](https://lodash.com/docs/#slice)                   | 获取元素第 m-n(不包含)个元素                     |\n| [tail](https://lodash.com/docs/#tail)                     | 获取出第一个元素之外的其他元素                   |\n| [initial](https://lodash.com/docs/#initial)               | 获取出最后一个元素之外的其他元素                 |\n| [take](https://lodash.com/docs/#take)                     | 从左侧开始获取任意数量的元素                     |\n| [takeRight](https://lodash.com/docs/#takeRight)           | 从右侧开始获取任意数量的元素                     |\n| [takeWhile](https://lodash.com/docs/#takeWhile)           | 从左侧开始获取任意数量的元素，直到断言返回假值   |\n| [takeRightWhile](https://lodash.com/docs/#takeRightWhile) | 从右侧开始获取任意数量的元素，直到断言返回假值   |\n| [drop](https://lodash.com/docs/#drop)                     | 丢掉前面几个元素，得到剩余元素                   |\n| [dropWhile](https://lodash.com/docs/#dropWhile)           | 丢掉前面几个元素知道迭代器返回假值，得到剩余元素 |\n| [dropRight](https://lodash.com/docs/#dropRight)           | 丢掉后面几个元素，得到剩余元素                   |\n| [dropRightWhile](https://lodash.com/docs/#dropRightWhile) | 丢掉后面几个元素知道迭代器返回假值，得到剩余元素 |\n\n### 数组常见操作\n\n| 操作 | 不修改原数组                                              | 修改原数组                                          |\n| ---- | --------------------------------------------------------- | --------------------------------------------------- |\n| 移除 | [without](https://lodash.com/docs/#without)               | [pull](https://lodash.com/docs/#pull)               |\n| 相减 | [difference](https://lodash.com/docs/#difference)         | [pullAll](https://lodash.com/docs/#pullAll)         |\n| 相减 | [differenceBy](https://lodash.com/docs/#differenceBy)     | [pullAllBy](https://lodash.com/docs/#pullAllBy)     |\n| 相减 | [differenceWith](https://lodash.com/docs/#differenceWith) | [pullAllWith](https://lodash.com/docs/#pullAllWith) |\n| 反转 |                                                           | [reverse](https://lodash.com/docs/#reverse)         |\n| 裁剪 | [at](https://lodash.com/docs/#at)                         | [pullAt](https://lodash.com/docs/#pullAt)           |\n| 过滤 | [filter](https://lodash.com/docs/#filter)                 | [remove](https://lodash.com/docs/#remove)           |\n\n### 数组常见操作变种函数 by, with\n\n有些函数还可以稍微变化一下，接受不同的参数，提供更多灵活性。\n\n| 作用 | 函数名                                                | by                                                        | with                                                                                                                                                                    |\n| ---- | ----------------------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 相减 | [difference](https://lodash.com/docs/#difference)     | [differenceBy](https://lodash.com/docs/#differenceBy)     | [differenceWith](https://lodash.com/docs/#differenceWith)                                                                                                               |\n| 交集 | [intersection](https://lodash.com/docs/#intersection) | [intersectionBy](https://lodash.com/docs/#intersectionBy) | [intersectionWith](https://lodash.com/docs/#intersectionWith)                                                                                                           |\n| 并集 | [union](https://lodash.com/docs/#union)               | [unionBy](https://lodash.com/docs/#unionBy)               | [unionWith](https://lodash.com/docs/#unionWith)                                                                                                                         |\n| 异或 | [xor](https://lodash.com/docs/#xor)                   | [xorBy](https://lodash.com/docs/#xorBy)                   | [xorWith](https://lodash.com/docs/#xorWith)                                                                                                                             |\n| 相减 | [pullAll](https://lodash.com/docs/#pullAll)           | [pullAllBy](https://lodash.com/docs/#pullAllBy)           | [pullAllWith](https://lodash.com/docs/#pullAllWith)，跟[difference](https://lodash.com/docs/#difference)不同的是，[pullAll](https://lodash.com/docs/#pullAll)修改原数组 |\n| 去重 | [uniq](https://lodash.com/docs/#uniq)                 | [uniqBy](https://lodash.com/docs/#uniqBy)                 | [uniqWith](https://lodash.com/docs/#uniqWith)                                                                                                                           |\n| 去重 | [sortedUniq](https://lodash.com/docs/#sortedUniq)     | [sortedUniqBy](https://lodash.com/docs/#sortedUniqBy)     |                                                                                                                                                                         |  |\n\n### 获取数组某个位置上的元素\n\n| 函数名                                | 主要参数-返回值 | 简介                                                                |\n| ------------------------------------- | --------------- | ------------------------------------------------------------------- |\n| [head](https://lodash.com/docs/#head) | 数组=>元素      | 返回数组的第一个元素，和[first](https://lodash.com/docs/#first)相同 |\n| [last](https://lodash.com/docs/#last) | 数组=>元素      | 返回数组的最后一个元素，和[head](https://lodash.com/docs/#head)相反 |\n| [nth](https://lodash.com/docs/#nth)   | 数组=>元素      | 返回数组中某个位置上的元素                                          |\n\n### 检测元素在数组中的索引\n\n| 函数名                                                          | 简介                                                                                |\n| --------------------------------------------------------------- | ----------------------------------------------------------------------------------- |\n| [indexOf](https://lodash.com/docs/#indexOf)                     | 获取元素在数组中的索引                                                              |\n| [sortedIndexOf](https://lodash.com/docs/#sortedIndexOf)         | 和[indexOf](https://lodash.com/docs/#indexOf)功能一致，只是通过二分搜索方法         |\n| [lastIndexOf](https://lodash.com/docs/#lastIndexOf)             | 获取元素在数组中的索引，最后一次出现                                                |\n| [sortedLastIndexOf](https://lodash.com/docs/#sortedLastIndexOf) | 和[lastIndexOf](https://lodash.com/docs/#lastIndexOf)功能一致，只是通过二分搜索方法 |\n| [findIndex](https://lodash.com/docs/#findIndex)                 | 寻找元素位置                                                                        |\n| [findLastIndex](https://lodash.com/docs/#findLastIndex)         | 寻找元素位置，从后往前                                                              |\n\n### 检测元素在插在有序数组的什么位置\n\n| 函数名                                                          | 简介                                                                      |\n| --------------------------------------------------------------- | ------------------------------------------------------------------------- |\n| [sortedIndex](https://lodash.com/docs/#sortedIndex)             | 通过二分搜索判断元素应该插在数组的哪个位置                                |\n| [sortedIndexBy](https://lodash.com/docs/#sortedIndexBy)         | 同上，可以额外提供一个迭代器函数                                          |\n| [sortedLastIndex](https://lodash.com/docs/#sortedLastIndex)     | 和[sortedIndex](https://lodash.com/docs/#sortedIndex)类似，但是从右边开始 |\n| [sortedLastIndexBy](https://lodash.com/docs/#sortedLastIndexBy) | 同上，可以额外提供一个迭代器函数                                          |\n\n### 将数组拍平\n\n| 函数名                                                | 主要参数-返回值    | 简介       |\n| ----------------------------------------------------- | ------------------ | ---------- |\n| [flatten](https://lodash.com/docs/#)                  | 高维数组=>低维数组 | 将数组拍平 |\n| [flattenDeep](https://lodash.com/docs/#flattenDeep)   | 高维数组=>数组     | 将数组拍平 |\n| [flattenDepth](https://lodash.com/docs/#flattenDepth) | 高维数组=>低维数组 | 将数组拍平 |\n\n### Zip\n\n| 函数名                                                  | 主要参数-返回值    | 简介                                                   |\n| ------------------------------------------------------- | ------------------ | ------------------------------------------------------ |\n| [zip](https://lodash.com/docs/#zip)                     | 多个数组=>二维数组 | 可以理解为二维数组的行列互换                           |\n| [zipWith](https://lodash.com/docs/#zipWith)             | 多个数组=>数组     | 同上，但是可以自由处理行列互换后的数组中的每个数组元素 |\n| [zipObject](https://lodash.com/docs/#zipObject)         | 两个数组=>对象     | 把 keys 和 values 数组组成一个新对象                   |\n| [zipObjectDeep](https://lodash.com/docs/#zipObjectDeep) | 两个数组=>对象     | 同上，递归地处理属性名                                 |\n\n### 未分类函数\n\n| 函数名                                          | 主要参数-返回值 | 简介                                                                  |\n| ----------------------------------------------- | --------------- | --------------------------------------------------------------------- |\n| [chunk](https://lodash.com/docs/#chunk)         | 数组=>二维数组  | 分段形成二维数组                                                      |\n| [compact](https://lodash.com/docs/#compact)     | 数组=>数组      | 移除假值                                                              |\n| [concat](https://lodash.com/docs/#concat)       | 多个数组=>数组  | 连接多个数组形成一个数组                                              |\n| [fill](https://lodash.com/docs/#fill)           | 数组=>数组      | 填充数组                                                              |\n| [fromPairs](https://lodash.com/docs/#fromPairs) | 二维数组=>对象  | 将键值数组变成对象。和[toPairs](https://lodash.com/docs/#toPairs)相反 |\n| [join](https://lodash.com/docs/#join)           | 数组=>字符串    | 拼接数组元素成一个字符串                                              |\n\n## 5 集合\n\n为什么区分集合函数和数组函数？\n集合函数不单单适用于数组，还适用于字符串，对象，类数组对象（比如 Arguments，NodeList 等）。字符串是字符的集合，对象是属性值的集合。类数组对象是通过“[鸭子类型](https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B)”工作的，所以如果你传入一个拥有`length`字段并且值为数字的对象，这个对象会被当做一个数组处理。具体请参考[Underscore.js](http://underscorejs.org/#collections)文档。\n\n范例：\n\n```js\nfunction printKeyVal(val, key) {\n    console.log(key, val);\n}\n\n//普通对象\n_.each({ a: 1 }, printKeyVal);\n//打印结果\n// a 1\n\n//拥有值为数字的length字段\n_.each({ a: 1, length: 2 }, printKeyVal);\n//打印结果\n// 0 undefined\n// 1 undefined\n```\n\n下面将分类介绍集合相关函数。\n\n### 遍历\n\n| 函数名                                          | 简介                                                    |\n| ----------------------------------------------- | ------------------------------------------------------- |\n| [each](https://lodash.com/docs/#each)           | 同[forEach](https://lodash.com/docs/#forEach)           |\n| [eachRight](https://lodash.com/docs/#eachRight) | 同[forEachRight](https://lodash.com/docs/#forEachRight) |\n\n### 排序\n\n| 函数名                                      | 简介                                                      |\n| ------------------------------------------- | --------------------------------------------------------- |\n| [sortBy](https://lodash.com/docs/#)         | 排序                                                      |\n| [orderBy](https://lodash.com/docs/#orderBy) | 同[sortBy](https://lodash.com/docs/#)，还可以指定正序倒序 |\n| [shuffle](https://lodash.com/docs/#shuffle) | 返回一个打乱顺序的新数组                                  |\n\n### 过滤\n\n| 函数名                                          | 简介                                       |\n| ----------------------------------------------- | ------------------------------------------ |\n| [filter](https://lodash.com/docs/#filter)       | 创建一个新数组，包含了所有让断言为真的元素 |\n| [reject](https://lodash.com/docs/#reject)       | 创建一个新数组，包含了所有让断言为假的元素 |\n| [partition](https://lodash.com/docs/#partition) | 根据断言真假将一个集合分成两个集合         |\n\n### Map 之后再 flatten\n\n| 函数名                                                | 简介                                                                                           |\n| ----------------------------------------------------- | ---------------------------------------------------------------------------------------------- |\n| [flatMap](https://lodash.com/docs/#flatMap)           | [map](https://lodash.com/docs/#map)之后再[flatten](https://lodash.com/docs/#flatten)           |\n| [flatMapDeep](https://lodash.com/docs/#flatMapDeep)   | [map](https://lodash.com/docs/#map)之后再[flattenDeep](https://lodash.com/docs/#flattenDeep)   |\n| [flatMapDepth](https://lodash.com/docs/#flatMapDepth) | [map](https://lodash.com/docs/#map)之后再[flattenDepth](https://lodash.com/docs/#flattenDepth) |\n\n### 寻找元素\n\n| 函数名                                        | 简介                       |\n| --------------------------------------------- | -------------------------- |\n| [find](https://lodash.com/docs/#find)         | 找到第一个让断言为真的元素 |\n| [findLast](https://lodash.com/docs/#findLast) | 同上，逆序                 |\n\n### 随机取值\n\n| 函数名                                            | 简介                      |\n| ------------------------------------------------- | ------------------------- |\n| [sample](https://lodash.com/docs/#sample)         | 从集合中随机选出一个元素  |\n| [sampleSize](https://lodash.com/docs/#sampleSize) | 从集合中随机选出 n 个元素 |\n\n### 迭代\n\n| 函数名                                              | 简介 |\n| --------------------------------------------------- | ---- |\n| [reduce](https://lodash.com/docs/#reduce)           |      |\n| [reduceRight](https://lodash.com/docs/#reduceRight) | -    |\n\n### 分组计数\n\n| 函数名                                      | 简介                                                                   |\n| ------------------------------------------- | ---------------------------------------------------------------------- |\n| [countBy](https://lodash.com/docs/#countBy) | 返回一个对象，属性名是迭代器的返回值，属性值该返回值出现的次数         |\n| [groupBy](https://lodash.com/docs/#groupBy) | 返回一个对象，属性名是迭代器的返回值，属性值是一个包含了相应元素的数组 |\n\n### 未分类\n\n| 函数名                                          | 简介                                                                                               |\n| ----------------------------------------------- | -------------------------------------------------------------------------------------------------- |\n| [keyBy](https://lodash.com/docs/#keyBy)         | 返回一个对象，属性名是迭代器的返回值，属性值是元素本身                                             |\n| [some](https://lodash.com/docs/#)               | 对于集合中的每个元素，是否至少其一返回真值                                                         |\n| [every](https://lodash.com/docs/#every)         | 对于集合中的每个元素，是否都返回真值                                                               |\n| [includes](https://lodash.com/docs/#includes)   | 判断元素是不是在数组中，判断某个值是不是某个对象的属性值，判断一个字符串是不是包含在另一个字符串中 |\n| [map](https://lodash.com/docs/#map)             | 对集合的数组                                                                                       |\n| [invokeMap](https://lodash.com/docs/#invokeMap) | -                                                                                                  |\n\n## 6 对象\n\n### 仅需要部分字段\n\n| 函数名                                    | 简介                           |\n| ----------------------------------------- | ------------------------------ |\n| [omit](https://lodash.com/docs/#omit)     | 通过忽略某些字段创建一个新对象 |\n| [omitBy](https://lodash.com/docs/#omitBy) |                                |\n| [pick](https://lodash.com/docs/#pick)     | 通过指定某些字段创建一个新对象 |\n| [pickBy](https://lodash.com/docs/#pickBy) | -                              |\n\n### 合并对象\n\n| 函数名                                                | 简介                                                                           |\n| ----------------------------------------------------- | ------------------------------------------------------------------------------ |\n| [assign](https://lodash.com/docs/#assign)             | 合并对象                                                                       |\n| [assignWith](https://lodash.com/docs/#assignWith)     | 有条件地合并对象                                                               |\n| [extend](https://lodash.com/docs/#extend)             | 合并对象，包括原型链上的属性                                                   |\n| [extendWith](https://lodash.com/docs/#extendWith)     | 有条件地合并对象，包括原型链上的属性                                           |\n| [assignIn](https://lodash.com/docs/#assignIn)         | 别名`extend`                                                                   |\n| [assignInWith](https://lodash.com/docs/#assignInWith) | 别名`extendWith`                                                               |\n| [defaults](https://lodash.com/docs/#defaults)         | 合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话       |\n| [defaultsDeep](https://lodash.com/docs/#defaultsDeep) | 递归地合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话 |\n| [merge](https://lodash.com/docs/#merge)               | 递归地合并对象，将后面参数的属性付给第一个参数                                 |\n| [mergeWith](https://lodash.com/docs/#mergeWith)       | 同[merge](https://lodash.com/docs/#merge)，额外接受一个 customizer 参数        |\n\n### 键值列表\n\n| 函数名                                              | 简介                                                         |\n| --------------------------------------------------- | ------------------------------------------------------------ |\n| [keys](https://lodash.com/docs/#keys)               | 创建一个数组，包含对象中所有的属性                           |\n| [keysIn](https://lodash.com/docs/#keysIn)           | 创建一个数组，包含对象中所有的属性（包含原型链上的）         |\n| [functions](https://lodash.com/docs/#functions)     | 创建一个数组，包含对象中所有值为函数的属性                   |\n| [functionsIn](https://lodash.com/docs/#functionsIn) | 创建一个数组，包含对象中所有值为函数的属性（包含原型链上的） |\n| [values](https://lodash.com/docs/#values)           | 创建一个数组，包含对象中所有的属性值                         |\n| [valuesIn](https://lodash.com/docs/#valuesIn)       | 创建一个数组，包含对象中所有的属性值（包含原型链上的）       |\n\n### 赋值取值\n\n| 函数名                                            | 简介                                                                               |\n| ------------------------------------------------- | ---------------------------------------------------------------------------------- |\n| [at](https://lodash.com/docs/#at)                 | 获取对象的一组属性路径的值，肯定不会报错                                           |\n| [get](https://lodash.com/docs/#get)               | 获取对象的某个属性路径的值，肯定不会报错                                           |\n| [result](https://lodash.com/docs/#result)         | 同[get](https://lodash.com/docs/#get)，但是如果属性值是函数的话，自动执行该函数    |\n| [set](https://lodash.com/docs/#set)               | 设置对象的某个属性路径的值                                                         |\n| [setWith](https://lodash.com/docs/#setWith)       | 设置对象的某个属性路径的值，遇到不存在的中间对象，使用数组呢？还是使用对象呢？等等 |\n| [update](https://lodash.com/docs/#update)         | 同[set](https://lodash.com/docs/#set)，只是接受一个函数作为参数                    |\n| [updateWith](https://lodash.com/docs/#updateWith) | 同[setWith](https://lodash.com/docs/#setWith)，只是接受一个函数作为参数            |\n| [unset](https://lodash.com/docs/#unset)           | 删除对象的某个属性路径                                                             |\n| [invoke](https://lodash.com/docs/#invoke)         | 调用对象中某个属性路径上的函数，肯定不会报错                                       |\n\n### 键值数组\n\n| 函数名                                          | 简介                                          |\n| ----------------------------------------------- | --------------------------------------------- |\n| [entries](https://lodash.com/docs/#entries)     | {'a':1}=>[['a',1]]。别名`toPairs`             |\n| [entriesIn](https://lodash.com/docs/#entriesIn) | 同上，但是包含原型链上的属性。别名`toPairsIn` |\n\n### 键值变换\n\n| 函数名                                          | 简介                                                                                  |\n| ----------------------------------------------- | ------------------------------------------------------------------------------------- |\n| [mapKeys](https://lodash.com/docs/#mapKeys)     | 对对象中所有属性名做某种处理之后形成一个新对象                                        |\n| [mapValues](https://lodash.com/docs/#mapValues) | 对对象中所有属性值做某种处理之后形成一个新对象                                        |\n| [invert](https://lodash.com/docs/#invert)       | 将对象中的属性名和属性值互换转成一个新对象                                            |\n| [invertBy](https://lodash.com/docs/#invertBy)   | 同[invert](https://lodash.com/docs/#invert)，但是转换以后的属性值是原属性值组成的数组 |\n\n### 键值遍历\n\n| 函数名                                              | 简介                                     |\n| --------------------------------------------------- | ---------------------------------------- |\n| [forIn](https://lodash.com/docs/#forIn)             | 遍历对象上的所有属性，包含原型链上的。   |\n| [forInRight](https://lodash.com/docs/#forInRight)   | 遍历对象上的所有属性，包含原型链上的。   |\n| [forOwn](https://lodash.com/docs/#forOwn)           | 遍历对象上的所有属性，不包含原型链上的。 |\n| [forOwnRight](https://lodash.com/docs/#forOwnRight) | 遍历对象上的所有属性，不包含原型链上的。 |\n\n### 寻找属性\n\n| 函数名                                              | 简介                                                                                              |\n| --------------------------------------------------- | ------------------------------------------------------------------------------------------------- |\n| [findKey](https://lodash.com/docs/#findKey)         | 同[find](https://lodash.com/docs/#find)类似，但是匹配的是对象的属性值，返回的是对象的属性名       |\n| [findLastKey](https://lodash.com/docs/#findLastKey) | 同[findKey](https://lodash.com/docs/#findKey)类似，但是匹配的是对象的属性值，返回的是对象的属性名 |\n\n### 判断属性是否存在\n\n| 函数名                                  | 简介                                         |\n| --------------------------------------- | -------------------------------------------- |\n| [has](https://lodash.com/docs/#has)     | 判断对象上是否拥有某个属性，不包含原型链上的 |\n| [hasIn](https://lodash.com/docs/#hasIn) | 判断对象上是否拥有某个属性，包含原型链上的   |\n\n### 转换对象或数组\n\n| 函数名                                          | 简介                                                                                                    |\n| ----------------------------------------------- | ------------------------------------------------------------------------------------------------------- |\n| [transform](https://lodash.com/docs/#transform) | 同[reduce](https://lodash.com/docs/#reduce)，但是其迭代器函数返回的是布尔值，如果返回 false，则停止迭代 |\n\n### 创建新对象\n\n| 函数名                                    | 简介                             |\n| ----------------------------------------- | -------------------------------- |\n| [create](https://lodash.com/docs/#create) | 创建一个对象，并指定其原型和属性 |\n\n## 7. 函数\n\n### 修改参数\n\n| 函数名                                        | 简介                                                                                        |\n| --------------------------------------------- | ------------------------------------------------------------------------------------------- |\n| [ary](https://lodash.com/docs/#ary)           | 创建一个包裹函数，只将前 n 个参数传递给原函数。                                             |\n| [unary](https://lodash.com/docs/#unary)       | 创建一个包裹函数，只将第一个参数传递给原函数。                                              |\n| [flip](https://lodash.com/docs/#flip)         | 创建一个包裹函数，将参数逆序之后传递给原函数。                                              |\n| [rearg](https://lodash.com/docs/#rearg)       | 创建一个包裹函数，调整参数顺序之后在传递给原函数                                            |\n| [rest](https://lodash.com/docs/#rest)         | 创建一个包裹函数，将参数合成数组之后传递给原函数                                            |\n| [spread](https://lodash.com/docs/#spread)     | 创建一个包裹函数，将数组参数展开之后传给原函数，跟[rest](https://lodash.com/docs/#rest)相反 |\n| [overArgs](https://lodash.com/docs/#overArgs) | 创建一个包裹函数，将参数做处理之后再传递给原函数。                                          |\n\n### 修改结果\n\n| 函数名                                    | 简介                                   |\n| ----------------------------------------- | -------------------------------------- |\n| [negate](https://lodash.com/docs/#negate) | 创建一个包裹函数，返回原函数结果的非。 |\n\n### 缓存结果\n\n| 函数名                                      | 简介                             |\n| ------------------------------------------- | -------------------------------- |\n| [memoize](https://lodash.com/docs/#memoize) | 创建一个包裹函数，会缓存计算结果 |\n\n### 降频调用\n\n| 函数名                                        | 简介 |\n| --------------------------------------------- | ---- |\n| [debounce](https://lodash.com/docs/#debounce) |      |\n| [throttle](https://lodash.com/docs/#throttle) |      |\n\n### 延迟调用\n\n| 函数名                                  | 简介                                 |\n| --------------------------------------- | ------------------------------------ |\n| [defer](https://lodash.com/docs/#defer) | 类似`setTimeout(fn,0)`，可以指定参数 |\n| [delay](https://lodash.com/docs/#delay) | 类似`setTimeout(fn,x)`，可以指定参数 |\n\n### 延迟调用\n\n| 函数名                                    | 简介                                                          |\n| ----------------------------------------- | ------------------------------------------------------------- |\n| [once](https://lodash.com/docs/#once)     | 创建一个包裹函数，确保原函数只被执行一次。                    |\n| [before](https://lodash.com/docs/#before) | 创建一个包裹函数，确保原函数只被执行 n 次。                   |\n| [after](https://lodash.com/docs/#after)   | 创建一个包裹函数，调用包裹函数时只有 n 次之后才会调用目标函数 |\n\n### 固定参数\n\n| 函数名                                                | 简介                                                                                                                     |\n| ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |\n| [wrap](https://lodash.com/docs/#wrap)                 | 创建一个包裹函数，固定原函数的第一个参数                                                                                 |\n| [partial](https://lodash.com/docs/#partial)           | 创建一个包裹函数，固定原函数若干个参数                                                                                   |\n| [partialRight](https://lodash.com/docs/#partialRight) | 创建一个包裹函数，固定原函数若干个参数                                                                                   |\n| [bind](https://lodash.com/docs/#bind)                 | 创建一个包裹函数，固定原函数若干个参数，并指定 this 对象                                                                 |\n| [bindKey](https://lodash.com/docs/#bindKey)           | 和[bind](https://lodash.com/docs/#bind)功能类似，但是能够处理尚未创建或被重写的函数，有点事件代理的感觉。                |\n| [curry](https://lodash.com/docs/#curry)               | 创建一个包裹函数，可以传入任意数量的参数，如果参数不完整，则返回一个接受余下参数的新函数，否则，调用原函数获得计算结果。 |\n| [curryRight](https://lodash.com/docs/#curryRight)     | 同上，逆序                                                                                                               |\n\n## 8. 字符串\n\n### 书写格式\n\n| 函数名                                          | 简介                           |\n| ----------------------------------------------- | ------------------------------ |\n| [startCase](https://lodash.com/docs/#startCase) | 每个单词首字母大写，多用于标题 |\n| [camelCase](https://lodash.com/docs/#camelCase) | 小驼峰                         |\n| [kebabCase](https://lodash.com/docs/#kebabCase) | 小写连字符                     |\n| [snakeCase](https://lodash.com/docs/#snakeCase) | 小写下划线                     |\n| [upperCase](https://lodash.com/docs/#upperCase) | 大写加空格                     |\n| [lowerCase](https://lodash.com/docs/#lowerCase) | 小写加空格                     |\n\n### 大写小写\n\n| 函数名                                            | 简介                 |\n| ------------------------------------------------- | -------------------- |\n| [capitalize](https://lodash.com/docs/#capitalize) | 首字母大写，其余小写 |\n| [upperFirst](https://lodash.com/docs/#upperFirst) | 首字母大写，其余不变 |\n| [lowerFirst](https://lodash.com/docs/#lowerFirst) | 首字母小写，其余不变 |\n| [toUpper](https://lodash.com/docs/#lowerFirst)    | 大写                 |\n| [toLower](https://lodash.com/docs/#toLower)       | 小写                 |\n\n### 打头结尾\n\n| 函数名                                            | 简介                   |\n| ------------------------------------------------- | ---------------------- |\n| [endsWith](https://lodash.com/docs/#endsWith)     | 是不是以特定字符串结尾 |\n| [startsWith](https://lodash.com/docs/#startsWith) | 是不是以特定字符串打头 |\n\n### 转义\n\n| 函数名                                                | 简介                                                            |\n| ----------------------------------------------------- | --------------------------------------------------------------- |\n| [escape](https://lodash.com/docs/#escape)             | 转义 &<>\"'，与[unescape](https://lodash.com/docs/#unescape)相反 |\n| [escapeRegExp](https://lodash.com/docs/#escapeRegExp) | 转义正则表达式中的特殊字符：^\\$.\\*+?()[]{}\\|                    |\n\n### 补全抹掉\n\n| 函数名                                | 简介                                                                                                                                           |\n| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |\n| [pad](https://lodash.com/docs/#pad)   | 使用某个字符串将特定字符串扩充至指定长度，类似地还有[padStart](https://lodash.com/docs/#padStart)，[padEnd](https://lodash.com/docs/#padEnd)   |\n| [trim](https://lodash.com/docs/#trim) | 去除字符串两边的特殊字符（默认为空格），类似地还有[trimStart](https://lodash.com/docs/#trimStart)，[trimEnd](https://lodash.com/docs/#trimEnd) |\n\n### 未分类\n\n| 函数名                                        | 简介                                 |\n| --------------------------------------------- | ------------------------------------ |\n| [parseInt](https://lodash.com/docs/#parseInt) | 转成整型                             |\n| [repeat](https://lodash.com/docs/#repeat)     | 将某个字符串重复 n 遍                |\n| [replace](https://lodash.com/docs/#replace)   | 替换字符串                           |\n| [split](https://lodash.com/docs/#split)       | 拆分字符串                           |\n| [template](https://lodash.com/docs/#template) | 简单模板引擎                         |\n| [truncate](https://lodash.com/docs/#truncate) | 截断字符串                           |\n| [words](https://lodash.com/docs/#words)       | 将字符串拆分成单词，可以指定拆分模式 |\n| [deburr](https://lodash.com/docs/#deburr)     | 基本拉丁字母                         |\n\n## 9. 数字\n\n| 函数名                                      | 主要参数-返回值 | 简介                                                 |\n| ------------------------------------------- | --------------- | ---------------------------------------------------- |\n| [clamp](https://lodash.com/docs/#clamp)     | 数字=>数字      | 将数字限定在一个范围内                               |\n| [inRange](https://lodash.com/docs/#inRange) | 数字=>布尔      | 判断数字是否在某个区间里                             |\n| [random](https://lodash.com/docs/#random)   | 区间=>数字      | 随机获取一个值，可以通过第三个参数指定是不是返回小数 |\n\n## 10. 数学\n\n### 加减乘除\n\n| 函数名                                        | 主要参数-返回值  | 简介             |\n| --------------------------------------------- | ---------------- | ---------------- |\n| [add](https://lodash.com/docs/#add)           | 两个数字 => 数字 | 返回两个数字的和 |\n| [subtract](https://lodash.com/docs/#subtract) | 两个数字 => 数字 | 返回两个数字的差 |\n| [multiply](https://lodash.com/docs/#multiply) | 两个数字 => 数字 | 返回两个数字的积 |\n| [divide](https://lodash.com/docs/#divide)     | 两个数字 => 数字 | 返回两个数字的商 |\n\n### 和，最大值，最小值，平均值\n\n| 函数名                                | 主要参数-返回值 | 简介                   |\n| ------------------------------------- | --------------- | ---------------------- |\n| [sum](https://lodash.com/docs/#sum)   | 数组 => 数字    | 返回数组中的各数字之和 |\n| [max](https://lodash.com/docs/#max)   | 数组 => 数字    | 返回数组中的最大值     |\n| [min](https://lodash.com/docs/#min)   | 数组 => 数字    | 返回数组中的最小值     |\n| [mean](https://lodash.com/docs/#mean) | 数组 => 数字    | 返回数组中的平均值     |\n\n### 数字精度\n\n| 函数名                                  | 主要参数-返回值 | 简介                       |\n| --------------------------------------- | --------------- | -------------------------- |\n| [ceil](https://lodash.com/docs/#ceil)   | 数字 => 数字    | 向上取整，可以指定精度     |\n| [floor](https://lodash.com/docs/#floor) | 数字 => 数字    | 向下取整，可以指定精度     |\n| [round](https://lodash.com/docs/#round) | 数字 => 数字    | 四舍五入取整，可以指定精度 |\n\n## 11. 语言\n\n### 数值比较\n\n| 函数名                                              | 简介                                       |\n| --------------------------------------------------- | ------------------------------------------ |\n| [eq](https://lodash.com/docs/#eq)                   | 等价于`===`                                |\n| [isEqual](https://lodash.com/docs/#isEqual)         | 深度比较对象是否相等                       |\n| [isEqualWith](https://lodash.com/docs/#isEqualWith) | 深度比较对象是否相等，可以定义相等比较函数 |\n| [gt](https://lodash.com/docs/#gt)                   | 大于                                       |\n| [lt](https://lodash.com/docs/#lt)                   | 小于                                       |\n| [gte](https://lodash.com/docs/#gte)                 | 大于等于                                   |\n| [lte](https://lodash.com/docs/#lte)                 | 小于等于                                   |\n\n### 类型判断\n\n| 函数名                                                          | 简介                                                     |\n| --------------------------------------------------------------- | -------------------------------------------------------- |\n| [isArguments](https://lodash.com/docs/#isArguments)             |                                                          |\n| [isArray](https://lodash.com/docs/#isArray)                     |                                                          |\n| [isArrayBuffer](https://lodash.com/docs/#isArrayBuffer)         |                                                          |\n| [isArrayLike](https://lodash.com/docs/#isArrayLike)             |                                                          |\n| [isArrayLikeObject](https://lodash.com/docs/#isArrayLikeObject) |                                                          |\n| [isBoolean](https://lodash.com/docs/#isBoolean)                 |                                                          |\n| [isBuffer](https://lodash.com/docs/#isBuffer)                   |                                                          |\n| [isDate](https://lodash.com/docs/#isDate)                       |                                                          |\n| [isElement](https://lodash.com/docs/#isElement)                 |                                                          |\n| [isEmpty](https://lodash.com/docs/#isEmpty)                     | 判断是否有可遍历的属性                                   |\n| [isError](https://lodash.com/docs/#isError)                     | 错误                                                     |\n| [isFinite](https://lodash.com/docs/#isFinite)                   | 是否是有限的数字，基于 Number.isFinite                   |\n| [isFunction](https://lodash.com/docs/#isFunction)               |                                                          |\n| [isInteger](https://lodash.com/docs/#isInteger)                 |                                                          |\n| [isLength](https://lodash.com/docs/#isLength)                   |                                                          |\n| [isMap](https://lodash.com/docs/#isMap)                         |                                                          |\n| [isMatch](https://lodash.com/docs/#isMatch)                     |                                                          |\n| [isMatchWith](https://lodash.com/docs/#isMatchWith)             |                                                          |\n| [isNaN](https://lodash.com/docs/#isNaN)                         |                                                          |\n| [isNative](https://lodash.com/docs/#isNative)                   | 原生函数                                                 |\n| [isNil](https://lodash.com/docs/#isNil)                         | 等价于 `_.isNull(val)` &#124;&#124; `_.isUndefined(val)` |\n| [isNull](https://lodash.com/docs/#isNull)                       |                                                          |\n| [isNumber](https://lodash.com/docs/#isNumber)                   |                                                          |\n| [isObject](https://lodash.com/docs/#isObject)                   |                                                          |\n| [isObjectLike](https://lodash.com/docs/#isObjectLike)           |                                                          |\n| [isPlainObject](https://lodash.com/docs/#isPlainObject)         |                                                          |\n| [isRegExp](https://lodash.com/docs/#isRegExp)                   |                                                          |\n| [isSafeInteger](https://lodash.com/docs/#isSafeInteger)         |                                                          |\n| [isSet](https://lodash.com/docs/#)                              | isSet                                                    |\n| [isString](https://lodash.com/docs/#isString)                   |                                                          |\n| [isSymbol](https://lodash.com/docs/#isSymbol)                   |                                                          |\n| [isTypedArray](https://lodash.com/docs/#isTypedArray)           |                                                          |\n| [isUndefined](https://lodash.com/docs/#isUndefined)             |                                                          |\n| [isWeakMap](https://lodash.com/docs/#isWeakMap)                 |                                                          |\n| [isWeakSet](https://lodash.com/docs/#isWeakSet)                 |                                                          |\n\n### 类型转换\n\n| 函数名                                                  | 简介                                                 |\n| ------------------------------------------------------- | ---------------------------------------------------- |\n| [castArray](https://lodash.com/docs/#castArray)         | 强制转给数组                                         |\n| [toArray](https://lodash.com/docs/#toArray)             | 转成数组，对象调用 Object.values，字符串转成字符数组 |\n| [toFinite](https://lodash.com/docs/#toFinite)           |                                                      |\n| [toInteger](https://lodash.com/docs/#toInteger)         |                                                      |\n| [toLength](https://lodash.com/docs/#toLength)           |                                                      |\n| [toNumber](https://lodash.com/docs/#toNumber)           |                                                      |\n| [toPlainObject](https://lodash.com/docs/#toPlainObject) |                                                      |\n| [toSafeInteger](https://lodash.com/docs/#toSafeInteger) |                                                      |\n| [toString](https://lodash.com/docs/#toString)           | 转成字符串，                                         |\n\n### 复制对象\n\n| 函数名                                                  | 简介 |\n| ------------------------------------------------------- | ---- |\n| [clone](https://lodash.com/docs/#clone)                 |      |\n| [cloneDeep](https://lodash.com/docs/#cloneDeep)         |      |\n| [cloneDeepWith](https://lodash.com/docs/#cloneDeepWith) |      |\n| [cloneWith](https://lodash.com/docs/#cloneWith)         |      |\n\n### 检测对象\n\n| 函数名                                            | 简介                               |\n| ------------------------------------------------- | ---------------------------------- |\n| [conformsTo](https://lodash.com/docs/#conformsTo) | 判断一个对象的字段是否满足一些条件 |\n\n## 12. 工具\n\n### 总是返回某个参数的函数\n\n| 函数名                                        | 简介                                  |\n| --------------------------------------------- | ------------------------------------- |\n| [constant](https://lodash.com/docs/#constant) | 创建一个包裹函数，总是返回第一个参数  |\n| [nthArg](https://lodash.com/docs/#nthArg)     | 创建一个包裹函数，总是返回第 n 个参数 |\n\n### 总是返回某个特定值的函数\n\n| 函数名                                            | 简介                      |\n| ------------------------------------------------- | ------------------------- |\n| [noop](https://lodash.com/docs/#noop)             | 总是返回`undefined`的函数 |\n| [stubArray](https://lodash.com/docs/#stubArray)   | 总是返回空数组的函数      |\n| [stubObject](https://lodash.com/docs/#stubObject) | 总是返回空对象的函数      |\n| [stubString](https://lodash.com/docs/#stubString) | 总是返回空字符串的函数    |\n| [stubTrue](https://lodash.com/docs/#stubTrue)     | 总是返回`true`的函数      |\n| [stubFalse](https://lodash.com/docs/#stubFalse)   | 总是返回`false`的函数     |\n| [identity](https://lodash.com/docs/#identity)     | 总是返回第一个参数        |\n\n### 获取对象的属性值或者调用对象的函数\n\n| 函数名                                            | 简介                                                                                                    |\n| ------------------------------------------------- | ------------------------------------------------------------------------------------------------------- |\n| [method](https://lodash.com/docs/#method)         | [\\_.invoke(object, path, [args])](https://lodash.com/docs/#invoke)预设`path`和`args`两个参数            |\n| [methodOf](https://lodash.com/docs/#methodOf)     | [\\_.invoke(object, path, [args])](https://lodash.com/docs/#invoke)预设`object`和`args`两个参数          |\n| [property](https://lodash.com/docs/#property)     | [\\_.get(object, path)](https://lodash.com/docs/#invoke)预设`path参数，不同的是缺少`defaultValue`参数    |\n| [propertyOf](https://lodash.com/docs/#propertyOf) | [\\_.get(object, path)](https://lodash.com/docs/#invoke)预设`object`参数，不同的是缺少`defaultValue`参数 |\n\n### 判断对象是否满足某些条件\n\n| 函数名                                                      | 简介                                                                                                                                                               |\n| ----------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| [conforms](https://lodash.com/docs/#conforms)               | 创建一个包裹函数，判断一个对象的字段是否满足某个函数。`conforms`意思是遵守。                                                                                       |\n| [matches](https://lodash.com/docs/#matches)                 | 创建一个包裹函数，判断一个对象的字段是否等于某个值，使用[isEqual](https://lodash.com/docs/#isEqual)判断是否相等。跟[isMatch](https://lodash.com/docs/#isMatch)类似 |\n| [matchesProperty](https://lodash.com/docs/#matchesProperty) | 创建一个包裹函数，判断一个对象特定字段是否等于某个值，使用[isEqual](https://lodash.com/docs/#isEqual)判断是否相等。                                                |\n\n### 把多个操作合成一个操作\n\n| 函数名                                          | 简介                           |\n| ----------------------------------------------- | ------------------------------ |\n| [flow](https://lodash.com/docs/#flow)           | 把一组函数串起来形成一个新函数 |\n| [flowRight](https://lodash.com/docs/#flowRight) | 同上，倒序                     |\n\n### 批量进行多个操作\n\n| 函数名                                          | 简介                                                           |\n| ----------------------------------------------- | -------------------------------------------------------------- |\n| [over](https://lodash.com/docs/#over)           | 创建一个新函数，并将参数传递给预先指定的一组函数，并返回其结果 |\n| [overEvery](https://lodash.com/docs/#overEvery) | 跟`over`类似，判断是不是所有函数都返回真值                     |\n| [overSome](https://lodash.com/docs/#overSome)   | 跟`over`类似，判断是不是至少一个函数返回真值                   |\n\n### 等差数列\n\n| 函数名                                            | 简介                                                                          |\n| ------------------------------------------------- | ----------------------------------------------------------------------------- |\n| [range](https://lodash.com/docs/#range)           | 生成等差数列，可以指定步长，步长可以是小数，也可以是负数                      |\n| [rangeRight](https://lodash.com/docs/#rangeRight) | 这个基本可以忽略，功能完成可以由[range](https://lodash.com/docs/#range)代替。 |\n\n### 其他未分类\n\n| 函数名                                                | 简介                                                                                                        |\n| ----------------------------------------------------- | ----------------------------------------------------------------------------------------------------------- |\n| [attempt](https://lodash.com/docs/#attempt)           | 使用 try-catch 包裹函数，如果出错返回错误对象                                                               |\n| [bindAll](https://lodash.com/docs/#bindAll)           | 将一个对象的多个函数中的 this 固定为该对象                                                                  |\n| [cond](https://lodash.com/docs/#cond)                 | 创建一个拥有复杂 if-else 的函数                                                                             |\n| [defaultTo](https://lodash.com/docs/#defaultTo)       | 如果第一个参数为 NaN,null,undefined，则返回第二个参数，否则返回第一个参数                                   |\n| [iteratee](https://lodash.com/docs/#iteratee)         | 创建一个迭代函数                                                                                            |\n| [noConflict](https://lodash.com/docs/#noConflict)     | 如果`_`被占用，可以使用该方法                                                                               |\n| [runInContext](https://lodash.com/docs/#runInContext) | 创建一个`lodash`镜像对象，可以扩展修改该对象                                                                |\n| [mixin](https://lodash.com/docs/#mixin)               | 给一个对象的原型添加属性或方法，一般配合[runInContext](https://lodash.com/docs/#runInContext)扩展`lodash`。 |\n| [times](https://lodash.com/docs/#times)               | 执行函数 n 次，传入参数为 index                                                                             |\n| [toPath](https://lodash.com/docs/#toPath)             | 'a[0].b.c'=>['a','0','b','c']                                                                               |\n| [uniqueId](https://lodash.com/docs/#uniqueId)         | 生成唯一 ID，可以指定前缀                                                                                   |\n\n## 13. 链式\n\n### 链式调用的好处\n\n省略了中间变量，让代码更加简洁，更加安全。\n链式调用可以优化成惰性求值（延迟计算），让代码更加高效。\n\n### \\_(value)\n\n创建一个经过 lodash 包装过后的对象会启用隐式链，直到调用了不支持链接调用的函数或者主动调用`value`方法解除链式调用。\n作用类似于[chain](https://lodash.com/docs/#chain)\n\n### lodash 包装对象上的特殊函数\n\n| 函数名                                              | 简介                                                                             |\n| --------------------------------------------------- | -------------------------------------------------------------------------------- |\n| [tap](https://lodash.com/docs/#prototype-tap)       | 可以在链式调用中插入普通方法，直接修改中间结果，也可以仅仅是用于调试打印中间结果 |\n| [thru](https://lodash.com/docs/#prototype-thru)     | 同[tap](https://lodash.com/docs/#tap)，但是使用函数的返回值作为中间结果          |\n| [commit](https://lodash.com/docs/#prototype-commit) | 立即执行链式调用中尚未进行的操作                                                 |\n| [next](https://lodash.com/docs/#prototype-next)     | 获得包装对象的下一个值                                                           |\n| [plant](https://lodash.com/docs/#prototype-plant)   | 复制一个链式调用，并传入初始值                                                   |\n| [value](https://lodash.com/docs/#prototype-value)   | 结束链式调用，并计算结果。别名`valueOf`，`toJSON`                                |\n","slug":"lodash-functions","published":1,"date":"2016-09-05T16:00:00.000Z","updated":"2018-12-07T02:42:36.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpdnfmb6001ow8wkc4i4d4nw","content":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h2><p><a href=\"https://github.com/lodash/lodash\" target=\"_blank\" rel=\"noopener\">Lodash</a>是一款优秀的 JavaScript 工具库，里面包含了大量的工具函数。在 2015 年就成为<a href=\"https://www.npmjs.com/browse/depended\" target=\"_blank\" rel=\"noopener\">被依赖最多的 JavaScript 库</a>，写这篇文档是最新版是 4.17.4，适用于常见浏览器以及 Node.js 等。</p>\n<p>这里给出其<a href=\"https://lodash.com/docs\" target=\"_blank\" rel=\"noopener\">英文文档</a>和<a href=\"http://lodash.think2011.net/\" target=\"_blank\" rel=\"noopener\">中文文档</a>的链接。其中中文文档的版本较低，但是区别不大，可以参考帮助理解。</p>\n<h2 id=\"2-常见用法\"><a href=\"#2-常见用法\" class=\"headerlink\" title=\"2 常见用法\"></a>2 常见用法</h2><p>在这部分我们介绍一些 Lodash 的常见的优雅的用法。主要是引起大家的学习兴趣，有更多优雅用法等待大家去发现。</p>\n<h3 id=\"get获取一个嵌套很深的字段\"><a href=\"#get获取一个嵌套很深的字段\" class=\"headerlink\" title=\"_.get获取一个嵌套很深的字段\"></a><code>_.get</code>获取一个嵌套很深的字段</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//config 初始化为 null，需要从服务器端获取权限数据</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> config = <span class=\"literal\">null</span>;</span><br><span class=\"line\">ajax.get(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// data = &#123;basic: &#123;delete: true&#125;&#125;</span></span><br><span class=\"line\">    config = data;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用原生JS获取是否有删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isDeletable = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (config &amp;&amp; config.basic) &#123;</span><br><span class=\"line\">    isDeletable = config.basic.delete || <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用lodash获取是否有删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isDeletable = _.get(config, <span class=\"string\">'basic.delete'</span>, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>对应地，可以通过<code>_.set({}, &#39;a.b.c&#39;, 1)</code>创建一个多级嵌套的对象。</p>\n<h3 id=\"map获取数组中每个对象的特定字段，并形成一个新的数组\"><a href=\"#map获取数组中每个对象的特定字段，并形成一个新的数组\" class=\"headerlink\" title=\"_.map获取数组中每个对象的特定字段，并形成一个新的数组\"></a><code>_.map</code>获取数组中每个对象的特定字段，并形成一个新的数组</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用所有用户的 idCard 字段创建出一个数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> users = [&#123; <span class=\"attr\">idCard</span>: <span class=\"string\">'20160512'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'张三'</span> &#125;, &#123; <span class=\"attr\">idCard</span>: <span class=\"string\">'20160513'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'李四'</span> &#125;];</span><br><span class=\"line\"><span class=\"comment\">//使用原生JS</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> idCards = users.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.idCard;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> idCards = _.map(model, <span class=\"string\">'idCard'</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"pick取出对象的部分字段形成一个新对象\"><a href=\"#pick取出对象的部分字段形成一个新对象\" class=\"headerlink\" title=\"_.pick取出对象的部分字段形成一个新对象\"></a><code>_.pick</code>取出对象的部分字段形成一个新对象</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在修改密码表单里，用户输入了如下字段并被封装到一个对象中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> form = &#123;</span><br><span class=\"line\">    password: <span class=\"string\">'123456'</span>, <span class=\"comment\">//密码</span></span><br><span class=\"line\">    repeatPassword: <span class=\"string\">'123456'</span>, <span class=\"comment\">//重复密码</span></span><br><span class=\"line\">    code: <span class=\"string\">'5489'</span>, <span class=\"comment\">//验证码</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里不直接使用delete删除字段，是因为该 form 对象与 DOM 进行了绑定。</span></span><br><span class=\"line\"><span class=\"comment\">//其中重复密码只用来在客户端校验，不需要发送给服务器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fields = [<span class=\"string\">'password'</span>, <span class=\"string\">'code'</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class=\"line\">    data[fields[i]] = form[fields[i]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = _.pick(form, <span class=\"string\">'password'</span>, <span class=\"string\">'code'</span>);</span><br></pre></td></tr></table></figure>\n<p>对应地，还有<code>_.omit</code>方法表示删除部分字段形成一个新对象。</p>\n<h3 id=\"random获取一个随机值\"><a href=\"#random获取一个随机值\" class=\"headerlink\" title=\"_.random获取一个随机值\"></a><code>_.random</code>获取一个随机值</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取[90, 100)之内的一个随机值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> min = <span class=\"number\">90</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> max = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//使用原生JS</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> random = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min;</span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> random = _.random(min, max);</span><br></pre></td></tr></table></figure>\n<p>类似地，<code>_.sample([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code>可以从数组中随机取出一个项目。</p>\n<h3 id=\"clamp将一个数字修改成区间中的一个值\"><a href=\"#clamp将一个数字修改成区间中的一个值\" class=\"headerlink\" title=\"_.clamp将一个数字修改成区间中的一个值\"></a><code>_.clamp</code>将一个数字修改成区间中的一个值</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用原生JS</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyRange</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.max(number, <span class=\"keyword\">this</span>.props.min);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.min(number, <span class=\"keyword\">this</span>.props.max);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> number = _.clamp(number, min, max);</span><br></pre></td></tr></table></figure>\n<h3 id=\"once确保一个函数只会执行一次\"><a href=\"#once确保一个函数只会执行一次\" class=\"headerlink\" title=\"_.once确保一个函数只会执行一次\"></a><code>_.once</code>确保一个函数只会执行一次</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用原生JS</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> inited = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inited) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// init code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> init = _.once(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// init code</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"chain链式操作\"><a href=\"#chain链式操作\" class=\"headerlink\" title=\"_.chain链式操作\"></a><code>_.chain</code>链式操作</h3><p>链接调用让代码更加整洁；避免了中间变量，避免了错误引用，让代码质量更有保证；<code>_.chain</code>还提供了延迟计算特性，在显式或隐式调用<code>value()</code>方法之前是不进行任何计算的，通过合并大大降低迭代次数。<br>下面是<code>lodash</code>的官方文档中的一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> users = [&#123; <span class=\"attr\">user</span>: <span class=\"string\">'barney'</span>, <span class=\"attr\">age</span>: <span class=\"number\">36</span> &#125;, &#123; <span class=\"attr\">user</span>: <span class=\"string\">'fred'</span>, <span class=\"attr\">age</span>: <span class=\"number\">40</span> &#125;, &#123; <span class=\"attr\">user</span>: <span class=\"string\">'pebbles'</span>, <span class=\"attr\">age</span>: <span class=\"number\">1</span> &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> youngest = _.chain(users)</span><br><span class=\"line\">    .sortBy(<span class=\"string\">'age'</span>)</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chr</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> chr.user + <span class=\"string\">' is '</span> + chr.age;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .first()</span><br><span class=\"line\">    .value();</span><br><span class=\"line\"><span class=\"comment\">// → 'pebbles is 1'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-模块\"><a href=\"#3-模块\" class=\"headerlink\" title=\"3 模块\"></a>3 模块</h2><p>Lodash 的工具函数很多，可以分为以下几类：数组（Array），集合（Collection），函数（Function），Lang（Lang），数学（Math），数字（Number），对象（Object），字符串（String），未分类工具函数（Util）。下面将会按类别介绍常见工具函数。</p>\n<h2 id=\"4-数组\"><a href=\"#4-数组\" class=\"headerlink\" title=\"4 数组\"></a>4 数组</h2><h3 id=\"获取子数组\"><a href=\"#获取子数组\" class=\"headerlink\" title=\"获取子数组\"></a>获取子数组</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#slice\" target=\"_blank\" rel=\"noopener\">slice</a></td>\n<td>获取元素第 m-n(不包含)个元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#tail\" target=\"_blank\" rel=\"noopener\">tail</a></td>\n<td>获取出第一个元素之外的其他元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#initial\" target=\"_blank\" rel=\"noopener\">initial</a></td>\n<td>获取出最后一个元素之外的其他元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#take\" target=\"_blank\" rel=\"noopener\">take</a></td>\n<td>从左侧开始获取任意数量的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#takeRight\" target=\"_blank\" rel=\"noopener\">takeRight</a></td>\n<td>从右侧开始获取任意数量的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#takeWhile\" target=\"_blank\" rel=\"noopener\">takeWhile</a></td>\n<td>从左侧开始获取任意数量的元素，直到断言返回假值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#takeRightWhile\" target=\"_blank\" rel=\"noopener\">takeRightWhile</a></td>\n<td>从右侧开始获取任意数量的元素，直到断言返回假值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#drop\" target=\"_blank\" rel=\"noopener\">drop</a></td>\n<td>丢掉前面几个元素，得到剩余元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#dropWhile\" target=\"_blank\" rel=\"noopener\">dropWhile</a></td>\n<td>丢掉前面几个元素知道迭代器返回假值，得到剩余元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#dropRight\" target=\"_blank\" rel=\"noopener\">dropRight</a></td>\n<td>丢掉后面几个元素，得到剩余元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#dropRightWhile\" target=\"_blank\" rel=\"noopener\">dropRightWhile</a></td>\n<td>丢掉后面几个元素知道迭代器返回假值，得到剩余元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数组常见操作\"><a href=\"#数组常见操作\" class=\"headerlink\" title=\"数组常见操作\"></a>数组常见操作</h3><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>不修改原数组</th>\n<th>修改原数组</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>移除</td>\n<td><a href=\"https://lodash.com/docs/#without\" target=\"_blank\" rel=\"noopener\">without</a></td>\n<td><a href=\"https://lodash.com/docs/#pull\" target=\"_blank\" rel=\"noopener\">pull</a></td>\n</tr>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAll\" target=\"_blank\" rel=\"noopener\">pullAll</a></td>\n</tr>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#differenceBy\" target=\"_blank\" rel=\"noopener\">differenceBy</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAllBy\" target=\"_blank\" rel=\"noopener\">pullAllBy</a></td>\n</tr>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#differenceWith\" target=\"_blank\" rel=\"noopener\">differenceWith</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAllWith\" target=\"_blank\" rel=\"noopener\">pullAllWith</a></td>\n</tr>\n<tr>\n<td>反转</td>\n<td></td>\n<td><a href=\"https://lodash.com/docs/#reverse\" target=\"_blank\" rel=\"noopener\">reverse</a></td>\n</tr>\n<tr>\n<td>裁剪</td>\n<td><a href=\"https://lodash.com/docs/#at\" target=\"_blank\" rel=\"noopener\">at</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAt\" target=\"_blank\" rel=\"noopener\">pullAt</a></td>\n</tr>\n<tr>\n<td>过滤</td>\n<td><a href=\"https://lodash.com/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a></td>\n<td><a href=\"https://lodash.com/docs/#remove\" target=\"_blank\" rel=\"noopener\">remove</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数组常见操作变种函数-by-with\"><a href=\"#数组常见操作变种函数-by-with\" class=\"headerlink\" title=\"数组常见操作变种函数 by, with\"></a>数组常见操作变种函数 by, with</h3><p>有些函数还可以稍微变化一下，接受不同的参数，提供更多灵活性。</p>\n<table>\n<thead>\n<tr>\n<th>作用</th>\n<th>函数名</th>\n<th>by</th>\n<th>with</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a></td>\n<td><a href=\"https://lodash.com/docs/#differenceBy\" target=\"_blank\" rel=\"noopener\">differenceBy</a></td>\n<td><a href=\"https://lodash.com/docs/#differenceWith\" target=\"_blank\" rel=\"noopener\">differenceWith</a></td>\n</tr>\n<tr>\n<td>交集</td>\n<td><a href=\"https://lodash.com/docs/#intersection\" target=\"_blank\" rel=\"noopener\">intersection</a></td>\n<td><a href=\"https://lodash.com/docs/#intersectionBy\" target=\"_blank\" rel=\"noopener\">intersectionBy</a></td>\n<td><a href=\"https://lodash.com/docs/#intersectionWith\" target=\"_blank\" rel=\"noopener\">intersectionWith</a></td>\n</tr>\n<tr>\n<td>并集</td>\n<td><a href=\"https://lodash.com/docs/#union\" target=\"_blank\" rel=\"noopener\">union</a></td>\n<td><a href=\"https://lodash.com/docs/#unionBy\" target=\"_blank\" rel=\"noopener\">unionBy</a></td>\n<td><a href=\"https://lodash.com/docs/#unionWith\" target=\"_blank\" rel=\"noopener\">unionWith</a></td>\n</tr>\n<tr>\n<td>异或</td>\n<td><a href=\"https://lodash.com/docs/#xor\" target=\"_blank\" rel=\"noopener\">xor</a></td>\n<td><a href=\"https://lodash.com/docs/#xorBy\" target=\"_blank\" rel=\"noopener\">xorBy</a></td>\n<td><a href=\"https://lodash.com/docs/#xorWith\" target=\"_blank\" rel=\"noopener\">xorWith</a></td>\n</tr>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#pullAll\" target=\"_blank\" rel=\"noopener\">pullAll</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAllBy\" target=\"_blank\" rel=\"noopener\">pullAllBy</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAllWith\" target=\"_blank\" rel=\"noopener\">pullAllWith</a>，跟<a href=\"https://lodash.com/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a>不同的是，<a href=\"https://lodash.com/docs/#pullAll\" target=\"_blank\" rel=\"noopener\">pullAll</a>修改原数组</td>\n</tr>\n<tr>\n<td>去重</td>\n<td><a href=\"https://lodash.com/docs/#uniq\" target=\"_blank\" rel=\"noopener\">uniq</a></td>\n<td><a href=\"https://lodash.com/docs/#uniqBy\" target=\"_blank\" rel=\"noopener\">uniqBy</a></td>\n<td><a href=\"https://lodash.com/docs/#uniqWith\" target=\"_blank\" rel=\"noopener\">uniqWith</a></td>\n</tr>\n<tr>\n<td>去重</td>\n<td><a href=\"https://lodash.com/docs/#sortedUniq\" target=\"_blank\" rel=\"noopener\">sortedUniq</a></td>\n<td><a href=\"https://lodash.com/docs/#sortedUniqBy\" target=\"_blank\" rel=\"noopener\">sortedUniqBy</a></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"获取数组某个位置上的元素\"><a href=\"#获取数组某个位置上的元素\" class=\"headerlink\" title=\"获取数组某个位置上的元素\"></a>获取数组某个位置上的元素</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#head\" target=\"_blank\" rel=\"noopener\">head</a></td>\n<td>数组=&gt;元素</td>\n<td>返回数组的第一个元素，和<a href=\"https://lodash.com/docs/#first\" target=\"_blank\" rel=\"noopener\">first</a>相同</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#last\" target=\"_blank\" rel=\"noopener\">last</a></td>\n<td>数组=&gt;元素</td>\n<td>返回数组的最后一个元素，和<a href=\"https://lodash.com/docs/#head\" target=\"_blank\" rel=\"noopener\">head</a>相反</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#nth\" target=\"_blank\" rel=\"noopener\">nth</a></td>\n<td>数组=&gt;元素</td>\n<td>返回数组中某个位置上的元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"检测元素在数组中的索引\"><a href=\"#检测元素在数组中的索引\" class=\"headerlink\" title=\"检测元素在数组中的索引\"></a>检测元素在数组中的索引</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#indexOf\" target=\"_blank\" rel=\"noopener\">indexOf</a></td>\n<td>获取元素在数组中的索引</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedIndexOf\" target=\"_blank\" rel=\"noopener\">sortedIndexOf</a></td>\n<td>和<a href=\"https://lodash.com/docs/#indexOf\" target=\"_blank\" rel=\"noopener\">indexOf</a>功能一致，只是通过二分搜索方法</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lastIndexOf\" target=\"_blank\" rel=\"noopener\">lastIndexOf</a></td>\n<td>获取元素在数组中的索引，最后一次出现</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedLastIndexOf\" target=\"_blank\" rel=\"noopener\">sortedLastIndexOf</a></td>\n<td>和<a href=\"https://lodash.com/docs/#lastIndexOf\" target=\"_blank\" rel=\"noopener\">lastIndexOf</a>功能一致，只是通过二分搜索方法</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findIndex\" target=\"_blank\" rel=\"noopener\">findIndex</a></td>\n<td>寻找元素位置</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findLastIndex\" target=\"_blank\" rel=\"noopener\">findLastIndex</a></td>\n<td>寻找元素位置，从后往前</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"检测元素在插在有序数组的什么位置\"><a href=\"#检测元素在插在有序数组的什么位置\" class=\"headerlink\" title=\"检测元素在插在有序数组的什么位置\"></a>检测元素在插在有序数组的什么位置</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedIndex\" target=\"_blank\" rel=\"noopener\">sortedIndex</a></td>\n<td>通过二分搜索判断元素应该插在数组的哪个位置</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedIndexBy\" target=\"_blank\" rel=\"noopener\">sortedIndexBy</a></td>\n<td>同上，可以额外提供一个迭代器函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedLastIndex\" target=\"_blank\" rel=\"noopener\">sortedLastIndex</a></td>\n<td>和<a href=\"https://lodash.com/docs/#sortedIndex\" target=\"_blank\" rel=\"noopener\">sortedIndex</a>类似，但是从右边开始</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedLastIndexBy\" target=\"_blank\" rel=\"noopener\">sortedLastIndexBy</a></td>\n<td>同上，可以额外提供一个迭代器函数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"将数组拍平\"><a href=\"#将数组拍平\" class=\"headerlink\" title=\"将数组拍平\"></a>将数组拍平</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">flatten</a></td>\n<td>高维数组=&gt;低维数组</td>\n<td>将数组拍平</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flattenDeep\" target=\"_blank\" rel=\"noopener\">flattenDeep</a></td>\n<td>高维数组=&gt;数组</td>\n<td>将数组拍平</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flattenDepth\" target=\"_blank\" rel=\"noopener\">flattenDepth</a></td>\n<td>高维数组=&gt;低维数组</td>\n<td>将数组拍平</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Zip\"><a href=\"#Zip\" class=\"headerlink\" title=\"Zip\"></a>Zip</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#zip\" target=\"_blank\" rel=\"noopener\">zip</a></td>\n<td>多个数组=&gt;二维数组</td>\n<td>可以理解为二维数组的行列互换</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#zipWith\" target=\"_blank\" rel=\"noopener\">zipWith</a></td>\n<td>多个数组=&gt;数组</td>\n<td>同上，但是可以自由处理行列互换后的数组中的每个数组元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#zipObject\" target=\"_blank\" rel=\"noopener\">zipObject</a></td>\n<td>两个数组=&gt;对象</td>\n<td>把 keys 和 values 数组组成一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#zipObjectDeep\" target=\"_blank\" rel=\"noopener\">zipObjectDeep</a></td>\n<td>两个数组=&gt;对象</td>\n<td>同上，递归地处理属性名</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"未分类函数\"><a href=\"#未分类函数\" class=\"headerlink\" title=\"未分类函数\"></a>未分类函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#chunk\" target=\"_blank\" rel=\"noopener\">chunk</a></td>\n<td>数组=&gt;二维数组</td>\n<td>分段形成二维数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#compact\" target=\"_blank\" rel=\"noopener\">compact</a></td>\n<td>数组=&gt;数组</td>\n<td>移除假值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#concat\" target=\"_blank\" rel=\"noopener\">concat</a></td>\n<td>多个数组=&gt;数组</td>\n<td>连接多个数组形成一个数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#fill\" target=\"_blank\" rel=\"noopener\">fill</a></td>\n<td>数组=&gt;数组</td>\n<td>填充数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#fromPairs\" target=\"_blank\" rel=\"noopener\">fromPairs</a></td>\n<td>二维数组=&gt;对象</td>\n<td>将键值数组变成对象。和<a href=\"https://lodash.com/docs/#toPairs\" target=\"_blank\" rel=\"noopener\">toPairs</a>相反</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#join\" target=\"_blank\" rel=\"noopener\">join</a></td>\n<td>数组=&gt;字符串</td>\n<td>拼接数组元素成一个字符串</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"5-集合\"><a href=\"#5-集合\" class=\"headerlink\" title=\"5 集合\"></a>5 集合</h2><p>为什么区分集合函数和数组函数？<br>集合函数不单单适用于数组，还适用于字符串，对象，类数组对象（比如 Arguments，NodeList 等）。字符串是字符的集合，对象是属性值的集合。类数组对象是通过“<a href=\"https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"noopener\">鸭子类型</a>”工作的，所以如果你传入一个拥有<code>length</code>字段并且值为数字的对象，这个对象会被当做一个数组处理。具体请参考<a href=\"http://underscorejs.org/#collections\" target=\"_blank\" rel=\"noopener\">Underscore.js</a>文档。</p>\n<p>范例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printKeyVal</span>(<span class=\"params\">val, key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//普通对象</span></span><br><span class=\"line\">_.each(&#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;, printKeyVal);</span><br><span class=\"line\"><span class=\"comment\">//打印结果</span></span><br><span class=\"line\"><span class=\"comment\">// a 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//拥有值为数字的length字段</span></span><br><span class=\"line\">_.each(&#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">length</span>: <span class=\"number\">2</span> &#125;, printKeyVal);</span><br><span class=\"line\"><span class=\"comment\">//打印结果</span></span><br><span class=\"line\"><span class=\"comment\">// 0 undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 1 undefined</span></span><br></pre></td></tr></table></figure>\n<p>下面将分类介绍集合相关函数。</p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#each\" target=\"_blank\" rel=\"noopener\">each</a></td>\n<td>同<a href=\"https://lodash.com/docs/#forEach\" target=\"_blank\" rel=\"noopener\">forEach</a></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#eachRight\" target=\"_blank\" rel=\"noopener\">eachRight</a></td>\n<td>同<a href=\"https://lodash.com/docs/#forEachRight\" target=\"_blank\" rel=\"noopener\">forEachRight</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">sortBy</a></td>\n<td>排序</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#orderBy\" target=\"_blank\" rel=\"noopener\">orderBy</a></td>\n<td>同<a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">sortBy</a>，还可以指定正序倒序</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#shuffle\" target=\"_blank\" rel=\"noopener\">shuffle</a></td>\n<td>返回一个打乱顺序的新数组</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a></td>\n<td>创建一个新数组，包含了所有让断言为真的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#reject\" target=\"_blank\" rel=\"noopener\">reject</a></td>\n<td>创建一个新数组，包含了所有让断言为假的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#partition\" target=\"_blank\" rel=\"noopener\">partition</a></td>\n<td>根据断言真假将一个集合分成两个集合</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Map-之后再-flatten\"><a href=\"#Map-之后再-flatten\" class=\"headerlink\" title=\"Map 之后再 flatten\"></a>Map 之后再 flatten</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flatMap\" target=\"_blank\" rel=\"noopener\">flatMap</a></td>\n<td><a href=\"https://lodash.com/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a>之后再<a href=\"https://lodash.com/docs/#flatten\" target=\"_blank\" rel=\"noopener\">flatten</a></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flatMapDeep\" target=\"_blank\" rel=\"noopener\">flatMapDeep</a></td>\n<td><a href=\"https://lodash.com/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a>之后再<a href=\"https://lodash.com/docs/#flattenDeep\" target=\"_blank\" rel=\"noopener\">flattenDeep</a></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flatMapDepth\" target=\"_blank\" rel=\"noopener\">flatMapDepth</a></td>\n<td><a href=\"https://lodash.com/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a>之后再<a href=\"https://lodash.com/docs/#flattenDepth\" target=\"_blank\" rel=\"noopener\">flattenDepth</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"寻找元素\"><a href=\"#寻找元素\" class=\"headerlink\" title=\"寻找元素\"></a>寻找元素</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#find\" target=\"_blank\" rel=\"noopener\">find</a></td>\n<td>找到第一个让断言为真的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findLast\" target=\"_blank\" rel=\"noopener\">findLast</a></td>\n<td>同上，逆序</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"随机取值\"><a href=\"#随机取值\" class=\"headerlink\" title=\"随机取值\"></a>随机取值</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sample\" target=\"_blank\" rel=\"noopener\">sample</a></td>\n<td>从集合中随机选出一个元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sampleSize\" target=\"_blank\" rel=\"noopener\">sampleSize</a></td>\n<td>从集合中随机选出 n 个元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#reduce\" target=\"_blank\" rel=\"noopener\">reduce</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#reduceRight\" target=\"_blank\" rel=\"noopener\">reduceRight</a></td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"分组计数\"><a href=\"#分组计数\" class=\"headerlink\" title=\"分组计数\"></a>分组计数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#countBy\" target=\"_blank\" rel=\"noopener\">countBy</a></td>\n<td>返回一个对象，属性名是迭代器的返回值，属性值该返回值出现的次数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#groupBy\" target=\"_blank\" rel=\"noopener\">groupBy</a></td>\n<td>返回一个对象，属性名是迭代器的返回值，属性值是一个包含了相应元素的数组</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"未分类\"><a href=\"#未分类\" class=\"headerlink\" title=\"未分类\"></a>未分类</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#keyBy\" target=\"_blank\" rel=\"noopener\">keyBy</a></td>\n<td>返回一个对象，属性名是迭代器的返回值，属性值是元素本身</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">some</a></td>\n<td>对于集合中的每个元素，是否至少其一返回真值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#every\" target=\"_blank\" rel=\"noopener\">every</a></td>\n<td>对于集合中的每个元素，是否都返回真值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#includes\" target=\"_blank\" rel=\"noopener\">includes</a></td>\n<td>判断元素是不是在数组中，判断某个值是不是某个对象的属性值，判断一个字符串是不是包含在另一个字符串中</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a></td>\n<td>对集合的数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#invokeMap\" target=\"_blank\" rel=\"noopener\">invokeMap</a></td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"6-对象\"><a href=\"#6-对象\" class=\"headerlink\" title=\"6 对象\"></a>6 对象</h2><h3 id=\"仅需要部分字段\"><a href=\"#仅需要部分字段\" class=\"headerlink\" title=\"仅需要部分字段\"></a>仅需要部分字段</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#omit\" target=\"_blank\" rel=\"noopener\">omit</a></td>\n<td>通过忽略某些字段创建一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#omitBy\" target=\"_blank\" rel=\"noopener\">omitBy</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#pick\" target=\"_blank\" rel=\"noopener\">pick</a></td>\n<td>通过指定某些字段创建一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#pickBy\" target=\"_blank\" rel=\"noopener\">pickBy</a></td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"合并对象\"><a href=\"#合并对象\" class=\"headerlink\" title=\"合并对象\"></a>合并对象</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#assign\" target=\"_blank\" rel=\"noopener\">assign</a></td>\n<td>合并对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#assignWith\" target=\"_blank\" rel=\"noopener\">assignWith</a></td>\n<td>有条件地合并对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#extend\" target=\"_blank\" rel=\"noopener\">extend</a></td>\n<td>合并对象，包括原型链上的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#extendWith\" target=\"_blank\" rel=\"noopener\">extendWith</a></td>\n<td>有条件地合并对象，包括原型链上的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#assignIn\" target=\"_blank\" rel=\"noopener\">assignIn</a></td>\n<td>别名<code>extend</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#assignInWith\" target=\"_blank\" rel=\"noopener\">assignInWith</a></td>\n<td>别名<code>extendWith</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#defaults\" target=\"_blank\" rel=\"noopener\">defaults</a></td>\n<td>合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#defaultsDeep\" target=\"_blank\" rel=\"noopener\">defaultsDeep</a></td>\n<td>递归地合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#merge\" target=\"_blank\" rel=\"noopener\">merge</a></td>\n<td>递归地合并对象，将后面参数的属性付给第一个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mergeWith\" target=\"_blank\" rel=\"noopener\">mergeWith</a></td>\n<td>同<a href=\"https://lodash.com/docs/#merge\" target=\"_blank\" rel=\"noopener\">merge</a>，额外接受一个 customizer 参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"键值列表\"><a href=\"#键值列表\" class=\"headerlink\" title=\"键值列表\"></a>键值列表</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#keys\" target=\"_blank\" rel=\"noopener\">keys</a></td>\n<td>创建一个数组，包含对象中所有的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#keysIn\" target=\"_blank\" rel=\"noopener\">keysIn</a></td>\n<td>创建一个数组，包含对象中所有的属性（包含原型链上的）</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#functions\" target=\"_blank\" rel=\"noopener\">functions</a></td>\n<td>创建一个数组，包含对象中所有值为函数的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#functionsIn\" target=\"_blank\" rel=\"noopener\">functionsIn</a></td>\n<td>创建一个数组，包含对象中所有值为函数的属性（包含原型链上的）</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#values\" target=\"_blank\" rel=\"noopener\">values</a></td>\n<td>创建一个数组，包含对象中所有的属性值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#valuesIn\" target=\"_blank\" rel=\"noopener\">valuesIn</a></td>\n<td>创建一个数组，包含对象中所有的属性值（包含原型链上的）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"赋值取值\"><a href=\"#赋值取值\" class=\"headerlink\" title=\"赋值取值\"></a>赋值取值</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#at\" target=\"_blank\" rel=\"noopener\">at</a></td>\n<td>获取对象的一组属性路径的值，肯定不会报错</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#get\" target=\"_blank\" rel=\"noopener\">get</a></td>\n<td>获取对象的某个属性路径的值，肯定不会报错</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#result\" target=\"_blank\" rel=\"noopener\">result</a></td>\n<td>同<a href=\"https://lodash.com/docs/#get\" target=\"_blank\" rel=\"noopener\">get</a>，但是如果属性值是函数的话，自动执行该函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#set\" target=\"_blank\" rel=\"noopener\">set</a></td>\n<td>设置对象的某个属性路径的值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#setWith\" target=\"_blank\" rel=\"noopener\">setWith</a></td>\n<td>设置对象的某个属性路径的值，遇到不存在的中间对象，使用数组呢？还是使用对象呢？等等</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#update\" target=\"_blank\" rel=\"noopener\">update</a></td>\n<td>同<a href=\"https://lodash.com/docs/#set\" target=\"_blank\" rel=\"noopener\">set</a>，只是接受一个函数作为参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#updateWith\" target=\"_blank\" rel=\"noopener\">updateWith</a></td>\n<td>同<a href=\"https://lodash.com/docs/#setWith\" target=\"_blank\" rel=\"noopener\">setWith</a>，只是接受一个函数作为参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#unset\" target=\"_blank\" rel=\"noopener\">unset</a></td>\n<td>删除对象的某个属性路径</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">invoke</a></td>\n<td>调用对象中某个属性路径上的函数，肯定不会报错</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"键值数组\"><a href=\"#键值数组\" class=\"headerlink\" title=\"键值数组\"></a>键值数组</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#entries\" target=\"_blank\" rel=\"noopener\">entries</a></td>\n<td>{‘a’:1}=&gt;[[‘a’,1]]。别名<code>toPairs</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#entriesIn\" target=\"_blank\" rel=\"noopener\">entriesIn</a></td>\n<td>同上，但是包含原型链上的属性。别名<code>toPairsIn</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"键值变换\"><a href=\"#键值变换\" class=\"headerlink\" title=\"键值变换\"></a>键值变换</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mapKeys\" target=\"_blank\" rel=\"noopener\">mapKeys</a></td>\n<td>对对象中所有属性名做某种处理之后形成一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mapValues\" target=\"_blank\" rel=\"noopener\">mapValues</a></td>\n<td>对对象中所有属性值做某种处理之后形成一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#invert\" target=\"_blank\" rel=\"noopener\">invert</a></td>\n<td>将对象中的属性名和属性值互换转成一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#invertBy\" target=\"_blank\" rel=\"noopener\">invertBy</a></td>\n<td>同<a href=\"https://lodash.com/docs/#invert\" target=\"_blank\" rel=\"noopener\">invert</a>，但是转换以后的属性值是原属性值组成的数组</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"键值遍历\"><a href=\"#键值遍历\" class=\"headerlink\" title=\"键值遍历\"></a>键值遍历</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#forIn\" target=\"_blank\" rel=\"noopener\">forIn</a></td>\n<td>遍历对象上的所有属性，包含原型链上的。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#forInRight\" target=\"_blank\" rel=\"noopener\">forInRight</a></td>\n<td>遍历对象上的所有属性，包含原型链上的。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#forOwn\" target=\"_blank\" rel=\"noopener\">forOwn</a></td>\n<td>遍历对象上的所有属性，不包含原型链上的。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#forOwnRight\" target=\"_blank\" rel=\"noopener\">forOwnRight</a></td>\n<td>遍历对象上的所有属性，不包含原型链上的。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"寻找属性\"><a href=\"#寻找属性\" class=\"headerlink\" title=\"寻找属性\"></a>寻找属性</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findKey\" target=\"_blank\" rel=\"noopener\">findKey</a></td>\n<td>同<a href=\"https://lodash.com/docs/#find\" target=\"_blank\" rel=\"noopener\">find</a>类似，但是匹配的是对象的属性值，返回的是对象的属性名</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findLastKey\" target=\"_blank\" rel=\"noopener\">findLastKey</a></td>\n<td>同<a href=\"https://lodash.com/docs/#findKey\" target=\"_blank\" rel=\"noopener\">findKey</a>类似，但是匹配的是对象的属性值，返回的是对象的属性名</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"判断属性是否存在\"><a href=\"#判断属性是否存在\" class=\"headerlink\" title=\"判断属性是否存在\"></a>判断属性是否存在</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#has\" target=\"_blank\" rel=\"noopener\">has</a></td>\n<td>判断对象上是否拥有某个属性，不包含原型链上的</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#hasIn\" target=\"_blank\" rel=\"noopener\">hasIn</a></td>\n<td>判断对象上是否拥有某个属性，包含原型链上的</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"转换对象或数组\"><a href=\"#转换对象或数组\" class=\"headerlink\" title=\"转换对象或数组\"></a>转换对象或数组</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#transform\" target=\"_blank\" rel=\"noopener\">transform</a></td>\n<td>同<a href=\"https://lodash.com/docs/#reduce\" target=\"_blank\" rel=\"noopener\">reduce</a>，但是其迭代器函数返回的是布尔值，如果返回 false，则停止迭代</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"创建新对象\"><a href=\"#创建新对象\" class=\"headerlink\" title=\"创建新对象\"></a>创建新对象</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#create\" target=\"_blank\" rel=\"noopener\">create</a></td>\n<td>创建一个对象，并指定其原型和属性</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"7-函数\"><a href=\"#7-函数\" class=\"headerlink\" title=\"7. 函数\"></a>7. 函数</h2><h3 id=\"修改参数\"><a href=\"#修改参数\" class=\"headerlink\" title=\"修改参数\"></a>修改参数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#ary\" target=\"_blank\" rel=\"noopener\">ary</a></td>\n<td>创建一个包裹函数，只将前 n 个参数传递给原函数。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#unary\" target=\"_blank\" rel=\"noopener\">unary</a></td>\n<td>创建一个包裹函数，只将第一个参数传递给原函数。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flip\" target=\"_blank\" rel=\"noopener\">flip</a></td>\n<td>创建一个包裹函数，将参数逆序之后传递给原函数。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#rearg\" target=\"_blank\" rel=\"noopener\">rearg</a></td>\n<td>创建一个包裹函数，调整参数顺序之后在传递给原函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#rest\" target=\"_blank\" rel=\"noopener\">rest</a></td>\n<td>创建一个包裹函数，将参数合成数组之后传递给原函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#spread\" target=\"_blank\" rel=\"noopener\">spread</a></td>\n<td>创建一个包裹函数，将数组参数展开之后传给原函数，跟<a href=\"https://lodash.com/docs/#rest\" target=\"_blank\" rel=\"noopener\">rest</a>相反</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#overArgs\" target=\"_blank\" rel=\"noopener\">overArgs</a></td>\n<td>创建一个包裹函数，将参数做处理之后再传递给原函数。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"修改结果\"><a href=\"#修改结果\" class=\"headerlink\" title=\"修改结果\"></a>修改结果</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#negate\" target=\"_blank\" rel=\"noopener\">negate</a></td>\n<td>创建一个包裹函数，返回原函数结果的非。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"缓存结果\"><a href=\"#缓存结果\" class=\"headerlink\" title=\"缓存结果\"></a>缓存结果</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#memoize\" target=\"_blank\" rel=\"noopener\">memoize</a></td>\n<td>创建一个包裹函数，会缓存计算结果</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"降频调用\"><a href=\"#降频调用\" class=\"headerlink\" title=\"降频调用\"></a>降频调用</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#debounce\" target=\"_blank\" rel=\"noopener\">debounce</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#throttle\" target=\"_blank\" rel=\"noopener\">throttle</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"延迟调用\"><a href=\"#延迟调用\" class=\"headerlink\" title=\"延迟调用\"></a>延迟调用</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#defer\" target=\"_blank\" rel=\"noopener\">defer</a></td>\n<td>类似<code>setTimeout(fn,0)</code>，可以指定参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#delay\" target=\"_blank\" rel=\"noopener\">delay</a></td>\n<td>类似<code>setTimeout(fn,x)</code>，可以指定参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"延迟调用-1\"><a href=\"#延迟调用-1\" class=\"headerlink\" title=\"延迟调用\"></a>延迟调用</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#once\" target=\"_blank\" rel=\"noopener\">once</a></td>\n<td>创建一个包裹函数，确保原函数只被执行一次。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#before\" target=\"_blank\" rel=\"noopener\">before</a></td>\n<td>创建一个包裹函数，确保原函数只被执行 n 次。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#after\" target=\"_blank\" rel=\"noopener\">after</a></td>\n<td>创建一个包裹函数，调用包裹函数时只有 n 次之后才会调用目标函数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"固定参数\"><a href=\"#固定参数\" class=\"headerlink\" title=\"固定参数\"></a>固定参数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#wrap\" target=\"_blank\" rel=\"noopener\">wrap</a></td>\n<td>创建一个包裹函数，固定原函数的第一个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#partial\" target=\"_blank\" rel=\"noopener\">partial</a></td>\n<td>创建一个包裹函数，固定原函数若干个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#partialRight\" target=\"_blank\" rel=\"noopener\">partialRight</a></td>\n<td>创建一个包裹函数，固定原函数若干个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#bind\" target=\"_blank\" rel=\"noopener\">bind</a></td>\n<td>创建一个包裹函数，固定原函数若干个参数，并指定 this 对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#bindKey\" target=\"_blank\" rel=\"noopener\">bindKey</a></td>\n<td>和<a href=\"https://lodash.com/docs/#bind\" target=\"_blank\" rel=\"noopener\">bind</a>功能类似，但是能够处理尚未创建或被重写的函数，有点事件代理的感觉。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#curry\" target=\"_blank\" rel=\"noopener\">curry</a></td>\n<td>创建一个包裹函数，可以传入任意数量的参数，如果参数不完整，则返回一个接受余下参数的新函数，否则，调用原函数获得计算结果。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#curryRight\" target=\"_blank\" rel=\"noopener\">curryRight</a></td>\n<td>同上，逆序</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"8-字符串\"><a href=\"#8-字符串\" class=\"headerlink\" title=\"8. 字符串\"></a>8. 字符串</h2><h3 id=\"书写格式\"><a href=\"#书写格式\" class=\"headerlink\" title=\"书写格式\"></a>书写格式</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#startCase\" target=\"_blank\" rel=\"noopener\">startCase</a></td>\n<td>每个单词首字母大写，多用于标题</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#camelCase\" target=\"_blank\" rel=\"noopener\">camelCase</a></td>\n<td>小驼峰</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#kebabCase\" target=\"_blank\" rel=\"noopener\">kebabCase</a></td>\n<td>小写连字符</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#snakeCase\" target=\"_blank\" rel=\"noopener\">snakeCase</a></td>\n<td>小写下划线</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#upperCase\" target=\"_blank\" rel=\"noopener\">upperCase</a></td>\n<td>大写加空格</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lowerCase\" target=\"_blank\" rel=\"noopener\">lowerCase</a></td>\n<td>小写加空格</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"大写小写\"><a href=\"#大写小写\" class=\"headerlink\" title=\"大写小写\"></a>大写小写</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#capitalize\" target=\"_blank\" rel=\"noopener\">capitalize</a></td>\n<td>首字母大写，其余小写</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#upperFirst\" target=\"_blank\" rel=\"noopener\">upperFirst</a></td>\n<td>首字母大写，其余不变</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lowerFirst\" target=\"_blank\" rel=\"noopener\">lowerFirst</a></td>\n<td>首字母小写，其余不变</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lowerFirst\" target=\"_blank\" rel=\"noopener\">toUpper</a></td>\n<td>大写</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toLower\" target=\"_blank\" rel=\"noopener\">toLower</a></td>\n<td>小写</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"打头结尾\"><a href=\"#打头结尾\" class=\"headerlink\" title=\"打头结尾\"></a>打头结尾</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#endsWith\" target=\"_blank\" rel=\"noopener\">endsWith</a></td>\n<td>是不是以特定字符串结尾</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#startsWith\" target=\"_blank\" rel=\"noopener\">startsWith</a></td>\n<td>是不是以特定字符串打头</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#escape\" target=\"_blank\" rel=\"noopener\">escape</a></td>\n<td>转义 &amp;&lt;&gt;”‘，与<a href=\"https://lodash.com/docs/#unescape\" target=\"_blank\" rel=\"noopener\">unescape</a>相反</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#escapeRegExp\" target=\"_blank\" rel=\"noopener\">escapeRegExp</a></td>\n<td>转义正则表达式中的特殊字符：^\\$.*+?()[]{}\\</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"补全抹掉\"><a href=\"#补全抹掉\" class=\"headerlink\" title=\"补全抹掉\"></a>补全抹掉</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#pad\" target=\"_blank\" rel=\"noopener\">pad</a></td>\n<td>使用某个字符串将特定字符串扩充至指定长度，类似地还有<a href=\"https://lodash.com/docs/#padStart\" target=\"_blank\" rel=\"noopener\">padStart</a>，<a href=\"https://lodash.com/docs/#padEnd\" target=\"_blank\" rel=\"noopener\">padEnd</a></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#trim\" target=\"_blank\" rel=\"noopener\">trim</a></td>\n<td>去除字符串两边的特殊字符（默认为空格），类似地还有<a href=\"https://lodash.com/docs/#trimStart\" target=\"_blank\" rel=\"noopener\">trimStart</a>，<a href=\"https://lodash.com/docs/#trimEnd\" target=\"_blank\" rel=\"noopener\">trimEnd</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"未分类-1\"><a href=\"#未分类-1\" class=\"headerlink\" title=\"未分类\"></a>未分类</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#parseInt\" target=\"_blank\" rel=\"noopener\">parseInt</a></td>\n<td>转成整型</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#repeat\" target=\"_blank\" rel=\"noopener\">repeat</a></td>\n<td>将某个字符串重复 n 遍</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#replace\" target=\"_blank\" rel=\"noopener\">replace</a></td>\n<td>替换字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#split\" target=\"_blank\" rel=\"noopener\">split</a></td>\n<td>拆分字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#template\" target=\"_blank\" rel=\"noopener\">template</a></td>\n<td>简单模板引擎</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#truncate\" target=\"_blank\" rel=\"noopener\">truncate</a></td>\n<td>截断字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#words\" target=\"_blank\" rel=\"noopener\">words</a></td>\n<td>将字符串拆分成单词，可以指定拆分模式</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#deburr\" target=\"_blank\" rel=\"noopener\">deburr</a></td>\n<td>基本拉丁字母</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"9-数字\"><a href=\"#9-数字\" class=\"headerlink\" title=\"9. 数字\"></a>9. 数字</h2><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#clamp\" target=\"_blank\" rel=\"noopener\">clamp</a></td>\n<td>数字=&gt;数字</td>\n<td>将数字限定在一个范围内</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#inRange\" target=\"_blank\" rel=\"noopener\">inRange</a></td>\n<td>数字=&gt;布尔</td>\n<td>判断数字是否在某个区间里</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#random\" target=\"_blank\" rel=\"noopener\">random</a></td>\n<td>区间=&gt;数字</td>\n<td>随机获取一个值，可以通过第三个参数指定是不是返回小数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"10-数学\"><a href=\"#10-数学\" class=\"headerlink\" title=\"10. 数学\"></a>10. 数学</h2><h3 id=\"加减乘除\"><a href=\"#加减乘除\" class=\"headerlink\" title=\"加减乘除\"></a>加减乘除</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#add\" target=\"_blank\" rel=\"noopener\">add</a></td>\n<td>两个数字 =&gt; 数字</td>\n<td>返回两个数字的和</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#subtract\" target=\"_blank\" rel=\"noopener\">subtract</a></td>\n<td>两个数字 =&gt; 数字</td>\n<td>返回两个数字的差</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#multiply\" target=\"_blank\" rel=\"noopener\">multiply</a></td>\n<td>两个数字 =&gt; 数字</td>\n<td>返回两个数字的积</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#divide\" target=\"_blank\" rel=\"noopener\">divide</a></td>\n<td>两个数字 =&gt; 数字</td>\n<td>返回两个数字的商</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"和，最大值，最小值，平均值\"><a href=\"#和，最大值，最小值，平均值\" class=\"headerlink\" title=\"和，最大值，最小值，平均值\"></a>和，最大值，最小值，平均值</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sum\" target=\"_blank\" rel=\"noopener\">sum</a></td>\n<td>数组 =&gt; 数字</td>\n<td>返回数组中的各数字之和</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#max\" target=\"_blank\" rel=\"noopener\">max</a></td>\n<td>数组 =&gt; 数字</td>\n<td>返回数组中的最大值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#min\" target=\"_blank\" rel=\"noopener\">min</a></td>\n<td>数组 =&gt; 数字</td>\n<td>返回数组中的最小值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mean\" target=\"_blank\" rel=\"noopener\">mean</a></td>\n<td>数组 =&gt; 数字</td>\n<td>返回数组中的平均值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数字精度\"><a href=\"#数字精度\" class=\"headerlink\" title=\"数字精度\"></a>数字精度</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#ceil\" target=\"_blank\" rel=\"noopener\">ceil</a></td>\n<td>数字 =&gt; 数字</td>\n<td>向上取整，可以指定精度</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#floor\" target=\"_blank\" rel=\"noopener\">floor</a></td>\n<td>数字 =&gt; 数字</td>\n<td>向下取整，可以指定精度</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#round\" target=\"_blank\" rel=\"noopener\">round</a></td>\n<td>数字 =&gt; 数字</td>\n<td>四舍五入取整，可以指定精度</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"11-语言\"><a href=\"#11-语言\" class=\"headerlink\" title=\"11. 语言\"></a>11. 语言</h2><h3 id=\"数值比较\"><a href=\"#数值比较\" class=\"headerlink\" title=\"数值比较\"></a>数值比较</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#eq\" target=\"_blank\" rel=\"noopener\">eq</a></td>\n<td>等价于<code>===</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isEqual\" target=\"_blank\" rel=\"noopener\">isEqual</a></td>\n<td>深度比较对象是否相等</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isEqualWith\" target=\"_blank\" rel=\"noopener\">isEqualWith</a></td>\n<td>深度比较对象是否相等，可以定义相等比较函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#gt\" target=\"_blank\" rel=\"noopener\">gt</a></td>\n<td>大于</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lt\" target=\"_blank\" rel=\"noopener\">lt</a></td>\n<td>小于</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#gte\" target=\"_blank\" rel=\"noopener\">gte</a></td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lte\" target=\"_blank\" rel=\"noopener\">lte</a></td>\n<td>小于等于</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArguments\" target=\"_blank\" rel=\"noopener\">isArguments</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArray\" target=\"_blank\" rel=\"noopener\">isArray</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArrayBuffer\" target=\"_blank\" rel=\"noopener\">isArrayBuffer</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArrayLike\" target=\"_blank\" rel=\"noopener\">isArrayLike</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArrayLikeObject\" target=\"_blank\" rel=\"noopener\">isArrayLikeObject</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isBoolean\" target=\"_blank\" rel=\"noopener\">isBoolean</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isBuffer\" target=\"_blank\" rel=\"noopener\">isBuffer</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isDate\" target=\"_blank\" rel=\"noopener\">isDate</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isElement\" target=\"_blank\" rel=\"noopener\">isElement</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isEmpty\" target=\"_blank\" rel=\"noopener\">isEmpty</a></td>\n<td>判断是否有可遍历的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isError\" target=\"_blank\" rel=\"noopener\">isError</a></td>\n<td>错误</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isFinite\" target=\"_blank\" rel=\"noopener\">isFinite</a></td>\n<td>是否是有限的数字，基于 Number.isFinite</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isFunction\" target=\"_blank\" rel=\"noopener\">isFunction</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isInteger\" target=\"_blank\" rel=\"noopener\">isInteger</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isLength\" target=\"_blank\" rel=\"noopener\">isLength</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isMap\" target=\"_blank\" rel=\"noopener\">isMap</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isMatch\" target=\"_blank\" rel=\"noopener\">isMatch</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isMatchWith\" target=\"_blank\" rel=\"noopener\">isMatchWith</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNaN\" target=\"_blank\" rel=\"noopener\">isNaN</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNative\" target=\"_blank\" rel=\"noopener\">isNative</a></td>\n<td>原生函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNil\" target=\"_blank\" rel=\"noopener\">isNil</a></td>\n<td>等价于 <code>_.isNull(val)</code> &#124;&#124; <code>_.isUndefined(val)</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNull\" target=\"_blank\" rel=\"noopener\">isNull</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNumber\" target=\"_blank\" rel=\"noopener\">isNumber</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isObject\" target=\"_blank\" rel=\"noopener\">isObject</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isObjectLike\" target=\"_blank\" rel=\"noopener\">isObjectLike</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isPlainObject\" target=\"_blank\" rel=\"noopener\">isPlainObject</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isRegExp\" target=\"_blank\" rel=\"noopener\">isRegExp</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isSafeInteger\" target=\"_blank\" rel=\"noopener\">isSafeInteger</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">isSet</a></td>\n<td>isSet</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isString\" target=\"_blank\" rel=\"noopener\">isString</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isSymbol\" target=\"_blank\" rel=\"noopener\">isSymbol</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isTypedArray\" target=\"_blank\" rel=\"noopener\">isTypedArray</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isUndefined\" target=\"_blank\" rel=\"noopener\">isUndefined</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isWeakMap\" target=\"_blank\" rel=\"noopener\">isWeakMap</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isWeakSet\" target=\"_blank\" rel=\"noopener\">isWeakSet</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#castArray\" target=\"_blank\" rel=\"noopener\">castArray</a></td>\n<td>强制转给数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toArray\" target=\"_blank\" rel=\"noopener\">toArray</a></td>\n<td>转成数组，对象调用 Object.values，字符串转成字符数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toFinite\" target=\"_blank\" rel=\"noopener\">toFinite</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toInteger\" target=\"_blank\" rel=\"noopener\">toInteger</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toLength\" target=\"_blank\" rel=\"noopener\">toLength</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toNumber\" target=\"_blank\" rel=\"noopener\">toNumber</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toPlainObject\" target=\"_blank\" rel=\"noopener\">toPlainObject</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toSafeInteger\" target=\"_blank\" rel=\"noopener\">toSafeInteger</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toString\" target=\"_blank\" rel=\"noopener\">toString</a></td>\n<td>转成字符串，</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"复制对象\"><a href=\"#复制对象\" class=\"headerlink\" title=\"复制对象\"></a>复制对象</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#clone\" target=\"_blank\" rel=\"noopener\">clone</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#cloneDeep\" target=\"_blank\" rel=\"noopener\">cloneDeep</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#cloneDeepWith\" target=\"_blank\" rel=\"noopener\">cloneDeepWith</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#cloneWith\" target=\"_blank\" rel=\"noopener\">cloneWith</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"检测对象\"><a href=\"#检测对象\" class=\"headerlink\" title=\"检测对象\"></a>检测对象</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#conformsTo\" target=\"_blank\" rel=\"noopener\">conformsTo</a></td>\n<td>判断一个对象的字段是否满足一些条件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"12-工具\"><a href=\"#12-工具\" class=\"headerlink\" title=\"12. 工具\"></a>12. 工具</h2><h3 id=\"总是返回某个参数的函数\"><a href=\"#总是返回某个参数的函数\" class=\"headerlink\" title=\"总是返回某个参数的函数\"></a>总是返回某个参数的函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#constant\" target=\"_blank\" rel=\"noopener\">constant</a></td>\n<td>创建一个包裹函数，总是返回第一个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#nthArg\" target=\"_blank\" rel=\"noopener\">nthArg</a></td>\n<td>创建一个包裹函数，总是返回第 n 个参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"总是返回某个特定值的函数\"><a href=\"#总是返回某个特定值的函数\" class=\"headerlink\" title=\"总是返回某个特定值的函数\"></a>总是返回某个特定值的函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#noop\" target=\"_blank\" rel=\"noopener\">noop</a></td>\n<td>总是返回<code>undefined</code>的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubArray\" target=\"_blank\" rel=\"noopener\">stubArray</a></td>\n<td>总是返回空数组的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubObject\" target=\"_blank\" rel=\"noopener\">stubObject</a></td>\n<td>总是返回空对象的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubString\" target=\"_blank\" rel=\"noopener\">stubString</a></td>\n<td>总是返回空字符串的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubTrue\" target=\"_blank\" rel=\"noopener\">stubTrue</a></td>\n<td>总是返回<code>true</code>的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubFalse\" target=\"_blank\" rel=\"noopener\">stubFalse</a></td>\n<td>总是返回<code>false</code>的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#identity\" target=\"_blank\" rel=\"noopener\">identity</a></td>\n<td>总是返回第一个参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"获取对象的属性值或者调用对象的函数\"><a href=\"#获取对象的属性值或者调用对象的函数\" class=\"headerlink\" title=\"获取对象的属性值或者调用对象的函数\"></a>获取对象的属性值或者调用对象的函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#method\" target=\"_blank\" rel=\"noopener\">method</a></td>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">_.invoke(object, path, [args])</a>预设<code>path</code>和<code>args</code>两个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#methodOf\" target=\"_blank\" rel=\"noopener\">methodOf</a></td>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">_.invoke(object, path, [args])</a>预设<code>object</code>和<code>args</code>两个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#property\" target=\"_blank\" rel=\"noopener\">property</a></td>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">_.get(object, path)</a>预设<code>path参数，不同的是缺少</code>defaultValue`参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#propertyOf\" target=\"_blank\" rel=\"noopener\">propertyOf</a></td>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">_.get(object, path)</a>预设<code>object</code>参数，不同的是缺少<code>defaultValue</code>参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"判断对象是否满足某些条件\"><a href=\"#判断对象是否满足某些条件\" class=\"headerlink\" title=\"判断对象是否满足某些条件\"></a>判断对象是否满足某些条件</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#conforms\" target=\"_blank\" rel=\"noopener\">conforms</a></td>\n<td>创建一个包裹函数，判断一个对象的字段是否满足某个函数。<code>conforms</code>意思是遵守。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#matches\" target=\"_blank\" rel=\"noopener\">matches</a></td>\n<td>创建一个包裹函数，判断一个对象的字段是否等于某个值，使用<a href=\"https://lodash.com/docs/#isEqual\" target=\"_blank\" rel=\"noopener\">isEqual</a>判断是否相等。跟<a href=\"https://lodash.com/docs/#isMatch\" target=\"_blank\" rel=\"noopener\">isMatch</a>类似</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#matchesProperty\" target=\"_blank\" rel=\"noopener\">matchesProperty</a></td>\n<td>创建一个包裹函数，判断一个对象特定字段是否等于某个值，使用<a href=\"https://lodash.com/docs/#isEqual\" target=\"_blank\" rel=\"noopener\">isEqual</a>判断是否相等。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"把多个操作合成一个操作\"><a href=\"#把多个操作合成一个操作\" class=\"headerlink\" title=\"把多个操作合成一个操作\"></a>把多个操作合成一个操作</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flow\" target=\"_blank\" rel=\"noopener\">flow</a></td>\n<td>把一组函数串起来形成一个新函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flowRight\" target=\"_blank\" rel=\"noopener\">flowRight</a></td>\n<td>同上，倒序</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"批量进行多个操作\"><a href=\"#批量进行多个操作\" class=\"headerlink\" title=\"批量进行多个操作\"></a>批量进行多个操作</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#over\" target=\"_blank\" rel=\"noopener\">over</a></td>\n<td>创建一个新函数，并将参数传递给预先指定的一组函数，并返回其结果</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#overEvery\" target=\"_blank\" rel=\"noopener\">overEvery</a></td>\n<td>跟<code>over</code>类似，判断是不是所有函数都返回真值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#overSome\" target=\"_blank\" rel=\"noopener\">overSome</a></td>\n<td>跟<code>over</code>类似，判断是不是至少一个函数返回真值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"等差数列\"><a href=\"#等差数列\" class=\"headerlink\" title=\"等差数列\"></a>等差数列</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#range\" target=\"_blank\" rel=\"noopener\">range</a></td>\n<td>生成等差数列，可以指定步长，步长可以是小数，也可以是负数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#rangeRight\" target=\"_blank\" rel=\"noopener\">rangeRight</a></td>\n<td>这个基本可以忽略，功能完成可以由<a href=\"https://lodash.com/docs/#range\" target=\"_blank\" rel=\"noopener\">range</a>代替。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"其他未分类\"><a href=\"#其他未分类\" class=\"headerlink\" title=\"其他未分类\"></a>其他未分类</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#attempt\" target=\"_blank\" rel=\"noopener\">attempt</a></td>\n<td>使用 try-catch 包裹函数，如果出错返回错误对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#bindAll\" target=\"_blank\" rel=\"noopener\">bindAll</a></td>\n<td>将一个对象的多个函数中的 this 固定为该对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#cond\" target=\"_blank\" rel=\"noopener\">cond</a></td>\n<td>创建一个拥有复杂 if-else 的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#defaultTo\" target=\"_blank\" rel=\"noopener\">defaultTo</a></td>\n<td>如果第一个参数为 NaN,null,undefined，则返回第二个参数，否则返回第一个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#iteratee\" target=\"_blank\" rel=\"noopener\">iteratee</a></td>\n<td>创建一个迭代函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#noConflict\" target=\"_blank\" rel=\"noopener\">noConflict</a></td>\n<td>如果<code>_</code>被占用，可以使用该方法</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#runInContext\" target=\"_blank\" rel=\"noopener\">runInContext</a></td>\n<td>创建一个<code>lodash</code>镜像对象，可以扩展修改该对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mixin\" target=\"_blank\" rel=\"noopener\">mixin</a></td>\n<td>给一个对象的原型添加属性或方法，一般配合<a href=\"https://lodash.com/docs/#runInContext\" target=\"_blank\" rel=\"noopener\">runInContext</a>扩展<code>lodash</code>。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#times\" target=\"_blank\" rel=\"noopener\">times</a></td>\n<td>执行函数 n 次，传入参数为 index</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toPath\" target=\"_blank\" rel=\"noopener\">toPath</a></td>\n<td>‘a[0].b.c’=&gt;[‘a’,’0’,’b’,’c’]</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#uniqueId\" target=\"_blank\" rel=\"noopener\">uniqueId</a></td>\n<td>生成唯一 ID，可以指定前缀</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"13-链式\"><a href=\"#13-链式\" class=\"headerlink\" title=\"13. 链式\"></a>13. 链式</h2><h3 id=\"链式调用的好处\"><a href=\"#链式调用的好处\" class=\"headerlink\" title=\"链式调用的好处\"></a>链式调用的好处</h3><p>省略了中间变量，让代码更加简洁，更加安全。<br>链式调用可以优化成惰性求值（延迟计算），让代码更加高效。</p>\n<h3 id=\"value\"><a href=\"#value\" class=\"headerlink\" title=\"_(value)\"></a>_(value)</h3><p>创建一个经过 lodash 包装过后的对象会启用隐式链，直到调用了不支持链接调用的函数或者主动调用<code>value</code>方法解除链式调用。<br>作用类似于<a href=\"https://lodash.com/docs/#chain\" target=\"_blank\" rel=\"noopener\">chain</a></p>\n<h3 id=\"lodash-包装对象上的特殊函数\"><a href=\"#lodash-包装对象上的特殊函数\" class=\"headerlink\" title=\"lodash 包装对象上的特殊函数\"></a>lodash 包装对象上的特殊函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-tap\" target=\"_blank\" rel=\"noopener\">tap</a></td>\n<td>可以在链式调用中插入普通方法，直接修改中间结果，也可以仅仅是用于调试打印中间结果</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-thru\" target=\"_blank\" rel=\"noopener\">thru</a></td>\n<td>同<a href=\"https://lodash.com/docs/#tap\" target=\"_blank\" rel=\"noopener\">tap</a>，但是使用函数的返回值作为中间结果</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-commit\" target=\"_blank\" rel=\"noopener\">commit</a></td>\n<td>立即执行链式调用中尚未进行的操作</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-next\" target=\"_blank\" rel=\"noopener\">next</a></td>\n<td>获得包装对象的下一个值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-plant\" target=\"_blank\" rel=\"noopener\">plant</a></td>\n<td>复制一个链式调用，并传入初始值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-value\" target=\"_blank\" rel=\"noopener\">value</a></td>\n<td>结束链式调用，并计算结果。别名<code>valueOf</code>，<code>toJSON</code></td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1 简介\"></a>1 简介</h2><p><a href=\"https://github.com/lodash/lodash\" target=\"_blank\" rel=\"noopener\">Lodash</a>是一款优秀的 JavaScript 工具库，里面包含了大量的工具函数。在 2015 年就成为<a href=\"https://www.npmjs.com/browse/depended\" target=\"_blank\" rel=\"noopener\">被依赖最多的 JavaScript 库</a>，写这篇文档是最新版是 4.17.4，适用于常见浏览器以及 Node.js 等。</p>\n<p>这里给出其<a href=\"https://lodash.com/docs\" target=\"_blank\" rel=\"noopener\">英文文档</a>和<a href=\"http://lodash.think2011.net/\" target=\"_blank\" rel=\"noopener\">中文文档</a>的链接。其中中文文档的版本较低，但是区别不大，可以参考帮助理解。</p>\n<h2 id=\"2-常见用法\"><a href=\"#2-常见用法\" class=\"headerlink\" title=\"2 常见用法\"></a>2 常见用法</h2><p>在这部分我们介绍一些 Lodash 的常见的优雅的用法。主要是引起大家的学习兴趣，有更多优雅用法等待大家去发现。</p>\n<h3 id=\"get获取一个嵌套很深的字段\"><a href=\"#get获取一个嵌套很深的字段\" class=\"headerlink\" title=\"_.get获取一个嵌套很深的字段\"></a><code>_.get</code>获取一个嵌套很深的字段</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//config 初始化为 null，需要从服务器端获取权限数据</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> config = <span class=\"literal\">null</span>;</span><br><span class=\"line\">ajax.get(url, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// data = &#123;basic: &#123;delete: true&#125;&#125;</span></span><br><span class=\"line\">    config = data;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用原生JS获取是否有删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isDeletable = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (config &amp;&amp; config.basic) &#123;</span><br><span class=\"line\">    isDeletable = config.basic.delete || <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用lodash获取是否有删除权限</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isDeletable = _.get(config, <span class=\"string\">'basic.delete'</span>, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n<p>对应地，可以通过<code>_.set({}, &#39;a.b.c&#39;, 1)</code>创建一个多级嵌套的对象。</p>\n<h3 id=\"map获取数组中每个对象的特定字段，并形成一个新的数组\"><a href=\"#map获取数组中每个对象的特定字段，并形成一个新的数组\" class=\"headerlink\" title=\"_.map获取数组中每个对象的特定字段，并形成一个新的数组\"></a><code>_.map</code>获取数组中每个对象的特定字段，并形成一个新的数组</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用所有用户的 idCard 字段创建出一个数组</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> users = [&#123; <span class=\"attr\">idCard</span>: <span class=\"string\">'20160512'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'张三'</span> &#125;, &#123; <span class=\"attr\">idCard</span>: <span class=\"string\">'20160513'</span>, <span class=\"attr\">name</span>: <span class=\"string\">'李四'</span> &#125;];</span><br><span class=\"line\"><span class=\"comment\">//使用原生JS</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> idCards = users.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.idCard;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> idCards = _.map(model, <span class=\"string\">'idCard'</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"pick取出对象的部分字段形成一个新对象\"><a href=\"#pick取出对象的部分字段形成一个新对象\" class=\"headerlink\" title=\"_.pick取出对象的部分字段形成一个新对象\"></a><code>_.pick</code>取出对象的部分字段形成一个新对象</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在修改密码表单里，用户输入了如下字段并被封装到一个对象中</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> form = &#123;</span><br><span class=\"line\">    password: <span class=\"string\">'123456'</span>, <span class=\"comment\">//密码</span></span><br><span class=\"line\">    repeatPassword: <span class=\"string\">'123456'</span>, <span class=\"comment\">//重复密码</span></span><br><span class=\"line\">    code: <span class=\"string\">'5489'</span>, <span class=\"comment\">//验证码</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里不直接使用delete删除字段，是因为该 form 对象与 DOM 进行了绑定。</span></span><br><span class=\"line\"><span class=\"comment\">//其中重复密码只用来在客户端校验，不需要发送给服务器</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> fields = [<span class=\"string\">'password'</span>, <span class=\"string\">'code'</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class=\"line\">    data[fields[i]] = form[fields[i]];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = _.pick(form, <span class=\"string\">'password'</span>, <span class=\"string\">'code'</span>);</span><br></pre></td></tr></table></figure>\n<p>对应地，还有<code>_.omit</code>方法表示删除部分字段形成一个新对象。</p>\n<h3 id=\"random获取一个随机值\"><a href=\"#random获取一个随机值\" class=\"headerlink\" title=\"_.random获取一个随机值\"></a><code>_.random</code>获取一个随机值</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取[90, 100)之内的一个随机值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> min = <span class=\"number\">90</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> max = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"comment\">//使用原生JS</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> random = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * (max - min)) + min;</span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> random = _.random(min, max);</span><br></pre></td></tr></table></figure>\n<p>类似地，<code>_.sample([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</code>可以从数组中随机取出一个项目。</p>\n<h3 id=\"clamp将一个数字修改成区间中的一个值\"><a href=\"#clamp将一个数字修改成区间中的一个值\" class=\"headerlink\" title=\"_.clamp将一个数字修改成区间中的一个值\"></a><code>_.clamp</code>将一个数字修改成区间中的一个值</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用原生JS</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyRange</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.max(number, <span class=\"keyword\">this</span>.props.min);</span><br><span class=\"line\">    number = <span class=\"built_in\">Math</span>.min(number, <span class=\"keyword\">this</span>.props.max);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> number = _.clamp(number, min, max);</span><br></pre></td></tr></table></figure>\n<h3 id=\"once确保一个函数只会执行一次\"><a href=\"#once确保一个函数只会执行一次\" class=\"headerlink\" title=\"_.once确保一个函数只会执行一次\"></a><code>_.once</code>确保一个函数只会执行一次</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//使用原生JS</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> inited = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inited) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">// init code</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//使用lodash</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> init = _.once(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// init code</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"chain链式操作\"><a href=\"#chain链式操作\" class=\"headerlink\" title=\"_.chain链式操作\"></a><code>_.chain</code>链式操作</h3><p>链接调用让代码更加整洁；避免了中间变量，避免了错误引用，让代码质量更有保证；<code>_.chain</code>还提供了延迟计算特性，在显式或隐式调用<code>value()</code>方法之前是不进行任何计算的，通过合并大大降低迭代次数。<br>下面是<code>lodash</code>的官方文档中的一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> users = [&#123; <span class=\"attr\">user</span>: <span class=\"string\">'barney'</span>, <span class=\"attr\">age</span>: <span class=\"number\">36</span> &#125;, &#123; <span class=\"attr\">user</span>: <span class=\"string\">'fred'</span>, <span class=\"attr\">age</span>: <span class=\"number\">40</span> &#125;, &#123; <span class=\"attr\">user</span>: <span class=\"string\">'pebbles'</span>, <span class=\"attr\">age</span>: <span class=\"number\">1</span> &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> youngest = _.chain(users)</span><br><span class=\"line\">    .sortBy(<span class=\"string\">'age'</span>)</span><br><span class=\"line\">    .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">chr</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> chr.user + <span class=\"string\">' is '</span> + chr.age;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .first()</span><br><span class=\"line\">    .value();</span><br><span class=\"line\"><span class=\"comment\">// → 'pebbles is 1'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-模块\"><a href=\"#3-模块\" class=\"headerlink\" title=\"3 模块\"></a>3 模块</h2><p>Lodash 的工具函数很多，可以分为以下几类：数组（Array），集合（Collection），函数（Function），Lang（Lang），数学（Math），数字（Number），对象（Object），字符串（String），未分类工具函数（Util）。下面将会按类别介绍常见工具函数。</p>\n<h2 id=\"4-数组\"><a href=\"#4-数组\" class=\"headerlink\" title=\"4 数组\"></a>4 数组</h2><h3 id=\"获取子数组\"><a href=\"#获取子数组\" class=\"headerlink\" title=\"获取子数组\"></a>获取子数组</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#slice\" target=\"_blank\" rel=\"noopener\">slice</a></td>\n<td>获取元素第 m-n(不包含)个元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#tail\" target=\"_blank\" rel=\"noopener\">tail</a></td>\n<td>获取出第一个元素之外的其他元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#initial\" target=\"_blank\" rel=\"noopener\">initial</a></td>\n<td>获取出最后一个元素之外的其他元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#take\" target=\"_blank\" rel=\"noopener\">take</a></td>\n<td>从左侧开始获取任意数量的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#takeRight\" target=\"_blank\" rel=\"noopener\">takeRight</a></td>\n<td>从右侧开始获取任意数量的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#takeWhile\" target=\"_blank\" rel=\"noopener\">takeWhile</a></td>\n<td>从左侧开始获取任意数量的元素，直到断言返回假值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#takeRightWhile\" target=\"_blank\" rel=\"noopener\">takeRightWhile</a></td>\n<td>从右侧开始获取任意数量的元素，直到断言返回假值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#drop\" target=\"_blank\" rel=\"noopener\">drop</a></td>\n<td>丢掉前面几个元素，得到剩余元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#dropWhile\" target=\"_blank\" rel=\"noopener\">dropWhile</a></td>\n<td>丢掉前面几个元素知道迭代器返回假值，得到剩余元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#dropRight\" target=\"_blank\" rel=\"noopener\">dropRight</a></td>\n<td>丢掉后面几个元素，得到剩余元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#dropRightWhile\" target=\"_blank\" rel=\"noopener\">dropRightWhile</a></td>\n<td>丢掉后面几个元素知道迭代器返回假值，得到剩余元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数组常见操作\"><a href=\"#数组常见操作\" class=\"headerlink\" title=\"数组常见操作\"></a>数组常见操作</h3><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>不修改原数组</th>\n<th>修改原数组</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>移除</td>\n<td><a href=\"https://lodash.com/docs/#without\" target=\"_blank\" rel=\"noopener\">without</a></td>\n<td><a href=\"https://lodash.com/docs/#pull\" target=\"_blank\" rel=\"noopener\">pull</a></td>\n</tr>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAll\" target=\"_blank\" rel=\"noopener\">pullAll</a></td>\n</tr>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#differenceBy\" target=\"_blank\" rel=\"noopener\">differenceBy</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAllBy\" target=\"_blank\" rel=\"noopener\">pullAllBy</a></td>\n</tr>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#differenceWith\" target=\"_blank\" rel=\"noopener\">differenceWith</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAllWith\" target=\"_blank\" rel=\"noopener\">pullAllWith</a></td>\n</tr>\n<tr>\n<td>反转</td>\n<td></td>\n<td><a href=\"https://lodash.com/docs/#reverse\" target=\"_blank\" rel=\"noopener\">reverse</a></td>\n</tr>\n<tr>\n<td>裁剪</td>\n<td><a href=\"https://lodash.com/docs/#at\" target=\"_blank\" rel=\"noopener\">at</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAt\" target=\"_blank\" rel=\"noopener\">pullAt</a></td>\n</tr>\n<tr>\n<td>过滤</td>\n<td><a href=\"https://lodash.com/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a></td>\n<td><a href=\"https://lodash.com/docs/#remove\" target=\"_blank\" rel=\"noopener\">remove</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数组常见操作变种函数-by-with\"><a href=\"#数组常见操作变种函数-by-with\" class=\"headerlink\" title=\"数组常见操作变种函数 by, with\"></a>数组常见操作变种函数 by, with</h3><p>有些函数还可以稍微变化一下，接受不同的参数，提供更多灵活性。</p>\n<table>\n<thead>\n<tr>\n<th>作用</th>\n<th>函数名</th>\n<th>by</th>\n<th>with</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a></td>\n<td><a href=\"https://lodash.com/docs/#differenceBy\" target=\"_blank\" rel=\"noopener\">differenceBy</a></td>\n<td><a href=\"https://lodash.com/docs/#differenceWith\" target=\"_blank\" rel=\"noopener\">differenceWith</a></td>\n</tr>\n<tr>\n<td>交集</td>\n<td><a href=\"https://lodash.com/docs/#intersection\" target=\"_blank\" rel=\"noopener\">intersection</a></td>\n<td><a href=\"https://lodash.com/docs/#intersectionBy\" target=\"_blank\" rel=\"noopener\">intersectionBy</a></td>\n<td><a href=\"https://lodash.com/docs/#intersectionWith\" target=\"_blank\" rel=\"noopener\">intersectionWith</a></td>\n</tr>\n<tr>\n<td>并集</td>\n<td><a href=\"https://lodash.com/docs/#union\" target=\"_blank\" rel=\"noopener\">union</a></td>\n<td><a href=\"https://lodash.com/docs/#unionBy\" target=\"_blank\" rel=\"noopener\">unionBy</a></td>\n<td><a href=\"https://lodash.com/docs/#unionWith\" target=\"_blank\" rel=\"noopener\">unionWith</a></td>\n</tr>\n<tr>\n<td>异或</td>\n<td><a href=\"https://lodash.com/docs/#xor\" target=\"_blank\" rel=\"noopener\">xor</a></td>\n<td><a href=\"https://lodash.com/docs/#xorBy\" target=\"_blank\" rel=\"noopener\">xorBy</a></td>\n<td><a href=\"https://lodash.com/docs/#xorWith\" target=\"_blank\" rel=\"noopener\">xorWith</a></td>\n</tr>\n<tr>\n<td>相减</td>\n<td><a href=\"https://lodash.com/docs/#pullAll\" target=\"_blank\" rel=\"noopener\">pullAll</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAllBy\" target=\"_blank\" rel=\"noopener\">pullAllBy</a></td>\n<td><a href=\"https://lodash.com/docs/#pullAllWith\" target=\"_blank\" rel=\"noopener\">pullAllWith</a>，跟<a href=\"https://lodash.com/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a>不同的是，<a href=\"https://lodash.com/docs/#pullAll\" target=\"_blank\" rel=\"noopener\">pullAll</a>修改原数组</td>\n</tr>\n<tr>\n<td>去重</td>\n<td><a href=\"https://lodash.com/docs/#uniq\" target=\"_blank\" rel=\"noopener\">uniq</a></td>\n<td><a href=\"https://lodash.com/docs/#uniqBy\" target=\"_blank\" rel=\"noopener\">uniqBy</a></td>\n<td><a href=\"https://lodash.com/docs/#uniqWith\" target=\"_blank\" rel=\"noopener\">uniqWith</a></td>\n</tr>\n<tr>\n<td>去重</td>\n<td><a href=\"https://lodash.com/docs/#sortedUniq\" target=\"_blank\" rel=\"noopener\">sortedUniq</a></td>\n<td><a href=\"https://lodash.com/docs/#sortedUniqBy\" target=\"_blank\" rel=\"noopener\">sortedUniqBy</a></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"获取数组某个位置上的元素\"><a href=\"#获取数组某个位置上的元素\" class=\"headerlink\" title=\"获取数组某个位置上的元素\"></a>获取数组某个位置上的元素</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#head\" target=\"_blank\" rel=\"noopener\">head</a></td>\n<td>数组=&gt;元素</td>\n<td>返回数组的第一个元素，和<a href=\"https://lodash.com/docs/#first\" target=\"_blank\" rel=\"noopener\">first</a>相同</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#last\" target=\"_blank\" rel=\"noopener\">last</a></td>\n<td>数组=&gt;元素</td>\n<td>返回数组的最后一个元素，和<a href=\"https://lodash.com/docs/#head\" target=\"_blank\" rel=\"noopener\">head</a>相反</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#nth\" target=\"_blank\" rel=\"noopener\">nth</a></td>\n<td>数组=&gt;元素</td>\n<td>返回数组中某个位置上的元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"检测元素在数组中的索引\"><a href=\"#检测元素在数组中的索引\" class=\"headerlink\" title=\"检测元素在数组中的索引\"></a>检测元素在数组中的索引</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#indexOf\" target=\"_blank\" rel=\"noopener\">indexOf</a></td>\n<td>获取元素在数组中的索引</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedIndexOf\" target=\"_blank\" rel=\"noopener\">sortedIndexOf</a></td>\n<td>和<a href=\"https://lodash.com/docs/#indexOf\" target=\"_blank\" rel=\"noopener\">indexOf</a>功能一致，只是通过二分搜索方法</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lastIndexOf\" target=\"_blank\" rel=\"noopener\">lastIndexOf</a></td>\n<td>获取元素在数组中的索引，最后一次出现</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedLastIndexOf\" target=\"_blank\" rel=\"noopener\">sortedLastIndexOf</a></td>\n<td>和<a href=\"https://lodash.com/docs/#lastIndexOf\" target=\"_blank\" rel=\"noopener\">lastIndexOf</a>功能一致，只是通过二分搜索方法</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findIndex\" target=\"_blank\" rel=\"noopener\">findIndex</a></td>\n<td>寻找元素位置</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findLastIndex\" target=\"_blank\" rel=\"noopener\">findLastIndex</a></td>\n<td>寻找元素位置，从后往前</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"检测元素在插在有序数组的什么位置\"><a href=\"#检测元素在插在有序数组的什么位置\" class=\"headerlink\" title=\"检测元素在插在有序数组的什么位置\"></a>检测元素在插在有序数组的什么位置</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedIndex\" target=\"_blank\" rel=\"noopener\">sortedIndex</a></td>\n<td>通过二分搜索判断元素应该插在数组的哪个位置</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedIndexBy\" target=\"_blank\" rel=\"noopener\">sortedIndexBy</a></td>\n<td>同上，可以额外提供一个迭代器函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedLastIndex\" target=\"_blank\" rel=\"noopener\">sortedLastIndex</a></td>\n<td>和<a href=\"https://lodash.com/docs/#sortedIndex\" target=\"_blank\" rel=\"noopener\">sortedIndex</a>类似，但是从右边开始</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sortedLastIndexBy\" target=\"_blank\" rel=\"noopener\">sortedLastIndexBy</a></td>\n<td>同上，可以额外提供一个迭代器函数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"将数组拍平\"><a href=\"#将数组拍平\" class=\"headerlink\" title=\"将数组拍平\"></a>将数组拍平</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">flatten</a></td>\n<td>高维数组=&gt;低维数组</td>\n<td>将数组拍平</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flattenDeep\" target=\"_blank\" rel=\"noopener\">flattenDeep</a></td>\n<td>高维数组=&gt;数组</td>\n<td>将数组拍平</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flattenDepth\" target=\"_blank\" rel=\"noopener\">flattenDepth</a></td>\n<td>高维数组=&gt;低维数组</td>\n<td>将数组拍平</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Zip\"><a href=\"#Zip\" class=\"headerlink\" title=\"Zip\"></a>Zip</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#zip\" target=\"_blank\" rel=\"noopener\">zip</a></td>\n<td>多个数组=&gt;二维数组</td>\n<td>可以理解为二维数组的行列互换</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#zipWith\" target=\"_blank\" rel=\"noopener\">zipWith</a></td>\n<td>多个数组=&gt;数组</td>\n<td>同上，但是可以自由处理行列互换后的数组中的每个数组元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#zipObject\" target=\"_blank\" rel=\"noopener\">zipObject</a></td>\n<td>两个数组=&gt;对象</td>\n<td>把 keys 和 values 数组组成一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#zipObjectDeep\" target=\"_blank\" rel=\"noopener\">zipObjectDeep</a></td>\n<td>两个数组=&gt;对象</td>\n<td>同上，递归地处理属性名</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"未分类函数\"><a href=\"#未分类函数\" class=\"headerlink\" title=\"未分类函数\"></a>未分类函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#chunk\" target=\"_blank\" rel=\"noopener\">chunk</a></td>\n<td>数组=&gt;二维数组</td>\n<td>分段形成二维数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#compact\" target=\"_blank\" rel=\"noopener\">compact</a></td>\n<td>数组=&gt;数组</td>\n<td>移除假值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#concat\" target=\"_blank\" rel=\"noopener\">concat</a></td>\n<td>多个数组=&gt;数组</td>\n<td>连接多个数组形成一个数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#fill\" target=\"_blank\" rel=\"noopener\">fill</a></td>\n<td>数组=&gt;数组</td>\n<td>填充数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#fromPairs\" target=\"_blank\" rel=\"noopener\">fromPairs</a></td>\n<td>二维数组=&gt;对象</td>\n<td>将键值数组变成对象。和<a href=\"https://lodash.com/docs/#toPairs\" target=\"_blank\" rel=\"noopener\">toPairs</a>相反</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#join\" target=\"_blank\" rel=\"noopener\">join</a></td>\n<td>数组=&gt;字符串</td>\n<td>拼接数组元素成一个字符串</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"5-集合\"><a href=\"#5-集合\" class=\"headerlink\" title=\"5 集合\"></a>5 集合</h2><p>为什么区分集合函数和数组函数？<br>集合函数不单单适用于数组，还适用于字符串，对象，类数组对象（比如 Arguments，NodeList 等）。字符串是字符的集合，对象是属性值的集合。类数组对象是通过“<a href=\"https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"noopener\">鸭子类型</a>”工作的，所以如果你传入一个拥有<code>length</code>字段并且值为数字的对象，这个对象会被当做一个数组处理。具体请参考<a href=\"http://underscorejs.org/#collections\" target=\"_blank\" rel=\"noopener\">Underscore.js</a>文档。</p>\n<p>范例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printKeyVal</span>(<span class=\"params\">val, key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(key, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//普通对象</span></span><br><span class=\"line\">_.each(&#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;, printKeyVal);</span><br><span class=\"line\"><span class=\"comment\">//打印结果</span></span><br><span class=\"line\"><span class=\"comment\">// a 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//拥有值为数字的length字段</span></span><br><span class=\"line\">_.each(&#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">length</span>: <span class=\"number\">2</span> &#125;, printKeyVal);</span><br><span class=\"line\"><span class=\"comment\">//打印结果</span></span><br><span class=\"line\"><span class=\"comment\">// 0 undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 1 undefined</span></span><br></pre></td></tr></table></figure>\n<p>下面将分类介绍集合相关函数。</p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#each\" target=\"_blank\" rel=\"noopener\">each</a></td>\n<td>同<a href=\"https://lodash.com/docs/#forEach\" target=\"_blank\" rel=\"noopener\">forEach</a></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#eachRight\" target=\"_blank\" rel=\"noopener\">eachRight</a></td>\n<td>同<a href=\"https://lodash.com/docs/#forEachRight\" target=\"_blank\" rel=\"noopener\">forEachRight</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">sortBy</a></td>\n<td>排序</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#orderBy\" target=\"_blank\" rel=\"noopener\">orderBy</a></td>\n<td>同<a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">sortBy</a>，还可以指定正序倒序</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#shuffle\" target=\"_blank\" rel=\"noopener\">shuffle</a></td>\n<td>返回一个打乱顺序的新数组</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"过滤\"><a href=\"#过滤\" class=\"headerlink\" title=\"过滤\"></a>过滤</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a></td>\n<td>创建一个新数组，包含了所有让断言为真的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#reject\" target=\"_blank\" rel=\"noopener\">reject</a></td>\n<td>创建一个新数组，包含了所有让断言为假的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#partition\" target=\"_blank\" rel=\"noopener\">partition</a></td>\n<td>根据断言真假将一个集合分成两个集合</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Map-之后再-flatten\"><a href=\"#Map-之后再-flatten\" class=\"headerlink\" title=\"Map 之后再 flatten\"></a>Map 之后再 flatten</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flatMap\" target=\"_blank\" rel=\"noopener\">flatMap</a></td>\n<td><a href=\"https://lodash.com/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a>之后再<a href=\"https://lodash.com/docs/#flatten\" target=\"_blank\" rel=\"noopener\">flatten</a></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flatMapDeep\" target=\"_blank\" rel=\"noopener\">flatMapDeep</a></td>\n<td><a href=\"https://lodash.com/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a>之后再<a href=\"https://lodash.com/docs/#flattenDeep\" target=\"_blank\" rel=\"noopener\">flattenDeep</a></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flatMapDepth\" target=\"_blank\" rel=\"noopener\">flatMapDepth</a></td>\n<td><a href=\"https://lodash.com/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a>之后再<a href=\"https://lodash.com/docs/#flattenDepth\" target=\"_blank\" rel=\"noopener\">flattenDepth</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"寻找元素\"><a href=\"#寻找元素\" class=\"headerlink\" title=\"寻找元素\"></a>寻找元素</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#find\" target=\"_blank\" rel=\"noopener\">find</a></td>\n<td>找到第一个让断言为真的元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findLast\" target=\"_blank\" rel=\"noopener\">findLast</a></td>\n<td>同上，逆序</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"随机取值\"><a href=\"#随机取值\" class=\"headerlink\" title=\"随机取值\"></a>随机取值</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sample\" target=\"_blank\" rel=\"noopener\">sample</a></td>\n<td>从集合中随机选出一个元素</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sampleSize\" target=\"_blank\" rel=\"noopener\">sampleSize</a></td>\n<td>从集合中随机选出 n 个元素</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#reduce\" target=\"_blank\" rel=\"noopener\">reduce</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#reduceRight\" target=\"_blank\" rel=\"noopener\">reduceRight</a></td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"分组计数\"><a href=\"#分组计数\" class=\"headerlink\" title=\"分组计数\"></a>分组计数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#countBy\" target=\"_blank\" rel=\"noopener\">countBy</a></td>\n<td>返回一个对象，属性名是迭代器的返回值，属性值该返回值出现的次数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#groupBy\" target=\"_blank\" rel=\"noopener\">groupBy</a></td>\n<td>返回一个对象，属性名是迭代器的返回值，属性值是一个包含了相应元素的数组</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"未分类\"><a href=\"#未分类\" class=\"headerlink\" title=\"未分类\"></a>未分类</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#keyBy\" target=\"_blank\" rel=\"noopener\">keyBy</a></td>\n<td>返回一个对象，属性名是迭代器的返回值，属性值是元素本身</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">some</a></td>\n<td>对于集合中的每个元素，是否至少其一返回真值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#every\" target=\"_blank\" rel=\"noopener\">every</a></td>\n<td>对于集合中的每个元素，是否都返回真值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#includes\" target=\"_blank\" rel=\"noopener\">includes</a></td>\n<td>判断元素是不是在数组中，判断某个值是不是某个对象的属性值，判断一个字符串是不是包含在另一个字符串中</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a></td>\n<td>对集合的数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#invokeMap\" target=\"_blank\" rel=\"noopener\">invokeMap</a></td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"6-对象\"><a href=\"#6-对象\" class=\"headerlink\" title=\"6 对象\"></a>6 对象</h2><h3 id=\"仅需要部分字段\"><a href=\"#仅需要部分字段\" class=\"headerlink\" title=\"仅需要部分字段\"></a>仅需要部分字段</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#omit\" target=\"_blank\" rel=\"noopener\">omit</a></td>\n<td>通过忽略某些字段创建一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#omitBy\" target=\"_blank\" rel=\"noopener\">omitBy</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#pick\" target=\"_blank\" rel=\"noopener\">pick</a></td>\n<td>通过指定某些字段创建一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#pickBy\" target=\"_blank\" rel=\"noopener\">pickBy</a></td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"合并对象\"><a href=\"#合并对象\" class=\"headerlink\" title=\"合并对象\"></a>合并对象</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#assign\" target=\"_blank\" rel=\"noopener\">assign</a></td>\n<td>合并对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#assignWith\" target=\"_blank\" rel=\"noopener\">assignWith</a></td>\n<td>有条件地合并对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#extend\" target=\"_blank\" rel=\"noopener\">extend</a></td>\n<td>合并对象，包括原型链上的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#extendWith\" target=\"_blank\" rel=\"noopener\">extendWith</a></td>\n<td>有条件地合并对象，包括原型链上的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#assignIn\" target=\"_blank\" rel=\"noopener\">assignIn</a></td>\n<td>别名<code>extend</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#assignInWith\" target=\"_blank\" rel=\"noopener\">assignInWith</a></td>\n<td>别名<code>extendWith</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#defaults\" target=\"_blank\" rel=\"noopener\">defaults</a></td>\n<td>合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#defaultsDeep\" target=\"_blank\" rel=\"noopener\">defaultsDeep</a></td>\n<td>递归地合并对象，将后面参数的属性付给第一个参数，如果第一个参数没有相应属性的话</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#merge\" target=\"_blank\" rel=\"noopener\">merge</a></td>\n<td>递归地合并对象，将后面参数的属性付给第一个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mergeWith\" target=\"_blank\" rel=\"noopener\">mergeWith</a></td>\n<td>同<a href=\"https://lodash.com/docs/#merge\" target=\"_blank\" rel=\"noopener\">merge</a>，额外接受一个 customizer 参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"键值列表\"><a href=\"#键值列表\" class=\"headerlink\" title=\"键值列表\"></a>键值列表</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#keys\" target=\"_blank\" rel=\"noopener\">keys</a></td>\n<td>创建一个数组，包含对象中所有的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#keysIn\" target=\"_blank\" rel=\"noopener\">keysIn</a></td>\n<td>创建一个数组，包含对象中所有的属性（包含原型链上的）</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#functions\" target=\"_blank\" rel=\"noopener\">functions</a></td>\n<td>创建一个数组，包含对象中所有值为函数的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#functionsIn\" target=\"_blank\" rel=\"noopener\">functionsIn</a></td>\n<td>创建一个数组，包含对象中所有值为函数的属性（包含原型链上的）</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#values\" target=\"_blank\" rel=\"noopener\">values</a></td>\n<td>创建一个数组，包含对象中所有的属性值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#valuesIn\" target=\"_blank\" rel=\"noopener\">valuesIn</a></td>\n<td>创建一个数组，包含对象中所有的属性值（包含原型链上的）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"赋值取值\"><a href=\"#赋值取值\" class=\"headerlink\" title=\"赋值取值\"></a>赋值取值</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#at\" target=\"_blank\" rel=\"noopener\">at</a></td>\n<td>获取对象的一组属性路径的值，肯定不会报错</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#get\" target=\"_blank\" rel=\"noopener\">get</a></td>\n<td>获取对象的某个属性路径的值，肯定不会报错</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#result\" target=\"_blank\" rel=\"noopener\">result</a></td>\n<td>同<a href=\"https://lodash.com/docs/#get\" target=\"_blank\" rel=\"noopener\">get</a>，但是如果属性值是函数的话，自动执行该函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#set\" target=\"_blank\" rel=\"noopener\">set</a></td>\n<td>设置对象的某个属性路径的值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#setWith\" target=\"_blank\" rel=\"noopener\">setWith</a></td>\n<td>设置对象的某个属性路径的值，遇到不存在的中间对象，使用数组呢？还是使用对象呢？等等</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#update\" target=\"_blank\" rel=\"noopener\">update</a></td>\n<td>同<a href=\"https://lodash.com/docs/#set\" target=\"_blank\" rel=\"noopener\">set</a>，只是接受一个函数作为参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#updateWith\" target=\"_blank\" rel=\"noopener\">updateWith</a></td>\n<td>同<a href=\"https://lodash.com/docs/#setWith\" target=\"_blank\" rel=\"noopener\">setWith</a>，只是接受一个函数作为参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#unset\" target=\"_blank\" rel=\"noopener\">unset</a></td>\n<td>删除对象的某个属性路径</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">invoke</a></td>\n<td>调用对象中某个属性路径上的函数，肯定不会报错</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"键值数组\"><a href=\"#键值数组\" class=\"headerlink\" title=\"键值数组\"></a>键值数组</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#entries\" target=\"_blank\" rel=\"noopener\">entries</a></td>\n<td>{‘a’:1}=&gt;[[‘a’,1]]。别名<code>toPairs</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#entriesIn\" target=\"_blank\" rel=\"noopener\">entriesIn</a></td>\n<td>同上，但是包含原型链上的属性。别名<code>toPairsIn</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"键值变换\"><a href=\"#键值变换\" class=\"headerlink\" title=\"键值变换\"></a>键值变换</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mapKeys\" target=\"_blank\" rel=\"noopener\">mapKeys</a></td>\n<td>对对象中所有属性名做某种处理之后形成一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mapValues\" target=\"_blank\" rel=\"noopener\">mapValues</a></td>\n<td>对对象中所有属性值做某种处理之后形成一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#invert\" target=\"_blank\" rel=\"noopener\">invert</a></td>\n<td>将对象中的属性名和属性值互换转成一个新对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#invertBy\" target=\"_blank\" rel=\"noopener\">invertBy</a></td>\n<td>同<a href=\"https://lodash.com/docs/#invert\" target=\"_blank\" rel=\"noopener\">invert</a>，但是转换以后的属性值是原属性值组成的数组</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"键值遍历\"><a href=\"#键值遍历\" class=\"headerlink\" title=\"键值遍历\"></a>键值遍历</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#forIn\" target=\"_blank\" rel=\"noopener\">forIn</a></td>\n<td>遍历对象上的所有属性，包含原型链上的。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#forInRight\" target=\"_blank\" rel=\"noopener\">forInRight</a></td>\n<td>遍历对象上的所有属性，包含原型链上的。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#forOwn\" target=\"_blank\" rel=\"noopener\">forOwn</a></td>\n<td>遍历对象上的所有属性，不包含原型链上的。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#forOwnRight\" target=\"_blank\" rel=\"noopener\">forOwnRight</a></td>\n<td>遍历对象上的所有属性，不包含原型链上的。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"寻找属性\"><a href=\"#寻找属性\" class=\"headerlink\" title=\"寻找属性\"></a>寻找属性</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findKey\" target=\"_blank\" rel=\"noopener\">findKey</a></td>\n<td>同<a href=\"https://lodash.com/docs/#find\" target=\"_blank\" rel=\"noopener\">find</a>类似，但是匹配的是对象的属性值，返回的是对象的属性名</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#findLastKey\" target=\"_blank\" rel=\"noopener\">findLastKey</a></td>\n<td>同<a href=\"https://lodash.com/docs/#findKey\" target=\"_blank\" rel=\"noopener\">findKey</a>类似，但是匹配的是对象的属性值，返回的是对象的属性名</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"判断属性是否存在\"><a href=\"#判断属性是否存在\" class=\"headerlink\" title=\"判断属性是否存在\"></a>判断属性是否存在</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#has\" target=\"_blank\" rel=\"noopener\">has</a></td>\n<td>判断对象上是否拥有某个属性，不包含原型链上的</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#hasIn\" target=\"_blank\" rel=\"noopener\">hasIn</a></td>\n<td>判断对象上是否拥有某个属性，包含原型链上的</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"转换对象或数组\"><a href=\"#转换对象或数组\" class=\"headerlink\" title=\"转换对象或数组\"></a>转换对象或数组</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#transform\" target=\"_blank\" rel=\"noopener\">transform</a></td>\n<td>同<a href=\"https://lodash.com/docs/#reduce\" target=\"_blank\" rel=\"noopener\">reduce</a>，但是其迭代器函数返回的是布尔值，如果返回 false，则停止迭代</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"创建新对象\"><a href=\"#创建新对象\" class=\"headerlink\" title=\"创建新对象\"></a>创建新对象</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#create\" target=\"_blank\" rel=\"noopener\">create</a></td>\n<td>创建一个对象，并指定其原型和属性</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"7-函数\"><a href=\"#7-函数\" class=\"headerlink\" title=\"7. 函数\"></a>7. 函数</h2><h3 id=\"修改参数\"><a href=\"#修改参数\" class=\"headerlink\" title=\"修改参数\"></a>修改参数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#ary\" target=\"_blank\" rel=\"noopener\">ary</a></td>\n<td>创建一个包裹函数，只将前 n 个参数传递给原函数。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#unary\" target=\"_blank\" rel=\"noopener\">unary</a></td>\n<td>创建一个包裹函数，只将第一个参数传递给原函数。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flip\" target=\"_blank\" rel=\"noopener\">flip</a></td>\n<td>创建一个包裹函数，将参数逆序之后传递给原函数。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#rearg\" target=\"_blank\" rel=\"noopener\">rearg</a></td>\n<td>创建一个包裹函数，调整参数顺序之后在传递给原函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#rest\" target=\"_blank\" rel=\"noopener\">rest</a></td>\n<td>创建一个包裹函数，将参数合成数组之后传递给原函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#spread\" target=\"_blank\" rel=\"noopener\">spread</a></td>\n<td>创建一个包裹函数，将数组参数展开之后传给原函数，跟<a href=\"https://lodash.com/docs/#rest\" target=\"_blank\" rel=\"noopener\">rest</a>相反</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#overArgs\" target=\"_blank\" rel=\"noopener\">overArgs</a></td>\n<td>创建一个包裹函数，将参数做处理之后再传递给原函数。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"修改结果\"><a href=\"#修改结果\" class=\"headerlink\" title=\"修改结果\"></a>修改结果</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#negate\" target=\"_blank\" rel=\"noopener\">negate</a></td>\n<td>创建一个包裹函数，返回原函数结果的非。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"缓存结果\"><a href=\"#缓存结果\" class=\"headerlink\" title=\"缓存结果\"></a>缓存结果</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#memoize\" target=\"_blank\" rel=\"noopener\">memoize</a></td>\n<td>创建一个包裹函数，会缓存计算结果</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"降频调用\"><a href=\"#降频调用\" class=\"headerlink\" title=\"降频调用\"></a>降频调用</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#debounce\" target=\"_blank\" rel=\"noopener\">debounce</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#throttle\" target=\"_blank\" rel=\"noopener\">throttle</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"延迟调用\"><a href=\"#延迟调用\" class=\"headerlink\" title=\"延迟调用\"></a>延迟调用</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#defer\" target=\"_blank\" rel=\"noopener\">defer</a></td>\n<td>类似<code>setTimeout(fn,0)</code>，可以指定参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#delay\" target=\"_blank\" rel=\"noopener\">delay</a></td>\n<td>类似<code>setTimeout(fn,x)</code>，可以指定参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"延迟调用-1\"><a href=\"#延迟调用-1\" class=\"headerlink\" title=\"延迟调用\"></a>延迟调用</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#once\" target=\"_blank\" rel=\"noopener\">once</a></td>\n<td>创建一个包裹函数，确保原函数只被执行一次。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#before\" target=\"_blank\" rel=\"noopener\">before</a></td>\n<td>创建一个包裹函数，确保原函数只被执行 n 次。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#after\" target=\"_blank\" rel=\"noopener\">after</a></td>\n<td>创建一个包裹函数，调用包裹函数时只有 n 次之后才会调用目标函数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"固定参数\"><a href=\"#固定参数\" class=\"headerlink\" title=\"固定参数\"></a>固定参数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#wrap\" target=\"_blank\" rel=\"noopener\">wrap</a></td>\n<td>创建一个包裹函数，固定原函数的第一个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#partial\" target=\"_blank\" rel=\"noopener\">partial</a></td>\n<td>创建一个包裹函数，固定原函数若干个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#partialRight\" target=\"_blank\" rel=\"noopener\">partialRight</a></td>\n<td>创建一个包裹函数，固定原函数若干个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#bind\" target=\"_blank\" rel=\"noopener\">bind</a></td>\n<td>创建一个包裹函数，固定原函数若干个参数，并指定 this 对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#bindKey\" target=\"_blank\" rel=\"noopener\">bindKey</a></td>\n<td>和<a href=\"https://lodash.com/docs/#bind\" target=\"_blank\" rel=\"noopener\">bind</a>功能类似，但是能够处理尚未创建或被重写的函数，有点事件代理的感觉。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#curry\" target=\"_blank\" rel=\"noopener\">curry</a></td>\n<td>创建一个包裹函数，可以传入任意数量的参数，如果参数不完整，则返回一个接受余下参数的新函数，否则，调用原函数获得计算结果。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#curryRight\" target=\"_blank\" rel=\"noopener\">curryRight</a></td>\n<td>同上，逆序</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"8-字符串\"><a href=\"#8-字符串\" class=\"headerlink\" title=\"8. 字符串\"></a>8. 字符串</h2><h3 id=\"书写格式\"><a href=\"#书写格式\" class=\"headerlink\" title=\"书写格式\"></a>书写格式</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#startCase\" target=\"_blank\" rel=\"noopener\">startCase</a></td>\n<td>每个单词首字母大写，多用于标题</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#camelCase\" target=\"_blank\" rel=\"noopener\">camelCase</a></td>\n<td>小驼峰</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#kebabCase\" target=\"_blank\" rel=\"noopener\">kebabCase</a></td>\n<td>小写连字符</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#snakeCase\" target=\"_blank\" rel=\"noopener\">snakeCase</a></td>\n<td>小写下划线</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#upperCase\" target=\"_blank\" rel=\"noopener\">upperCase</a></td>\n<td>大写加空格</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lowerCase\" target=\"_blank\" rel=\"noopener\">lowerCase</a></td>\n<td>小写加空格</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"大写小写\"><a href=\"#大写小写\" class=\"headerlink\" title=\"大写小写\"></a>大写小写</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#capitalize\" target=\"_blank\" rel=\"noopener\">capitalize</a></td>\n<td>首字母大写，其余小写</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#upperFirst\" target=\"_blank\" rel=\"noopener\">upperFirst</a></td>\n<td>首字母大写，其余不变</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lowerFirst\" target=\"_blank\" rel=\"noopener\">lowerFirst</a></td>\n<td>首字母小写，其余不变</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lowerFirst\" target=\"_blank\" rel=\"noopener\">toUpper</a></td>\n<td>大写</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toLower\" target=\"_blank\" rel=\"noopener\">toLower</a></td>\n<td>小写</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"打头结尾\"><a href=\"#打头结尾\" class=\"headerlink\" title=\"打头结尾\"></a>打头结尾</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#endsWith\" target=\"_blank\" rel=\"noopener\">endsWith</a></td>\n<td>是不是以特定字符串结尾</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#startsWith\" target=\"_blank\" rel=\"noopener\">startsWith</a></td>\n<td>是不是以特定字符串打头</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"转义\"><a href=\"#转义\" class=\"headerlink\" title=\"转义\"></a>转义</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#escape\" target=\"_blank\" rel=\"noopener\">escape</a></td>\n<td>转义 &amp;&lt;&gt;”‘，与<a href=\"https://lodash.com/docs/#unescape\" target=\"_blank\" rel=\"noopener\">unescape</a>相反</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#escapeRegExp\" target=\"_blank\" rel=\"noopener\">escapeRegExp</a></td>\n<td>转义正则表达式中的特殊字符：^\\$.*+?()[]{}\\</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"补全抹掉\"><a href=\"#补全抹掉\" class=\"headerlink\" title=\"补全抹掉\"></a>补全抹掉</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#pad\" target=\"_blank\" rel=\"noopener\">pad</a></td>\n<td>使用某个字符串将特定字符串扩充至指定长度，类似地还有<a href=\"https://lodash.com/docs/#padStart\" target=\"_blank\" rel=\"noopener\">padStart</a>，<a href=\"https://lodash.com/docs/#padEnd\" target=\"_blank\" rel=\"noopener\">padEnd</a></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#trim\" target=\"_blank\" rel=\"noopener\">trim</a></td>\n<td>去除字符串两边的特殊字符（默认为空格），类似地还有<a href=\"https://lodash.com/docs/#trimStart\" target=\"_blank\" rel=\"noopener\">trimStart</a>，<a href=\"https://lodash.com/docs/#trimEnd\" target=\"_blank\" rel=\"noopener\">trimEnd</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"未分类-1\"><a href=\"#未分类-1\" class=\"headerlink\" title=\"未分类\"></a>未分类</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#parseInt\" target=\"_blank\" rel=\"noopener\">parseInt</a></td>\n<td>转成整型</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#repeat\" target=\"_blank\" rel=\"noopener\">repeat</a></td>\n<td>将某个字符串重复 n 遍</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#replace\" target=\"_blank\" rel=\"noopener\">replace</a></td>\n<td>替换字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#split\" target=\"_blank\" rel=\"noopener\">split</a></td>\n<td>拆分字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#template\" target=\"_blank\" rel=\"noopener\">template</a></td>\n<td>简单模板引擎</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#truncate\" target=\"_blank\" rel=\"noopener\">truncate</a></td>\n<td>截断字符串</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#words\" target=\"_blank\" rel=\"noopener\">words</a></td>\n<td>将字符串拆分成单词，可以指定拆分模式</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#deburr\" target=\"_blank\" rel=\"noopener\">deburr</a></td>\n<td>基本拉丁字母</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"9-数字\"><a href=\"#9-数字\" class=\"headerlink\" title=\"9. 数字\"></a>9. 数字</h2><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#clamp\" target=\"_blank\" rel=\"noopener\">clamp</a></td>\n<td>数字=&gt;数字</td>\n<td>将数字限定在一个范围内</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#inRange\" target=\"_blank\" rel=\"noopener\">inRange</a></td>\n<td>数字=&gt;布尔</td>\n<td>判断数字是否在某个区间里</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#random\" target=\"_blank\" rel=\"noopener\">random</a></td>\n<td>区间=&gt;数字</td>\n<td>随机获取一个值，可以通过第三个参数指定是不是返回小数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"10-数学\"><a href=\"#10-数学\" class=\"headerlink\" title=\"10. 数学\"></a>10. 数学</h2><h3 id=\"加减乘除\"><a href=\"#加减乘除\" class=\"headerlink\" title=\"加减乘除\"></a>加减乘除</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#add\" target=\"_blank\" rel=\"noopener\">add</a></td>\n<td>两个数字 =&gt; 数字</td>\n<td>返回两个数字的和</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#subtract\" target=\"_blank\" rel=\"noopener\">subtract</a></td>\n<td>两个数字 =&gt; 数字</td>\n<td>返回两个数字的差</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#multiply\" target=\"_blank\" rel=\"noopener\">multiply</a></td>\n<td>两个数字 =&gt; 数字</td>\n<td>返回两个数字的积</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#divide\" target=\"_blank\" rel=\"noopener\">divide</a></td>\n<td>两个数字 =&gt; 数字</td>\n<td>返回两个数字的商</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"和，最大值，最小值，平均值\"><a href=\"#和，最大值，最小值，平均值\" class=\"headerlink\" title=\"和，最大值，最小值，平均值\"></a>和，最大值，最小值，平均值</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#sum\" target=\"_blank\" rel=\"noopener\">sum</a></td>\n<td>数组 =&gt; 数字</td>\n<td>返回数组中的各数字之和</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#max\" target=\"_blank\" rel=\"noopener\">max</a></td>\n<td>数组 =&gt; 数字</td>\n<td>返回数组中的最大值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#min\" target=\"_blank\" rel=\"noopener\">min</a></td>\n<td>数组 =&gt; 数字</td>\n<td>返回数组中的最小值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mean\" target=\"_blank\" rel=\"noopener\">mean</a></td>\n<td>数组 =&gt; 数字</td>\n<td>返回数组中的平均值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"数字精度\"><a href=\"#数字精度\" class=\"headerlink\" title=\"数字精度\"></a>数字精度</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>主要参数-返回值</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#ceil\" target=\"_blank\" rel=\"noopener\">ceil</a></td>\n<td>数字 =&gt; 数字</td>\n<td>向上取整，可以指定精度</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#floor\" target=\"_blank\" rel=\"noopener\">floor</a></td>\n<td>数字 =&gt; 数字</td>\n<td>向下取整，可以指定精度</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#round\" target=\"_blank\" rel=\"noopener\">round</a></td>\n<td>数字 =&gt; 数字</td>\n<td>四舍五入取整，可以指定精度</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"11-语言\"><a href=\"#11-语言\" class=\"headerlink\" title=\"11. 语言\"></a>11. 语言</h2><h3 id=\"数值比较\"><a href=\"#数值比较\" class=\"headerlink\" title=\"数值比较\"></a>数值比较</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#eq\" target=\"_blank\" rel=\"noopener\">eq</a></td>\n<td>等价于<code>===</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isEqual\" target=\"_blank\" rel=\"noopener\">isEqual</a></td>\n<td>深度比较对象是否相等</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isEqualWith\" target=\"_blank\" rel=\"noopener\">isEqualWith</a></td>\n<td>深度比较对象是否相等，可以定义相等比较函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#gt\" target=\"_blank\" rel=\"noopener\">gt</a></td>\n<td>大于</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lt\" target=\"_blank\" rel=\"noopener\">lt</a></td>\n<td>小于</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#gte\" target=\"_blank\" rel=\"noopener\">gte</a></td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#lte\" target=\"_blank\" rel=\"noopener\">lte</a></td>\n<td>小于等于</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"类型判断\"><a href=\"#类型判断\" class=\"headerlink\" title=\"类型判断\"></a>类型判断</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArguments\" target=\"_blank\" rel=\"noopener\">isArguments</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArray\" target=\"_blank\" rel=\"noopener\">isArray</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArrayBuffer\" target=\"_blank\" rel=\"noopener\">isArrayBuffer</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArrayLike\" target=\"_blank\" rel=\"noopener\">isArrayLike</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isArrayLikeObject\" target=\"_blank\" rel=\"noopener\">isArrayLikeObject</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isBoolean\" target=\"_blank\" rel=\"noopener\">isBoolean</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isBuffer\" target=\"_blank\" rel=\"noopener\">isBuffer</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isDate\" target=\"_blank\" rel=\"noopener\">isDate</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isElement\" target=\"_blank\" rel=\"noopener\">isElement</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isEmpty\" target=\"_blank\" rel=\"noopener\">isEmpty</a></td>\n<td>判断是否有可遍历的属性</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isError\" target=\"_blank\" rel=\"noopener\">isError</a></td>\n<td>错误</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isFinite\" target=\"_blank\" rel=\"noopener\">isFinite</a></td>\n<td>是否是有限的数字，基于 Number.isFinite</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isFunction\" target=\"_blank\" rel=\"noopener\">isFunction</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isInteger\" target=\"_blank\" rel=\"noopener\">isInteger</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isLength\" target=\"_blank\" rel=\"noopener\">isLength</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isMap\" target=\"_blank\" rel=\"noopener\">isMap</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isMatch\" target=\"_blank\" rel=\"noopener\">isMatch</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isMatchWith\" target=\"_blank\" rel=\"noopener\">isMatchWith</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNaN\" target=\"_blank\" rel=\"noopener\">isNaN</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNative\" target=\"_blank\" rel=\"noopener\">isNative</a></td>\n<td>原生函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNil\" target=\"_blank\" rel=\"noopener\">isNil</a></td>\n<td>等价于 <code>_.isNull(val)</code> &#124;&#124; <code>_.isUndefined(val)</code></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNull\" target=\"_blank\" rel=\"noopener\">isNull</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isNumber\" target=\"_blank\" rel=\"noopener\">isNumber</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isObject\" target=\"_blank\" rel=\"noopener\">isObject</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isObjectLike\" target=\"_blank\" rel=\"noopener\">isObjectLike</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isPlainObject\" target=\"_blank\" rel=\"noopener\">isPlainObject</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isRegExp\" target=\"_blank\" rel=\"noopener\">isRegExp</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isSafeInteger\" target=\"_blank\" rel=\"noopener\">isSafeInteger</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#\" target=\"_blank\" rel=\"noopener\">isSet</a></td>\n<td>isSet</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isString\" target=\"_blank\" rel=\"noopener\">isString</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isSymbol\" target=\"_blank\" rel=\"noopener\">isSymbol</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isTypedArray\" target=\"_blank\" rel=\"noopener\">isTypedArray</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isUndefined\" target=\"_blank\" rel=\"noopener\">isUndefined</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isWeakMap\" target=\"_blank\" rel=\"noopener\">isWeakMap</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#isWeakSet\" target=\"_blank\" rel=\"noopener\">isWeakSet</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#castArray\" target=\"_blank\" rel=\"noopener\">castArray</a></td>\n<td>强制转给数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toArray\" target=\"_blank\" rel=\"noopener\">toArray</a></td>\n<td>转成数组，对象调用 Object.values，字符串转成字符数组</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toFinite\" target=\"_blank\" rel=\"noopener\">toFinite</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toInteger\" target=\"_blank\" rel=\"noopener\">toInteger</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toLength\" target=\"_blank\" rel=\"noopener\">toLength</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toNumber\" target=\"_blank\" rel=\"noopener\">toNumber</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toPlainObject\" target=\"_blank\" rel=\"noopener\">toPlainObject</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toSafeInteger\" target=\"_blank\" rel=\"noopener\">toSafeInteger</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toString\" target=\"_blank\" rel=\"noopener\">toString</a></td>\n<td>转成字符串，</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"复制对象\"><a href=\"#复制对象\" class=\"headerlink\" title=\"复制对象\"></a>复制对象</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#clone\" target=\"_blank\" rel=\"noopener\">clone</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#cloneDeep\" target=\"_blank\" rel=\"noopener\">cloneDeep</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#cloneDeepWith\" target=\"_blank\" rel=\"noopener\">cloneDeepWith</a></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#cloneWith\" target=\"_blank\" rel=\"noopener\">cloneWith</a></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"检测对象\"><a href=\"#检测对象\" class=\"headerlink\" title=\"检测对象\"></a>检测对象</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#conformsTo\" target=\"_blank\" rel=\"noopener\">conformsTo</a></td>\n<td>判断一个对象的字段是否满足一些条件</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"12-工具\"><a href=\"#12-工具\" class=\"headerlink\" title=\"12. 工具\"></a>12. 工具</h2><h3 id=\"总是返回某个参数的函数\"><a href=\"#总是返回某个参数的函数\" class=\"headerlink\" title=\"总是返回某个参数的函数\"></a>总是返回某个参数的函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#constant\" target=\"_blank\" rel=\"noopener\">constant</a></td>\n<td>创建一个包裹函数，总是返回第一个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#nthArg\" target=\"_blank\" rel=\"noopener\">nthArg</a></td>\n<td>创建一个包裹函数，总是返回第 n 个参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"总是返回某个特定值的函数\"><a href=\"#总是返回某个特定值的函数\" class=\"headerlink\" title=\"总是返回某个特定值的函数\"></a>总是返回某个特定值的函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#noop\" target=\"_blank\" rel=\"noopener\">noop</a></td>\n<td>总是返回<code>undefined</code>的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubArray\" target=\"_blank\" rel=\"noopener\">stubArray</a></td>\n<td>总是返回空数组的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubObject\" target=\"_blank\" rel=\"noopener\">stubObject</a></td>\n<td>总是返回空对象的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubString\" target=\"_blank\" rel=\"noopener\">stubString</a></td>\n<td>总是返回空字符串的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubTrue\" target=\"_blank\" rel=\"noopener\">stubTrue</a></td>\n<td>总是返回<code>true</code>的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#stubFalse\" target=\"_blank\" rel=\"noopener\">stubFalse</a></td>\n<td>总是返回<code>false</code>的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#identity\" target=\"_blank\" rel=\"noopener\">identity</a></td>\n<td>总是返回第一个参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"获取对象的属性值或者调用对象的函数\"><a href=\"#获取对象的属性值或者调用对象的函数\" class=\"headerlink\" title=\"获取对象的属性值或者调用对象的函数\"></a>获取对象的属性值或者调用对象的函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#method\" target=\"_blank\" rel=\"noopener\">method</a></td>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">_.invoke(object, path, [args])</a>预设<code>path</code>和<code>args</code>两个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#methodOf\" target=\"_blank\" rel=\"noopener\">methodOf</a></td>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">_.invoke(object, path, [args])</a>预设<code>object</code>和<code>args</code>两个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#property\" target=\"_blank\" rel=\"noopener\">property</a></td>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">_.get(object, path)</a>预设<code>path参数，不同的是缺少</code>defaultValue`参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#propertyOf\" target=\"_blank\" rel=\"noopener\">propertyOf</a></td>\n<td><a href=\"https://lodash.com/docs/#invoke\" target=\"_blank\" rel=\"noopener\">_.get(object, path)</a>预设<code>object</code>参数，不同的是缺少<code>defaultValue</code>参数</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"判断对象是否满足某些条件\"><a href=\"#判断对象是否满足某些条件\" class=\"headerlink\" title=\"判断对象是否满足某些条件\"></a>判断对象是否满足某些条件</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#conforms\" target=\"_blank\" rel=\"noopener\">conforms</a></td>\n<td>创建一个包裹函数，判断一个对象的字段是否满足某个函数。<code>conforms</code>意思是遵守。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#matches\" target=\"_blank\" rel=\"noopener\">matches</a></td>\n<td>创建一个包裹函数，判断一个对象的字段是否等于某个值，使用<a href=\"https://lodash.com/docs/#isEqual\" target=\"_blank\" rel=\"noopener\">isEqual</a>判断是否相等。跟<a href=\"https://lodash.com/docs/#isMatch\" target=\"_blank\" rel=\"noopener\">isMatch</a>类似</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#matchesProperty\" target=\"_blank\" rel=\"noopener\">matchesProperty</a></td>\n<td>创建一个包裹函数，判断一个对象特定字段是否等于某个值，使用<a href=\"https://lodash.com/docs/#isEqual\" target=\"_blank\" rel=\"noopener\">isEqual</a>判断是否相等。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"把多个操作合成一个操作\"><a href=\"#把多个操作合成一个操作\" class=\"headerlink\" title=\"把多个操作合成一个操作\"></a>把多个操作合成一个操作</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flow\" target=\"_blank\" rel=\"noopener\">flow</a></td>\n<td>把一组函数串起来形成一个新函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#flowRight\" target=\"_blank\" rel=\"noopener\">flowRight</a></td>\n<td>同上，倒序</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"批量进行多个操作\"><a href=\"#批量进行多个操作\" class=\"headerlink\" title=\"批量进行多个操作\"></a>批量进行多个操作</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#over\" target=\"_blank\" rel=\"noopener\">over</a></td>\n<td>创建一个新函数，并将参数传递给预先指定的一组函数，并返回其结果</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#overEvery\" target=\"_blank\" rel=\"noopener\">overEvery</a></td>\n<td>跟<code>over</code>类似，判断是不是所有函数都返回真值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#overSome\" target=\"_blank\" rel=\"noopener\">overSome</a></td>\n<td>跟<code>over</code>类似，判断是不是至少一个函数返回真值</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"等差数列\"><a href=\"#等差数列\" class=\"headerlink\" title=\"等差数列\"></a>等差数列</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#range\" target=\"_blank\" rel=\"noopener\">range</a></td>\n<td>生成等差数列，可以指定步长，步长可以是小数，也可以是负数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#rangeRight\" target=\"_blank\" rel=\"noopener\">rangeRight</a></td>\n<td>这个基本可以忽略，功能完成可以由<a href=\"https://lodash.com/docs/#range\" target=\"_blank\" rel=\"noopener\">range</a>代替。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"其他未分类\"><a href=\"#其他未分类\" class=\"headerlink\" title=\"其他未分类\"></a>其他未分类</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#attempt\" target=\"_blank\" rel=\"noopener\">attempt</a></td>\n<td>使用 try-catch 包裹函数，如果出错返回错误对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#bindAll\" target=\"_blank\" rel=\"noopener\">bindAll</a></td>\n<td>将一个对象的多个函数中的 this 固定为该对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#cond\" target=\"_blank\" rel=\"noopener\">cond</a></td>\n<td>创建一个拥有复杂 if-else 的函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#defaultTo\" target=\"_blank\" rel=\"noopener\">defaultTo</a></td>\n<td>如果第一个参数为 NaN,null,undefined，则返回第二个参数，否则返回第一个参数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#iteratee\" target=\"_blank\" rel=\"noopener\">iteratee</a></td>\n<td>创建一个迭代函数</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#noConflict\" target=\"_blank\" rel=\"noopener\">noConflict</a></td>\n<td>如果<code>_</code>被占用，可以使用该方法</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#runInContext\" target=\"_blank\" rel=\"noopener\">runInContext</a></td>\n<td>创建一个<code>lodash</code>镜像对象，可以扩展修改该对象</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#mixin\" target=\"_blank\" rel=\"noopener\">mixin</a></td>\n<td>给一个对象的原型添加属性或方法，一般配合<a href=\"https://lodash.com/docs/#runInContext\" target=\"_blank\" rel=\"noopener\">runInContext</a>扩展<code>lodash</code>。</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#times\" target=\"_blank\" rel=\"noopener\">times</a></td>\n<td>执行函数 n 次，传入参数为 index</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#toPath\" target=\"_blank\" rel=\"noopener\">toPath</a></td>\n<td>‘a[0].b.c’=&gt;[‘a’,’0’,’b’,’c’]</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#uniqueId\" target=\"_blank\" rel=\"noopener\">uniqueId</a></td>\n<td>生成唯一 ID，可以指定前缀</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"13-链式\"><a href=\"#13-链式\" class=\"headerlink\" title=\"13. 链式\"></a>13. 链式</h2><h3 id=\"链式调用的好处\"><a href=\"#链式调用的好处\" class=\"headerlink\" title=\"链式调用的好处\"></a>链式调用的好处</h3><p>省略了中间变量，让代码更加简洁，更加安全。<br>链式调用可以优化成惰性求值（延迟计算），让代码更加高效。</p>\n<h3 id=\"value\"><a href=\"#value\" class=\"headerlink\" title=\"_(value)\"></a>_(value)</h3><p>创建一个经过 lodash 包装过后的对象会启用隐式链，直到调用了不支持链接调用的函数或者主动调用<code>value</code>方法解除链式调用。<br>作用类似于<a href=\"https://lodash.com/docs/#chain\" target=\"_blank\" rel=\"noopener\">chain</a></p>\n<h3 id=\"lodash-包装对象上的特殊函数\"><a href=\"#lodash-包装对象上的特殊函数\" class=\"headerlink\" title=\"lodash 包装对象上的特殊函数\"></a>lodash 包装对象上的特殊函数</h3><table>\n<thead>\n<tr>\n<th>函数名</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-tap\" target=\"_blank\" rel=\"noopener\">tap</a></td>\n<td>可以在链式调用中插入普通方法，直接修改中间结果，也可以仅仅是用于调试打印中间结果</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-thru\" target=\"_blank\" rel=\"noopener\">thru</a></td>\n<td>同<a href=\"https://lodash.com/docs/#tap\" target=\"_blank\" rel=\"noopener\">tap</a>，但是使用函数的返回值作为中间结果</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-commit\" target=\"_blank\" rel=\"noopener\">commit</a></td>\n<td>立即执行链式调用中尚未进行的操作</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-next\" target=\"_blank\" rel=\"noopener\">next</a></td>\n<td>获得包装对象的下一个值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-plant\" target=\"_blank\" rel=\"noopener\">plant</a></td>\n<td>复制一个链式调用，并传入初始值</td>\n</tr>\n<tr>\n<td><a href=\"https://lodash.com/docs/#prototype-value\" target=\"_blank\" rel=\"noopener\">value</a></td>\n<td>结束链式调用，并计算结果。别名<code>valueOf</code>，<code>toJSON</code></td>\n</tr>\n</tbody>\n</table>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}